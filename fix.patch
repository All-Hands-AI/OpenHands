commit 3b77d57079440d6f9307b37173275d4c68860d8f
Author: openhands <openhands@all-hands.dev>
Date:   Wed Mar 26 12:38:41 2025 +0000

    Fix TypeScript errors and linting issues in frontend code

diff --git a/frontend/src/components/features/chat/chat-interface.tsx b/frontend/src/components/features/chat/chat-interface.tsx
index dc7b157e0..4dd30df53 100644
--- a/frontend/src/components/features/chat/chat-interface.tsx
+++ b/frontend/src/components/features/chat/chat-interface.tsx
@@ -2,6 +2,7 @@ import { useDispatch, useSelector } from "react-redux";
 import React from "react";
 import posthog from "posthog-js";
 import { useParams } from "react-router";
+import { useTranslation } from "react-i18next";
 import { convertImageToBase64 } from "#/utils/convert-image-to-base-64";
 import { TrajectoryActions } from "../trajectory/trajectory-actions";
 import { createChatMessage } from "#/services/chat-service";
@@ -17,7 +18,6 @@ import { useWsClient } from "#/context/ws-client-provider";
 import { Messages } from "./messages";
 import { ChatSuggestions } from "./chat-suggestions";
 import { ActionSuggestions } from "./action-suggestions";
-import { useTranslation } from "react-i18next";
 
 import { ScrollToBottomButton } from "#/components/shared/buttons/scroll-to-bottom-button";
 import { LoadingSpinner } from "#/components/shared/loading-spinner";
@@ -107,7 +107,7 @@ export function ChatInterface() {
           data.trajectory,
         );
       },
-      onError: (error) => {
+      onError: () => {
         displayErrorToast(t("CONVERSATION$DOWNLOAD_ERROR"));
       },
     });
diff --git a/frontend/src/components/features/conversation-panel/conversation-card.tsx b/frontend/src/components/features/conversation-panel/conversation-card.tsx
index be5afc261..a56b59faf 100644
--- a/frontend/src/components/features/conversation-panel/conversation-card.tsx
+++ b/frontend/src/components/features/conversation-panel/conversation-card.tsx
@@ -245,15 +245,24 @@ export function ConversationCard({
       >
         <div className="space-y-2">
           {metrics?.cost !== null && (
-            <p>{t("CONVERSATION$TOTAL_COST")}{metrics.cost.toFixed(4)}</p>
+            <p>
+              {t("CONVERSATION$TOTAL_COST")}
+              {metrics.cost.toFixed(4)}
+            </p>
           )}
           {metrics?.usage !== null && (
             <>
               <p>{t("CONVERSATION$TOKENS_USED")}</p>
               <ul className="list-inside space-y-1 ml-2">
-                <li>{t("CONVERSATION$INPUT")} {metrics.usage.prompt_tokens}</li>
-                <li>{t("CONVERSATION$OUTPUT")} {metrics.usage.completion_tokens}</li>
-                <li>{t("CONVERSATION$TOTAL")} {metrics.usage.total_tokens}</li>
+                <li>
+                  {t("CONVERSATION$INPUT")} {metrics.usage.prompt_tokens}
+                </li>
+                <li>
+                  {t("CONVERSATION$OUTPUT")} {metrics.usage.completion_tokens}
+                </li>
+                <li>
+                  {t("CONVERSATION$TOTAL")} {metrics.usage.total_tokens}
+                </li>
               </ul>
             </>
           )}
diff --git a/frontend/src/components/features/github/code-not-in-github-link.tsx b/frontend/src/components/features/github/code-not-in-github-link.tsx
index 51724bd13..c4350d49d 100644
--- a/frontend/src/components/features/github/code-not-in-github-link.tsx
+++ b/frontend/src/components/features/github/code-not-in-github-link.tsx
@@ -1,8 +1,8 @@
 import React from "react";
 import { useDispatch } from "react-redux";
+import { useTranslation } from "react-i18next";
 import { useCreateConversation } from "#/hooks/mutation/use-create-conversation";
 import { setInitialPrompt } from "#/state/initial-query-slice";
-import { useTranslation } from "react-i18next";
 
 const INITIAL_PROMPT = "";
 
diff --git a/frontend/src/components/features/waitlist/join-waitlist-anchor.tsx b/frontend/src/components/features/waitlist/join-waitlist-anchor.tsx
index b1a4a9536..55c0ce5a3 100644
--- a/frontend/src/components/features/waitlist/join-waitlist-anchor.tsx
+++ b/frontend/src/components/features/waitlist/join-waitlist-anchor.tsx
@@ -2,7 +2,7 @@ import { useTranslation } from "react-i18next";
 
 export function JoinWaitlistAnchor() {
   const { t } = useTranslation();
-  
+
   return (
     <a
       href="https://www.all-hands.dev/join-waitlist"
diff --git a/frontend/src/components/features/waitlist/waitlist-modal.tsx b/frontend/src/components/features/waitlist/waitlist-modal.tsx
index 89da632b4..41ae1b809 100644
--- a/frontend/src/components/features/waitlist/waitlist-modal.tsx
+++ b/frontend/src/components/features/waitlist/waitlist-modal.tsx
@@ -1,4 +1,5 @@
 import React from "react";
+import { useTranslation } from "react-i18next";
 import AllHandsLogo from "#/assets/branding/all-hands-logo.svg?react";
 import { JoinWaitlistAnchor } from "./join-waitlist-anchor";
 import { WaitlistMessage } from "./waitlist-message";
@@ -8,7 +9,6 @@ import { TOSCheckbox } from "./tos-checkbox";
 import { handleCaptureConsent } from "#/utils/handle-capture-consent";
 import { BrandButton } from "../settings/brand-button";
 import GitHubLogo from "#/assets/branding/github-logo.svg?react";
-import { useTranslation } from "react-i18next";
 
 interface WaitlistModalProps {
   ghTokenIsSet: boolean;
diff --git a/frontend/src/routes/_oh.app._index/route.tsx b/frontend/src/routes/_oh.app._index/route.tsx
index d2cc3ce63..72e1bfb66 100644
--- a/frontend/src/routes/_oh.app._index/route.tsx
+++ b/frontend/src/routes/_oh.app._index/route.tsx
@@ -2,11 +2,13 @@ import React from "react";
 import { useRouteError } from "react-router";
 import { Prism as SyntaxHighlighter } from "react-syntax-highlighter";
 import { vscDarkPlus } from "react-syntax-highlighter/dist/esm/styles/prism";
+import { useTranslation } from "react-i18next";
 import { FileExplorer } from "#/components/features/file-explorer/file-explorer";
 import { useFiles } from "#/context/files";
 
 export function ErrorBoundary() {
   const error = useRouteError();
+  const { t } = useTranslation();
 
   return (
     <div className="w-full h-full border border-danger rounded-b-xl flex flex-col items-center justify-center gap-2 bg-red-500/5">
diff --git a/frontend/src/routes/_oh/route.tsx b/frontend/src/routes/_oh/route.tsx
index 376737d38..6ea056a6d 100644
--- a/frontend/src/routes/_oh/route.tsx
+++ b/frontend/src/routes/_oh/route.tsx
@@ -24,6 +24,7 @@ import { displaySuccessToast } from "#/utils/custom-toast-handlers";
 
 export function ErrorBoundary() {
   const error = useRouteError();
+  const { t } = useTranslation();
 
   if (isRouteErrorResponse(error)) {
     return (
diff --git a/frontend/src/routes/account-settings.tsx b/frontend/src/routes/account-settings.tsx
index 036724844..10981aba6 100644
--- a/frontend/src/routes/account-settings.tsx
+++ b/frontend/src/routes/account-settings.tsx
@@ -155,8 +155,9 @@ function AccountSettings() {
       SECURITY_ANALYZER:
         formData.get("security-analyzer-input")?.toString() || "",
       REMOTE_RUNTIME_RESOURCE_FACTOR:
-        remoteRuntimeResourceFactor ||
-        DEFAULT_SETTINGS.REMOTE_RUNTIME_RESOURCE_FACTOR,
+        remoteRuntimeResourceFactor !== null
+          ? Number(remoteRuntimeResourceFactor)
+          : DEFAULT_SETTINGS.REMOTE_RUNTIME_RESOURCE_FACTOR,
       CONFIRMATION_MODE: confirmationModeIsEnabled,
     };
 
diff --git a/frontend/src/utils/scan-unlocalized-strings-ast.ts b/frontend/src/utils/scan-unlocalized-strings-ast.ts
index 620f7ef2d..6734118ea 100644
--- a/frontend/src/utils/scan-unlocalized-strings-ast.ts
+++ b/frontend/src/utils/scan-unlocalized-strings-ast.ts
@@ -110,14 +110,14 @@ function isCommonDevelopmentString(str: string): boolean {
 }
 
 function isLikelyUserFacingText(str: string): boolean {
-  if (!str || str.length <= 2 || !(/[a-zA-Z]/.test(str))) {
+  if (!str || str.length <= 2 || !/[a-zA-Z]/.test(str)) {
     return false;
   }
-  
+
   if (isLikelyTranslationKey(str) || isCommonDevelopmentString(str)) {
     return false;
   }
-  
+
   // Check if it's likely user-facing text
   // 1. Contains multiple words with spaces
   // 2. Contains punctuation like question marks, periods, or exclamation marks
@@ -125,7 +125,7 @@ function isLikelyUserFacingText(str: string): boolean {
   const hasMultipleWords = /\s+/.test(str) && str.split(/\s+/).length > 1;
   const hasPunctuation = /[?!.]/.test(str);
   const isCapitalizedPhrase = /^[A-Z]/.test(str) && hasMultipleWords;
-  
+
   return hasMultipleWords || hasPunctuation || isCapitalizedPhrase;
 }
 
@@ -134,142 +134,164 @@ function isTranslationCall(node: t.Node): boolean {
   if (
     t.isCallExpression(node) &&
     t.isIdentifier(node.callee) &&
-    node.callee.name === 't' &&
+    node.callee.name === "t" &&
     node.arguments.length > 0
   ) {
     return true;
   }
-  
+
   // Check for useTranslation() pattern
   if (
     t.isCallExpression(node) &&
     t.isIdentifier(node.callee) &&
-    node.callee.name === 'useTranslation'
+    node.callee.name === "useTranslation"
   ) {
     return true;
   }
-  
+
   // Check for <Trans> component
   if (
     t.isJSXElement(node) &&
     t.isJSXIdentifier(node.openingElement.name) &&
-    node.openingElement.name.name === 'Trans'
+    node.openingElement.name.name === "Trans"
   ) {
     return true;
   }
-  
+
   return false;
 }
 
 function isInTranslationContext(path: NodePath<t.Node>): boolean {
   let current: NodePath<t.Node> | null = path;
-  
+
   while (current) {
     if (isTranslationCall(current.node)) {
       return true;
     }
     current = current.parentPath;
   }
-  
+
   return false;
 }
 
 export function scanFileForUnlocalizedStrings(filePath: string): string[] {
   try {
-    const content = fs.readFileSync(filePath, 'utf-8');
+    const content = fs.readFileSync(filePath, "utf-8");
     const unlocalizedStrings: string[] = [];
-    
+
     // Skip files that are too large
     if (content.length > 1000000) {
       console.warn(`Skipping large file: ${filePath}`);
       return [];
     }
-    
+
     // Check if file is using translations
-    const hasTranslationImport = content.includes('useTranslation') || 
-                                content.includes('I18nKey') ||
-                                content.includes('<Trans');
-    
+    const hasTranslationImport =
+      content.includes("useTranslation") ||
+      content.includes("I18nKey") ||
+      content.includes("<Trans");
+
     try {
       // Parse the file
       const ast = parser.parse(content, {
-        sourceType: 'module',
-        plugins: ['jsx', 'typescript', 'classProperties', 'decorators-legacy'],
+        sourceType: "module",
+        plugins: ["jsx", "typescript", "classProperties", "decorators-legacy"],
       });
-      
+
       // Traverse the AST
       traverse(ast, {
         // Find JSX text content
         JSXText(path) {
           const text = path.node.value.trim();
-          if (text && isLikelyUserFacingText(text) && !isInTranslationContext(path)) {
+          if (
+            text &&
+            isLikelyUserFacingText(text) &&
+            !isInTranslationContext(path)
+          ) {
             unlocalizedStrings.push(text);
           }
         },
-        
+
         // Find string literals in JSX attributes
         JSXAttribute(path) {
           const attrName = path.node.name.name.toString();
-          
+
           // Skip attributes that typically don't contain user-facing text
           if (NON_TEXT_ATTRIBUTES.includes(attrName)) {
             return;
           }
-          
+
           // Check the attribute value
-          const value = path.node.value;
+          const { value } = path.node;
           if (t.isStringLiteral(value)) {
             const text = value.value.trim();
-            if (text && isLikelyUserFacingText(text) && !isInTranslationContext(path)) {
+            if (
+              text &&
+              isLikelyUserFacingText(text) &&
+              !isInTranslationContext(path)
+            ) {
               unlocalizedStrings.push(text);
             }
           }
         },
-        
+
         // Find string literals
         StringLiteral(path) {
           // Skip if parent is a JSX attribute (handled separately)
           if (t.isJSXAttribute(path.parent)) {
             return;
           }
-          
+
           // Skip if it's part of an import statement
-          if (t.isImportDeclaration(path.parent) || t.isExportDeclaration(path.parent)) {
+          if (
+            t.isImportDeclaration(path.parent) ||
+            t.isExportDeclaration(path.parent)
+          ) {
             return;
           }
-          
+
           const text = path.node.value.trim();
-          if (text && isLikelyUserFacingText(text) && !isInTranslationContext(path)) {
+          if (
+            text &&
+            isLikelyUserFacingText(text) &&
+            !isInTranslationContext(path)
+          ) {
             unlocalizedStrings.push(text);
           }
         },
-        
+
         // Find template literals
         TemplateLiteral(path) {
           // Skip if it's a tagged template literal
           if (t.isTaggedTemplateExpression(path.parent)) {
             return;
           }
-          
+
           // Get the full template string if it's simple
           if (path.node.quasis.length === 1) {
             const text = path.node.quasis[0].value.raw.trim();
-            if (text && isLikelyUserFacingText(text) && !isInTranslationContext(path)) {
+            if (
+              text &&
+              isLikelyUserFacingText(text) &&
+              !isInTranslationContext(path)
+            ) {
               unlocalizedStrings.push(text);
             }
           }
-        }
+        },
       });
     } catch (error) {
       // If parsing fails, fall back to regex-based scanning
-      console.warn(`Failed to parse ${filePath}, falling back to regex scanning: ${error}`);
-      
+      console.warn(
+        `Failed to parse ${filePath}, falling back to regex scanning: ${error}`,
+      );
+
       // Simple regex to find potential text strings
       const stringRegex = /['"`]([^'"`\n]{3,})['"`]/g;
       const jsxTextRegex = />([\s]*[A-Za-z][\w\s.,!?]+)[\s]*</g;
-      
+
       let match;
-      
+
       // Find string literals
       while ((match = stringRegex.exec(content)) !== null) {
         const text = match[1].trim();
@@ -277,7 +299,7 @@ export function scanFileForUnlocalizedStrings(filePath: string): string[] {
           unlocalizedStrings.push(text);
         }
       }
-      
+
       // Find JSX text content
       while ((match = jsxTextRegex.exec(content)) !== null) {
         const text = match[1].trim();
@@ -286,7 +308,7 @@ export function scanFileForUnlocalizedStrings(filePath: string): string[] {
         }
       }
     }
-    
+
     // Filter out duplicates
     return [...new Set(unlocalizedStrings)];
   } catch (error) {
@@ -324,4 +346,4 @@ export function scanDirectoryForUnlocalizedStrings(
 
   scanDir(dirPath);
   return results;
-}
\ No newline at end of file
+}
diff --git a/frontend/src/utils/scan-unlocalized-strings.ts b/frontend/src/utils/scan-unlocalized-strings.ts
index aa30220db..7857ec8aa 100644
--- a/frontend/src/utils/scan-unlocalized-strings.ts
+++ b/frontend/src/utils/scan-unlocalized-strings.ts
@@ -1,11 +1,12 @@
 import fs from "fs";
-import path from "path";
+import nodePath from "path";
 import * as parser from "@babel/parser";
 import * as _traverse from "@babel/traverse";
 import type { NodePath } from "@babel/traverse";
 import * as t from "@babel/types";
 
 // Fix for ESM/CJS compatibility
+// @ts-ignore - This is a workaround for ESM/CJS compatibility
 const traverse = (_traverse as any).default || _traverse;
 
 // Attributes that typically don't contain user-facing text
@@ -199,14 +200,14 @@ function isCommonDevelopmentString(str: string): boolean {
 }
 
 function isLikelyUserFacingText(str: string): boolean {
-  if (!str || str.length <= 2 || !(/[a-zA-Z]/.test(str))) {
+  if (!str || str.length <= 2 || !/[a-zA-Z]/.test(str)) {
     return false;
   }
-  
+
   if (isLikelyTranslationKey(str) || isCommonDevelopmentString(str)) {
     return false;
   }
-  
+
   // Check if it's likely user-facing text
   // 1. Contains multiple words with spaces
   // 2. Contains punctuation like question marks, periods, or exclamation marks
@@ -214,7 +215,7 @@ function isLikelyUserFacingText(str: string): boolean {
   const hasMultipleWords = /\s+/.test(str) && str.split(/\s+/).length > 1;
   const hasPunctuation = /[?!.]/.test(str);
   const isCapitalizedPhrase = /^[A-Z]/.test(str) && hasMultipleWords;
-  
+
   return hasMultipleWords || hasPunctuation || isCapitalizedPhrase;
 }
 
@@ -223,146 +224,171 @@ function isTranslationCall(node: t.Node): boolean {
   if (
     t.isCallExpression(node) &&
     t.isIdentifier(node.callee) &&
-    node.callee.name === 't' &&
+    node.callee.name === "t" &&
     node.arguments.length > 0
   ) {
     return true;
   }
-  
+
   // Check for useTranslation() pattern
   if (
     t.isCallExpression(node) &&
     t.isIdentifier(node.callee) &&
-    node.callee.name === 'useTranslation'
+    node.callee.name === "useTranslation"
   ) {
     return true;
   }
-  
+
   // Check for <Trans> component
   if (
     t.isJSXElement(node) &&
     t.isJSXIdentifier(node.openingElement.name) &&
-    node.openingElement.name.name === 'Trans'
+    node.openingElement.name.name === "Trans"
   ) {
     return true;
   }
-  
+
   return false;
 }
 
-function isInTranslationContext(path: NodePath<t.Node>): boolean {
-  let current: NodePath<t.Node> | null = path;
-  
+function isInTranslationContext(nodePath: NodePath<t.Node>): boolean {
+  let current: NodePath<t.Node> | null = nodePath;
+
   while (current) {
     if (isTranslationCall(current.node)) {
       return true;
     }
     current = current.parentPath;
   }
-  
+
   return false;
 }
 
 export function scanFileForUnlocalizedStrings(filePath: string): string[] {
   try {
-    const content = fs.readFileSync(filePath, 'utf-8');
+    const content = fs.readFileSync(filePath, "utf-8");
     const unlocalizedStrings: string[] = [];
-    
+
     // Skip files that are too large
     if (content.length > 1000000) {
+      // eslint-disable-next-line no-console
       console.warn(`Skipping large file: ${filePath}`);
       return [];
     }
-    
+
     try {
       // Parse the file
       const ast = parser.parse(content, {
-        sourceType: 'module',
-        plugins: ['jsx', 'typescript', 'classProperties', 'decorators-legacy'],
+        sourceType: "module",
+        plugins: ["jsx", "typescript", "classProperties", "decorators-legacy"],
       });
-      
+
       // Traverse the AST
       traverse(ast, {
         // Find JSX text content
-        JSXText(path) {
-          const text = path.node.value.trim();
-          if (text && isLikelyUserFacingText(text) && !isInTranslationContext(path)) {
+        JSXText(nodePath: NodePath<t.JSXText>) {
+          const text = nodePath.node.value.trim();
+          if (
+            text &&
+            isLikelyUserFacingText(text) &&
+            !isInTranslationContext(nodePath)
+          ) {
             unlocalizedStrings.push(text);
           }
         },
-        
+
         // Find string literals in JSX attributes
-        JSXAttribute(path) {
-          const attrName = path.node.name.name.toString();
-          
+        JSXAttribute(nodePath: NodePath<t.JSXAttribute>) {
+          const attrName = nodePath.node.name.name.toString();
+
           // Skip attributes that typically don't contain user-facing text
           if (NON_TEXT_ATTRIBUTES.includes(attrName)) {
             return;
           }
-          
+
           // Check the attribute value
-          const value = path.node.value;
+          const { value } = nodePath.node;
           if (t.isStringLiteral(value)) {
             const text = value.value.trim();
-            if (text && isLikelyUserFacingText(text) && !isInTranslationContext(path)) {
+            if (
+              text &&
+              isLikelyUserFacingText(text) &&
+              !isInTranslationContext(nodePath)
+            ) {
               unlocalizedStrings.push(text);
             }
           }
         },
-        
+
         // Find string literals
-        StringLiteral(path) {
+        StringLiteral(nodePath: NodePath<t.StringLiteral>) {
           // Skip if parent is a JSX attribute (handled separately)
-          if (t.isJSXAttribute(path.parent)) {
+          if (t.isJSXAttribute(nodePath.parent)) {
             return;
           }
-          
+
           // Skip if it's part of an import statement
-          if (t.isImportDeclaration(path.parent) || t.isExportDeclaration(path.parent)) {
+          if (
+            t.isImportDeclaration(nodePath.parent) ||
+            t.isExportDeclaration(nodePath.parent)
+          ) {
             return;
           }
-          
-          const text = path.node.value.trim();
-          if (text && isLikelyUserFacingText(text) && !isInTranslationContext(path)) {
+
+          const text = nodePath.node.value.trim();
+          if (
+            text &&
+            isLikelyUserFacingText(text) &&
+            !isInTranslationContext(nodePath)
+          ) {
             unlocalizedStrings.push(text);
           }
         },
-        
+
         // Find template literals
-        TemplateLiteral(path) {
+        TemplateLiteral(nodePath: NodePath<t.TemplateLiteral>) {
           // Skip if it's a tagged template literal
-          if (t.isTaggedTemplateExpression(path.parent)) {
+          if (t.isTaggedTemplateExpression(nodePath.parent)) {
             return;
           }
-          
+
           // Get the full template string if it's simple
-          if (path.node.quasis.length === 1) {
-            const text = path.node.quasis[0].value.raw.trim();
-            if (text && isLikelyUserFacingText(text) && !isInTranslationContext(path)) {
+          if (nodePath.node.quasis.length === 1) {
+            const text = nodePath.node.quasis[0].value.raw.trim();
+            if (
+              text &&
+              isLikelyUserFacingText(text) &&
+              !isInTranslationContext(nodePath)
+            ) {
               unlocalizedStrings.push(text);
             }
           }
-        }
+        },
       });
     } catch (error) {
       // If parsing fails, fall back to regex-based scanning
-      console.warn(`Failed to parse ${filePath}, falling back to regex scanning: ${error}`);
-      
+      // eslint-disable-next-line no-console
+      console.warn(
+        `Failed to parse ${filePath}, falling back to regex scanning: ${error}`,
+      );
+
       // Simple regex to find potential text strings
       const stringRegex = /['"`]([^'"`\n]{3,})['"`]/g;
       const jsxTextRegex = />([\s]*[A-Za-z][\w\s.,!?]+)[\s]*</g;
-      
-      let match;
-      
+
+      let match: RegExpExecArray | null;
+
       // Find string literals
+      // eslint-disable-next-line no-cond-assign
       while ((match = stringRegex.exec(content)) !== null) {
         const text = match[1].trim();
         if (text && isLikelyUserFacingText(text)) {
           unlocalizedStrings.push(text);
         }
       }
-      
+
       // Find JSX text content
+      // eslint-disable-next-line no-cond-assign
       while ((match = jsxTextRegex.exec(content)) !== null) {
         const text = match[1].trim();
         if (text && isLikelyUserFacingText(text)) {
@@ -370,10 +396,11 @@ export function scanFileForUnlocalizedStrings(filePath: string): string[] {
         }
       }
     }
-    
+
     // Filter out duplicates
     return [...new Set(unlocalizedStrings)];
   } catch (error) {
+    // eslint-disable-next-line no-console
     console.error(`Error scanning file ${filePath}:`, error);
     return [];
   }
@@ -388,14 +415,14 @@ export function scanDirectoryForUnlocalizedStrings(
     const entries = fs.readdirSync(currentPath, { withFileTypes: true });
 
     for (const entry of entries) {
-      const fullPath = path.join(currentPath, entry.name);
+      const fullPath = nodePath.join(currentPath, entry.name);
 
       if (!shouldIgnorePath(fullPath)) {
         if (entry.isDirectory()) {
           scanDir(fullPath);
         } else if (
           entry.isFile() &&
-          SCAN_EXTENSIONS.includes(path.extname(fullPath))
+          SCAN_EXTENSIONS.includes(nodePath.extname(fullPath))
         ) {
           const unlocalized = scanFileForUnlocalizedStrings(fullPath);
           if (unlocalized.length > 0) {
@@ -408,4 +435,4 @@ export function scanDirectoryForUnlocalizedStrings(
 
   scanDir(dirPath);
   return results;
-}
\ No newline at end of file
+}
