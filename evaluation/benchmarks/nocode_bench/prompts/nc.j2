<uploaded_files>
/workspace/{{ workspace_dir_name }}
</uploaded_files>

I've uploaded a python code repository in the directory {{ workspace_dir_name }}. Consider the following issue description:

<doc_change>
{{ instance.problem_statement }}
</doc_change>

Can you help me add the new features to the repository based on the changes in the <doc_change>?
I've already taken care of all changes to any of the test files described in the <doc_change>. This means you DON'T have to modify the testing logic or any of the tests in any way!
Also the development Python environment is already set up for you (i.e., all dependencies already installed), so you don't need to install other packages.
Your task is to make the minimal changes to non-test files in the /workspace/{{ workspace_dir_name }} directory to implement the new features required by the documentation updates.

Follow these phases to resolve the issue:

Phase 1. READING: read the requirements and reword it in clearer terms
   1.1 If there are code or config snippets. Express in words any best practices or conventions in them.
   1.2 Hightlight method names, variables, file names, stack traces, and technical details, particularly those related to new features.
   1.3 Explain the new feature requirements in clear terms.
   1.4 Specify functional scope and expected behavior of new features.
   1.5 Hightlight any best practices to take into account when developing and testing the new feature.

Phase 2. RUNNING: install and run the functionality in the repository to validate the new features
   2.1 Follow the readme.
   2.2 Install the environment and anything needed.
   2.2 Iterate and figure out how to validate the newly added features.

Phase 3. EXPLORATION: find the files related to the new features and possible implementation solutions
   3.1 Use `grep` to search for relevant methods, classes, keywords and feature requirements.
   3.2 Identify all files related to the new features.
   3.3 Propose the methods and files to implement the new features and explain why.
   3.4 From the possible file locations, select the most likely location to implement the new features.

Phase 4. TEST CREATION: before implementing any new features, create a script to validate the feature's correctness.
   4.1 Look at existing test files in the repository to understand the test format/structure.
   4.2 Create a minimal validation script to verify the newly added features.
   4.3 Run the validation script to confirm the new features are successfully added and working as expected.
   4.4 Adjust the validation script as necessary to ensure the new features fully meet the requirements.

Phase 5. FEATURE ANALYSIS: state clearly the new feature and how to implement it
   5.1 State clearly what the new feature is.
   5.2 State clearly where the feature should be implemented.
   5.3 State clearly how the test validates the new feature.
   5.4 State clearly the best practices to take into account when implementing the new feature.
   5.5 State clearly how to implement the new feature.

Phase 6. FEATURE IMPLEMENTATION: edit the source code to implement your chosen solution for the new feature
   6.1 Make minimal, focused changes to implement the new feature.

Phase 7. VERIFICATION: Test your new feature thoroughly.
   7.1 Run your validation script to verify the new feature works as expected.
   7.2 Add edge cases to your test script to ensure comprehensive coverage of the new feature.
   7.3 Run existing tests related to the modified code to ensure you haven't broken anything.

Phase 8. FINAL REVIEW: Carefully re-read the feature requirements and compare your changes with the base commit {{ instance.base_commit }}
   8.1 Ensure you've fully implemented all required features.
   8.2 Run any tests in the repository related to:
     8.2.1 The new features you are adding
     8.2.2 The files you modified
     8.2.3 The functions you changed
   8.3 If any tests fail, revise your implementation until all tests pass and the new feature works as expected.

Be thorough in your exploration, testing, and reasoning. It's fine if your thinking process is lengthy - quality and completeness are more important than brevity.
