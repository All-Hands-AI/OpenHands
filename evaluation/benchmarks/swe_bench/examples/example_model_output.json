[
  {
    "instance_id": "sphinx-doc__sphinx-8721",
    "model_patch": "diff --git a/sphinx/ext/viewcode.py b/sphinx/ext/viewcode.py\r\nindex a7d52a91c..e5f058693 100644\r\n--- a/sphinx/ext/viewcode.py\r\n+++ b/sphinx/ext/viewcode.py\r\n@@ -159,6 +159,10 @@ def get_module_filename(app: Sphinx, modname: str) -> Optional[str]:\r\n \r\n def should_generate_module_page(app: Sphinx, modname: str) -> bool:\r\n     \"\"\"Check generation of module page is needed.\"\"\"\r\n+    # Do not generate module page if viewcode is disabled for epub\r\n+    if app.builder.name.startswith('epub') and not app.config.viewcode_enable_epub:\r\n+        return False\r\n+\r\n     module_filename = get_module_filename(app, modname)\r\n     if module_filename is None:\r\n         # Always (re-)generate module page when module filename is not found.",
    "model_name_or_path": "openhands"
  },
  {
    "instance_id": "django__django-15202",
    "model_patch": "diff --git a/django/core/validators.py b/django/core/validators.py\r\nindex 72fbe15551..14a9eafbab 100644\r\n--- a/django/core/validators.py\r\n+++ b/django/core/validators.py\r\n@@ -127,20 +127,15 @@ class URLValidator(RegexValidator):\r\n                 raise\r\n         else:\r\n             # Now verify IPv6 in the netloc part\r\n-            host_match = re.search(r'^\\[(.+)\\](?::\\d{1,5})?$', urlsplit(value).netloc)\r\n-            if host_match:\r\n-                potential_ip = host_match[1]\r\n-                try:\r\n+            try:\r\n+                host_match = re.search(r'^\\[(.+)\\](?::\\d{1,5})?$', urlsplit(value).netloc)\r\n+                if host_match:\r\n+                    potential_ip = host_match[1]\r\n                     validate_ipv6_address(potential_ip)\r\n-                except ValidationError:\r\n-                    raise ValidationError(self.message, code=self.code, params={'value': value})\r\n-\r\n-        # The maximum length of a full host name is 253 characters per RFC 1034\r\n-        # section 3.1. It's defined to be 255 bytes or less, but this includes\r\n-        # one byte for the length of the name and one byte for the trailing dot\r\n-        # that's used to indicate absolute names in DNS.\r\n-        if len(urlsplit(value).hostname) > 253:\r\n-            raise ValidationError(self.message, code=self.code, params={'value': value})\r\n+            except ValidationError:\r\n+                raise ValidationError(self.message, code=self.code, params={'value': value})\r\n+            except ValueError:\r\n+                raise ValidationError(self.message, code=self.code, params={'value': value})\r\n \r\n \r\n integer_validator = RegexValidator(\r\ndiff --git a/django/forms/fields.py b/django/forms/fields.py\r\nindex 65d6a9ec82..f02d6d6245 100644\r\n--- a/django/forms/fields.py\r\n+++ b/django/forms/fields.py\r\n@@ -687,10 +687,8 @@ class URLField(CharField):\r\n             \"\"\"\r\n             try:\r\n                 return list(urlsplit(url))\r\n-            except ValueError:\r\n-                # urlparse.urlsplit can raise a ValueError with some\r\n-                # misformatted URLs.\r\n-                raise ValidationError(self.error_messages['invalid'], code='invalid')\r\n+            except ValueError as e:\r\n+                raise ValidationError(self.error_messages['invalid'], code='invalid') from e\r\n \r\n         value = super().to_python(value)\r\n         if value:\r\ndiff --git a/tests/forms_tests/field_tests/test_urlfield.py b/tests/forms_tests/field_tests/test_urlfield.py\r\nindex 152456f216..90d4f15736 100644\r\n--- a/tests/forms_tests/field_tests/test_urlfield.py\r\n+++ b/tests/forms_tests/field_tests/test_urlfield.py\r\n@@ -129,3 +129,8 @@ class URLFieldTest(FormFieldAssertionsMixin, SimpleTestCase):\r\n         msg = \"__init__() got multiple values for keyword argument 'strip'\"\r\n         with self.assertRaisesMessage(TypeError, msg):\r\n             URLField(strip=False)\r\n+\r\n+    def test_urlfield_clean_value_error(self):\r\n+        f = URLField()\r\n+        with self.assertRaises(ValidationError):\r\n+            f.clean('////]@N.AN')",
    "model_name_or_path": "openhands"
  },
  {
    "instance_id": "django__django-14017",
    "model_patch": "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\r\nindex ffc3a7fda5..593a34f95a 100644\r\n--- a/django/db/models/expressions.py\r\n+++ b/django/db/models/expressions.py\r\n@@ -1151,10 +1151,10 @@ class Exists(Subquery):\r\n     template = 'EXISTS(%(subquery)s)'\r\n     output_field = fields.BooleanField()\r\n \r\n-    def __init__(self, queryset, negated=False, **kwargs):\r\n-        self.negated = negated\r\n-        super().__init__(queryset, **kwargs)\r\n-\r\n+def __rand__(self, other):\r\n+    if not isinstance(other, Q):\r\n+        raise TypeError('Cannot combine a Q object with %s' % type(other))\r\n+    return other & self\r\n     def __invert__(self):\r\n         clone = self.copy()\r\n         clone.negated = not self.negated",
    "model_name_or_path": "openhands"
  },
  {
    "instance_id": "sympy__sympy-14774",
    "model_patch": "diff --git a/sympy/printing/latex.py b/sympy/printing/latex.py\r\nindex a3ead157c1..f3b7669e96 100644\r\n--- a/sympy/printing/latex.py\r\n+++ b/sympy/printing/latex.py\r\n@@ -740,7 +740,7 @@ def _print_Function(self, expr, exp=None):\r\n                 len(args) == 1 and \\\r\n                 not self._needs_function_brackets(expr.args[0])\r\n \r\n-            inv_trig_table = [\"asin\", \"acos\", \"atan\", \"acot\"]\r\n+            inv_trig_table = [\"asin\", \"acos\", \"atan\", \"acsc\", \"asec\", \"acot\"]\r\n \r\n             # If the function is an inverse trig function, handle the style\r\n             if func in inv_trig_table:",
    "model_name_or_path": "openhands"
  },
  {
    "instance_id": "scikit-learn__scikit-learn-10508",
    "model_patch": "diff --git a/sklearn/preprocessing/label.py b/sklearn/preprocessing/label.py\r\nindex 61b8d4a21..6f9c43807 100644\r\n--- a/sklearn/preprocessing/label.py\r\n+++ b/sklearn/preprocessing/label.py\r\n@@ -124,9 +124,14 @@ class LabelEncoder(BaseEstimator, TransformerMixin):\r\n         -------\r\n         y : array-like of shape [n_samples]\r\n         \"\"\"\r\n-        check_is_fitted(self, 'classes_')\r\n+        # Directly return an empty array with the expected dtype for empty input\r\n+        if len(y) == 0:\r\n+            return np.array([], dtype='<U32' if self.classes_.dtype.kind == 'U' else int)\r\n+        # Return an empty array with the same dtype as the classes_ if the input is empty\r\n+        if len(y) == 0:\r\n+            return np.array([], dtype=self.classes_.dtype)\r\n         y = column_or_1d(y, warn=True)\r\n-\r\n+        \r\n         classes = np.unique(y)\r\n         if len(np.intersect1d(classes, self.classes_)) < len(classes):\r\n             diff = np.setdiff1d(classes, self.classes_)",
    "model_name_or_path": "openhands"
  },
  {
    "instance_id": "django__django-14915",
    "model_patch": "diff --git a/django/forms/models.py b/django/forms/models.py\r\nindex 5dcf923c12..c6d4c2c36c 100644\r\n--- a/django/forms/models.py\r\n+++ b/django/forms/models.py\r\n@@ -1321,7 +1321,8 @@ class ModelChoiceField(ChoiceField):\r\n         data_value = data if data is not None else ''\r\n         return str(self.prepare_value(initial_value)) != str(data_value)\r\n \r\n-\r\n+    def __hash__(self):\r\n+        return hash(self.value)\r\n class ModelMultipleChoiceField(ModelChoiceField):\r\n     \"\"\"A MultipleChoiceField whose choices are a model QuerySet.\"\"\"\r\n     widget = SelectMultiple",
    "model_name_or_path": "openhands"
  },
  {
    "instance_id": "django__django-17087",
    "model_patch": "diff --git a/django/db/migrations/serializer.py b/django/db/migrations/serializer.py\r\nindex d88cda6e20..06657ebaab 100644\r\n--- a/django/db/migrations/serializer.py\r\n+++ b/django/db/migrations/serializer.py\r\n@@ -168,7 +168,7 @@ class FunctionTypeSerializer(BaseSerializer):\r\n         ):\r\n             klass = self.value.__self__\r\n             module = klass.__module__\r\n-            return \"%s.%s.%s\" % (module, klass.__name__, self.value.__name__), {\r\n+            return \"%s.%s.%s\" % (module, klass.__qualname__, self.value.__name__), {\r\n                 \"import %s\" % module\r\n             }\r\n         # Further error checking\r\ndiff --git a/tests/migrations/test_writer/test_nested_class_default.py b/tests/migrations/test_writer/test_nested_class_default.py\r\nnew file mode 100644\r\nindex 0000000000..93ecf2ea6b\r\n--- /dev/null\r\n+++ b/tests/migrations/test_writer/test_nested_class_default.py\r\n@@ -0,0 +1,23 @@\r\n+from django.db import migrations, models\r\n+from django.db.migrations.writer import MigrationWriter\r\n+from django.test import SimpleTestCase\r\n+\r\n+class MockModel(models.Model):\r\n+    class MockNestedClass:\r\n+        @classmethod\r\n+        def default(cls):\r\n+            return 'default_value'\r\n+\r\n+    field = models.CharField(\r\n+        max_length=100,\r\n+        default=MockNestedClass.default,\r\n+    )\r\n+\r\n+class TestNestedClassDefault(SimpleTestCase):\r\n+\r\n+    def test_serialize_nested_class_method_as_default(self):\r\n+        field = MockModel._meta.get_field('field')\r\n+        statement, imports = MigrationWriter.serialize(field)\r\n+\r\n+        # Check that the default is correctly serialized\r\n+        self.assertIn('MockModel.MockNestedClass.default', statement)\r\ndiff --git a/tests/test_settings.py b/tests/test_settings.py\r\nnew file mode 100644\r\nindex 0000000000..93ecf2ea6b\r\n--- /dev/null\r\n+++ b/tests/test_settings.py\r\n@@ -0,0 +1,23 @@\r\n+from django.db import migrations, models\r\n+from django.db.migrations.writer import MigrationWriter\r\n+from django.test import SimpleTestCase\r\n+\r\n+class MockModel(models.Model):\r\n+    class MockNestedClass:\r\n+        @classmethod\r\n+        def default(cls):\r\n+            return 'default_value'\r\n+\r\n+    field = models.CharField(\r\n+        max_length=100,\r\n+        default=MockNestedClass.default,\r\n+    )\r\n+\r\n+class TestNestedClassDefault(SimpleTestCase):\r\n+\r\n+    def test_serialize_nested_class_method_as_default(self):\r\n+        field = MockModel._meta.get_field('field')\r\n+        statement, imports = MigrationWriter.serialize(field)\r\n+\r\n+        # Check that the default is correctly serialized\r\n+        self.assertIn('MockModel.MockNestedClass.default', statement)",
    "model_name_or_path": "openhands"
  },
  {
    "instance_id": "sympy__sympy-22005",
    "model_patch": "diff --git a/sympy/solvers/polysys.py b/sympy/solvers/polysys.py\r\nindex b9809fd4e9..1cd89c1add 100644\r\n--- a/sympy/solvers/polysys.py\r\n+++ b/sympy/solvers/polysys.py\r\n@@ -241,8 +241,12 @@ def _solve_reduced_system(system, gens, entry=False):\r\n         univariate = list(filter(_is_univariate, basis))\r\n \r\n         if len(univariate) == 1:\r\n-            f = univariate.pop()\r\n-        else:\r\n+            if len(gens) == 1:\r\n+                f = univariate.pop()\r\n+            else:\r\n+                raise NotImplementedError(filldedent('''\r\n+                    only zero-dimensional systems supported\r\n+                    (finite number of solutions)'''))\r\n             raise NotImplementedError(filldedent('''\r\n                 only zero-dimensional systems supported\r\n                 (finite number of solutions)\r\ndiff --git a/sympy/solvers/tests/test_polysys.py b/sympy/solvers/tests/test_polysys.py\r\nindex 58419f8762..15cb70bc53 100644\r\n--- a/sympy/solvers/tests/test_polysys.py\r\n+++ b/sympy/solvers/tests/test_polysys.py\r\n@@ -47,7 +47,10 @@ def test_solve_poly_system():\r\n     raises(NotImplementedError, lambda: solve_poly_system([x**3 - y**3], x, y))\r\n     raises(NotImplementedError, lambda: solve_poly_system(\r\n         [z, -2*x*y**2 + x + y**2*z, y**2*(-z - 4) + 2]))\r\n-    raises(PolynomialError, lambda: solve_poly_system([1/x], x))\r\n+    raises(NotImplementedError, lambda: solve_poly_system(\r\n+        [Poly(x - 1, x, y)], (x, y)))\r\n+    raises(NotImplementedError, lambda: solve_poly_system(\r\n+        [Poly(y - 1, x, y)], (x, y)))\r\n \r\n \r\n def test_solve_biquadratic():",
    "model_name_or_path": "openhands"
  },
  {
    "instance_id": "pytest-dev__pytest-5221",
    "model_patch": "diff --git a/src/_pytest/python.py b/src/_pytest/python.py\r\nindex 377357846..f15299a41 100644\r\n--- a/src/_pytest/python.py\r\n+++ b/src/_pytest/python.py\r\n@@ -1342,10 +1342,11 @@ def _showfixtures_main(config, session):\r\n                 currentmodule = module\r\n         if verbose <= 0 and argname[0] == \"_\":\r\n             continue\r\n+        scope = fixturedef.scope\r\n         if verbose > 0:\r\n-            funcargspec = \"%s -- %s\" % (argname, bestrel)\r\n+            funcargspec = f\"{argname} -- scope: {scope} -- {bestrel}\"\r\n         else:\r\n-            funcargspec = argname\r\n+            funcargspec = f\"{argname} -- scope: {scope}\"\r\n         tw.line(funcargspec, green=True)\r\n         loc = getlocation(fixturedef.func, curdir)\r\n         doc = fixturedef.func.__doc__ or \"\"",
    "model_name_or_path": "openhands"
  },
  {
    "instance_id": "sympy__sympy-17022",
    "model_patch": "diff --git a/sympy/printing/lambdarepr.py b/sympy/printing/lambdarepr.py\r\nindex 8f60434e89..851530c286 100644\r\n--- a/sympy/printing/lambdarepr.py\r\n+++ b/sympy/printing/lambdarepr.py\r\n@@ -89,7 +89,12 @@ class NumExprPrinter(LambdaPrinter):\r\n         'contains' : 'contains',\r\n     }\r\n \r\n-    def _print_ImaginaryUnit(self, expr):\r\n+def _print_Identity(self, expr):\r\n+    from sympy import Integer\r\n+    if isinstance(expr.args[0], Integer):\r\n+        return f\"numpy.eye({expr.args[0]})\"\r\n+    else:\r\n+        raise ValueError(\"Identity matrix dimension must be an Integer\")\r\n         return '1j'\r\n \r\n     def _print_seq(self, seq, delimiter=', '):",
    "model_name_or_path": "openhands"
  },
  {
    "instance_id": "django__django-11422",
    "model_patch": "diff --git a/django/utils/autoreload.py b/django/utils/autoreload.py\r\nindex 7ca0d68fae..9e4a806c31 100644\r\n--- a/django/utils/autoreload.py\r\n+++ b/django/utils/autoreload.py\r\n@@ -114,14 +114,17 @@ def iter_modules_and_files(modules, extra_files):\r\n         # During debugging (with PyDev) the 'typing.io' and 'typing.re' objects\r\n         # are added to sys.modules, however they are types not modules and so\r\n         # cause issues here.\r\n-        if not isinstance(module, ModuleType) or getattr(module, '__spec__', None) is None:\r\n+        if not isinstance(module, ModuleType):\r\n             continue\r\n-        spec = module.__spec__\r\n-        # Modules could be loaded from places without a concrete location. If\r\n-        # this is the case, skip them.\r\n-        if spec.has_location:\r\n-            origin = spec.loader.archive if isinstance(spec.loader, zipimporter) else spec.origin\r\n-            sys_file_paths.append(origin)\r\n+        if module.__name__ == '__main__':\r\n+            filename = getattr(module, '__file__', None)\r\n+            if filename:\r\n+                sys_file_paths.append(filename)\r\n+        elif getattr(module, '__spec__', None) is not None:\r\n+            spec = module.__spec__\r\n+            if spec.has_location:\r\n+                origin = spec.loader.archive if isinstance(spec.loader, zipimporter) else spec.origin\r\n+                sys_file_paths.append(origin)\r\n \r\n     results = set()\r\n     for filename in itertools.chain(sys_file_paths, extra_files):\r\ndiff --git a/tests/i18n/sampleproject/sampleproject/settings.py b/tests/i18n/sampleproject/sampleproject/settings.py\r\nindex e69de29bb2..d6cccb516b 100644\r\n--- a/tests/i18n/sampleproject/sampleproject/settings.py\r\n+++ b/tests/i18n/sampleproject/sampleproject/settings.py\r\n@@ -0,0 +1,34 @@\r\n+SECRET_KEY = 'fake-secret-key-for-testing'\r\n+DEBUG = True\r\n+ALLOWED_HOSTS = []\r\n+INSTALLED_APPS = [\r\n+    'django.contrib.admin',\r\n+    'django.contrib.auth',\r\n+    'django.contrib.contenttypes',\r\n+    'django.contrib.sessions',\r\n+    'django.contrib.messages',\r\n+    'django.contrib.staticfiles',\r\n+]\r\n+MIDDLEWARE = [\r\n+    'django.middleware.security.SecurityMiddleware',\r\n+    'django.contrib.sessions.middleware.SessionMiddleware',\r\n+    'django.middleware.common.CommonMiddleware',\r\n+    'django.middleware.csrf.CsrfViewMiddleware',\r\n+    'django.contrib.auth.middleware.AuthenticationMiddleware',\r\n+    'django.contrib.messages.middleware.MessageMiddleware',\r\n+    'django.middleware.clickjacking.XFrameOptionsMiddleware',\r\n+]\r\n+TEMPLATES = [\r\n+    {\r\n+        'BACKEND': 'django.template.backends.django.DjangoTemplates',\r\n+        'APP_DIRS': True,\r\n+        'OPTIONS': {\r\n+            'context_processors': [\r\n+                'django.template.context_processors.debug',\r\n+                'django.template.context_processors.request',\r\n+                'django.contrib.auth.context_processors.auth',\r\n+                'django.contrib.messages.context_processors.messages',\r\n+            ],\r\n+        },\r\n+    },\r\n+]",
    "model_name_or_path": "openhands"
  },
  {
    "instance_id": "sympy__sympy-20590",
    "model_patch": "diff --git a/sympy/core/_print_helpers.py b/sympy/core/_print_helpers.py\r\nindex 96d7e72676..b72e022e68 100644\r\n--- a/sympy/core/_print_helpers.py\r\n+++ b/sympy/core/_print_helpers.py\r\n@@ -6,6 +6,7 @@\r\n \"\"\"\r\n \r\n class Printable:\r\n+    __slots__ = ()\r\n     \"\"\"\r\n     The default implementation of printing for SymPy classes.",
    "model_name_or_path": "openhands"
  },
  {
    "instance_id": "django__django-15996",
    "model_patch": "diff --git a/django/db/migrations/serializer.py b/django/db/migrations/serializer.py\r\nindex 38da1e6ecc..f59fd93415 100644\r\n--- a/django/db/migrations/serializer.py\r\n+++ b/django/db/migrations/serializer.py\r\n@@ -121,14 +121,31 @@ class DictionarySerializer(BaseSerializer):\r\n         return \"{%s}\" % (\", \".join(\"%s: %s\" % (k, v) for k, v in strings)), imports\r\n \r\n \r\n+from django.utils.module_loading import import_string\r\n+\r\n+from django.utils.module_loading import import_string\r\n+\r\n class EnumSerializer(BaseSerializer):\r\n     def serialize(self):\r\n         enum_class = self.value.__class__\r\n         module = enum_class.__module__\r\n-        return (\r\n-            \"%s.%s[%r]\" % (module, enum_class.__qualname__, self.value.name),\r\n-            {\"import %s\" % module},\r\n-        )\r\n+        enum_value = self.value\r\n+\r\n+        # Check if the value is a single enum member\r\n+        if isinstance(enum_value, enum.Enum):\r\n+            value = \"%s.%s['%s']\" % (module, enum_class.__qualname__, enum_value.name)\r\n+        else:\r\n+            # Decompose the value into individual flags\r\n+            enum_member = enum_class._decompose(enum_class, enum_value)\r\n+            if isinstance(enum_member, list):\r\n+                # Create an expression by ORing the individual flags\r\n+                member_names = [member.name for member in enum_member]\r\n+                value = ' | '.join([\"%s.%s['%s']\" % (module, enum_class.__qualname__, name) for name in member_names])\r\n+            else:\r\n+                # It's a single enum member after all\r\n+                value = \"%s.%s['%s']\" % (module, enum_class.__qualname__, enum_member.name)\r\n+\r\n+        return value, {\"import %s\" % module}\r\n \r\n \r\n class FloatSerializer(BaseSimpleSerializer):\r\ndiff --git a/tests/migrations/test_enum_serializer.py b/tests/migrations/test_enum_serializer.py\r\nnew file mode 100644\r\nindex 0000000000..02f4c2f554\r\n--- /dev/null\r\n+++ b/tests/migrations/test_enum_serializer.py\r\n@@ -0,0 +1,15 @@\r\n+import enum\r\n+from django.db.migrations.serializer import EnumSerializer\r\n+\r\n+class TestEnumSerializer:\r\n+    def test_enum_flag_combination_serialization(self):\r\n+        class RegexFlag(enum.IntFlag):\r\n+            IGNORECASE = enum.auto()\r\n+            UNICODE = enum.auto()\r\n+\r\n+        combined_flags = RegexFlag.IGNORECASE | RegexFlag.UNICODE\r\n+        serializer = EnumSerializer(combined_flags)\r\n+\r\n+        serialized_value, imports = serializer.serialize()\r\n+        assert serialized_value == \"tests.migrations.test_enum_serializer.RegexFlag.IGNORECASE | tests.migrations.test_enum_serializer.RegexFlag.UNICODE\"\r\n+        assert \"import tests.migrations.test_enum_serializer\" in imports",
    "model_name_or_path": "openhands"
  },
  {
    "instance_id": "matplotlib__matplotlib-23476",
    "model_patch": "diff --git a/lib/matplotlib/figure.py b/lib/matplotlib/figure.py\r\nindex c55864243a..a9526e5039 100644\r\n--- a/lib/matplotlib/figure.py\r\n+++ b/lib/matplotlib/figure.py\r\n@@ -2264,7 +2264,7 @@ class Figure(FigureBase):\r\n \r\n         dpi : float, default: :rc:`figure.dpi`\r\n             Dots per inch.\r\n-\r\n+self._original_dpi = dpi\r\n         facecolor : default: :rc:`figure.facecolor`\r\n             The figure patch facecolor.\r\n \r\n@@ -3014,7 +3014,7 @@ class Figure(FigureBase):\r\n \r\n     def __getstate__(self):\r\n         state = super().__getstate__()\r\n-\r\n+        state['dpi'] = self._original_dpi\r\n         # The canvas cannot currently be pickled, but this has the benefit\r\n         # of meaning that a figure can be detached from one canvas, and\r\n         # re-attached to another.",
    "model_name_or_path": "openhands"
  },
  {
    "instance_id": "django__django-15252",
    "model_patch": "diff --git a/django/db/migrations/recorder.py b/django/db/migrations/recorder.py\r\nindex 1a37c6b7d0..03a1a4879b 100644\r\n--- a/django/db/migrations/recorder.py\r\n+++ b/django/db/migrations/recorder.py\r\n@@ -56,18 +56,23 @@ class MigrationRecorder:\r\n             tables = self.connection.introspection.table_names(cursor)\r\n         return self.Migration._meta.db_table in tables\r\n \r\n-    def ensure_schema(self):\r\n-        \"\"\"Ensure the table exists and has the correct schema.\"\"\"\r\n-        # If the table's there, that's fine - we've never changed its schema\r\n-        # in the codebase.\r\n-        if self.has_table():\r\n-            return\r\n-        # Make the table\r\n-        try:\r\n-            with self.connection.schema_editor() as editor:\r\n-                editor.create_model(self.Migration)\r\n-        except DatabaseError as exc:\r\n-            raise MigrationSchemaMissing(\"Unable to create the django_migrations table (%s)\" % exc)\r\n+from django.db import models, DatabaseError, router\r\n+\r\n+def ensure_schema(self):\r\n+    \"\"\"Ensure the table exists and has the correct schema.\"\"\"\r\n+    # If the table's there, that's fine - we've never changed its schema\r\n+    # in the codebase.\r\n+    if self.has_table():\r\n+        return\r\n+    # Check if we're allowed to migrate\r\n+    if not router.allow_migrate(self.connection.alias, self.Migration):\r\n+        return\r\n+    # Make the table\r\n+    try:\r\n+        with self.connection.schema_editor() as editor:\r\n+            editor.create_model(self.Migration)\r\n+    except DatabaseError as exc:\r\n+        raise MigrationSchemaMissing(\"Unable to create the django_migrations table (%s)\" % exc)\r\n \r\n     def applied_migrations(self):\r\n         \"\"\"",
    "model_name_or_path": "openhands"
  },
  {
    "instance_id": "sympy__sympy-11897",
    "model_patch": "",
    "model_name_or_path": "openhands"
  },
  {
    "instance_id": "matplotlib__matplotlib-23987",
    "model_patch": "diff --git a/lib/matplotlib/figure.py b/lib/matplotlib/figure.py\r\nindex 5bbb786984..5600a3fcb5 100644\r\n--- a/lib/matplotlib/figure.py\r\n+++ b/lib/matplotlib/figure.py\r\n@@ -1310,7 +1310,8 @@ default: %(va)s\r\n             as a fraction of the average Axes height.\r\n         \"\"\"\r\n         if (self.get_layout_engine() is not None and\r\n-                not self.get_layout_engine().adjust_compatible):\r\n+            not self.get_layout_engine().adjust_compatible and\r\n+            self.get_constrained_layout()):\r\n             _api.warn_external(\r\n                 \"This figure was using a layout engine that is \"\r\n                 \"incompatible with subplots_adjust and/or tight_layout; \"",
    "model_name_or_path": "openhands"
  },
  {
    "instance_id": "sympy__sympy-21171",
    "model_patch": "",
    "model_name_or_path": "openhands"
  },
  {
    "instance_id": "django__django-11797",
    "model_patch": "diff --git a/django/db/models/lookups.py b/django/db/models/lookups.py\r\nindex 105dc93251..9b1355dd29 100644\r\n--- a/django/db/models/lookups.py\r\n+++ b/django/db/models/lookups.py\r\n@@ -261,16 +261,11 @@ class Exact(FieldGetDbPrepValueMixin, BuiltinLookup):\r\n     def process_rhs(self, compiler, connection):\r\n         from django.db.models.sql.query import Query\r\n         if isinstance(self.rhs, Query):\r\n-            if self.rhs.has_limit_one():\r\n+            # If the subquery is sliced or has a group by clause, do not alter it.\r\n+            if not (self.rhs.is_sliced or self.rhs.group_by):\r\n                 # The subquery must select only the pk.\r\n                 self.rhs.clear_select_clause()\r\n                 self.rhs.add_fields(['pk'])\r\n-            else:\r\n-                raise ValueError(\r\n-                    'The QuerySet value for an exact lookup must be limited to '\r\n-                    'one result using slicing.'\r\n-                )\r\n-        return super().process_rhs(compiler, connection)\r\n \r\n \r\n @Field.register_lookup\r\ndiff --git a/tests/auth_tests/test_group_by.py b/tests/auth_tests/test_group_by.py\r\nnew file mode 100644\r\nindex 0000000000..38f88cefe3\r\n--- /dev/null\r\n+++ b/tests/auth_tests/test_group_by.py\r\n@@ -0,0 +1,13 @@\r\n+from django.contrib.auth.models import User\r\n+from django.db.models import Max\r\n+from django.test import TestCase\r\n+\r\n+class GroupByTestCase(TestCase):\r\n+    def setUp(self):\r\n+        User.objects.create_user('user1', 'user1@example.com')\r\n+        User.objects.create_user('user2', 'user2@example.com')\r\n+\r\n+    def test_group_by_override(self):\r\n+        a = User.objects.filter(email__isnull=True).values('email').annotate(m=Max('id')).values('m')\r\n+        b = User.objects.filter(id=a[:1])\r\n+        self.assertIn('GROUP BY \"auth_user\".\"email\"', str(b.query))\r\ndiff --git a/tests/test_settings.py b/tests/test_settings.py\r\nnew file mode 100644\r\nindex 0000000000..942e75c86e\r\n--- /dev/null\r\n+++ b/tests/test_settings.py\r\n@@ -0,0 +1,42 @@\r\n+SECRET_KEY = 'fake-key-for-testing'\r\n+\r\n+INSTALLED_APPS = [\r\n+    'django.contrib.auth',\r\n+    'django.contrib.contenttypes',\r\n+    'django.contrib.sessions',\r\n+    'django.contrib.messages',\r\n+    'django.contrib.admin',\r\n+]\r\n+\r\n+DATABASES = {\r\n+    'default': {\r\n+        'ENGINE': 'django.db.backends.sqlite3',\r\n+        'NAME': ':memory:',\r\n+    }\r\n+}\r\n+\r\n+MIDDLEWARE = [\r\n+    'django.middleware.security.SecurityMiddleware',\r\n+    'django.contrib.sessions.middleware.SessionMiddleware',\r\n+    'django.middleware.common.CommonMiddleware',\r\n+    'django.middleware.csrf.CsrfViewMiddleware',\r\n+    'django.contrib.auth.middleware.AuthenticationMiddleware',\r\n+    'django.contrib.messages.middleware.MessageMiddleware',\r\n+    'django.middleware.clickjacking.XFrameOptionsMiddleware',\r\n+]\r\n+\r\n+\r\n+TEMPLATES = [\r\n+    {\r\n+        'BACKEND': 'django.template.backends.django.DjangoTemplates',\r\n+        'APP_DIRS': True,\r\n+        'OPTIONS': {\r\n+            'context_processors': [\r\n+                'django.template.context_processors.debug',\r\n+                'django.template.context_processors.request',\r\n+                'django.contrib.auth.context_processors.auth',\r\n+                'django.contrib.messages.context_processors.messages',\r\n+            ],\r\n+        },\r\n+    },\r\n+]",
    "model_name_or_path": "openhands"
  },
  {
    "instance_id": "scikit-learn__scikit-learn-13142",
    "model_patch": "diff --git a/sklearn/mixture/base.py b/sklearn/mixture/base.py\r\nindex bd34333c0..4ed41389c 100644\r\n--- a/sklearn/mixture/base.py\r\n+++ b/sklearn/mixture/base.py\r\n@@ -369,9 +369,9 @@ class BaseMixture(DensityMixin, BaseEstimator, metaclass=ABCMeta):\r\n         labels : array, shape (n_samples,)\r\n             Component labels.\r\n         \"\"\"\r\n-        self._check_is_fitted()\r\n-        X = _check_X(X, None, self.means_.shape[1])\r\n-        return self._estimate_weighted_log_prob(X).argmax(axis=1)\r\n+        # Perform an expectation step to ensure the most up-to-date parameters are used\r\n+        _, log_resp = self._e_step(X)\r\n+        return log_resp.argmax(axis=1)\r\n \r\n     def predict_proba(self, X):\r\n         \"\"\"Predict posterior probability of each component given the data.",
    "model_name_or_path": "openhands"
  },
  {
    "instance_id": "matplotlib__matplotlib-18869",
    "model_patch": "",
    "model_name_or_path": "openhands"
  },
  {
    "instance_id": "django__django-11583",
    "model_patch": "diff --git a/django/utils/autoreload.py b/django/utils/autoreload.py\r\nindex 25c3b44250..3636ca7a4a 100644\r\n--- a/django/utils/autoreload.py\r\n+++ b/django/utils/autoreload.py\r\n@@ -139,6 +139,9 @@ def iter_modules_and_files(modules, extra_files):\r\n         path = Path(filename)\r\n         try:\r\n             resolved_path = path.resolve(strict=True).absolute()\r\n+        except ValueError:\r\n+            # If a ValueError is encountered, skip this path and continue.\r\n+            continue\r\n         except FileNotFoundError:\r\n             # The module could have been removed, don't fail loudly if this\r\n             # is the case.",
    "model_name_or_path": "openhands"
  },
  {
    "instance_id": "matplotlib__matplotlib-25311",
    "model_patch": "diff --git a/draggable_legend_patch.diff b/draggable_legend_patch.diff\r\nnew file mode 100644\r\nindex 0000000000..f2e13c267c\r\n--- /dev/null\r\n+++ b/draggable_legend_patch.diff\r\n@@ -0,0 +1,22 @@\r\n+--- a/lib/matplotlib/legend.py\r\n++++ b/lib/matplotlib/legend.py\r\n+@@ -96,6 +96,21 @@\r\n+         self.legend.set_bbox_to_anchor(loc_in_bbox)\r\n+ \r\n++    def disable_draggable(self):\r\n++        \"\"\"\r\n++        Disable the draggable feature of the legend to allow pickling.\r\n++        \"\"\"\r\n++        if hasattr(self, '_draggable'):\r\n++            self._draggable.disconnect_events()\r\n++            self._draggable = None\r\n++\r\n++    def enable_draggable(self, use_blit=False, update='loc'):\r\n++        \"\"\"\r\n++        Re-enable the draggable feature of the legend after pickling.\r\n++        \"\"\"\r\n++        self.set_draggable(True, use_blit=use_blit, update=update)\r\n++\r\n++\r\n+ _legend_kw_doc_base = \"\"\"\r\n+ bbox_to_anchor : `.BboxBase`, 2-tuple, or 4-tuple of floats\r\ndiff --git a/lib/matplotlib/legend.py.orig b/lib/matplotlib/legend.py.orig\r\nnew file mode 100644\r\nindex 0000000000..ff6abdb958\r\n--- /dev/null\r\n+++ b/lib/matplotlib/legend.py.orig\r\n@@ -0,0 +1,1355 @@\r\n+\"\"\"\r\n+The legend module defines the Legend class, which is responsible for\r\n+drawing legends associated with axes and/or figures.\r\n+\r\n+.. important::\r\n+\r\n+    It is unlikely that you would ever create a Legend instance manually.\r\n+    Most users would normally create a legend via the `~.Axes.legend`\r\n+    function. For more details on legends there is also a :doc:`legend guide\r\n+    </tutorials/intermediate/legend_guide>`.\r\n+\r\n+The `Legend` class is a container of legend handles and legend texts.\r\n+\r\n+The legend handler map specifies how to create legend handles from artists\r\n+(lines, patches, etc.) in the axes or figures. Default legend handlers are\r\n+defined in the :mod:`~matplotlib.legend_handler` module. While not all artist\r\n+types are covered by the default legend handlers, custom legend handlers can be\r\n+defined to support arbitrary objects.\r\n+\r\n+See the :doc:`legend guide </tutorials/intermediate/legend_guide>` for more\r\n+information.\r\n+\"\"\"\r\n+\r\n+import itertools\r\n+import logging\r\n+import time\r\n+\r\n+import numpy as np\r\n+\r\n+import matplotlib as mpl\r\n+from matplotlib import _api, _docstring, colors, offsetbox\r\n+from matplotlib.artist import Artist, allow_rasterization\r\n+from matplotlib.cbook import silent_list\r\n+from matplotlib.font_manager import FontProperties\r\n+from matplotlib.lines import Line2D\r\n+from matplotlib.patches import (Patch, Rectangle, Shadow, FancyBboxPatch,\r\n+                                StepPatch)\r\n+from matplotlib.collections import (\r\n+    Collection, CircleCollection, LineCollection, PathCollection,\r\n+    PolyCollection, RegularPolyCollection)\r\n+from matplotlib.text import Text\r\n+from matplotlib.transforms import Bbox, BboxBase, TransformedBbox\r\n+from matplotlib.transforms import BboxTransformTo, BboxTransformFrom\r\n+from matplotlib.offsetbox import (\r\n+    AnchoredOffsetbox, DraggableOffsetBox,\r\n+    HPacker, VPacker,\r\n+    DrawingArea, TextArea,\r\n+)\r\n+from matplotlib.container import ErrorbarContainer, BarContainer, StemContainer\r\n+from . import legend_handler\r\n+\r\n+\r\n+class DraggableLegend(DraggableOffsetBox):\r\n+    def __init__(self, legend, use_blit=False, update=\"loc\"):\r\n+        \"\"\"\r\n+        Wrapper around a `.Legend` to support mouse dragging.\r\n+\r\n+        Parameters\r\n+        ----------\r\n+        legend : `.Legend`\r\n+            The `.Legend` instance to wrap.\r\n+        use_blit : bool, optional\r\n+            Use blitting for faster image composition. For details see\r\n+            :ref:`func-animation`.\r\n+        update : {'loc', 'bbox'}, optional\r\n+            If \"loc\", update the *loc* parameter of the legend upon finalizing.\r\n+            If \"bbox\", update the *bbox_to_anchor* parameter.\r\n+        \"\"\"\r\n+        self.legend = legend\r\n+\r\n+        _api.check_in_list([\"loc\", \"bbox\"], update=update)\r\n+        self._update = update\r\n+\r\n+        super().__init__(legend, legend._legend_box, use_blit=use_blit)\r\n+\r\n+    def finalize_offset(self):\r\n+        if self._update == \"loc\":\r\n+            self._update_loc(self.get_loc_in_canvas())\r\n+        elif self._update == \"bbox\":\r\n+            self._bbox_to_anchor(self.get_loc_in_canvas())\r\n+\r\n+    def _update_loc(self, loc_in_canvas):\r\n+        bbox = self.legend.get_bbox_to_anchor()\r\n+        # if bbox has zero width or height, the transformation is\r\n+        # ill-defined. Fall back to the default bbox_to_anchor.\r\n+        if bbox.width == 0 or bbox.height == 0:\r\n+            self.legend.set_bbox_to_anchor(None)\r\n+            bbox = self.legend.get_bbox_to_anchor()\r\n+        _bbox_transform = BboxTransformFrom(bbox)\r\n+        self.legend._loc = tuple(_bbox_transform.transform(loc_in_canvas))\r\n+\r\n+    def _update_bbox_to_anchor(self, loc_in_canvas):\r\n+        loc_in_bbox = self.legend.axes.transAxes.transform(loc_in_canvas)\r\n+        self.legend.set_bbox_to_anchor(loc_in_bbox)\r\n+\r\n+\r\n+_legend_kw_doc_base = \"\"\"\r\n+bbox_to_anchor : `.BboxBase`, 2-tuple, or 4-tuple of floats\r\n+    Box that is used to position the legend in conjunction with *loc*.\r\n+    Defaults to `axes.bbox` (if called as a method to `.Axes.legend`) or\r\n+    `figure.bbox` (if `.Figure.legend`).  This argument allows arbitrary\r\n+    placement of the legend.\r\n+\r\n+    Bbox coordinates are interpreted in the coordinate system given by\r\n+    *bbox_transform*, with the default transform\r\n+    Axes or Figure coordinates, depending on which ``legend`` is called.\r\n+\r\n+    If a 4-tuple or `.BboxBase` is given, then it specifies the bbox\r\n+    ``(x, y, width, height)`` that the legend is placed in.\r\n+    To put the legend in the best location in the bottom right\r\n+    quadrant of the axes (or figure)::\r\n+\r\n+        loc='best', bbox_to_anchor=(0.5, 0., 0.5, 0.5)\r\n+\r\n+    A 2-tuple ``(x, y)`` places the corner of the legend specified by *loc* at\r\n+    x, y.  For example, to put the legend's upper right-hand corner in the\r\n+    center of the axes (or figure) the following keywords can be used::\r\n+\r\n+        loc='upper right', bbox_to_anchor=(0.5, 0.5)\r\n+\r\n+ncols : int, default: 1\r\n+    The number of columns that the legend has.\r\n+\r\n+    For backward compatibility, the spelling *ncol* is also supported\r\n+    but it is discouraged. If both are given, *ncols* takes precedence.\r\n+\r\n+prop : None or `matplotlib.font_manager.FontProperties` or dict\r\n+    The font properties of the legend. If None (default), the current\r\n+    :data:`matplotlib.rcParams` will be used.\r\n+\r\n+fontsize : int or {'xx-small', 'x-small', 'small', 'medium', 'large', \\\r\n+'x-large', 'xx-large'}\r\n+    The font size of the legend. If the value is numeric the size will be the\r\n+    absolute font size in points. String values are relative to the current\r\n+    default font size. This argument is only used if *prop* is not specified.\r\n+\r\n+labelcolor : str or list, default: :rc:`legend.labelcolor`\r\n+    The color of the text in the legend. Either a valid color string\r\n+    (for example, 'red'), or a list of color strings. The labelcolor can\r\n+    also be made to match the color of the line or marker using 'linecolor',\r\n+    'markerfacecolor' (or 'mfc'), or 'markeredgecolor' (or 'mec').\r\n+\r\n+    Labelcolor can be set globally using :rc:`legend.labelcolor`. If None,\r\n+    use :rc:`text.color`.\r\n+\r\n+numpoints : int, default: :rc:`legend.numpoints`\r\n+    The number of marker points in the legend when creating a legend\r\n+    entry for a `.Line2D` (line).\r\n+\r\n+scatterpoints : int, default: :rc:`legend.scatterpoints`\r\n+    The number of marker points in the legend when creating\r\n+    a legend entry for a `.PathCollection` (scatter plot).\r\n+\r\n+scatteryoffsets : iterable of floats, default: ``[0.375, 0.5, 0.3125]``\r\n+    The vertical offset (relative to the font size) for the markers\r\n+    created for a scatter plot legend entry. 0.0 is at the base the\r\n+    legend text, and 1.0 is at the top. To draw all markers at the\r\n+    same height, set to ``[0.5]``.\r\n+\r\n+markerscale : float, default: :rc:`legend.markerscale`\r\n+    The relative size of legend markers compared with the originally\r\n+    drawn ones.\r\n+\r\n+markerfirst : bool, default: True\r\n+    If *True*, legend marker is placed to the left of the legend label.\r\n+    If *False*, legend marker is placed to the right of the legend label.\r\n+\r\n+reverse : bool, default: False\r\n+    If *True*, the legend labels are displayed in reverse order from the input.\r\n+    If *False*, the legend labels are displayed in the same order as the input.\r\n+\r\n+    .. versionadded:: 3.7\r\n+\r\n+frameon : bool, default: :rc:`legend.frameon`\r\n+    Whether the legend should be drawn on a patch (frame).\r\n+\r\n+fancybox : bool, default: :rc:`legend.fancybox`\r\n+    Whether round edges should be enabled around the `.FancyBboxPatch` which\r\n+    makes up the legend's background.\r\n+\r\n+shadow : bool, default: :rc:`legend.shadow`\r\n+    Whether to draw a shadow behind the legend.\r\n+\r\n+framealpha : float, default: :rc:`legend.framealpha`\r\n+    The alpha transparency of the legend's background.\r\n+    If *shadow* is activated and *framealpha* is ``None``, the default value is\r\n+    ignored.\r\n+\r\n+facecolor : \"inherit\" or color, default: :rc:`legend.facecolor`\r\n+    The legend's background color.\r\n+    If ``\"inherit\"``, use :rc:`axes.facecolor`.\r\n+\r\n+edgecolor : \"inherit\" or color, default: :rc:`legend.edgecolor`\r\n+    The legend's background patch edge color.\r\n+    If ``\"inherit\"``, use take :rc:`axes.edgecolor`.\r\n+\r\n+mode : {\"expand\", None}\r\n+    If *mode* is set to ``\"expand\"`` the legend will be horizontally\r\n+    expanded to fill the axes area (or *bbox_to_anchor* if defines\r\n+    the legend's size).\r\n+\r\n+bbox_transform : None or `matplotlib.transforms.Transform`\r\n+    The transform for the bounding box (*bbox_to_anchor*). For a value\r\n+    of ``None`` (default) the Axes'\r\n+    :data:`~matplotlib.axes.Axes.transAxes` transform will be used.\r\n+\r\n+title : str or None\r\n+    The legend's title. Default is no title (``None``).\r\n+\r\n+title_fontproperties : None or `matplotlib.font_manager.FontProperties` or dict\r\n+    The font properties of the legend's title. If None (default), the\r\n+    *title_fontsize* argument will be used if present; if *title_fontsize* is\r\n+    also None, the current :rc:`legend.title_fontsize` will be used.\r\n+\r\n+title_fontsize : int or {'xx-small', 'x-small', 'small', 'medium', 'large', \\\r\n+'x-large', 'xx-large'}, default: :rc:`legend.title_fontsize`\r\n+    The font size of the legend's title.\r\n+    Note: This cannot be combined with *title_fontproperties*. If you want\r\n+    to set the fontsize alongside other font properties, use the *size*\r\n+    parameter in *title_fontproperties*.\r\n+\r\n+alignment : {'center', 'left', 'right'}, default: 'center'\r\n+    The alignment of the legend title and the box of entries. The entries\r\n+    are aligned as a single block, so that markers always lined up.\r\n+\r\n+borderpad : float, default: :rc:`legend.borderpad`\r\n+    The fractional whitespace inside the legend border, in font-size units.\r\n+\r\n+labelspacing : float, default: :rc:`legend.labelspacing`\r\n+    The vertical space between the legend entries, in font-size units.\r\n+\r\n+handlelength : float, default: :rc:`legend.handlelength`\r\n+    The length of the legend handles, in font-size units.\r\n+\r\n+handleheight : float, default: :rc:`legend.handleheight`\r\n+    The height of the legend handles, in font-size units.\r\n+\r\n+handletextpad : float, default: :rc:`legend.handletextpad`\r\n+    The pad between the legend handle and text, in font-size units.\r\n+\r\n+borderaxespad : float, default: :rc:`legend.borderaxespad`\r\n+    The pad between the axes and legend border, in font-size units.\r\n+\r\n+columnspacing : float, default: :rc:`legend.columnspacing`\r\n+    The spacing between columns, in font-size units.\r\n+\r\n+handler_map : dict or None\r\n+    The custom dictionary mapping instances or types to a legend\r\n+    handler. This *handler_map* updates the default handler map\r\n+    found at `matplotlib.legend.Legend.get_legend_handler_map`.\r\n+\r\n+draggable : bool, default: False\r\n+    Whether the legend can be dragged with the mouse.\r\n+\"\"\"\r\n+\r\n+_loc_doc_base = \"\"\"\r\n+loc : str or pair of floats, {0}\r\n+    The location of the legend.\r\n+\r\n+    The strings\r\n+    ``'upper left', 'upper right', 'lower left', 'lower right'``\r\n+    place the legend at the corresponding corner of the axes/figure.\r\n+\r\n+    The strings\r\n+    ``'upper center', 'lower center', 'center left', 'center right'``\r\n+    place the legend at the center of the corresponding edge of the\r\n+    axes/figure.\r\n+\r\n+    The string ``'center'`` places the legend at the center of the axes/figure.\r\n+\r\n+    The string ``'best'`` places the legend at the location, among the nine\r\n+    locations defined so far, with the minimum overlap with other drawn\r\n+    artists.  This option can be quite slow for plots with large amounts of\r\n+    data; your plotting speed may benefit from providing a specific location.\r\n+\r\n+    The location can also be a 2-tuple giving the coordinates of the lower-left\r\n+    corner of the legend in axes coordinates (in which case *bbox_to_anchor*\r\n+    will be ignored).\r\n+\r\n+    For back-compatibility, ``'center right'`` (but no other location) can also\r\n+    be spelled ``'right'``, and each \"string\" locations can also be given as a\r\n+    numeric value:\r\n+\r\n+        ===============   =============\r\n+        Location String   Location Code\r\n+        ===============   =============\r\n+        'best'            0\r\n+        'upper right'     1\r\n+        'upper left'      2\r\n+        'lower left'      3\r\n+        'lower right'     4\r\n+        'right'           5\r\n+        'center left'     6\r\n+        'center right'    7\r\n+        'lower center'    8\r\n+        'upper center'    9\r\n+        'center'          10\r\n+        ===============   =============\r\n+    {1}\"\"\"\r\n+\r\n+_legend_kw_axes_st = (_loc_doc_base.format(\"default: :rc:`legend.loc`\", '') +\r\n+                      _legend_kw_doc_base)\r\n+_docstring.interpd.update(_legend_kw_axes=_legend_kw_axes_st)\r\n+\r\n+_outside_doc = \"\"\"\r\n+    If a figure is using the constrained layout manager, the string codes\r\n+    of the *loc* keyword argument can get better layout behaviour using the\r\n+    prefix 'outside'. There is ambiguity at the corners, so 'outside\r\n+    upper right' will make space for the legend above the rest of the\r\n+    axes in the layout, and 'outside right upper' will make space on the\r\n+    right side of the layout.  In addition to the values of *loc*\r\n+    listed above, we have 'outside right upper', 'outside right lower',\r\n+    'outside left upper', and 'outside left lower'.  See\r\n+    :doc:`/tutorials/intermediate/legend_guide` for more details.\r\n+\"\"\"\r\n+\r\n+_legend_kw_figure_st = (_loc_doc_base.format(\"default: 'upper right'\",\r\n+                                             _outside_doc) +\r\n+                        _legend_kw_doc_base)\r\n+_docstring.interpd.update(_legend_kw_figure=_legend_kw_figure_st)\r\n+\r\n+_legend_kw_both_st = (\r\n+    _loc_doc_base.format(\"default: 'best' for axes, 'upper right' for figures\",\r\n+                         _outside_doc) +\r\n+    _legend_kw_doc_base)\r\n+_docstring.interpd.update(_legend_kw_doc=_legend_kw_both_st)\r\n+\r\n+\r\n+class Legend(Artist):\r\n+    \"\"\"\r\n+    Place a legend on the axes at location loc.\r\n+    \"\"\"\r\n+\r\n+    # 'best' is only implemented for axes legends\r\n+    codes = {'best': 0, **AnchoredOffsetbox.codes}\r\n+    zorder = 5\r\n+\r\n+    def __str__(self):\r\n+        return \"Legend\"\r\n+\r\n+    @_api.make_keyword_only(\"3.6\", \"loc\")\r\n+    @_docstring.dedent_interpd\r\n+    def __init__(\r\n+        self, parent, handles, labels,\r\n+        loc=None,\r\n+        numpoints=None,      # number of points in the legend line\r\n+        markerscale=None,    # relative size of legend markers vs. original\r\n+        markerfirst=True,    # left/right ordering of legend marker and label\r\n+        reverse=False,       # reverse ordering of legend marker and label\r\n+        scatterpoints=None,  # number of scatter points\r\n+        scatteryoffsets=None,\r\n+        prop=None,           # properties for the legend texts\r\n+        fontsize=None,       # keyword to set font size directly\r\n+        labelcolor=None,     # keyword to set the text color\r\n+\r\n+        # spacing & pad defined as a fraction of the font-size\r\n+        borderpad=None,      # whitespace inside the legend border\r\n+        labelspacing=None,   # vertical space between the legend entries\r\n+        handlelength=None,   # length of the legend handles\r\n+        handleheight=None,   # height of the legend handles\r\n+        handletextpad=None,  # pad between the legend handle and text\r\n+        borderaxespad=None,  # pad between the axes and legend border\r\n+        columnspacing=None,  # spacing between columns\r\n+\r\n+        ncols=1,     # number of columns\r\n+        mode=None,  # horizontal distribution of columns: None or \"expand\"\r\n+\r\n+        fancybox=None,  # True: fancy box, False: rounded box, None: rcParam\r\n+        shadow=None,\r\n+        title=None,           # legend title\r\n+        title_fontsize=None,  # legend title font size\r\n+        framealpha=None,      # set frame alpha\r\n+        edgecolor=None,       # frame patch edgecolor\r\n+        facecolor=None,       # frame patch facecolor\r\n+\r\n+        bbox_to_anchor=None,  # bbox to which the legend will be anchored\r\n+        bbox_transform=None,  # transform for the bbox\r\n+        frameon=None,         # draw frame\r\n+        handler_map=None,\r\n+        title_fontproperties=None,  # properties for the legend title\r\n+        alignment=\"center\",       # control the alignment within the legend box\r\n+        *,\r\n+        ncol=1,  # synonym for ncols (backward compatibility)\r\n+        draggable=False  # whether the legend can be dragged with the mouse\r\n+    ):\r\n+        \"\"\"\r\n+        Parameters\r\n+        ----------\r\n+        parent : `~matplotlib.axes.Axes` or `.Figure`\r\n+            The artist that contains the legend.\r\n+\r\n+        handles : list of `.Artist`\r\n+            A list of Artists (lines, patches) to be added to the legend.\r\n+\r\n+        labels : list of str\r\n+            A list of labels to show next to the artists. The length of handles\r\n+            and labels should be the same. If they are not, they are truncated\r\n+            to the length of the shorter list.\r\n+\r\n+        Other Parameters\r\n+        ----------------\r\n+        %(_legend_kw_doc)s\r\n+\r\n+        Attributes\r\n+        ----------\r\n+        legend_handles\r\n+            List of `.Artist` objects added as legend entries.\r\n+\r\n+            .. versionadded:: 3.7\r\n+\r\n+        Notes\r\n+        -----\r\n+        Users can specify any arbitrary location for the legend using the\r\n+        *bbox_to_anchor* keyword argument. *bbox_to_anchor* can be a\r\n+        `.BboxBase` (or derived there from) or a tuple of 2 or 4 floats.\r\n+        See `set_bbox_to_anchor` for more detail.\r\n+\r\n+        The legend location can be specified by setting *loc* with a tuple of\r\n+        2 floats, which is interpreted as the lower-left corner of the legend\r\n+        in the normalized axes coordinate.\r\n+        \"\"\"\r\n+        # local import only to avoid circularity\r\n+        from matplotlib.axes import Axes\r\n+        from matplotlib.figure import FigureBase\r\n+\r\n+        super().__init__()\r\n+\r\n+        if prop is None:\r\n+            if fontsize is not None:\r\n+                self.prop = FontProperties(size=fontsize)\r\n+            else:\r\n+                self.prop = FontProperties(\r\n+                    size=mpl.rcParams[\"legend.fontsize\"])\r\n+        else:\r\n+            self.prop = FontProperties._from_any(prop)\r\n+            if isinstance(prop, dict) and \"size\" not in prop:\r\n+                self.prop.set_size(mpl.rcParams[\"legend.fontsize\"])\r\n+\r\n+        self._fontsize = self.prop.get_size_in_points()\r\n+\r\n+        self.texts = []\r\n+        self.legend_handles = []\r\n+        self._legend_title_box = None\r\n+\r\n+        #: A dictionary with the extra handler mappings for this Legend\r\n+        #: instance.\r\n+        self._custom_handler_map = handler_map\r\n+\r\n+        def val_or_rc(val, rc_name):\r\n+            return val if val is not None else mpl.rcParams[rc_name]\r\n+\r\n+        self.numpoints = val_or_rc(numpoints, 'legend.numpoints')\r\n+        self.markerscale = val_or_rc(markerscale, 'legend.markerscale')\r\n+        self.scatterpoints = val_or_rc(scatterpoints, 'legend.scatterpoints')\r\n+        self.borderpad = val_or_rc(borderpad, 'legend.borderpad')\r\n+        self.labelspacing = val_or_rc(labelspacing, 'legend.labelspacing')\r\n+        self.handlelength = val_or_rc(handlelength, 'legend.handlelength')\r\n+        self.handleheight = val_or_rc(handleheight, 'legend.handleheight')\r\n+        self.handletextpad = val_or_rc(handletextpad, 'legend.handletextpad')\r\n+        self.borderaxespad = val_or_rc(borderaxespad, 'legend.borderaxespad')\r\n+        self.columnspacing = val_or_rc(columnspacing, 'legend.columnspacing')\r\n+        self.shadow = val_or_rc(shadow, 'legend.shadow')\r\n+        # trim handles and labels if illegal label...\r\n+        _lab, _hand = [], []\r\n+        for label, handle in zip(labels, handles):\r\n+            if isinstance(label, str) and label.startswith('_'):\r\n+                _api.warn_external(f\"The label {label!r} of {handle!r} starts \"\r\n+                                   \"with '_'. It is thus excluded from the \"\r\n+                                   \"legend.\")\r\n+            else:\r\n+                _lab.append(label)\r\n+                _hand.append(handle)\r\n+        labels, handles = _lab, _hand\r\n+\r\n+        if reverse:\r\n+            labels.reverse()\r\n+            handles.reverse()\r\n+\r\n+        if len(handles) < 2:\r\n+            ncols = 1\r\n+        self._ncols = ncols if ncols != 1 else ncol\r\n+\r\n+        if self.numpoints <= 0:\r\n+            raise ValueError(\"numpoints must be > 0; it was %d\" % numpoints)\r\n+\r\n+        # introduce y-offset for handles of the scatter plot\r\n+        if scatteryoffsets is None:\r\n+            self._scatteryoffsets = np.array([3. / 8., 4. / 8., 2.5 / 8.])\r\n+        else:\r\n+            self._scatteryoffsets = np.asarray(scatteryoffsets)\r\n+        reps = self.scatterpoints // len(self._scatteryoffsets) + 1\r\n+        self._scatteryoffsets = np.tile(self._scatteryoffsets,\r\n+                                        reps)[:self.scatterpoints]\r\n+\r\n+        # _legend_box is a VPacker instance that contains all\r\n+        # legend items and will be initialized from _init_legend_box()\r\n+        # method.\r\n+        self._legend_box = None\r\n+\r\n+        if isinstance(parent, Axes):\r\n+            self.isaxes = True\r\n+            self.axes = parent\r\n+            self.set_figure(parent.figure)\r\n+        elif isinstance(parent, FigureBase):\r\n+            self.isaxes = False\r\n+            self.set_figure(parent)\r\n+        else:\r\n+            raise TypeError(\r\n+                \"Legend needs either Axes or FigureBase as parent\"\r\n+            )\r\n+        self.parent = parent\r\n+\r\n+        loc0 = loc\r\n+        self._loc_used_default = loc is None\r\n+        if loc is None:\r\n+            loc = mpl.rcParams[\"legend.loc\"]\r\n+            if not self.isaxes and loc in [0, 'best']:\r\n+                loc = 'upper right'\r\n+\r\n+        # handle outside legends:\r\n+        self._outside_loc = None\r\n+        if isinstance(loc, str):\r\n+            if loc.split()[0] == 'outside':\r\n+                # strip outside:\r\n+                loc = loc.split('outside ')[1]\r\n+                # strip \"center\" at the beginning\r\n+                self._outside_loc = loc.replace('center ', '')\r\n+                # strip first\r\n+                self._outside_loc = self._outside_loc.split()[0]\r\n+                locs = loc.split()\r\n+                if len(locs) > 1 and locs[0] in ('right', 'left'):\r\n+                    # locs doesn't accept \"left upper\", etc, so swap\r\n+                    if locs[0] != 'center':\r\n+                        locs = locs[::-1]\r\n+                    loc = locs[0] + ' ' + locs[1]\r\n+            # check that loc is in acceptable strings\r\n+            loc = _api.check_getitem(self.codes, loc=loc)\r\n+\r\n+        if self.isaxes and self._outside_loc:\r\n+            raise ValueError(\r\n+                f\"'outside' option for loc='{loc0}' keyword argument only \"\r\n+                \"works for figure legends\")\r\n+\r\n+        if not self.isaxes and loc == 0:\r\n+            raise ValueError(\r\n+                \"Automatic legend placement (loc='best') not implemented for \"\r\n+                \"figure legend\")\r\n+\r\n+        self._mode = mode\r\n+        self.set_bbox_to_anchor(bbox_to_anchor, bbox_transform)\r\n+\r\n+        # We use FancyBboxPatch to draw a legend frame. The location\r\n+        # and size of the box will be updated during the drawing time.\r\n+\r\n+        if facecolor is None:\r\n+            facecolor = mpl.rcParams[\"legend.facecolor\"]\r\n+        if facecolor == 'inherit':\r\n+            facecolor = mpl.rcParams[\"axes.facecolor\"]\r\n+\r\n+        if edgecolor is None:\r\n+            edgecolor = mpl.rcParams[\"legend.edgecolor\"]\r\n+        if edgecolor == 'inherit':\r\n+            edgecolor = mpl.rcParams[\"axes.edgecolor\"]\r\n+\r\n+        if fancybox is None:\r\n+            fancybox = mpl.rcParams[\"legend.fancybox\"]\r\n+\r\n+        self.legendPatch = FancyBboxPatch(\r\n+            xy=(0, 0), width=1, height=1,\r\n+            facecolor=facecolor, edgecolor=edgecolor,\r\n+            # If shadow is used, default to alpha=1 (#8943).\r\n+            alpha=(framealpha if framealpha is not None\r\n+                   else 1 if shadow\r\n+                   else mpl.rcParams[\"legend.framealpha\"]),\r\n+            # The width and height of the legendPatch will be set (in draw())\r\n+            # to the length that includes the padding. Thus we set pad=0 here.\r\n+            boxstyle=(\"round,pad=0,rounding_size=0.2\" if fancybox\r\n+                      else \"square,pad=0\"),\r\n+            mutation_scale=self._fontsize,\r\n+            snap=True,\r\n+            visible=(frameon if frameon is not None\r\n+                     else mpl.rcParams[\"legend.frameon\"])\r\n+        )\r\n+        self._set_artist_props(self.legendPatch)\r\n+\r\n+        _api.check_in_list([\"center\", \"left\", \"right\"], alignment=alignment)\r\n+        self._alignment = alignment\r\n+\r\n+        # init with null renderer\r\n+        self._init_legend_box(handles, labels, markerfirst)\r\n+\r\n+        tmp = self._loc_used_default\r\n+        self._set_loc(loc)\r\n+        self._loc_used_default = tmp  # ignore changes done by _set_loc\r\n+\r\n+        # figure out title font properties:\r\n+        if title_fontsize is not None and title_fontproperties is not None:\r\n+            raise ValueError(\r\n+                \"title_fontsize and title_fontproperties can't be specified \"\r\n+                \"at the same time. Only use one of them. \")\r\n+        title_prop_fp = FontProperties._from_any(title_fontproperties)\r\n+        if isinstance(title_fontproperties, dict):\r\n+            if \"size\" not in title_fontproperties:\r\n+                title_fontsize = mpl.rcParams[\"legend.title_fontsize\"]\r\n+                title_prop_fp.set_size(title_fontsize)\r\n+        elif title_fontsize is not None:\r\n+            title_prop_fp.set_size(title_fontsize)\r\n+        elif not isinstance(title_fontproperties, FontProperties):\r\n+            title_fontsize = mpl.rcParams[\"legend.title_fontsize\"]\r\n+            title_prop_fp.set_size(title_fontsize)\r\n+\r\n+        self.set_title(title, prop=title_prop_fp)\r\n+\r\n+        self._draggable = None\r\n+        self.set_draggable(state=draggable)\r\n+\r\n+        # set the text color\r\n+\r\n+        color_getters = {  # getter function depends on line or patch\r\n+            'linecolor':       ['get_color',           'get_facecolor'],\r\n+            'markerfacecolor': ['get_markerfacecolor', 'get_facecolor'],\r\n+            'mfc':             ['get_markerfacecolor', 'get_facecolor'],\r\n+            'markeredgecolor': ['get_markeredgecolor', 'get_edgecolor'],\r\n+            'mec':             ['get_markeredgecolor', 'get_edgecolor'],\r\n+        }\r\n+        if labelcolor is None:\r\n+            if mpl.rcParams['legend.labelcolor'] is not None:\r\n+                labelcolor = mpl.rcParams['legend.labelcolor']\r\n+            else:\r\n+                labelcolor = mpl.rcParams['text.color']\r\n+        if isinstance(labelcolor, str) and labelcolor in color_getters:\r\n+            getter_names = color_getters[labelcolor]\r\n+            for handle, text in zip(self.legend_handles, self.texts):\r\n+                try:\r\n+                    if handle.get_array() is not None:\r\n+                        continue\r\n+                except AttributeError:\r\n+                    pass\r\n+                for getter_name in getter_names:\r\n+                    try:\r\n+                        color = getattr(handle, getter_name)()\r\n+                        if isinstance(color, np.ndarray):\r\n+                            if (\r\n+                                    color.shape[0] == 1\r\n+                                    or np.isclose(color, color[0]).all()\r\n+                            ):\r\n+                                text.set_color(color[0])\r\n+                            else:\r\n+                                pass\r\n+                        else:\r\n+                            text.set_color(color)\r\n+                        break\r\n+                    except AttributeError:\r\n+                        pass\r\n+        elif isinstance(labelcolor, str) and labelcolor == 'none':\r\n+            for text in self.texts:\r\n+                text.set_color(labelcolor)\r\n+        elif np.iterable(labelcolor):\r\n+            for text, color in zip(self.texts,\r\n+                                   itertools.cycle(\r\n+                                       colors.to_rgba_array(labelcolor))):\r\n+                text.set_color(color)\r\n+        else:\r\n+            raise ValueError(f\"Invalid labelcolor: {labelcolor!r}\")\r\n+\r\n+    legendHandles = _api.deprecated('3.7', alternative=\"legend_handles\")(\r\n+        property(lambda self: self.legend_handles))\r\n+\r\n+    def _set_artist_props(self, a):\r\n+        \"\"\"\r\n+        Set the boilerplate props for artists added to axes.\r\n+        \"\"\"\r\n+        a.set_figure(self.figure)\r\n+        if self.isaxes:\r\n+            # a.set_axes(self.axes)\r\n+            a.axes = self.axes\r\n+\r\n+        a.set_transform(self.get_transform())\r\n+\r\n+    def _set_loc(self, loc):\r\n+        # find_offset function will be provided to _legend_box and\r\n+        # _legend_box will draw itself at the location of the return\r\n+        # value of the find_offset.\r\n+        self._loc_used_default = False\r\n+        self._loc_real = loc\r\n+        self.stale = True\r\n+        self._legend_box.set_offset(self._findoffset)\r\n+\r\n+    def set_ncols(self, ncols):\r\n+        \"\"\"Set the number of columns.\"\"\"\r\n+        self._ncols = ncols\r\n+\r\n+    def _get_loc(self):\r\n+        return self._loc_real\r\n+\r\n+    _loc = property(_get_loc, _set_loc)\r\n+\r\n+    def _findoffset(self, width, height, xdescent, ydescent, renderer):\r\n+        \"\"\"Helper function to locate the legend.\"\"\"\r\n+\r\n+        if self._loc == 0:  # \"best\".\r\n+            x, y = self._find_best_position(width, height, renderer)\r\n+        elif self._loc in Legend.codes.values():  # Fixed location.\r\n+            bbox = Bbox.from_bounds(0, 0, width, height)\r\n+            x, y = self._get_anchored_bbox(self._loc, bbox,\r\n+                                           self.get_bbox_to_anchor(),\r\n+                                           renderer)\r\n+        else:  # Axes or figure coordinates.\r\n+            fx, fy = self._loc\r\n+            bbox = self.get_bbox_to_anchor()\r\n+            x, y = bbox.x0 + bbox.width * fx, bbox.y0 + bbox.height * fy\r\n+\r\n+        return x + xdescent, y + ydescent\r\n+\r\n+    @allow_rasterization\r\n+    def draw(self, renderer):\r\n+        # docstring inherited\r\n+        if not self.get_visible():\r\n+            return\r\n+\r\n+        renderer.open_group('legend', gid=self.get_gid())\r\n+\r\n+        fontsize = renderer.points_to_pixels(self._fontsize)\r\n+\r\n+        # if mode == fill, set the width of the legend_box to the\r\n+        # width of the parent (minus pads)\r\n+        if self._mode in [\"expand\"]:\r\n+            pad = 2 * (self.borderaxespad + self.borderpad) * fontsize\r\n+            self._legend_box.set_width(self.get_bbox_to_anchor().width - pad)\r\n+\r\n+        # update the location and size of the legend. This needs to\r\n+        # be done in any case to clip the figure right.\r\n+        bbox = self._legend_box.get_window_extent(renderer)\r\n+        self.legendPatch.set_bounds(bbox.bounds)\r\n+        self.legendPatch.set_mutation_scale(fontsize)\r\n+\r\n+        if self.shadow:\r\n+            Shadow(self.legendPatch, 2, -2).draw(renderer)\r\n+\r\n+        self.legendPatch.draw(renderer)\r\n+        self._legend_box.draw(renderer)\r\n+\r\n+        renderer.close_group('legend')\r\n+        self.stale = False\r\n+\r\n+    # _default_handler_map defines the default mapping between plot\r\n+    # elements and the legend handlers.\r\n+\r\n+    _default_handler_map = {\r\n+        StemContainer: legend_handler.HandlerStem(),\r\n+        ErrorbarContainer: legend_handler.HandlerErrorbar(),\r\n+        Line2D: legend_handler.HandlerLine2D(),\r\n+        Patch: legend_handler.HandlerPatch(),\r\n+        StepPatch: legend_handler.HandlerStepPatch(),\r\n+        LineCollection: legend_handler.HandlerLineCollection(),\r\n+        RegularPolyCollection: legend_handler.HandlerRegularPolyCollection(),\r\n+        CircleCollection: legend_handler.HandlerCircleCollection(),\r\n+        BarContainer: legend_handler.HandlerPatch(\r\n+            update_func=legend_handler.update_from_first_child),\r\n+        tuple: legend_handler.HandlerTuple(),\r\n+        PathCollection: legend_handler.HandlerPathCollection(),\r\n+        PolyCollection: legend_handler.HandlerPolyCollection()\r\n+        }\r\n+\r\n+    # (get|set|update)_default_handler_maps are public interfaces to\r\n+    # modify the default handler map.\r\n+\r\n+    @classmethod\r\n+    def get_default_handler_map(cls):\r\n+        \"\"\"Return the global default handler map, shared by all legends.\"\"\"\r\n+        return cls._default_handler_map\r\n+\r\n+    @classmethod\r\n+    def set_default_handler_map(cls, handler_map):\r\n+        \"\"\"Set the global default handler map, shared by all legends.\"\"\"\r\n+        cls._default_handler_map = handler_map\r\n+\r\n+    @classmethod\r\n+    def update_default_handler_map(cls, handler_map):\r\n+        \"\"\"Update the global default handler map, shared by all legends.\"\"\"\r\n+        cls._default_handler_map.update(handler_map)\r\n+\r\n+    def get_legend_handler_map(self):\r\n+        \"\"\"Return this legend instance's handler map.\"\"\"\r\n+        default_handler_map = self.get_default_handler_map()\r\n+        return ({**default_handler_map, **self._custom_handler_map}\r\n+                if self._custom_handler_map else default_handler_map)\r\n+\r\n+    @staticmethod\r\n+    def get_legend_handler(legend_handler_map, orig_handle):\r\n+        \"\"\"\r\n+        Return a legend handler from *legend_handler_map* that\r\n+        corresponds to *orig_handler*.\r\n+\r\n+        *legend_handler_map* should be a dictionary object (that is\r\n+        returned by the get_legend_handler_map method).\r\n+\r\n+        It first checks if the *orig_handle* itself is a key in the\r\n+        *legend_handler_map* and return the associated value.\r\n+        Otherwise, it checks for each of the classes in its\r\n+        method-resolution-order. If no matching key is found, it\r\n+        returns ``None``.\r\n+        \"\"\"\r\n+        try:\r\n+            return legend_handler_map[orig_handle]\r\n+        except (TypeError, KeyError):  # TypeError if unhashable.\r\n+            pass\r\n+        for handle_type in type(orig_handle).mro():\r\n+            try:\r\n+                return legend_handler_map[handle_type]\r\n+            except KeyError:\r\n+                pass\r\n+        return None\r\n+\r\n+    def _init_legend_box(self, handles, labels, markerfirst=True):\r\n+        \"\"\"\r\n+        Initialize the legend_box. The legend_box is an instance of\r\n+        the OffsetBox, which is packed with legend handles and\r\n+        texts. Once packed, their location is calculated during the\r\n+        drawing time.\r\n+        \"\"\"\r\n+\r\n+        fontsize = self._fontsize\r\n+\r\n+        # legend_box is a HPacker, horizontally packed with columns.\r\n+        # Each column is a VPacker, vertically packed with legend items.\r\n+        # Each legend item is a HPacker packed with:\r\n+        # - handlebox: a DrawingArea which contains the legend handle.\r\n+        # - labelbox: a TextArea which contains the legend text.\r\n+\r\n+        text_list = []  # the list of text instances\r\n+        handle_list = []  # the list of handle instances\r\n+        handles_and_labels = []\r\n+\r\n+        # The approximate height and descent of text. These values are\r\n+        # only used for plotting the legend handle.\r\n+        descent = 0.35 * fontsize * (self.handleheight - 0.7)  # heuristic.\r\n+        height = fontsize * self.handleheight - descent\r\n+        # each handle needs to be drawn inside a box of (x, y, w, h) =\r\n+        # (0, -descent, width, height).  And their coordinates should\r\n+        # be given in the display coordinates.\r\n+\r\n+        # The transformation of each handle will be automatically set\r\n+        # to self.get_transform(). If the artist does not use its\r\n+        # default transform (e.g., Collections), you need to\r\n+        # manually set their transform to the self.get_transform().\r\n+        legend_handler_map = self.get_legend_handler_map()\r\n+\r\n+        for orig_handle, label in zip(handles, labels):\r\n+            handler = self.get_legend_handler(legend_handler_map, orig_handle)\r\n+            if handler is None:\r\n+                _api.warn_external(\r\n+                             \"Legend does not support handles for \"\r\n+                             f\"{type(orig_handle).__name__} \"\r\n+                             \"instances.\\nA proxy artist may be used \"\r\n+                             \"instead.\\nSee: https://matplotlib.org/\"\r\n+                             \"stable/tutorials/intermediate/legend_guide.html\"\r\n+                             \"#controlling-the-legend-entries\")\r\n+                # No handle for this artist, so we just defer to None.\r\n+                handle_list.append(None)\r\n+            else:\r\n+                textbox = TextArea(label, multilinebaseline=True,\r\n+                                   textprops=dict(\r\n+                                       verticalalignment='baseline',\r\n+                                       horizontalalignment='left',\r\n+                                       fontproperties=self.prop))\r\n+                handlebox = DrawingArea(width=self.handlelength * fontsize,\r\n+                                        height=height,\r\n+                                        xdescent=0., ydescent=descent)\r\n+\r\n+                text_list.append(textbox._text)\r\n+                # Create the artist for the legend which represents the\r\n+                # original artist/handle.\r\n+                handle_list.append(handler.legend_artist(self, orig_handle,\r\n+                                                         fontsize, handlebox))\r\n+                handles_and_labels.append((handlebox, textbox))\r\n+\r\n+        columnbox = []\r\n+        # array_split splits n handles_and_labels into ncols columns, with the\r\n+        # first n%ncols columns having an extra entry.  filter(len, ...)\r\n+        # handles the case where n < ncols: the last ncols-n columns are empty\r\n+        # and get filtered out.\r\n+        for handles_and_labels_column in filter(\r\n+                len, np.array_split(handles_and_labels, self._ncols)):\r\n+            # pack handlebox and labelbox into itembox\r\n+            itemboxes = [HPacker(pad=0,\r\n+                                 sep=self.handletextpad * fontsize,\r\n+                                 children=[h, t] if markerfirst else [t, h],\r\n+                                 align=\"baseline\")\r\n+                         for h, t in handles_and_labels_column]\r\n+            # pack columnbox\r\n+            alignment = \"baseline\" if markerfirst else \"right\"\r\n+            columnbox.append(VPacker(pad=0,\r\n+                                     sep=self.labelspacing * fontsize,\r\n+                                     align=alignment,\r\n+                                     children=itemboxes))\r\n+\r\n+        mode = \"expand\" if self._mode == \"expand\" else \"fixed\"\r\n+        sep = self.columnspacing * fontsize\r\n+        self._legend_handle_box = HPacker(pad=0,\r\n+                                          sep=sep, align=\"baseline\",\r\n+                                          mode=mode,\r\n+                                          children=columnbox)\r\n+        self._legend_title_box = TextArea(\"\")\r\n+        self._legend_box = VPacker(pad=self.borderpad * fontsize,\r\n+                                   sep=self.labelspacing * fontsize,\r\n+                                   align=self._alignment,\r\n+                                   children=[self._legend_title_box,\r\n+                                             self._legend_handle_box])\r\n+        self._legend_box.set_figure(self.figure)\r\n+        self._legend_box.axes = self.axes\r\n+        self.texts = text_list\r\n+        self.legend_handles = handle_list\r\n+\r\n+    def _auto_legend_data(self):\r\n+        \"\"\"\r\n+        Return display coordinates for hit testing for \"best\" positioning.\r\n+\r\n+        Returns\r\n+        -------\r\n+        bboxes\r\n+            List of bounding boxes of all patches.\r\n+        lines\r\n+            List of `.Path` corresponding to each line.\r\n+        offsets\r\n+            List of (x, y) offsets of all collection.\r\n+        \"\"\"\r\n+        assert self.isaxes  # always holds, as this is only called internally\r\n+        bboxes = []\r\n+        lines = []\r\n+        offsets = []\r\n+        for artist in self.parent._children:\r\n+            if isinstance(artist, Line2D):\r\n+                lines.append(\r\n+                    artist.get_transform().transform_path(artist.get_path()))\r\n+            elif isinstance(artist, Rectangle):\r\n+                bboxes.append(\r\n+                    artist.get_bbox().transformed(artist.get_data_transform()))\r\n+            elif isinstance(artist, Patch):\r\n+                lines.append(\r\n+                    artist.get_transform().transform_path(artist.get_path()))\r\n+            elif isinstance(artist, Collection):\r\n+                transform, transOffset, hoffsets, _ = artist._prepare_points()\r\n+                if len(hoffsets):\r\n+                    for offset in transOffset.transform(hoffsets):\r\n+                        offsets.append(offset)\r\n+\r\n+        return bboxes, lines, offsets\r\n+\r\n+    def get_children(self):\r\n+        # docstring inherited\r\n+        return [self._legend_box, self.get_frame()]\r\n+\r\n+    def get_frame(self):\r\n+        \"\"\"Return the `~.patches.Rectangle` used to frame the legend.\"\"\"\r\n+        return self.legendPatch\r\n+\r\n+    def get_lines(self):\r\n+        r\"\"\"Return the list of `~.lines.Line2D`\\s in the legend.\"\"\"\r\n+        return [h for h in self.legend_handles if isinstance(h, Line2D)]\r\n+\r\n+    def get_patches(self):\r\n+        r\"\"\"Return the list of `~.patches.Patch`\\s in the legend.\"\"\"\r\n+        return silent_list('Patch',\r\n+                           [h for h in self.legend_handles\r\n+                            if isinstance(h, Patch)])\r\n+\r\n+    def get_texts(self):\r\n+        r\"\"\"Return the list of `~.text.Text`\\s in the legend.\"\"\"\r\n+        return silent_list('Text', self.texts)\r\n+\r\n+    def set_alignment(self, alignment):\r\n+        \"\"\"\r\n+        Set the alignment of the legend title and the box of entries.\r\n+\r\n+        The entries are aligned as a single block, so that markers always\r\n+        lined up.\r\n+\r\n+        Parameters\r\n+        ----------\r\n+        alignment : {'center', 'left', 'right'}.\r\n+\r\n+        \"\"\"\r\n+        _api.check_in_list([\"center\", \"left\", \"right\"], alignment=alignment)\r\n+        self._alignment = alignment\r\n+        self._legend_box.align = alignment\r\n+\r\n+    def get_alignment(self):\r\n+        \"\"\"Get the alignment value of the legend box\"\"\"\r\n+        return self._legend_box.align\r\n+\r\n+    def set_title(self, title, prop=None):\r\n+        \"\"\"\r\n+        Set legend title and title style.\r\n+\r\n+        Parameters\r\n+        ----------\r\n+        title : str\r\n+            The legend title.\r\n+\r\n+        prop : `.font_manager.FontProperties` or `str` or `pathlib.Path`\r\n+            The font properties of the legend title.\r\n+            If a `str`, it is interpreted as a fontconfig pattern parsed by\r\n+            `.FontProperties`.  If a `pathlib.Path`, it is interpreted as the\r\n+            absolute path to a font file.\r\n+\r\n+        \"\"\"\r\n+        self._legend_title_box._text.set_text(title)\r\n+        if title:\r\n+            self._legend_title_box._text.set_visible(True)\r\n+            self._legend_title_box.set_visible(True)\r\n+        else:\r\n+            self._legend_title_box._text.set_visible(False)\r\n+            self._legend_title_box.set_visible(False)\r\n+\r\n+        if prop is not None:\r\n+            self._legend_title_box._text.set_fontproperties(prop)\r\n+\r\n+        self.stale = True\r\n+\r\n+    def get_title(self):\r\n+        \"\"\"Return the `.Text` instance for the legend title.\"\"\"\r\n+        return self._legend_title_box._text\r\n+\r\n+    def get_window_extent(self, renderer=None):\r\n+        # docstring inherited\r\n+        if renderer is None:\r\n+            renderer = self.figure._get_renderer()\r\n+        return self._legend_box.get_window_extent(renderer=renderer)\r\n+\r\n+    def get_tightbbox(self, renderer=None):\r\n+        # docstring inherited\r\n+        return self._legend_box.get_window_extent(renderer)\r\n+\r\n+    def get_frame_on(self):\r\n+        \"\"\"Get whether the legend box patch is drawn.\"\"\"\r\n+        return self.legendPatch.get_visible()\r\n+\r\n+    def set_frame_on(self, b):\r\n+        \"\"\"\r\n+        Set whether the legend box patch is drawn.\r\n+\r\n+        Parameters\r\n+        ----------\r\n+        b : bool\r\n+        \"\"\"\r\n+        self.legendPatch.set_visible(b)\r\n+        self.stale = True\r\n+\r\n+    draw_frame = set_frame_on  # Backcompat alias.\r\n+\r\n+    def get_bbox_to_anchor(self):\r\n+        \"\"\"Return the bbox that the legend will be anchored to.\"\"\"\r\n+        if self._bbox_to_anchor is None:\r\n+            return self.parent.bbox\r\n+        else:\r\n+            return self._bbox_to_anchor\r\n+\r\n+    def set_bbox_to_anchor(self, bbox, transform=None):\r\n+        \"\"\"\r\n+        Set the bbox that the legend will be anchored to.\r\n+\r\n+        Parameters\r\n+        ----------\r\n+        bbox : `~matplotlib.transforms.BboxBase` or tuple\r\n+            The bounding box can be specified in the following ways:\r\n+\r\n+            - A `.BboxBase` instance\r\n+            - A tuple of ``(left, bottom, width, height)`` in the given\r\n+              transform (normalized axes coordinate if None)\r\n+            - A tuple of ``(left, bottom)`` where the width and height will be\r\n+              assumed to be zero.\r\n+            - *None*, to remove the bbox anchoring, and use the parent bbox.\r\n+\r\n+        transform : `~matplotlib.transforms.Transform`, optional\r\n+            A transform to apply to the bounding box. If not specified, this\r\n+            will use a transform to the bounding box of the parent.\r\n+        \"\"\"\r\n+        if bbox is None:\r\n+            self._bbox_to_anchor = None\r\n+            return\r\n+        elif isinstance(bbox, BboxBase):\r\n+            self._bbox_to_anchor = bbox\r\n+        else:\r\n+            try:\r\n+                l = len(bbox)\r\n+            except TypeError as err:\r\n+                raise ValueError(f\"Invalid bbox: {bbox}\") from err\r\n+\r\n+            if l == 2:\r\n+                bbox = [bbox[0], bbox[1], 0, 0]\r\n+\r\n+            self._bbox_to_anchor = Bbox.from_bounds(*bbox)\r\n+\r\n+        if transform is None:\r\n+            transform = BboxTransformTo(self.parent.bbox)\r\n+\r\n+        self._bbox_to_anchor = TransformedBbox(self._bbox_to_anchor,\r\n+                                               transform)\r\n+        self.stale = True\r\n+\r\n+    def _get_anchored_bbox(self, loc, bbox, parentbbox, renderer):\r\n+        \"\"\"\r\n+        Place the *bbox* inside the *parentbbox* according to a given\r\n+        location code. Return the (x, y) coordinate of the bbox.\r\n+\r\n+        Parameters\r\n+        ----------\r\n+        loc : int\r\n+            A location code in range(1, 11). This corresponds to the possible\r\n+            values for ``self._loc``, excluding \"best\".\r\n+        bbox : `~matplotlib.transforms.Bbox`\r\n+            bbox to be placed, in display coordinates.\r\n+        parentbbox : `~matplotlib.transforms.Bbox`\r\n+            A parent box which will contain the bbox, in display coordinates.\r\n+        \"\"\"\r\n+        return offsetbox._get_anchored_bbox(\r\n+            loc, bbox, parentbbox,\r\n+            self.borderaxespad * renderer.points_to_pixels(self._fontsize))\r\n+\r\n+    def _find_best_position(self, width, height, renderer, consider=None):\r\n+        \"\"\"\r\n+        Determine the best location to place the legend.\r\n+\r\n+        *consider* is a list of ``(x, y)`` pairs to consider as a potential\r\n+        lower-left corner of the legend. All are display coords.\r\n+        \"\"\"\r\n+        assert self.isaxes  # always holds, as this is only called internally\r\n+\r\n+        start_time = time.perf_counter()\r\n+\r\n+        bboxes, lines, offsets = self._auto_legend_data()\r\n+\r\n+        bbox = Bbox.from_bounds(0, 0, width, height)\r\n+        if consider is None:\r\n+            consider = [self._get_anchored_bbox(x, bbox,\r\n+                                                self.get_bbox_to_anchor(),\r\n+                                                renderer)\r\n+                        for x in range(1, len(self.codes))]\r\n+\r\n+        candidates = []\r\n+        for idx, (l, b) in enumerate(consider):\r\n+            legendBox = Bbox.from_bounds(l, b, width, height)\r\n+            badness = 0\r\n+            # XXX TODO: If markers are present, it would be good to take them\r\n+            # into account when checking vertex overlaps in the next line.\r\n+            badness = (sum(legendBox.count_contains(line.vertices)\r\n+                           for line in lines)\r\n+                       + legendBox.count_contains(offsets)\r\n+                       + legendBox.count_overlaps(bboxes)\r\n+                       + sum(line.intersects_bbox(legendBox, filled=False)\r\n+                             for line in lines))\r\n+            if badness == 0:\r\n+                return l, b\r\n+            # Include the index to favor lower codes in case of a tie.\r\n+            candidates.append((badness, idx, (l, b)))\r\n+\r\n+        _, _, (l, b) = min(candidates)\r\n+\r\n+        if self._loc_used_default and time.perf_counter() - start_time > 1:\r\n+            _api.warn_external(\r\n+                'Creating legend with loc=\"best\" can be slow with large '\r\n+                'amounts of data.')\r\n+\r\n+        return l, b\r\n+\r\n+    def contains(self, event):\r\n+        inside, info = self._default_contains(event)\r\n+        if inside is not None:\r\n+            return inside, info\r\n+        return self.legendPatch.contains(event)\r\n+\r\n+    def set_draggable(self, state, use_blit=False, update='loc'):\r\n+        \"\"\"\r\n+        Enable or disable mouse dragging support of the legend.\r\n+\r\n+        Parameters\r\n+        ----------\r\n+        state : bool\r\n+            Whether mouse dragging is enabled.\r\n+        use_blit : bool, optional\r\n+            Use blitting for faster image composition. For details see\r\n+            :ref:`func-animation`.\r\n+        update : {'loc', 'bbox'}, optional\r\n+            The legend parameter to be changed when dragged:\r\n+\r\n+            - 'loc': update the *loc* parameter of the legend\r\n+            - 'bbox': update the *bbox_to_anchor* parameter of the legend\r\n+\r\n+        Returns\r\n+        -------\r\n+        `.DraggableLegend` or *None*\r\n+            If *state* is ``True`` this returns the `.DraggableLegend` helper\r\n+            instance. Otherwise this returns *None*.\r\n+        \"\"\"\r\n+        if state:\r\n+            if self._draggable is None:\r\n+                self._draggable = DraggableLegend(self,\r\n+                                                  use_blit,\r\n+                                                  update=update)\r\n+        else:\r\n+            if self._draggable is not None:\r\n+                self._draggable.disconnect()\r\n+            self._draggable = None\r\n+        return self._draggable\r\n+\r\n+    def get_draggable(self):\r\n+        \"\"\"Return ``True`` if the legend is draggable, ``False`` otherwise.\"\"\"\r\n+        return self._draggable is not None\r\n+\r\n+\r\n+# Helper functions to parse legend arguments for both `figure.legend` and\r\n+# `axes.legend`:\r\n+def _get_legend_handles(axs, legend_handler_map=None):\r\n+    \"\"\"Yield artists that can be used as handles in a legend.\"\"\"\r\n+    handles_original = []\r\n+    for ax in axs:\r\n+        handles_original += [\r\n+            *(a for a in ax._children\r\n+              if isinstance(a, (Line2D, Patch, Collection, Text))),\r\n+            *ax.containers]\r\n+        # support parasite axes:\r\n+        if hasattr(ax, 'parasites'):\r\n+            for axx in ax.parasites:\r\n+                handles_original += [\r\n+                    *(a for a in axx._children\r\n+                      if isinstance(a, (Line2D, Patch, Collection, Text))),\r\n+                    *axx.containers]\r\n+\r\n+    handler_map = {**Legend.get_default_handler_map(),\r\n+                   **(legend_handler_map or {})}\r\n+    has_handler = Legend.get_legend_handler\r\n+    for handle in handles_original:\r\n+        label = handle.get_label()\r\n+        if label != '_nolegend_' and has_handler(handler_map, handle):\r\n+            yield handle\r\n+        elif (label and not label.startswith('_') and\r\n+                not has_handler(handler_map, handle)):\r\n+            _api.warn_external(\r\n+                             \"Legend does not support handles for \"\r\n+                             f\"{type(handle).__name__} \"\r\n+                             \"instances.\\nSee: https://matplotlib.org/stable/\"\r\n+                             \"tutorials/intermediate/legend_guide.html\"\r\n+                             \"#implementing-a-custom-legend-handler\")\r\n+            continue\r\n+\r\n+\r\n+def _get_legend_handles_labels(axs, legend_handler_map=None):\r\n+    \"\"\"Return handles and labels for legend.\"\"\"\r\n+    handles = []\r\n+    labels = []\r\n+    for handle in _get_legend_handles(axs, legend_handler_map):\r\n+        label = handle.get_label()\r\n+        if label and not label.startswith('_'):\r\n+            handles.append(handle)\r\n+            labels.append(label)\r\n+    return handles, labels\r\n+\r\n+\r\n+def _parse_legend_args(axs, *args, handles=None, labels=None, **kwargs):\r\n+    \"\"\"\r\n+    Get the handles and labels from the calls to either ``figure.legend``\r\n+    or ``axes.legend``.\r\n+\r\n+    The parser is a bit involved because we support::\r\n+\r\n+        legend()\r\n+        legend(labels)\r\n+        legend(handles, labels)\r\n+        legend(labels=labels)\r\n+        legend(handles=handles)\r\n+        legend(handles=handles, labels=labels)\r\n+\r\n+    The behavior for a mixture of positional and keyword handles and labels\r\n+    is undefined and issues a warning.\r\n+\r\n+    Parameters\r\n+    ----------\r\n+    axs : list of `.Axes`\r\n+        If handles are not given explicitly, the artists in these Axes are\r\n+        used as handles.\r\n+    *args : tuple\r\n+        Positional parameters passed to ``legend()``.\r\n+    handles\r\n+        The value of the keyword argument ``legend(handles=...)``, or *None*\r\n+        if that keyword argument was not used.\r\n+    labels\r\n+        The value of the keyword argument ``legend(labels=...)``, or *None*\r\n+        if that keyword argument was not used.\r\n+    **kwargs\r\n+        All other keyword arguments passed to ``legend()``.\r\n+\r\n+    Returns\r\n+    -------\r\n+    handles : list of `.Artist`\r\n+        The legend handles.\r\n+    labels : list of str\r\n+        The legend labels.\r\n+    extra_args : tuple\r\n+        *args* with positional handles and labels removed.\r\n+    kwargs : dict\r\n+        *kwargs* with keywords handles and labels removed.\r\n+\r\n+    \"\"\"\r\n+    log = logging.getLogger(__name__)\r\n+\r\n+    handlers = kwargs.get('handler_map')\r\n+    extra_args = ()\r\n+\r\n+    if (handles is not None or labels is not None) and args:\r\n+        _api.warn_external(\"You have mixed positional and keyword arguments, \"\r\n+                           \"some input may be discarded.\")\r\n+\r\n+    # if got both handles and labels as kwargs, make same length\r\n+    if handles and labels:\r\n+        handles, labels = zip(*zip(handles, labels))\r\n+\r\n+    elif handles is not None and labels is None:\r\n+        labels = [handle.get_label() for handle in handles]\r\n+\r\n+    elif labels is not None and handles is None:\r\n+        # Get as many handles as there are labels.\r\n+        handles = [handle for handle, label\r\n+                   in zip(_get_legend_handles(axs, handlers), labels)]\r\n+\r\n+    # No arguments - automatically detect labels and handles.\r\n+    elif len(args) == 0:\r\n+        handles, labels = _get_legend_handles_labels(axs, handlers)\r\n+        if not handles:\r\n+            log.warning(\r\n+                \"No artists with labels found to put in legend.  Note that \"\r\n+                \"artists whose label start with an underscore are ignored \"\r\n+                \"when legend() is called with no argument.\")\r\n+\r\n+    # One argument. User defined labels - automatic handle detection.\r\n+    elif len(args) == 1:\r\n+        labels, = args\r\n+        if any(isinstance(l, Artist) for l in labels):\r\n+            raise TypeError(\"A single argument passed to legend() must be a \"\r\n+                            \"list of labels, but found an Artist in there.\")\r\n+\r\n+        # Get as many handles as there are labels.\r\n+        handles = [handle for handle, label\r\n+                   in zip(_get_legend_handles(axs, handlers), labels)]\r\n+\r\n+    # Two arguments:\r\n+    #   * user defined handles and labels\r\n+    elif len(args) >= 2:\r\n+        handles, labels = args[:2]\r\n+        extra_args = args[2:]\r\n+\r\n+    else:\r\n+        raise TypeError('Invalid arguments to legend.')\r\n+\r\n+    return handles, labels, extra_args, kwargs\r\ndiff --git a/lib/matplotlib/legend.py.rej b/lib/matplotlib/legend.py.rej\r\nnew file mode 100644\r\nindex 0000000000..2c44e6f220\r\n--- /dev/null\r\n+++ b/lib/matplotlib/legend.py.rej\r\n@@ -0,0 +1,24 @@\r\n+--- legend.py\r\n++++ legend.py\r\n+@@ -96,6 +96,21 @@\r\n+         self.legend.set_bbox_to_anchor(loc_in_bbox)\r\n+ \r\n++    def disable_draggable(self):\r\n++        \"\"\"\r\n++        Disable the draggable feature of the legend to allow pickling.\r\n++        \"\"\"\r\n++        if hasattr(self, '_draggable'):\r\n++            self._draggable.disconnect_events()\r\n++            self._draggable = None\r\n++\r\n++    def enable_draggable(self, use_blit=False, update='loc'):\r\n++        \"\"\"\r\n++        Re-enable the draggable feature of the legend after pickling.\r\n++        \"\"\"\r\n++        self.set_draggable(True, use_blit=use_blit, update=update)\r\n++\r\n++\r\n+ _legend_kw_doc_base = \"\"\"\r\n+ bbox_to_anchor : `.BboxBase`, 2-tuple, or 4-tuple of floats\r\n+ \r\n+",
    "model_name_or_path": "openhands"
  },
  {
    "instance_id": "django__django-12113",
    "model_patch": "diff --git a/tests/test_sqlite.py b/tests/test_sqlite.py\r\nindex f1b65f7d01..1b3b294773 100644\r\n--- a/tests/test_sqlite.py\r\n+++ b/tests/test_sqlite.py\r\n@@ -15,9 +15,11 @@\r\n DATABASES = {\r\n     'default': {\r\n         'ENGINE': 'django.db.backends.sqlite3',\r\n+        'NAME': 'django_tests_default.sqlite3',\r\n     },\r\n     'other': {\r\n         'ENGINE': 'django.db.backends.sqlite3',\r\n+        'NAME': 'django_tests_other.sqlite3',\r\n     }\r\n }",
    "model_name_or_path": "openhands"
  },
  {
    "instance_id": "matplotlib__matplotlib-24334",
    "model_patch": "",
    "model_name_or_path": "openhands"
  },
  {
    "instance_id": "django__django-15738",
    "model_patch": "diff --git a/tests/i18n/sampleproject/authors/__init__.py b/tests/i18n/sampleproject/authors/__init__.py\r\nnew file mode 100644\r\nindex 0000000000..e69de29bb2\r\ndiff --git a/tests/i18n/sampleproject/authors/admin.py b/tests/i18n/sampleproject/authors/admin.py\r\nnew file mode 100644\r\nindex 0000000000..8c38f3f3da\r\n--- /dev/null\r\n+++ b/tests/i18n/sampleproject/authors/admin.py\r\n@@ -0,0 +1,3 @@\r\n+from django.contrib import admin\r\n+\r\n+# Register your models here.\r\ndiff --git a/tests/i18n/sampleproject/authors/apps.py b/tests/i18n/sampleproject/authors/apps.py\r\nnew file mode 100644\r\nindex 0000000000..4fead46d63\r\n--- /dev/null\r\n+++ b/tests/i18n/sampleproject/authors/apps.py\r\n@@ -0,0 +1,6 @@\r\n+from django.apps import AppConfig\r\n+\r\n+\r\n+class AuthorsConfig(AppConfig):\r\n+    default_auto_field = \"django.db.models.BigAutoField\"\r\n+    name = \"authors\"\r\ndiff --git a/tests/i18n/sampleproject/authors/migrations/0001_initial.py b/tests/i18n/sampleproject/authors/migrations/0001_initial.py\r\nnew file mode 100644\r\nindex 0000000000..3b1a2cd8b7\r\n--- /dev/null\r\n+++ b/tests/i18n/sampleproject/authors/migrations/0001_initial.py\r\n@@ -0,0 +1,108 @@\r\n+# Generated by Django 4.2.dev20220601171126 on 2024-05-04 20:05\r\n+\r\n+from django.db import migrations, models\r\n+import django.db.models.deletion\r\n+\r\n+\r\n+class Migration(migrations.Migration):\r\n+\r\n+    initial = True\r\n+\r\n+    dependencies = []\r\n+\r\n+    operations = [\r\n+        migrations.CreateModel(\r\n+            name=\"DataSet\",\r\n+            fields=[\r\n+                (\r\n+                    \"id\",\r\n+                    models.BigAutoField(\r\n+                        auto_created=True,\r\n+                        primary_key=True,\r\n+                        serialize=False,\r\n+                        verbose_name=\"ID\",\r\n+                    ),\r\n+                ),\r\n+                (\"name\", models.TextField(max_length=50)),\r\n+            ],\r\n+        ),\r\n+        migrations.CreateModel(\r\n+            name=\"Project\",\r\n+            fields=[\r\n+                (\r\n+                    \"id\",\r\n+                    models.BigAutoField(\r\n+                        auto_created=True,\r\n+                        primary_key=True,\r\n+                        serialize=False,\r\n+                        verbose_name=\"ID\",\r\n+                    ),\r\n+                ),\r\n+                (\"name\", models.TextField(max_length=50)),\r\n+            ],\r\n+        ),\r\n+        migrations.CreateModel(\r\n+            name=\"ProjectDataSet\",\r\n+            fields=[\r\n+                (\r\n+                    \"id\",\r\n+                    models.BigAutoField(\r\n+                        auto_created=True,\r\n+                        primary_key=True,\r\n+                        serialize=False,\r\n+                        verbose_name=\"ID\",\r\n+                    ),\r\n+                ),\r\n+                (\r\n+                    \"data_set\",\r\n+                    models.ForeignKey(\r\n+                        on_delete=django.db.models.deletion.PROTECT,\r\n+                        to=\"authors.dataset\",\r\n+                    ),\r\n+                ),\r\n+                (\r\n+                    \"project\",\r\n+                    models.ForeignKey(\r\n+                        on_delete=django.db.models.deletion.PROTECT,\r\n+                        to=\"authors.project\",\r\n+                    ),\r\n+                ),\r\n+            ],\r\n+            options={\r\n+                \"unique_together\": {(\"data_set\", \"project\")},\r\n+            },\r\n+        ),\r\n+        migrations.AddField(\r\n+            model_name=\"project\",\r\n+            name=\"data_sets\",\r\n+            field=models.ManyToManyField(\r\n+                through=\"authors.ProjectDataSet\", to=\"authors.dataset\"\r\n+            ),\r\n+        ),\r\n+        migrations.CreateModel(\r\n+            name=\"Authors\",\r\n+            fields=[\r\n+                (\r\n+                    \"id\",\r\n+                    models.BigAutoField(\r\n+                        auto_created=True,\r\n+                        primary_key=True,\r\n+                        serialize=False,\r\n+                        verbose_name=\"ID\",\r\n+                    ),\r\n+                ),\r\n+                (\"state\", models.IntegerField()),\r\n+                (\"start_date\", models.DateField()),\r\n+                (\r\n+                    \"project_data_set\",\r\n+                    models.ForeignKey(\r\n+                        on_delete=django.db.models.deletion.PROTECT,\r\n+                        to=\"authors.projectdataset\",\r\n+                    ),\r\n+                ),\r\n+            ],\r\n+            options={\r\n+                \"unique_together\": {(\"project_data_set\", \"state\", \"start_date\")},\r\n+            },\r\n+        ),\r\n+    ]\r\ndiff --git a/tests/i18n/sampleproject/authors/migrations/__init__.py b/tests/i18n/sampleproject/authors/migrations/__init__.py\r\nnew file mode 100644\r\nindex 0000000000..e69de29bb2\r\ndiff --git a/tests/i18n/sampleproject/authors/models.py b/tests/i18n/sampleproject/authors/models.py\r\nnew file mode 100644\r\nindex 0000000000..290af49445\r\n--- /dev/null\r\n+++ b/tests/i18n/sampleproject/authors/models.py\r\n@@ -0,0 +1,22 @@\r\n+from django.db import models\r\n+\r\n+class DataSet(models.Model):\r\n+    name = models.TextField(max_length=50)\r\n+\r\n+class Project(models.Model):\r\n+    data_sets = models.ManyToManyField(DataSet, through='ProjectDataSet')\r\n+    name = models.TextField(max_length=50)\r\n+\r\n+class ProjectDataSet(models.Model):\r\n+    data_set = models.ForeignKey(DataSet, on_delete=models.PROTECT)\r\n+    project = models.ForeignKey(Project, on_delete=models.PROTECT)\r\n+    class Meta:\r\n+        unique_together = (('data_set', 'project'),)\r\n+\r\n+class Authors(models.Model):\r\n+    project_data_set = models.ForeignKey(ProjectDataSet, on_delete=models.PROTECT)\r\n+    state = models.IntegerField()\r\n+    start_date = models.DateField()\r\n+    class Meta:\r\n+        unique_together = (('project_data_set', 'state', 'start_date'),)\r\n+\r\ndiff --git a/tests/i18n/sampleproject/authors/tests.py b/tests/i18n/sampleproject/authors/tests.py\r\nnew file mode 100644\r\nindex 0000000000..7ce503c2dd\r\n--- /dev/null\r\n+++ b/tests/i18n/sampleproject/authors/tests.py\r\n@@ -0,0 +1,3 @@\r\n+from django.test import TestCase\r\n+\r\n+# Create your tests here.\r\ndiff --git a/tests/i18n/sampleproject/authors/views.py b/tests/i18n/sampleproject/authors/views.py\r\nnew file mode 100644\r\nindex 0000000000..91ea44a218\r\n--- /dev/null\r\n+++ b/tests/i18n/sampleproject/authors/views.py\r\n@@ -0,0 +1,3 @@\r\n+from django.shortcuts import render\r\n+\r\n+# Create your views here.\r\ndiff --git a/tests/i18n/sampleproject/db.sqlite3 b/tests/i18n/sampleproject/db.sqlite3\r\nnew file mode 100644\r\nindex 0000000000..92499e59ae\r\nBinary files /dev/null and b/tests/i18n/sampleproject/db.sqlite3 differ\r\ndiff --git a/tests/i18n/sampleproject/sampleproject/settings.py b/tests/i18n/sampleproject/sampleproject/settings.py\r\nindex e69de29bb2..3e2c845651 100644\r\n--- a/tests/i18n/sampleproject/sampleproject/settings.py\r\n+++ b/tests/i18n/sampleproject/sampleproject/settings.py\r\n@@ -0,0 +1,10 @@\r\n+SECRET_KEY = 'fake-key'\r\n+INSTALLED_APPS = []\r\n+\r\n+INSTALLED_APPS = ['authors']\r\n+DATABASES = {\r\n+    'default': {\r\n+        'ENGINE': 'django.db.backends.sqlite3',\r\n+        'NAME': 'db.sqlite3',\r\n+    }\r\n+}\r\ndiff --git a/tests/migrations/migrations_test_apps/alter_fk/author_app/models.py b/tests/migrations/migrations_test_apps/alter_fk/author_app/models.py\r\nnew file mode 100644\r\nindex 0000000000..290af49445\r\n--- /dev/null\r\n+++ b/tests/migrations/migrations_test_apps/alter_fk/author_app/models.py\r\n@@ -0,0 +1,22 @@\r\n+from django.db import models\r\n+\r\n+class DataSet(models.Model):\r\n+    name = models.TextField(max_length=50)\r\n+\r\n+class Project(models.Model):\r\n+    data_sets = models.ManyToManyField(DataSet, through='ProjectDataSet')\r\n+    name = models.TextField(max_length=50)\r\n+\r\n+class ProjectDataSet(models.Model):\r\n+    data_set = models.ForeignKey(DataSet, on_delete=models.PROTECT)\r\n+    project = models.ForeignKey(Project, on_delete=models.PROTECT)\r\n+    class Meta:\r\n+        unique_together = (('data_set', 'project'),)\r\n+\r\n+class Authors(models.Model):\r\n+    project_data_set = models.ForeignKey(ProjectDataSet, on_delete=models.PROTECT)\r\n+    state = models.IntegerField()\r\n+    start_date = models.DateField()\r\n+    class Meta:\r\n+        unique_together = (('project_data_set', 'state', 'start_date'),)\r\n+",
    "model_name_or_path": "openhands"
  },
  {
    "instance_id": "sympy__sympy-21612",
    "model_patch": "diff --git a/sympy/printing/str.py b/sympy/printing/str.py\r\nindex c3fdcdd435..3e4b7d1b19 100644\r\n--- a/sympy/printing/str.py\r\n+++ b/sympy/printing/str.py\r\n@@ -333,7 +333,7 @@ def apow(i):\r\n                     b.append(apow(item))\r\n                 else:\r\n                     if (len(item.args[0].args) != 1 and\r\n-                            isinstance(item.base, Mul)):\r\n+                            isinstance(item.base, (Mul, Pow))):\r\n                         # To avoid situations like #14160\r\n                         pow_paren.append(item)\r\n                     b.append(item.base)\r\ndiff --git a/sympy/printing/tests/test_issue_sympy_21537.py b/sympy/printing/tests/test_issue_sympy_21537.py\r\nnew file mode 100644\r\nindex 0000000000..89930cc45e\r\n--- /dev/null\r\n+++ b/sympy/printing/tests/test_issue_sympy_21537.py\r\n@@ -0,0 +1,10 @@\r\n+from sympy import symbols, Mul, Pow\r\n+from sympy.parsing.latex import parse_latex\r\n+\r\n+def test_latex_parsing_issue_21537():\r\n+    x, y = symbols('x y')\r\n+    expr = parse_latex(\"\\\\frac{x}{\\\\frac{1}{y}}\")\r\n+    expected = Mul(x, Pow(y, -1, evaluate=False), evaluate=False)\r\n+    assert expr == expected\r\n+\r\n+# test_latex_parsing_issue_21537()",
    "model_name_or_path": "openhands"
  },
  {
    "instance_id": "pytest-dev__pytest-11148",
    "model_patch": "diff --git a/testing/__init__.py b/testing/__init__.py\r\nnew file mode 100644\r\nindex 000000000..e69de29bb\r\ndiff --git a/testing/test_commands.py b/testing/test_commands.py\r\nnew file mode 100644\r\nindex 000000000..2117b6eb8\r\n--- /dev/null\r\n+++ b/testing/test_commands.py\r\n@@ -0,0 +1,14 @@\r\n+import sys\r\n+import os\r\n+sys.path.insert(0, os.path.dirname(__file__))\r\n+import pytest\r\n+from test_logging import Logger\r\n+\r\n+class TestCommands:\r\n+    @classmethod\r\n+    def setup_class(cls):\r\n+        Logger.initialize(store=[])\r\n+        Logger.message(\"logged\", \"testrunner\", \"some text\")\r\n+\r\n+    def test_logger_initialized(self):\r\n+        assert Logger.store is not None, \"Logger.store should be initialized.\"\r\ndiff --git a/testing/test_logging.py b/testing/test_logging.py\r\nnew file mode 100644\r\nindex 000000000..6833dde1c\r\n--- /dev/null\r\n+++ b/testing/test_logging.py\r\n@@ -0,0 +1,13 @@\r\n+class Logger:\r\n+    store = None\r\n+\r\n+    @classmethod\r\n+    def initialize(cls, store):\r\n+        cls.store = store\r\n+\r\n+    @classmethod\r\n+    def message(cls, channel, nick, text):\r\n+        if cls.store is None:\r\n+            raise ValueError('Logger not initialized with a store.')\r\n+        cls.store.append((channel, nick, text))\r\n+",
    "model_name_or_path": "openhands"
  },
  {
    "instance_id": "sphinx-doc__sphinx-8282",
    "model_patch": "diff --git a/sphinx/ext/autodoc/typehints.py b/sphinx/ext/autodoc/typehints.py\r\nindex 4f81a6eae..67dbe278c 100644\r\n--- a/sphinx/ext/autodoc/typehints.py\r\n+++ b/sphinx/ext/autodoc/typehints.py\r\n@@ -21,6 +21,8 @@ from sphinx.application import Sphinx\r\n from sphinx.util import inspect, typing\r\n \r\n \r\n+from sphinx.pycode import ModuleAnalyzer, PycodeError\r\n+\r\n def record_typehints(app: Sphinx, objtype: str, name: str, obj: Any,\r\n                      options: Dict, args: str, retann: str) -> None:\r\n     \"\"\"Record type hints to env object.\"\"\"\r\n@@ -28,14 +30,39 @@ def record_typehints(app: Sphinx, objtype: str, name: str, obj: Any,\r\n         if callable(obj):\r\n             annotations = app.env.temp_data.setdefault('annotations', {})\r\n             annotation = annotations.setdefault(name, OrderedDict())\r\n-            sig = inspect.signature(obj)\r\n-            for param in sig.parameters.values():\r\n-                if param.annotation is not param.empty:\r\n-                    annotation[param.name] = typing.stringify(param.annotation)\r\n-            if sig.return_annotation is not sig.empty:\r\n-                annotation['return'] = typing.stringify(sig.return_annotation)\r\n+            # Check if the object is overloaded and handle accordingly\r\n+            try:\r\n+                analyzer = ModuleAnalyzer.for_module(obj.__module__)\r\n+                analyzer.parse()\r\n+                qualname = obj.__qualname__\r\n+                if qualname in analyzer.overloads:\r\n+                    # Record type hints for each overload\r\n+                    for overload in analyzer.overloads[qualname]:\r\n+                        sig = inspect.signature(overload)\r\n+                        for param in sig.parameters.values():\r\n+                            if param.annotation is not param.empty:\r\n+                                annotation[param.name] = typing.stringify(param.annotation)\r\n+                        if sig.return_annotation is not sig.empty:\r\n+                            annotation['return'] = typing.stringify(sig.return_annotation)\r\n+                else:\r\n+                    # Record type hints for non-overloaded functions\r\n+                    sig = inspect.signature(obj)\r\n+                    for param in sig.parameters.values():\r\n+                        if param.annotation is not param.empty:\r\n+                            annotation[param.name] = typing.stringify(param.annotation)\r\n+                    if sig.return_annotation is not sig.empty:\r\n+                        annotation['return'] = typing.stringify(sig.return_annotation)\r\n+            except (PycodeError, TypeError, ValueError):\r\n+                # If there's an error analyzing the module, fall back to non-overloaded handling\r\n+                sig = inspect.signature(obj)\r\n+                for param in sig.parameters.values():\r\n+                    if param.annotation is not param.empty:\r\n+                        annotation[param.name] = typing.stringify(param.annotation)\r\n+                if sig.return_annotation is not sig.empty:\r\n+                    annotation['return'] = typing.stringify(sig.return_annotation)\r\n     except (TypeError, ValueError):\r\n         pass\r\n+        pass\r\n \r\n \r\n def merge_typehints(app: Sphinx, domain: str, objtype: str, contentnode: Element) -> None:",
    "model_name_or_path": "openhands"
  },
  {
    "instance_id": "astropy__astropy-12907",
    "model_patch": "diff --git a/astropy/modeling/separable.py b/astropy/modeling/separable.py\r\nindex a308e2729..c6a3dae0e 100644\r\n--- a/astropy/modeling/separable.py\r\n+++ b/astropy/modeling/separable.py\r\n@@ -217,32 +217,26 @@ def _coord_matrix(model, pos, noutp):\r\n \r\n \r\n def _cstack(left, right):\r\n-    \"\"\"\r\n-    Function corresponding to '&' operation.\r\n-\r\n-    Parameters\r\n-    ----------\r\n-    left, right : `astropy.modeling.Model` or ndarray\r\n-        If input is of an array, it is the output of `coord_matrix`.\r\n-\r\n-    Returns\r\n-    -------\r\n-    result : ndarray\r\n-        Result from this operation.\r\n-\r\n-    \"\"\"\r\n     noutp = _compute_n_outputs(left, right)\r\n \r\n     if isinstance(left, Model):\r\n         cleft = _coord_matrix(left, 'left', noutp)\r\n     else:\r\n-        cleft = np.zeros((noutp, left.shape[1]))\r\n-        cleft[: left.shape[0], : left.shape[1]] = left\r\n+        cleft = left\r\n+\r\n     if isinstance(right, Model):\r\n         cright = _coord_matrix(right, 'right', noutp)\r\n     else:\r\n-        cright = np.zeros((noutp, right.shape[1]))\r\n-        cright[-right.shape[0]:, -right.shape[1]:] = 1\r\n+        cright = right\r\n+\r\n+    # Ensure the matrices have the correct shape before stacking\r\n+    if cleft.shape[1] != cright.shape[1]:\r\n+        # Pad the matrix with fewer columns with zeros on the right\r\n+        max_cols = max(cleft.shape[1], cright.shape[1])\r\n+        if cleft.shape[1] < max_cols:\r\n+            cleft = np.hstack([cleft, np.zeros((cleft.shape[0], max_cols - cleft.shape[1]))])\r\n+        else:\r\n+            cright = np.hstack([cright, np.zeros((cright.shape[0], max_cols - cright.shape[1]))])\r\n \r\n     return np.hstack([cleft, cright])",
    "model_name_or_path": "openhands"
  }
]
