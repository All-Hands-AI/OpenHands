{
    "count": 1561,
    "data": [
        {
            "dependency": "accelerate",
            "version": "==0.16.0",
            "time": "2023-01-31",
            "description": "This code initializes two torch tensors of size 1000x1000 on the GPU using CUDA and then releases the memory occupied by these tensors.",
            "code": "import torch\nfrom accelerate.utils import release_memory\n\na = torch.ones(1000, 1000).cuda()\nb = torch.ones(1000, 1000).cuda()\na, b = release_memory(a, b)\n",
            "masked_code": "import torch\nfrom accelerate.utils import release_memory\n\na = torch.ones(1000, 1000).cuda()\nb = torch.ones(1000, 1000).cuda()\n<line_mask>\n",
            "masked_line": "a, b = release_memory(a, b)",
            "answer": "release_memory",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1"
        },
        {
            "dependency": "accelerate",
            "version": "==0.16.0",
            "time": "2023-01-31",
            "description": "This code performs training of a machine learning model using an accelerated computing framework. It initializes the accelerator, prepares the dataloader, model, optimizer, and scheduler for training. Then it iterates over batches of data, calculates the loss, performs backpropagation, and updates the model parameters through optimization.",
            "code": "from accelerate import Accelerator\n\naccelerator = Accelerator()\ndataloader, model, optimizer, scheduler = accelerator.prepare(dataloader, model, optimizer, scheduler)\n\nfor (input, target) in accelerator.skip_first_batches(dataloader, num_batches=2):\n    optimizer.zero_grad()\n    output = model(input)\n    loss = loss_func(output, target)\n    accelerator.backward(loss)\n    optimizer.step()\n",
            "masked_code": "from accelerate import Accelerator\n\naccelerator = Accelerator()\ndataloader, model, optimizer, scheduler = accelerator.prepare(dataloader, model, optimizer, scheduler)\n\n<line_mask>\n    optimizer.zero_grad()\n    output = model(input)\n    loss = loss_func(output, target)\n    accelerator.backward(loss)\n    optimizer.step()\n",
            "masked_line": "for (input, target) in accelerator.skip_first_batches(dataloader, num_batches=2):",
            "answer": "skip_first_batches",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_2"
        },
        {
            "dependency": "accelerate",
            "version": "==0.17.0",
            "time": "2023-03-09",
            "description": "The code checks if the current process is the main process. If it is, it sleeps for 2 seconds. If it is not the main process, it waits for the main process to finish sleeping. After that, it waits for all processes to reach a synchronization barrier and prints \"Everyone is here\".",
            "code": "import time\nfrom accelerate.state import PartialState\n\nstate = PartialState()\nif state.is_main_process:\n    time.sleep(2)\nelse:\n    print(\"I'm waiting for the main process to finish its sleep...\")\nstate.wait_for_everyone()\nprint(\"Everyone is here\")\n",
            "masked_code": "import time\nfrom accelerate.state import PartialState\n\nstate = PartialState()\nif state.is_main_process:\n    time.sleep(2)\nelse:\n    print(\"I'm waiting for the main process to finish its sleep...\")\n<line_mask>\nprint(\"Everyone is here\")\n",
            "masked_line": "state.wait_for_everyone()",
            "answer": "wait_for_everyone",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_3"
        },
        {
            "dependency": "accelerate",
            "version": "==0.17.0",
            "time": "2023-03-09",
            "description": "The code offloads three different models to a specified CUDA device and conducts forward passes using these models. Model 1 is offloaded to the CPU, model 2 stays on the GPU for a specified number of iterations, and model 3 is offloaded to the CPU again. Additionally, a manual offload method is called for model 3.",
            "code": "model_1, hook_1 = cpu_offload_with_hook(model_1, cuda_device)\nmodel_2, hook_2 = cpu_offload_with_hook(model_2, cuda_device, prev_module_hook=hook_1)\nmodel_3, hook_3 = cpu_offload_with_hook(model_3, cuda_device, prev_module_hook=hook_2)\n\nhid_1 = model_1(input)\nfor i in range(50):\n    # model1 is offloaded on the CPU at the first iteration, model 2 stays on the GPU for this whole loop.\n    hid_2 = model_2(hid_1)\n# model2 is offloaded to the CPU just before this forward.\nhid_3 = model_3(hid_3)\n\n# For model3, you need to manually call the hook offload method.\nhook_3.offload()\n",
            "masked_code": "model_1, hook_1 = cpu_offload_with_hook(model_1, cuda_device)\nmodel_2, hook_2 = cpu_offload_with_hook(model_2, cuda_device, prev_module_hook=hook_1)\n<line_mask>\n\nhid_1 = model_1(input)\nfor i in range(50):\n    # model1 is offloaded on the CPU at the first iteration, model 2 stays on the GPU for this whole loop.\n    hid_2 = model_2(hid_1)\n# model2 is offloaded to the CPU just before this forward.\nhid_3 = model_3(hid_3)\n\n# For model3, you need to manually call the hook offload method.\nhook_3.offload()\n",
            "masked_line": "model_3, hook_3 = cpu_offload_with_hook(model_3, cuda_device, prev_module_hook=hook_2)",
            "answer": "cpu_offload_with_hook",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_4"
        },
        {
            "dependency": "accelerate",
            "version": "==0.20.0",
            "time": "2023-06-07",
            "description": "This code splits a list of items into two separate processes using the Accelerator class. The first split_between_processes call splits the list [\"A\", \"B\", \"C\"] without padding, resulting in Process 0 getting [\"A\", \"B\"] and Process 1 getting [\"C\"]. The second split_between_processes call splits the same list with padding (apply_padding=True), resulting in Process 0 getting [\"A\", \"B\"] and Process 1 getting [\"C\", \"C\"].",
            "code": "# Assume there are two processes\nfrom accelerate import Accelerator\n\naccelerator = Accelerator()\nwith accelerator.split_between_processes([\"A\", \"B\", \"C\"]) as inputs:\n    print(inputs)\n# Process 0\n[\"A\", \"B\"]\n# Process 1\n[\"C\"]\n\nwith accelerator.split_between_processes([\"A\", \"B\", \"C\"], apply_padding=True) as inputs:\n    print(inputs)\n# Process 0\n[\"A\", \"B\"]\n# Process 1\n[\"C\", \"C\"]\n",
            "masked_code": "# Assume there are two processes\nfrom accelerate import Accelerator\n\naccelerator = Accelerator()\nwith accelerator.split_between_processes([\"A\", \"B\", \"C\"]) as inputs:\n    print(inputs)\n# Process 0\n[\"A\", \"B\"]\n# Process 1\n[\"C\"]\n\n<line_mask>\n    print(inputs)\n# Process 0\n[\"A\", \"B\"]\n# Process 1\n[\"C\", \"C\"]\n",
            "masked_line": "with accelerator.split_between_processes([\"A\", \"B\", \"C\"], apply_padding=True) as inputs:",
            "answer": "split_between_processes",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_5"
        },
        {
            "dependency": "accelerate",
            "version": "==0.20.0",
            "time": "2023-06-07",
            "description": "This code splits a list of elements between two processes and prints the inputs assigned to each process. The second split includes padding the inputs to make the assignment equal.",
            "code": "# Assume there are two processes\nfrom accelerate import PartialState\n\nstate = PartialState()\nwith state.split_between_processes([\"A\", \"B\", \"C\"]) as inputs:\n    print(inputs)\n# Process 0\n[\"A\", \"B\"]\n# Process 1\n[\"C\"]\n\nwith state.split_between_processes([\"A\", \"B\", \"C\"], apply_padding=True) as inputs:\n    print(inputs)\n# Process 0\n[\"A\", \"B\"]\n# Process 1\n[\"C\", \"C\"]\n",
            "masked_code": "# Assume there are two processes\nfrom accelerate import PartialState\n\nstate = PartialState()\nwith state.split_between_processes([\"A\", \"B\", \"C\"]) as inputs:\n    print(inputs)\n# Process 0\n[\"A\", \"B\"]\n# Process 1\n[\"C\"]\n\n<line_mask>\n    print(inputs)\n# Process 0\n[\"A\", \"B\"]\n# Process 1\n[\"C\", \"C\"]\n",
            "masked_line": "with state.split_between_processes([\"A\", \"B\", \"C\"], apply_padding=True) as inputs:",
            "answer": "split_between_processes",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_6"
        },
        {
            "dependency": "accelerate",
            "version": "==0.20.0",
            "time": "2023-06-07",
            "description": "The code splits a list of inputs between two processes, with the option to apply padding to maintain equal length lists for each process.",
            "code": "# Assume there are two processes\nfrom accelerate.state import AcceleratorState\n\nstate = AcceleratorState()\nwith state.split_between_processes([\"A\", \"B\", \"C\"]) as inputs:\n    print(inputs)\n# Process 0\n[\"A\", \"B\"]\n# Process 1\n[\"C\"]\n\nwith state.split_between_processes([\"A\", \"B\", \"C\"], apply_padding=True) as inputs:\n    print(inputs)\n# Process 0\n[\"A\", \"B\"]\n# Process 1\n[\"C\", \"C\"]\n",
            "masked_code": "# Assume there are two processes\nfrom accelerate.state import AcceleratorState\n\nstate = AcceleratorState()\n<line_mask>\n    print(inputs)\n# Process 0\n[\"A\", \"B\"]\n# Process 1\n[\"C\"]\n\nwith state.split_between_processes([\"A\", \"B\", \"C\"], apply_padding=True) as inputs:\n    print(inputs)\n# Process 0\n[\"A\", \"B\"]\n# Process 1\n[\"C\", \"C\"]\n",
            "masked_line": "with state.split_between_processes([\"A\", \"B\", \"C\"]) as inputs:",
            "answer": "split_between_processes",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_7"
        },
        {
            "dependency": "accelerate",
            "version": "==0.22.0",
            "time": "2023-08-23",
            "description": "The code sets an environment variable \"FOO\" to \"bar\", prints out the current environment variables, changes the value of \"FOO\" to \"new_bar\" within a cleared environment, and prints out the updated value of \"FOO\".",
            "code": "import os\nfrom accelerate.utils import clear_environment\n\nos.environ[\"FOO\"] = \"bar\"\nwith clear_environment():\n    print(os.environ)\n    os.environ[\"FOO\"] = \"new_bar\"\n    print(os.environ[\"FOO\"])\n\n",
            "masked_code": "import os\n<line_mask>\n\nos.environ[\"FOO\"] = \"bar\"\nwith clear_environment():\n    print(os.environ)\n    os.environ[\"FOO\"] = \"new_bar\"\n    print(os.environ[\"FOO\"])\n\n",
            "masked_line": "from accelerate.utils import clear_environment",
            "answer": "clear_environment",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_8"
        },
        {
            "dependency": "accelerate",
            "version": "==0.8.0",
            "time": "2022-05-12",
            "description": "The code initializes a deep learning model with 1000 layers, each consisting of a linear transformation from 10000 inputs to 10000 outputs, without using any RAM.",
            "code": "pyton\nimport torch.nn as nn\nfrom accelerate import init_empty_weights\n\n# Initialize a model with 100 billions parameters in no time and without using any RAM.\nwith init_empty_weights():\n    tst = nn.Sequential(*[nn.Linear(10000, 10000) for _ in range(1000)])\n",
            "masked_code": "pyton\nimport torch.nn as nn\n<line_mask>\n\n# Initialize a model with 100 billions parameters in no time and without using any RAM.\nwith init_empty_weights():\n    tst = nn.Sequential(*[nn.Linear(10000, 10000) for _ in range(1000)])\n",
            "masked_line": "from accelerate import init_empty_weights",
            "answer": "init_empty_weights",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_9"
        },
        {
            "dependency": "accelerate",
            "version": "==0.8.0",
            "time": "2022-05-12",
            "description": "This code converts a file size represented as a string to an integer value in bytes. It checks if the input size is already an integer and returns it as is. If the size is a string, it looks for units such as B, KB, MB, GB, and TB at the end of the string, and converts the size to bytes according to the unit. If no valid unit is found, it raises a ValueError.",
            "code": "def convert_file_size_to_int(size):\n    if isinstance(size, int):\n        return size\n    units = {\"B\": 1, \"KB\": 1024, \"MB\": 1024 ** 2, \"GB\": 1024 ** 3, \"TB\": 1024 ** 4}\n    size_str = str(size)\n    for unit in units:\n        if size_str.endswith(unit):\n            return int(size_str[:-len(unit)]) * units[unit]\n    raise ValueError(\"Invalid size format\")\n",
            "masked_code": "<line_mask>\n    if isinstance(size, int):\n        return size\n    units = {\"B\": 1, \"KB\": 1024, \"MB\": 1024 ** 2, \"GB\": 1024 ** 3, \"TB\": 1024 ** 4}\n    size_str = str(size)\n    for unit in units:\n        if size_str.endswith(unit):\n            return int(size_str[:-len(unit)]) * units[unit]\n    raise ValueError(\"Invalid size format\")\n",
            "masked_line": "def convert_file_size_to_int(size):",
            "answer": "convert_file_size_to_int",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_10"
        },
        {
            "dependency": "attrs",
            "version": "==19.2.0",
            "time": "2019-10-01",
            "description": "The code defines version information objects and performs comparison operations between the version objects and tuples.",
            "code": "attr.VersionInfo(19, 1, 0, \"final\")  <= (19, 2)\nattr.VersionInfo(19, 1, 0, \"final\") < (19, 1, 1)\nvi = attr.VersionInfo(19, 2, 0, \"final\")\nvi < (19, 1, 1)\nvi < (19,)\nvi == (19, 2,)\nvi == (19, 2, 1)",
            "masked_code": "attr.VersionInfo(19, 1, 0, \"final\")  <= (19, 2)\n<line_mask>\nvi = attr.VersionInfo(19, 2, 0, \"final\")\nvi < (19, 1, 1)\nvi < (19,)\nvi == (19, 2,)\nvi == (19, 2, 1)",
            "masked_line": "attr.VersionInfo(19, 1, 0, \"final\") < (19, 1, 1)",
            "answer": "VersionInfo",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_11"
        },
        {
            "dependency": "click",
            "version": "==5.0",
            "time": "2015-08-16",
            "description": "This code defines a language key variable, sets the language value in the current context metadata, and retrieves the language value from the current context metadata with a default value of 'en_US'.",
            "code": "LANG_KEY = __name__ + '.lang'\n\ndef set_language(value):\n    ctx = get_current_context()\n    ctx.meta[LANG_KEY] = value\n\ndef get_language():\n    return get_current_context().meta.get(LANG_KEY, 'en_US')\n",
            "masked_code": "LANG_KEY = __name__ + '.lang'\n\ndef set_language(value):\n    ctx = get_current_context()\n    ctx.meta[LANG_KEY] = value\n\ndef get_language():\n    <line_mask>\n",
            "masked_line": "return get_current_context().meta.get(LANG_KEY, 'en_US')",
            "answer": "meta",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_12"
        },
        {
            "dependency": "click",
            "version": "==5.1",
            "time": "2015-08-17",
            "description": "The code unpacks the arguments passed in the list and applies them to the function call using range(6) as the iterable.",
            "code": "unpack_args(range(6), [1, 2, 1, -1])\nunpack_args(range(6), [1, 2, 1])\nunpack_args(range(6), [-1])\nunpack_args(range(6), [1, 1])\nunpack_args(range(6), [-1,1,1,1,1])",
            "masked_code": "unpack_args(range(6), [1, 2, 1, -1])\nunpack_args(range(6), [1, 2, 1])\nunpack_args(range(6), [-1])\nunpack_args(range(6), [1, 1])\n<line_mask>",
            "masked_line": "unpack_args(range(6), [-1,1,1,1,1])",
            "answer": "unpack_args",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_14"
        },
        {
            "dependency": "datasets",
            "version": "==1.1.3",
            "time": "2020-11-19",
            "description": "This code snippet demonstrates two ways to acquire and release a lock in Python using context manager or try-finally construct. The code ensures that the resources protected by the lock are properly released after they are no longer needed.",
            "code": "# You can use this method in the context manager (recommended)\nwith lock.acquire():\n    pass\n\n# Or use an equivalent try-finally construct:\nlock.acquire()\ntry:\n    pass\nfinally:\n    lock.release()\n",
            "masked_code": "# You can use this method in the context manager (recommended)\nwith lock.acquire():\n    pass\n\n# Or use an equivalent try-finally construct:\n<line_mask>\ntry:\n    pass\nfinally:\n    lock.release()\n",
            "masked_line": "lock.acquire()",
            "answer": "acquire",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_15"
        },
        {
            "dependency": "datasets",
            "version": "==1.18.0",
            "time": "2022-01-21",
            "description": "This function splits a given path using \"::\" as a separator, then extracts the base name and extension from the first part of the split path. Finally, it concatenates the base name with the rest of the split parts and returns a tuple of the modified path and extension.",
            "code": "def xsplitext(path):\n    parts = path.split(\"::\")\n    first_part, *rest = parts\n    base, ext = os.path.splitext(first_part)\n    return (base + \"\".join(rest), ext)\n",
            "masked_code": "<line_mask>\n    parts = path.split(\"::\")\n    first_part, *rest = parts\n    base, ext = os.path.splitext(first_part)\n    return (base + \"\".join(rest), ext)\n",
            "masked_line": "def xsplitext(path):",
            "answer": "xsplitext",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_16"
        },
        {
            "dependency": "datasets",
            "version": "==1.8.0",
            "time": "2021-06-08",
            "description": "The code reorders the fields of two feature objects and checks if the type of the first feature object after reordering matches the type of the second feature object.",
            "code": "from datasets import Features, Sequence, Value\n\nf1 = Features({\"root\": Sequence({\"a\": Value(\"string\"), \"b\": Value(\"string\")})})\nf2 = Features({\"root\": {\"b\": Sequence(Value(\"string\")), \"a\": Sequence(Value(\"string\"))}})\nassert f1.type != f2.type\nf1.reorder_fields_as(f2)\nassert f1.reorder_fields_as(f2).type == f2.type\n",
            "masked_code": "from datasets import Features, Sequence, Value\n\nf1 = Features({\"root\": Sequence({\"a\": Value(\"string\"), \"b\": Value(\"string\")})})\nf2 = Features({\"root\": {\"b\": Sequence(Value(\"string\")), \"a\": Sequence(Value(\"string\"))}})\nassert f1.type != f2.type\nf1.reorder_fields_as(f2)\n<line_mask>\n",
            "masked_line": "assert f1.reorder_fields_as(f2).type == f2.type",
            "answer": "reorder_fields_as",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_17"
        },
        {
            "dependency": "datasets",
            "version": "==1.9.0",
            "time": "2021-07-05",
            "description": "The code is patching the submodule \"os.path.join\" in the snli module with a custom function xjoin and then starting the patcher.",
            "code": "import importlib\nfrom datasets.load import prepare_module\nfrom datasets.streaming import patch_submodule, xjoin\n\nsnli_module_path, _ = prepare_module(\"snli\")\nsnli_module = importlib.import_module(snli_module_path)\npatcher = patch_submodule(snli_module, \"os.path.join\", xjoin)\npatcher.start()\nassert snli_module.os.path.join is xjoin",
            "masked_code": "import importlib\nfrom datasets.load import prepare_module\n<line_mask>\n\nsnli_module_path, _ = prepare_module(\"snli\")\nsnli_module = importlib.import_module(snli_module_path)\npatcher = patch_submodule(snli_module, \"os.path.join\", xjoin)\npatcher.start()\nassert snli_module.os.path.join is xjoin",
            "masked_line": "from datasets.streaming import patch_submodule, xjoin",
            "answer": "patch_submodule",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_18"
        },
        {
            "dependency": "datasets",
            "version": "==2.15.0",
            "time": "2023-11-16",
            "description": "This code block demonstrates two ways to acquire and release a lock in Python: one using a context manager with the `with` statement, and the other using a try-finally construct.",
            "code": "# You can use this method in the context manager (recommended)\nwith lock.acquire():\n    pass\n\n# Or use an equivalent try-finally construct:\nlock.acquire()\ntry:\n    pass\nfinally:\n    lock.release()\n",
            "masked_code": "# You can use this method in the context manager (recommended)\n<line_mask>\n    pass\n\n# Or use an equivalent try-finally construct:\nlock.acquire()\ntry:\n    pass\nfinally:\n    lock.release()\n",
            "masked_line": "with lock.acquire():",
            "answer": "acquire",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_19"
        },
        {
            "dependency": "datasets",
            "version": "==2.2.0",
            "time": "2022-05-10",
            "description": "This function converts a file size string to an integer, where the input size can be in bytes (B), kilobytes (KB), megabytes (MB), gigabytes (GB), or terabytes (TB).",
            "code": "def convert_file_size_to_int(size):\n    if isinstance(size, int):\n        return size\n    units = {\"B\": 1, \"KB\": 1024, \"MB\": 1024 ** 2, \"GB\": 1024 ** 3, \"TB\": 1024 ** 4}\n    number, unit = int(size[:-2]), size[-2:]\n    return number * units[unit]\n\n",
            "masked_code": "<line_mask>\n    if isinstance(size, int):\n        return size\n    units = {\"B\": 1, \"KB\": 1024, \"MB\": 1024 ** 2, \"GB\": 1024 ** 3, \"TB\": 1024 ** 4}\n    number, unit = int(size[:-2]), size[-2:]\n    return number * units[unit]\n\n",
            "masked_line": "def convert_file_size_to_int(size):",
            "answer": "convert_file_size_to_int",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_20"
        },
        {
            "dependency": "datasets",
            "version": "==2.4.0",
            "time": "2022-07-25",
            "description": "Check if the given file path is inside the specified special directory pattern.",
            "code": "_is_inside_unrequested_special_dir(\"__pycache__/b.txt\", \"**\")\nTrue\n_is_inside_unrequested_special_dir(\"__pycache__/b.txt\", \"*/b.txt\")\nTrue\n_is_inside_unrequested_special_dir(\"__pycache__/b.txt\", \"__pycache__/*\")\nFalse\n_is_inside_unrequested_special_dir(\"__pycache__/b.txt\", \"__*/*\")\nFalse",
            "masked_code": "_is_inside_unrequested_special_dir(\"__pycache__/b.txt\", \"**\")\nTrue\n_is_inside_unrequested_special_dir(\"__pycache__/b.txt\", \"*/b.txt\")\nTrue\n_is_inside_unrequested_special_dir(\"__pycache__/b.txt\", \"__pycache__/*\")\nFalse\n<line_mask>\nFalse",
            "masked_line": "_is_inside_unrequested_special_dir(\"__pycache__/b.txt\", \"__*/*\")",
            "answer": "_is_inside_unrequested_special_dir",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_21"
        },
        {
            "dependency": "datasets",
            "version": "==2.4.0",
            "time": "2022-07-25",
            "description": "The code creates a mock filesystem and checks if the filesystem class is \"DummyTestFS\". It then asserts that the type of the filesystem is also \"DummyTestFS\" and prints out the files and directories in the filesystem.",
            "code": "fs = mock_fs([\"data/train.txt\", \"data.test.txt\"])\nassert fsspec.get_filesystem_class(\"mock\").__name__ == \"DummyTestFS\"\nassert type(fs).__name__ == \"DummyTestFS\"\nprint(fs.glob(\"**\"))\n[\"data\", \"data/train.txt\", \"data.test.txt\"]\n",
            "masked_code": "<line_mask>\nassert fsspec.get_filesystem_class(\"mock\").__name__ == \"DummyTestFS\"\nassert type(fs).__name__ == \"DummyTestFS\"\nprint(fs.glob(\"**\"))\n[\"data\", \"data/train.txt\", \"data.test.txt\"]\n",
            "masked_line": "fs = mock_fs([\"data/train.txt\", \"data.test.txt\"])",
            "answer": "mock_fs",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_22"
        },
        {
            "dependency": "datasets",
            "version": "==2.6.0",
            "time": "2022-10-13",
            "description": "The code fetches data from a database table and executes SQL queries on the table using a Selectable object.",
            "code": "from datasets import Dataset\n\n# Fetch a database table\nds = Dataset.from_sql(\"test_data\", \"postgres:///db_name\")\n# Execute a SQL query on the table\nds = Dataset.from_sql(\"SELECT sentence FROM test_data\", \"postgres:///db_name\")\n# Use a Selectable object to specify the query\nfrom sqlalchemy import select, text\nstmt = select([text(\"sentence\")]).select_from(text(\"test_data\"))\nds = Dataset.from_sql(stmt, \"postgres:///db_name\")\n",
            "masked_code": "from datasets import Dataset\n\n# Fetch a database table\nds = Dataset.from_sql(\"test_data\", \"postgres:///db_name\")\n# Execute a SQL query on the table\nds = Dataset.from_sql(\"SELECT sentence FROM test_data\", \"postgres:///db_name\")\n# Use a Selectable object to specify the query\nfrom sqlalchemy import select, text\nstmt = select([text(\"sentence\")]).select_from(text(\"test_data\"))\n<line_mask>\n",
            "masked_line": "ds = Dataset.from_sql(stmt, \"postgres:///db_name\")",
            "answer": "from_sql",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_23"
        },
        {
            "dependency": "evaluate",
            "version": "==0.2.0",
            "time": "2022-07-25",
            "description": "This code segment evaluates the performance of a pre-trained model \"nateraw/vit-base-beans\" on the \"beans\" dataset for the task of image classification. It uses the specified label mapping and evaluation metric (accuracy) to compute the model's performance using a bootstrapping strategy.",
            "code": "from evaluate import evaluator\nfrom datasets import load_dataset\ntask_evaluator = evaluator(\"image-classification\")\ndata = load_dataset(\"beans\", split=\"test[:40]\")\nresults = task_evaluator.compute(\n    model_or_pipeline=\"nateraw/vit-base-beans\",\n    data=data,\n    label_column=\"labels\",\n    metric=\"accuracy\",\n    label_mapping={'angular_leaf_spot': 0, 'bean_rust': 1, 'healthy': 2},\n    strategy=\"bootstrap\"\n)\n",
            "masked_code": "from evaluate import evaluator\nfrom datasets import load_dataset\ntask_evaluator = evaluator(\"image-classification\")\ndata = load_dataset(\"beans\", split=\"test[:40]\")\n<line_mask>\n    model_or_pipeline=\"nateraw/vit-base-beans\",\n    data=data,\n    label_column=\"labels\",\n    metric=\"accuracy\",\n    label_mapping={'angular_leaf_spot': 0, 'bean_rust': 1, 'healthy': 2},\n    strategy=\"bootstrap\"\n)\n",
            "masked_line": "results = task_evaluator.compute(",
            "answer": "compute",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_24"
        },
        {
            "dependency": "evaluate",
            "version": "==0.2.0",
            "time": "2022-07-25",
            "description": "The code evaluates question-answering models using specified datasets and computes their performance metrics for the SQuAD (Stanford Question Answering Dataset) tasks.",
            "code": "from evaluate import evaluator\nfrom datasets import load_dataset\ntask_evaluator = evaluator(\"question-answering\")\ndata = load_dataset(\"squad\", split=\"validation[:2]\")\nresults = task_evaluator.compute(\n    model_or_pipeline=\"sshleifer/tiny-distilbert-base-cased-distilled-squad\",\n    data=data,\n    metric=\"squad\",\n)\n\n\nfrom evaluate import evaluator\nfrom datasets import load_dataset\ntask_evaluator = evaluator(\"question-answering\")\ndata = load_dataset(\"squad_v2\", split=\"validation[:2]\")\nresults = task_evaluator.compute(\n    model_or_pipeline=\"mrm8488/bert-tiny-finetuned-squadv2\",\n    data=data,\n    metric=\"squad_v2\",\n    squad_v2_format=True,\n)\n",
            "masked_code": "from evaluate import evaluator\nfrom datasets import load_dataset\ntask_evaluator = evaluator(\"question-answering\")\ndata = load_dataset(\"squad\", split=\"validation[:2]\")\n<line_mask>\n    model_or_pipeline=\"sshleifer/tiny-distilbert-base-cased-distilled-squad\",\n    data=data,\n    metric=\"squad\",\n)\n\n\nfrom evaluate import evaluator\nfrom datasets import load_dataset\ntask_evaluator = evaluator(\"question-answering\")\ndata = load_dataset(\"squad_v2\", split=\"validation[:2]\")\nresults = task_evaluator.compute(\n    model_or_pipeline=\"mrm8488/bert-tiny-finetuned-squadv2\",\n    data=data,\n    metric=\"squad_v2\",\n    squad_v2_format=True,\n)\n",
            "masked_line": "results = task_evaluator.compute(",
            "answer": "compute",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_25"
        },
        {
            "dependency": "evaluate",
            "version": "==0.3.0",
            "time": "2022-10-13",
            "description": "The code evaluates the performance of the Facebook BART model on the CNN/DailyMail dataset for text-to-text generation task using the ROUGE metric on the first 40 validation examples.",
            "code": "from evaluate import evaluator\nfrom datasets import load_dataset\ntask_evaluator = evaluator(\"text2text-generation\")\ndata = load_dataset(\"cnn_dailymail\", \"3.0.0\", split=\"validation[:40]\")\nresults = task_evaluator.compute(\n    model_or_pipeline=\"facebook/bart-large-cnn\",\n    data=data,\n    input_column=\"article\",\n    label_column=\"highlights\",\n    metric=\"rouge\",\n)",
            "masked_code": "from evaluate import evaluator\nfrom datasets import load_dataset\ntask_evaluator = evaluator(\"text2text-generation\")\ndata = load_dataset(\"cnn_dailymail\", \"3.0.0\", split=\"validation[:40]\")\n<line_mask>\n    model_or_pipeline=\"facebook/bart-large-cnn\",\n    data=data,\n    input_column=\"article\",\n    label_column=\"highlights\",\n    metric=\"rouge\",\n)",
            "masked_line": "results = task_evaluator.compute(",
            "answer": "compute",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_26"
        },
        {
            "dependency": "evaluate",
            "version": "==0.3.0",
            "time": "2022-10-13",
            "description": "The code is used to evaluate the performance of the model \"facebook/bart-large-cnn\" on the task of summarization using the data from the \"cnn_dailymail\" dataset. It computes the evaluation metrics based on the model's predictions compared to the actual highlights in the dataset.",
            "code": "from evaluate import evaluator\nfrom datasets import load_dataset\ntask_evaluator = evaluator(\"summarization\")\ndata = load_dataset(\"cnn_dailymail\", \"3.0.0\", split=\"validation[:40]\")\nresults = task_evaluator.compute(\n    model_or_pipeline=\"facebook/bart-large-cnn\",\n    data=data,\n    input_column=\"article\",\n    label_column=\"highlights\",\n)",
            "masked_code": "from evaluate import evaluator\nfrom datasets import load_dataset\ntask_evaluator = evaluator(\"summarization\")\ndata = load_dataset(\"cnn_dailymail\", \"3.0.0\", split=\"validation[:40]\")\n<line_mask>\n    model_or_pipeline=\"facebook/bart-large-cnn\",\n    data=data,\n    input_column=\"article\",\n    label_column=\"highlights\",\n)",
            "masked_line": "results = task_evaluator.compute(",
            "answer": "compute",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_27"
        },
        {
            "dependency": "evaluate",
            "version": "==0.3.0",
            "time": "2022-10-13",
            "description": "This code is for evaluating the translation model on a specific dataset by computing the performance metrics using the given model or pipeline. Specifically, it loads the WMT19 dataset for translation from French to German, maps the data to the required format, and evaluates the performance using the specified model.",
            "code": "from evaluate import evaluator\nfrom datasets import load_dataset\ntask_evaluator = evaluator(\"translation\")\ndata = load_dataset(\"wmt19\", \"fr-de\", split=\"validation[:40]\")\ndata = data.map(lambda x: {\"text\": x[\"translation\"][\"de\"], \"label\": x[\"translation\"][\"fr\"]})\nresults = task_evaluator.compute(\n    model_or_pipeline=\"Helsinki-NLP/opus-mt-de-fr\",\n    data=data,\n)",
            "masked_code": "from evaluate import evaluator\nfrom datasets import load_dataset\ntask_evaluator = evaluator(\"translation\")\ndata = load_dataset(\"wmt19\", \"fr-de\", split=\"validation[:40]\")\ndata = data.map(lambda x: {\"text\": x[\"translation\"][\"de\"], \"label\": x[\"translation\"][\"fr\"]})\n<line_mask>\n    model_or_pipeline=\"Helsinki-NLP/opus-mt-de-fr\",\n    data=data,\n)",
            "masked_line": "results = task_evaluator.compute(",
            "answer": "compute",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_28"
        },
        {
            "dependency": "evaluate",
            "version": "==0.4.0",
            "time": "2022-12-13",
            "description": "The code computes the ROUGE metric evaluation for a text-to-text generation task using the BART model on a subset of the CNN/Daily Mail dataset validation set.",
            "code": "from evaluate import evaluator\nfrom datasets import load_dataset\ntask_evaluator = evaluator(\"text2text-generation\")\ndata = load_dataset(\"cnn_dailymail\", \"3.0.0\", split=\"validation[:40]\")\nresults = task_evaluator.compute(\n    model_or_pipeline=\"facebook/bart-large-cnn\",\n    data=data,\n    input_column=\"article\",\n    label_column=\"highlights\",\n    metric=\"rouge\",\n)",
            "masked_code": "from evaluate import evaluator\nfrom datasets import load_dataset\ntask_evaluator = evaluator(\"text2text-generation\")\ndata = load_dataset(\"cnn_dailymail\", \"3.0.0\", split=\"validation[:40]\")\n<line_mask>\n    model_or_pipeline=\"facebook/bart-large-cnn\",\n    data=data,\n    input_column=\"article\",\n    label_column=\"highlights\",\n    metric=\"rouge\",\n)",
            "masked_line": "results = task_evaluator.compute(",
            "answer": "compute",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_29"
        },
        {
            "dependency": "evaluate",
            "version": "==0.4.0",
            "time": "2022-12-13",
            "description": "The code evaluates the performance of the \"facebook/bart-large-cnn\" model on the summarization task using the dataset \"cnn_dailymail\" for its validation subset, utilizing the \"evaluate\" module and \"datasets\" module.",
            "code": "from evaluate import evaluator\nfrom datasets import load_dataset\ntask_evaluator = evaluator(\"summarization\")\ndata = load_dataset(\"cnn_dailymail\", \"3.0.0\", split=\"validation[:40]\")\nresults = task_evaluator.compute(\n    model_or_pipeline=\"facebook/bart-large-cnn\",\n    data=data,\n    input_column=\"article\",\n    label_column=\"highlights\",\n)",
            "masked_code": "from evaluate import evaluator\nfrom datasets import load_dataset\ntask_evaluator = evaluator(\"summarization\")\ndata = load_dataset(\"cnn_dailymail\", \"3.0.0\", split=\"validation[:40]\")\n<line_mask>\n    model_or_pipeline=\"facebook/bart-large-cnn\",\n    data=data,\n    input_column=\"article\",\n    label_column=\"highlights\",\n)",
            "masked_line": "results = task_evaluator.compute(",
            "answer": "compute",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_30"
        },
        {
            "dependency": "evaluate",
            "version": "==0.4.0",
            "time": "2022-12-13",
            "description": "The code evaluates the translation task using the model \"Helsinki-NLP/opus-mt-de-fr\" on the WMT19 dataset with language pairs of French to German. It takes the validation data, maps the data to extract the German text and French labels, then computes the results using the evaluator.",
            "code": "from evaluate import evaluator\nfrom datasets import load_dataset\ntask_evaluator = evaluator(\"translation\")\ndata = load_dataset(\"wmt19\", \"fr-de\", split=\"validation[:40]\")\ndata = data.map(lambda x: {\"text\": x[\"translation\"][\"de\"], \"label\": x[\"translation\"][\"fr\"]})\nresults = task_evaluator.compute(\n    model_or_pipeline=\"Helsinki-NLP/opus-mt-de-fr\",\n    data=data,\n)",
            "masked_code": "from evaluate import evaluator\nfrom datasets import load_dataset\ntask_evaluator = evaluator(\"translation\")\ndata = load_dataset(\"wmt19\", \"fr-de\", split=\"validation[:40]\")\ndata = data.map(lambda x: {\"text\": x[\"translation\"][\"de\"], \"label\": x[\"translation\"][\"fr\"]})\n<line_mask>\n    model_or_pipeline=\"Helsinki-NLP/opus-mt-de-fr\",\n    data=data,\n)",
            "masked_line": "results = task_evaluator.compute(",
            "answer": "compute",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_31"
        },
        {
            "dependency": "faiss-cpu",
            "version": "==1.7.1",
            "time": "2021-05-27",
            "description": "The code defines a function called supported_instruction_sets() that returns a set of supported instruction sets for different architectures. It provides sets of instruction sets for x86, PPC, and ARM architectures respectively.",
            "code": "supported_instruction_sets()  # for x86\n{\"SSE2\", \"AVX2\", ...}\nsupported_instruction_sets()  # for PPC\n{\"VSX\", \"VSX2\", ...}\nsupported_instruction_sets()  # for ARM\n{\"NEON\", \"ASIMD\", ...}",
            "masked_code": "supported_instruction_sets()  # for x86\n{\"SSE2\", \"AVX2\", ...}\n<line_mask>\n{\"VSX\", \"VSX2\", ...}\nsupported_instruction_sets()  # for ARM\n{\"NEON\", \"ASIMD\", ...}",
            "masked_line": "supported_instruction_sets()  # for PPC",
            "answer": "supported_instruction_sets",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_32"
        },
        {
            "dependency": "flax",
            "version": "==0.3.3",
            "time": "2021-03-31",
            "description": "This function initializes a module with optional output and returns the initialized module along with any variables generated during initialization.",
            "code": "def init_with_output(fn, module, mutable=False):\n    def init_fn(rngs, *args, **kwargs):\n        variables = module.init(rngs)\n        return fn(module, *args, **kwargs), variables\n    return init_fn\n",
            "masked_code": "<line_mask>\n    def init_fn(rngs, *args, **kwargs):\n        variables = module.init(rngs)\n        return fn(module, *args, **kwargs), variables\n    return init_fn\n",
            "masked_line": "def init_with_output(fn, module, mutable=False):",
            "answer": "init_with_output",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_33"
        },
        {
            "dependency": "flax",
            "version": "==0.3.3",
            "time": "2021-03-31",
            "description": "This code defines an autoencoder neural network model, with an encoder and a decoder. The model can encode input data and reconstruct the data from the encoded representation.",
            "code": "class AutoEncoder(nn.Module):\n    def setup(self):\n      self.encoder = nn.Dense(3)\n      self.decoder = nn.Dense(5)\n  \nae = AutoEncoder()\nmodel = ae.bind(variables)\nz = model.encode(x)\nx_reconstructed = model.decode(z)\n",
            "masked_code": "class AutoEncoder(nn.Module):\n    def setup(self):\n      self.encoder = nn.Dense(3)\n      self.decoder = nn.Dense(5)\n  \nae = AutoEncoder()\n<line_mask>\nz = model.encode(x)\nx_reconstructed = model.decode(z)\n",
            "masked_line": "model = ae.bind(variables)",
            "answer": "bind",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_34"
        },
        {
            "dependency": "flax",
            "version": "==0.3.4",
            "time": "2021-05-18",
            "description": "This function generates a mask for a sequence based on the lengths of the sequences and a maximum length, where each sequence is represented as a boolean array with True values for the actual length of the sequence and False values for the padding.",
            "code": "def sequence_mask(lengths, max_length):\n    mask = []\n    for length in lengths:\n        mask.append([True] * length + [False] * (max_length - length))\n    return mask\n",
            "masked_code": "<line_mask>\n    mask = []\n    for length in lengths:\n        mask.append([True] * length + [False] * (max_length - length))\n    return mask\n",
            "masked_line": "def sequence_mask(lengths, max_length):",
            "answer": "sequence_mask",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_36"
        },
        {
            "dependency": "flax",
            "version": "==0.3.4",
            "time": "2021-05-18",
            "description": "This code function flips sequences by reversing the first part of each sequence based on the lengths provided.",
            "code": "def flip_sequences(inputs, lengths):\n    flipped_inputs = []\n    for i in range(len(inputs)):\n        seq = inputs[i][:lengths[i]]\n        flipped_seq = seq[::-1] + inputs[i][lengths[i]:]\n        flipped_inputs.append(flipped_seq)\n    return flipped_inputs\n",
            "masked_code": "<line_mask>\n    flipped_inputs = []\n    for i in range(len(inputs)):\n        seq = inputs[i][:lengths[i]]\n        flipped_seq = seq[::-1] + inputs[i][lengths[i]:]\n        flipped_inputs.append(flipped_seq)\n    return flipped_inputs\n",
            "masked_line": "def flip_sequences(inputs, lengths):",
            "answer": "flip_sequences",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_37"
        },
        {
            "dependency": "flax",
            "version": "==0.3.5",
            "time": "2021-09-21",
            "description": "This code defines a method to create a dense layer and then applies this dense layer to the input data x.",
            "code": "@nowrap\ndef _make_dense(self, num_features):\n  return nn.Dense(num_features)\n\n@compact\ndef __call__(self, x):\n  # now safe to use constructor helper even if using named_call\n  dense = self._dense(self.num_features)\n  return dense(x)",
            "masked_code": "<line_mask>\ndef _make_dense(self, num_features):\n  return nn.Dense(num_features)\n\n@compact\ndef __call__(self, x):\n  # now safe to use constructor helper even if using named_call\n  dense = self._dense(self.num_features)\n  return dense(x)",
            "masked_line": "@nowrap",
            "answer": "nowrap",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_38"
        },
        {
            "dependency": "flax",
            "version": "==0.3.6",
            "time": "2021-10-27",
            "description": "The function `f` takes a scope and input `x`, then calculates the output `y` by scaling `x` based on the parameters obtained from the `learn_scale` function. It then computes the gradients of the parameters and input `x` with respect to `y` using reverse-mode automatic differentiation and returns `y`, the gradient of the parameters, and the gradient of `x`.",
            "code": "def learn_scale(scope, x):\n    p = scope.param('scale', nn.initializers.zeros, ())\n    return p * x\n\ndef f(scope, x):\n    y, bwd = lift.vjp(learn_scale, scope, x)\n    params_grad, x_grad = bwd(jnp.ones(y.shape))\n    return y, params_grad, x_grad",
            "masked_code": "def learn_scale(scope, x):\n    p = scope.param('scale', nn.initializers.zeros, ())\n    return p * x\n\ndef f(scope, x):\n    <line_mask>\n    params_grad, x_grad = bwd(jnp.ones(y.shape))\n    return y, params_grad, x_grad",
            "masked_line": "y, bwd = lift.vjp(learn_scale, scope, x)",
            "answer": "vjp",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_39"
        },
        {
            "dependency": "flax",
            "version": "==0.3.6",
            "time": "2021-10-27",
            "description": "This code defines a function that learns a scaling parameter and applies it to an input x using JAX library functions.",
            "code": "def learn_scale(scope, x):\n    p = scope.param('scale', nn.initializers.zeros, ())\n    return p * x\n\ndef f(scope, x):\n    vars_t = jax.tree_map(jnp.ones_like, scope.variables().get('params', {}))\n    x, out_t = lift.jvp(\n        learn_scale, scope, (x,), (jnp.zeros_like(x),),\n        variable_tangents={'params': vars_t})\n    return out_t",
            "masked_code": "def learn_scale(scope, x):\n    p = scope.param('scale', nn.initializers.zeros, ())\n    return p * x\n\ndef f(scope, x):\n    vars_t = jax.tree_map(jnp.ones_like, scope.variables().get('params', {}))\n    <line_mask>\n        learn_scale, scope, (x,), (jnp.zeros_like(x),),\n        variable_tangents={'params': vars_t})\n    return out_t",
            "masked_line": "x, out_t = lift.jvp(",
            "answer": "jvp",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_40"
        },
        {
            "dependency": "flax",
            "version": "==0.3.6",
            "time": "2021-10-27",
            "description": "This code defines a class named Example that has a method called apply. The apply method calculates an exponential moving average (EMA) of the inputs using the decay parameter and updates the EMA value accordingly. The method then returns the original inputs.",
            "code": "class Example(nn.Module):\n    def apply(self, inputs, decay=0.9):\n      ema = self.state('ema', inputs.shape, initializers.zeros)\n      ema.value = decay * ema.value + (1 - decay) * inputs\n      return inputs\n",
            "masked_code": "class Example(nn.Module):\n    def apply(self, inputs, decay=0.9):\n      <line_mask>\n      ema.value = decay * ema.value + (1 - decay) * inputs\n      return inputs\n",
            "masked_line": "ema = self.state('ema', inputs.shape, initializers.zeros)",
            "answer": "state",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_43"
        },
        {
            "dependency": "flax",
            "version": "==0.3.6",
            "time": "2021-10-27",
            "description": "This code defines a dense layer neural network module that takes an input x and the number of features as input, applies a fully connected layer operation, followed by a rectified linear unit (ReLU) activation function, and returns the output.",
            "code": "@nn.module\ndef DenseLayer(x, features):\n    x = flax.nn.Dense(x, features)\n    x = flax.nn.relu(x)\n    return x\n\nclass DenseLayer(nn.Module):\n    def apply(self, x, features):\n        x = flax.nn.Dense(x, features)\n        x = flax.nn.relu(x)\n        return x",
            "masked_code": "<line_mask>\ndef DenseLayer(x, features):\n    x = flax.nn.Dense(x, features)\n    x = flax.nn.relu(x)\n    return x\n\nclass DenseLayer(nn.Module):\n    def apply(self, x, features):\n        x = flax.nn.Dense(x, features)\n        x = flax.nn.relu(x)\n        return x",
            "masked_line": "@nn.module",
            "answer": "module",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_45"
        },
        {
            "dependency": "flax",
            "version": "==0.3.6",
            "time": "2021-10-27",
            "description": "This code defines a class named Example that extends the nn.Module class. Inside this class, there is a method called apply which calculates the exponential moving average (EMA) of the input data using the decay parameter. The EMA is updated based on the current inputs and the previous EMA value. The method returns the original inputs.",
            "code": "class Example(nn.Module):\n    def apply(self, inputs, decay=0.9):\n      ema = self.state('ema', inputs.shape, initializers.zeros)\n      ema.value = decay * ema.value + (1 - decay) * inputs\n      return inputs\n",
            "masked_code": "class Example(nn.Module):\n    def apply(self, inputs, decay=0.9):\n      <line_mask>\n      ema.value = decay * ema.value + (1 - decay) * inputs\n      return inputs\n",
            "masked_line": "ema = self.state('ema', inputs.shape, initializers.zeros)",
            "answer": "state",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_46"
        },
        {
            "dependency": "flax",
            "version": "==0.4.1",
            "time": "2022-03-23",
            "description": "This code implements a while loop that iterates until the 'state' variable 'acc' is less than 10. Inside the loop, it increments the 'acc' variable by 1 and creates a new variable 'y' using a neural network dense layer.",
            "code": "def cond_fn(scope, c):\n    return scope.get_variable('state', 'acc') < 10\n\ndef body_fn(scope, c):\n    acc = scope.variable('state', 'acc')\n    acc += 1\n    y = scope.child(nn.dense)(c, c.shape[-1])\n    return y\n\nc = x\nc = body_fn(scope, c)\nreturn lift.while_loop(cond_fn, body_fn, scope, (),\n                       carry_variables='state')",
            "masked_code": "def cond_fn(scope, c):\n    return scope.get_variable('state', 'acc') < 10\n\ndef body_fn(scope, c):\n    acc = scope.variable('state', 'acc')\n    acc += 1\n    y = scope.child(nn.dense)(c, c.shape[-1])\n    return y\n\nc = x\nc = body_fn(scope, c)\n<line_mask>\n                       carry_variables='state')",
            "masked_line": "return lift.while_loop(cond_fn, body_fn, scope, (),",
            "answer": "while_loop",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_47"
        },
        {
            "dependency": "flax",
            "version": "==0.4.2",
            "time": "2022-05-02",
            "description": "This function defines two sub-functions that update true_count and false_count variables respectively based on the value of the pred parameter. It then uses a conditional statement to return the result of calling either true_fn or false_fn on the inputs scope and x.",
            "code": "def cond_example(scope, x, pred):\n    scope.variable('state', 'true_count', lambda: 0)\n    scope.variable('state', 'false_count', lambda: 0)\n    def true_fn(scope, x):\n      scope.variable('state', 'true_count').value += 1\n      return scope.child(nn.dense)(x, 2)\n    def false_fn(scope, x):\n      scope.variable('state', 'false_count').value += 1\n      return -scope.child(nn.dense)(x, 2)\n    return lift.cond(pred, true_fn, false_fn, scope, x)",
            "masked_code": "def cond_example(scope, x, pred):\n    scope.variable('state', 'true_count', lambda: 0)\n    scope.variable('state', 'false_count', lambda: 0)\n    def true_fn(scope, x):\n      scope.variable('state', 'true_count').value += 1\n      return scope.child(nn.dense)(x, 2)\n    def false_fn(scope, x):\n      scope.variable('state', 'false_count').value += 1\n      return -scope.child(nn.dense)(x, 2)\n    <line_mask>",
            "masked_line": "return lift.cond(pred, true_fn, false_fn, scope, x)",
            "answer": "cond",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_48"
        },
        {
            "dependency": "flax",
            "version": "==0.4.2",
            "time": "2022-05-02",
            "description": "This code defines a function that takes in a scope, a variable x, and a predicate. It creates state variables true_count and false_count which are incremented based on the outcome of the predicate. It then defines two functions, true_fn and false_fn, which update the state variables and return the result of a dense neural network layer. Finally, it uses a conditional statement based on the predicate to choose between true_fn and false_fn and return the result.",
            "code": "def cond_example(scope, x, pred):\n    scope.variable('state', 'true_count', lambda: 0)\n    scope.variable('state', 'false_count', lambda: 0)\n    def true_fn(scope, x):\n        scope.variable('state', 'true_count').value += 1\n        return scope.child(nn.dense)(x, 2)\n    def false_fn(scope, x):\n        scope.variable('state', 'false_count').value += 1\n        return -scope.child(nn.dense)(x, 2)\n    return lift.cond(pred, true_fn, false_fn, scope, x)",
            "masked_code": "def cond_example(scope, x, pred):\n    scope.variable('state', 'true_count', lambda: 0)\n    scope.variable('state', 'false_count', lambda: 0)\n    def true_fn(scope, x):\n        scope.variable('state', 'true_count').value += 1\n        return scope.child(nn.dense)(x, 2)\n    def false_fn(scope, x):\n        scope.variable('state', 'false_count').value += 1\n        return -scope.child(nn.dense)(x, 2)\n    <line_mask>",
            "masked_line": "return lift.cond(pred, true_fn, false_fn, scope, x)",
            "answer": "cond",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_49"
        },
        {
            "dependency": "flax",
            "version": "==0.5.1",
            "time": "2022-06-10",
            "description": "The code defines a neural network model using Flax, which consists of two dense layers. The model takes input data 'x' of shape (16, 9), passes it through the defined dense layers, and returns the output.",
            "code": "import jax\nimport jax.numpy as jnp\nimport flax.linen as nn\n\nclass Foo(nn.Module):\n    @nn.compact\n    def __call__(self, x):\n        h = nn.Dense(4)(x)\n        return nn.Dense(2)(h)\n\nx = jnp.ones((16, 9))\ntabulate_fn = nn.tabulate(Foo(), jax.random.PRNGKey(0))\n\nprint(tabulate_fn(x))\n",
            "masked_code": "import jax\nimport jax.numpy as jnp\nimport flax.linen as nn\n\nclass Foo(nn.Module):\n    @nn.compact\n    def __call__(self, x):\n        h = nn.Dense(4)(x)\n        return nn.Dense(2)(h)\n\nx = jnp.ones((16, 9))\n<line_mask>\n\nprint(tabulate_fn(x))\n",
            "masked_line": "tabulate_fn = nn.tabulate(Foo(), jax.random.PRNGKey(0))",
            "answer": "tabulate",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_50"
        },
        {
            "dependency": "flax",
            "version": "==0.5.1",
            "time": "2022-06-10",
            "description": "This code defines a neural network model using the Flax library in Python. The model consists of two dense layers with 4 and 2 units respectively. The code then creates an input tensor `x` with shape (16, 9) and passes it through the neural network model to output the result.",
            "code": "import jax\nimport jax.numpy as jnp\nimport flax.linen as nn\n\nclass Foo(nn.Module):\n    @nn.compact\n    def __call__(self, x):\n        h = nn.Dense(4)(x)\n        return nn.Dense(2)(h)\n\nx = jnp.ones((16, 9))\n\nprint(Foo().tabulate(jax.random.PRNGKey(0), x))\n",
            "masked_code": "import jax\nimport jax.numpy as jnp\nimport flax.linen as nn\n\nclass Foo(nn.Module):\n    @nn.compact\n    def __call__(self, x):\n        h = nn.Dense(4)(x)\n        return nn.Dense(2)(h)\n\nx = jnp.ones((16, 9))\n\n<line_mask>\n",
            "masked_line": "print(Foo().tabulate(jax.random.PRNGKey(0), x))",
            "answer": "tabulate",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_51"
        },
        {
            "dependency": "flax",
            "version": "==0.5.3",
            "time": "2022-07-25",
            "description": "The code defines two types of parameter traversal objects for kernels and biases, creates separate optimizers for kernels and biases using momentum optimization, creates a multi-optimizer object combining both optimizers, initializes the optimizer for a given model, retrieves hyperparameters from the optimizer, and applies gradient updates with modified hyperparameters for learning rates.",
            "code": "kernels = traverse_util.ModelParamTraversal(lambda path, _: 'kernel' in path)\nbiases = traverse_util.ModelParamTraversal(lambda path, _: 'bias' in path)\nkernel_opt = optim.Momentum(learning_rate=0.01)\nbias_opt = optim.Momentum(learning_rate=0.1)\nopt_def = MultiOptimizer((kernels, kernel_opt), (biases, bias_opt))\noptimizer = opt_def.create(model)\n\nhparams = optimizer.optimizer_def.hyper_params\nnew_optimizer = optimizer.apply_gradient(\n    grads,\n    hyper_params=[\n        hparams[0].replace(learning_rate=0.2),\n        hparams[1].replace(learning_rate=jnp.where(step < 1000, 0., lr)),\n    ])\n",
            "masked_code": "kernels = traverse_util.ModelParamTraversal(lambda path, _: 'kernel' in path)\nbiases = traverse_util.ModelParamTraversal(lambda path, _: 'bias' in path)\nkernel_opt = optim.Momentum(learning_rate=0.01)\nbias_opt = optim.Momentum(learning_rate=0.1)\n<line_mask>\noptimizer = opt_def.create(model)\n\nhparams = optimizer.optimizer_def.hyper_params\nnew_optimizer = optimizer.apply_gradient(\n    grads,\n    hyper_params=[\n        hparams[0].replace(learning_rate=0.2),\n        hparams[1].replace(learning_rate=jnp.where(step < 1000, 0., lr)),\n    ])\n",
            "masked_line": "opt_def = MultiOptimizer((kernels, kernel_opt), (biases, bias_opt))",
            "answer": "MultiOptimizer",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_52"
        },
        {
            "dependency": "flax",
            "version": "==0.6.1",
            "time": "2022-10-03",
            "description": "The code applies a function to each leaf node in the nested dictionary `params` based on whether the leaf node key contains the substring 'x' in its path. The function `f` increments the value by 5 if the key contains 'x' and negates the value otherwise.",
            "code": "import jax.numpy as jnp\nfrom flax import traverse_util\n\nparams = {'a': {'x': 10, 'y': 3}, 'b': {'x': 20}}\nf = lambda path, x: x + 5 if 'x' in path else -x\ntraverse_util.path_aware_map(f, params)\n",
            "masked_code": "import jax.numpy as jnp\nfrom flax import traverse_util\n\nparams = {'a': {'x': 10, 'y': 3}, 'b': {'x': 20}}\nf = lambda path, x: x + 5 if 'x' in path else -x\n<line_mask>\n",
            "masked_line": "traverse_util.path_aware_map(f, params)",
            "answer": "path_aware_map",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_53"
        },
        {
            "dependency": "flax",
            "version": "==0.6.6",
            "time": "2023-02-28",
            "description": "The code initializes a RMSNorm layer using Flax, generates random input data, initializes the layer's variables with another random key, and applies the RMSNorm layer to the input data to obtain the output.",
            "code": "import jax.numpy as jnp\nimport jax\nimport flax.linen as nn\n\nx = jax.random.uniform(jax.random.PRNGKey(0), (2, 3))\nlayer = nn.RMSNorm()\nvariables = layer.init(jax.random.PRNGKey(1), x)\ny = layer.apply(variables, x)",
            "masked_code": "import jax.numpy as jnp\nimport jax\nimport flax.linen as nn\n\nx = jax.random.uniform(jax.random.PRNGKey(0), (2, 3))\n<line_mask>\nvariables = layer.init(jax.random.PRNGKey(1), x)\ny = layer.apply(variables, x)",
            "masked_line": "layer = nn.RMSNorm()",
            "answer": "RMSNorm",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_54"
        },
        {
            "dependency": "flax",
            "version": "==0.7.4",
            "time": "2023-09-13",
            "description": "The code modifies a dictionary object and a training state object by setting specific values at specified paths within the objects. The modified dictionary object is checked against an expected value.",
            "code": "from flax.cursor import cursor\nfrom flax.training import train_state\nimport optax\n\ndict_obj = {'a': 1, 'b': (2, 3), 'c': [4, 5]}\nmodified_dict_obj = cursor(dict_obj)['b'][0].set(10)\nassert modified_dict_obj == {'a': 1, 'b': (10, 3), 'c': [4, 5]}\n\nstate = train_state.TrainState.create(\n    apply_fn=lambda x: x,\n    params=dict_obj,\n    tx=optax.adam(1e-3),\n)\nmodified_state = cursor(state).params['b'][1].set(10)\nassert modified_state.params == {'a': 1, 'b': (2, 10), 'c': [4, 5]}",
            "masked_code": "from flax.cursor import cursor\nfrom flax.training import train_state\nimport optax\n\ndict_obj = {'a': 1, 'b': (2, 3), 'c': [4, 5]}\n<line_mask>\nassert modified_dict_obj == {'a': 1, 'b': (10, 3), 'c': [4, 5]}\n\nstate = train_state.TrainState.create(\n    apply_fn=lambda x: x,\n    params=dict_obj,\n    tx=optax.adam(1e-3),\n)\nmodified_state = cursor(state).params['b'][1].set(10)\nassert modified_state.params == {'a': 1, 'b': (2, 10), 'c': [4, 5]}",
            "masked_line": "modified_dict_obj = cursor(dict_obj)['b'][0].set(10)",
            "answer": "set",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_55"
        },
        {
            "dependency": "flax",
            "version": "==0.8.0",
            "time": "2024-01-23",
            "description": "This code defines two functions. The first function `learn_scale` takes in a scope, two input variables x and y, and returns the product of a parameter `p`, x, and y. The second function `f` takes in a scope, x, and y, and computes the value of `learn_scale` and its gradients with respect to x and y.",
            "code": "def learn_scale(scope, x, y):\n    p = scope.param('scale', nn.initializers.zeros_init(), ())\n    return p * x * y\n\ndef f(scope, x, y):\n    z, x_grad, y_grad = lift.value_and_grad(learn_scale, scope, x, y)\n    return z, x_grad, y_grad\n",
            "masked_code": "def learn_scale(scope, x, y):\n    p = scope.param('scale', nn.initializers.zeros_init(), ())\n    return p * x * y\n\ndef f(scope, x, y):\n    <line_mask>\n    return z, x_grad, y_grad\n",
            "masked_line": "z, x_grad, y_grad = lift.value_and_grad(learn_scale, scope, x, y)",
            "answer": "value_and_grad",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_56"
        },
        {
            "dependency": "flax",
            "version": "==0.8.0",
            "time": "2024-01-23",
            "description": "This code defines a function that learns the scale of the input and returns the scaled product of the input variables x and y. It also includes a function that computes the value and gradients of the scaled product function with respect to x and y.",
            "code": "def learn_scale(scope, x, y):\n    p = scope.param('scale', nn.initializers.zeros_init(), ())\n    return p * x * y\ndef f(scope, x, y):\n    z, x_grad, y_grad = lift.value_and_grad(learn_scale, scope, x, y)\n    return z, x_grad, y_grad\n",
            "masked_code": "def learn_scale(scope, x, y):\n    p = scope.param('scale', nn.initializers.zeros_init(), ())\n    return p * x * y\ndef f(scope, x, y):\n    <line_mask>\n    return z, x_grad, y_grad\n",
            "masked_line": "z, x_grad, y_grad = lift.value_and_grad(learn_scale, scope, x, y)",
            "answer": "value_and_grad",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_57"
        },
        {
            "dependency": "flax",
            "version": "==0.8.0",
            "time": "2024-01-23",
            "description": "The `Foo` class defines a function that calculates the gradient of the product of `x` and `y` with respect to `x` and `y`, using the `LearnScale` class as the model.",
            "code": "class LearnScale(nn.Module):\n    @nn.compact\n    def __call__(self, x, y):\n      p = self.param('scale', nn.initializers.zeros_init(), ())\n      return p * x * y\n\nclass Foo(nn.Module):\n    @nn.compact\n    def __call__(self, x, y):\n      x_grad, y_grad = nn.grad(\n          lambda mdl, x, y: mdl(x, y), LearnScale(), x, y)\n      return x_grad, y_grad\n",
            "masked_code": "class LearnScale(nn.Module):\n    @nn.compact\n    def __call__(self, x, y):\n      p = self.param('scale', nn.initializers.zeros_init(), ())\n      return p * x * y\n\nclass Foo(nn.Module):\n    @nn.compact\n    def __call__(self, x, y):\n      <line_mask>\n          lambda mdl, x, y: mdl(x, y), LearnScale(), x, y)\n      return x_grad, y_grad\n",
            "masked_line": "x_grad, y_grad = nn.grad(",
            "answer": "grad",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_58"
        },
        {
            "dependency": "flax",
            "version": "==0.8.1",
            "time": "2024-02-07",
            "description": "This code defines a neural network module called Foo, which consists of two dense layers. It creates an instance of Foo, generates random module paths using JAX, and then prints a dictionary showing the module paths and their corresponding types.",
            "code": "class Foo(nn.Module):\n  @nn.compact\n  def __call__(self, x):\n    h = nn.Dense(4)(x)\n    return nn.Dense(2)(h)\n\n\nx = jnp.ones((16, 9))\nmodules = Foo().module_paths(jax.random.key(0), x)\nprint({\n    p: type(m).__name__ for p, m in modules.items()\n})\n",
            "masked_code": "class Foo(nn.Module):\n  @nn.compact\n  def __call__(self, x):\n    h = nn.Dense(4)(x)\n    return nn.Dense(2)(h)\n\n\nx = jnp.ones((16, 9))\n<line_mask>\nprint({\n    p: type(m).__name__ for p, m in modules.items()\n})\n",
            "masked_line": "modules = Foo().module_paths(jax.random.key(0), x)",
            "answer": "module_paths",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_59"
        },
        {
            "dependency": "gym",
            "version": "==0.12.6",
            "time": "2019-06-21",
            "description": "This code generates random samples from a Box space with values between 0 and 1 of shape (3,) and stores them in the 'items' list. Then, it concatenates these samples into a 2D numpy array 'out'.",
            "code": "from gym.spaces import Box\nimport numpy as np\n\nspace = Box(low=0, high=1, shape=(3,), dtype=np.float32)\nout = np.zeros((2, 3), dtype=np.float32)\nitems = [space.sample() for _ in range(2)]\nconcatenate(items, out, space)\n",
            "masked_code": "from gym.spaces import Box\nimport numpy as np\n\nspace = Box(low=0, high=1, shape=(3,), dtype=np.float32)\nout = np.zeros((2, 3), dtype=np.float32)\nitems = [space.sample() for _ in range(2)]\n<line_mask>\n",
            "masked_line": "concatenate(items, out, space)",
            "answer": "concatenate",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_60"
        },
        {
            "dependency": "gym",
            "version": "==0.15.0",
            "time": "2019-08-23",
            "description": "The code initializes a CartPole-v1 environment and applies a reward transformation function to scale the rewards by a factor of 0.01. It then resets the environment, takes a random action, and retrieves the modified reward value, which is then returned as 0.01.",
            "code": "import gym\nenv = gym.make('CartPole-v1')\nenv = TransformReward(env, lambda r: 0.01*r)\nenv.reset()\nobservation, reward, done, info = env.step(env.action_space.sample())\nreward\n0.01",
            "masked_code": "import gym\nenv = gym.make('CartPole-v1')\n<line_mask>\nenv.reset()\nobservation, reward, done, info = env.step(env.action_space.sample())\nreward\n0.01",
            "masked_line": "env = TransformReward(env, lambda r: 0.01*r)",
            "answer": "TransformReward",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_61"
        },
        {
            "dependency": "gym",
            "version": "==0.15.4",
            "time": "2019-11-08",
            "description": "The code creates a gym environment for the CartPole-v1 game, transforms observations by adding random noise, and resets the environment to start a new episode.",
            "code": "import gym\nenv = gym.make('CartPole-v1')\nenv = TransformObservation(env, lambda obs: obs + 0.1*np.random.randn(*obs.shape))\nenv.reset()\narray([-0.08319338,  0.04635121, -0.07394746,  0.20877492])",
            "masked_code": "import gym\nenv = gym.make('CartPole-v1')\n<line_mask>\nenv.reset()\narray([-0.08319338,  0.04635121, -0.07394746,  0.20877492])",
            "masked_line": "env = TransformObservation(env, lambda obs: obs + 0.1*np.random.randn(*obs.shape))",
            "answer": "TransformObservation",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_62"
        },
        {
            "dependency": "gym",
            "version": "==0.17.2",
            "time": "2020-05-08",
            "description": "This function flattens a given gym space into a Box space, which is a high-dimensional space with shape information.",
            "code": "def flatten_space(space):\n    if isinstance(space, Box):\n        return Box(np.prod(space.shape),)\n    elif isinstance(space, Discrete):\n        return Box(space.n,)\n    elif isinstance(space, Dict):\n        return Box(sum([flatten_space(subspace).shape[0] for subspace in space.spaces]),)\n    else:\n        raise NotImplementedError\n",
            "masked_code": "<line_mask>\n    if isinstance(space, Box):\n        return Box(np.prod(space.shape),)\n    elif isinstance(space, Discrete):\n        return Box(space.n,)\n    elif isinstance(space, Dict):\n        return Box(sum([flatten_space(subspace).shape[0] for subspace in space.spaces]),)\n    else:\n        raise NotImplementedError\n",
            "masked_line": "def flatten_space(space):",
            "answer": "flatten_space",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_63"
        },
        {
            "dependency": "gym",
            "version": "==0.22.0",
            "time": "2022-02-17",
            "description": "The code creates a class called Example which registers an instance of itself with an object called closer when initialized, and unregisters itself from closer when closed or when the object is deleted.",
            "code": "closer = Closer()\nclass Example(object):\n    def __init__(self):\n        self._id = closer.register(self)\n\n    def close(self):\n        # Probably worth making idempotent too!\n        ...\n        closer.unregister(self._id)\n\n    def __del__(self):\n        self.close()\n",
            "masked_code": "<line_mask>\nclass Example(object):\n    def __init__(self):\n        self._id = closer.register(self)\n\n    def close(self):\n        # Probably worth making idempotent too!\n        ...\n        closer.unregister(self._id)\n\n    def __del__(self):\n        self.close()\n",
            "masked_line": "closer = Closer()",
            "answer": "Closer",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_64"
        },
        {
            "dependency": "gym",
            "version": "==0.24.0",
            "time": "2022-05-25",
            "description": "This code defines a custom observation wrapper class that calculates the relative position between the \"target\" and \"agent\" in the observation data.",
            "code": "class RelativePosition(gym.ObservationWrapper):\n    def __init__(self, env):\n        super().__init__(env)\n        self.observation_space = Box(shape=(2,), low=-np.inf, high=np.inf)\n\n    def observation(self, obs):\n        return obs[\"target\"] - obs[\"agent\"]\n",
            "masked_code": "<line_mask>\n    def __init__(self, env):\n        super().__init__(env)\n        self.observation_space = Box(shape=(2,), low=-np.inf, high=np.inf)\n\n    def observation(self, obs):\n        return obs[\"target\"] - obs[\"agent\"]\n",
            "masked_line": "class RelativePosition(gym.ObservationWrapper):",
            "answer": "ObservationWrapper",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_65"
        },
        {
            "dependency": "gym",
            "version": "==0.24.0",
            "time": "2022-05-25",
            "description": "The code creates a CartPole environment and initializes it with a function called OrderEnforcing. It then resets the environment, renders it, and takes a step with an action index of 0.",
            "code": "from gym.envs.classic_control import CartPoleEnv\nenv = CartPoleEnv()\nenv = OrderEnforcing(env)\nenv.reset()\nenv.render()\nenv.step(0)\n",
            "masked_code": "from gym.envs.classic_control import CartPoleEnv\nenv = CartPoleEnv()\n<line_mask>\nenv.reset()\nenv.render()\nenv.step(0)\n",
            "masked_line": "env = OrderEnforcing(env)",
            "answer": "OrderEnforcing",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_66"
        },
        {
            "dependency": "gym",
            "version": "==0.7.4",
            "time": "2017-03-05",
            "description": "The code defines a callback function that takes in an observation, the next observation, reward, done flag, and additional info. It then creates an environment plotter object with the callback function, a time step of 30*5, and a list of plotted data (in this case, just \"reward\"). Finally, it creates a gym environment for playing the game \"Pong-v3\" and uses the callback function from the environment plotter during gameplay.",
            "code": "def callback(obs_t, obs_tp1, rew, done, info):\n    return [rew,]\n\nenv_plotter = EnvPlotter(callback, 30 * 5, [\"reward\"])\n\nenv = gym.make(\"Pong-v3\")\nplay(env, callback=env_plotter.callback)",
            "masked_code": "def callback(obs_t, obs_tp1, rew, done, info):\n    return [rew,]\n\nenv_plotter = EnvPlotter(callback, 30 * 5, [\"reward\"])\n\nenv = gym.make(\"Pong-v3\")\n<line_mask>",
            "masked_line": "play(env, callback=env_plotter.callback)",
            "answer": "play",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_67"
        },
        {
            "dependency": "huggingface-hub",
            "version": "==0.0.13",
            "time": "2021-06-28",
            "description": "The code creates and commits a file named \"file.txt\" containing a JSON object {\"hey\": 8} to a repository named \"text-files\" cloned from <user>/text-files using an authentication token. It also creates a new PyTorch Transformer model, saves the model's state dictionary to a file named \"model.pt\", and commits it to a repository named \"torch-model\" cloned from <user>/torch-model using an authentication token.",
            "code": "with Repository(\"text-files\", clone_from=\"<user>/text-files\", use_auth_token=True).commit(\"My first file :)\"):\n    with open(\"file.txt\", \"w+\") as f:\n        f.write(json.dumps({\"hey\": 8}))\nimport torch\nmodel = torch.nn.Transformer()\nwith Repository(\"torch-model\", clone_from=\"<user>/torch-model\", use_auth_token=True).commit(\"My cool model :)\"):\n    torch.save(model.state_dict(), \"model.pt\")",
            "masked_code": "<line_mask>\n    with open(\"file.txt\", \"w+\") as f:\n        f.write(json.dumps({\"hey\": 8}))\nimport torch\nmodel = torch.nn.Transformer()\nwith Repository(\"torch-model\", clone_from=\"<user>/torch-model\", use_auth_token=True).commit(\"My cool model :)\"):\n    torch.save(model.state_dict(), \"model.pt\")",
            "masked_line": "with Repository(\"text-files\", clone_from=\"<user>/text-files\", use_auth_token=True).commit(\"My first file :)\"):",
            "answer": "commit",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_68"
        },
        {
            "dependency": "huggingface-hub",
            "version": "==0.10.0",
            "time": "2022-09-28",
            "description": "The code generates DatasetCard objects for datasets with specified metadata such as language, license, annotations creators, task categories, task ids, multilinguality, and pretty name. It can use both default and custom templates to create DatasetCard objects.",
            "code": "from huggingface_hub import DatasetCard, DatasetCardData\n\n# Using the Default Template\ncard_data = DatasetCardData(\n    language='en',\n    license='mit',\n    annotations_creators='crowdsourced',\n    task_categories=['text-classification'],\n    task_ids=['sentiment-classification', 'text-scoring'],\n    multilinguality='monolingual',\n    pretty_name='My Text Classification Dataset',\n)\ncard = DatasetCard.from_template(\n    card_data,\n    pretty_name=card_data.pretty_name,\n)\n\n# Using a Custom Template\ncard_data = DatasetCardData(\n    language='en',\n    license='mit',\n)\ncard = DatasetCard.from_template(\n    card_data=card_data,\n    template_path='./src/huggingface_hub/templates/datasetcard_template.md',\n    custom_template_var='custom value',  # will be replaced in template if it exists\n)\n",
            "masked_code": "from huggingface_hub import DatasetCard, DatasetCardData\n\n# Using the Default Template\ncard_data = DatasetCardData(\n    language='en',\n    license='mit',\n    annotations_creators='crowdsourced',\n    task_categories=['text-classification'],\n    task_ids=['sentiment-classification', 'text-scoring'],\n    multilinguality='monolingual',\n    pretty_name='My Text Classification Dataset',\n)\ncard = DatasetCard.from_template(\n    card_data,\n    pretty_name=card_data.pretty_name,\n)\n\n# Using a Custom Template\ncard_data = DatasetCardData(\n    language='en',\n    license='mit',\n)\n<line_mask>\n    card_data=card_data,\n    template_path='./src/huggingface_hub/templates/datasetcard_template.md',\n    custom_template_var='custom value',  # will be replaced in template if it exists\n)\n",
            "masked_line": "card = DatasetCard.from_template(",
            "answer": "from_template",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_69"
        },
        {
            "dependency": "huggingface-hub",
            "version": "==0.10.0",
            "time": "2022-09-28",
            "description": "The code is used to scan and delete specific cache revisions in the cache directory. It calculates the expected freed size before executing the deletion of the specified cache revisions.",
            "code": "from huggingface_hub import scan_cache_dir\ncache_info = scan_cache_dir()\ndelete_strategy = cache_info.delete_revisions(\n    \"81fd1d6e7847c99f5862c9fb81387956d99ec7aa\"\n)\nprint(f\"Will free {delete_strategy.expected_freed_size_str}.\")\ndelete_strategy.execute()\n\n\nfrom huggingface_hub import scan_cache_dir\nscan_cache_dir().delete_revisions(\n    \"81fd1d6e7847c99f5862c9fb81387956d99ec7aa\",\n    \"e2983b237dccf3ab4937c97fa717319a9ca1a96d\",\n    \"6c0e6080953db56375760c0471a8c5f2929baf11\",\n).execute()\n",
            "masked_code": "from huggingface_hub import scan_cache_dir\ncache_info = scan_cache_dir()\ndelete_strategy = cache_info.delete_revisions(\n    \"81fd1d6e7847c99f5862c9fb81387956d99ec7aa\"\n)\nprint(f\"Will free {delete_strategy.expected_freed_size_str}.\")\ndelete_strategy.execute()\n\n\nfrom huggingface_hub import scan_cache_dir\n<line_mask>\n    \"81fd1d6e7847c99f5862c9fb81387956d99ec7aa\",\n    \"e2983b237dccf3ab4937c97fa717319a9ca1a96d\",\n    \"6c0e6080953db56375760c0471a8c5f2929baf11\",\n).execute()\n",
            "masked_line": "scan_cache_dir().delete_revisions(",
            "answer": "delete_revisions",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_70"
        },
        {
            "dependency": "huggingface-hub",
            "version": "==0.11.0",
            "time": "2022-11-16",
            "description": "The code generates cached paths for different assets related to specified libraries, namespaces, and subfolders.",
            "code": "from huggingface_hub import cached_assets_path\n\ncached_assets_path(library_name=\"datasets\", namespace=\"SQuAD\", subfolder=\"download\")\nPosixPath('/home/wauplin/.cache/huggingface/extra/datasets/SQuAD/download')\n\ncached_assets_path(library_name=\"datasets\", namespace=\"SQuAD\", subfolder=\"extracted\")\nPosixPath('/home/wauplin/.cache/huggingface/extra/datasets/SQuAD/extracted')\n\ncached_assets_path(library_name=\"datasets\", namespace=\"Helsinki-NLP/tatoeba_mt\")\nPosixPath('/home/wauplin/.cache/huggingface/extra/datasets/Helsinki-NLP--tatoeba_mt/default')\n\ncached_assets_path(library_name=\"datasets\", assets_dir=\"/tmp/tmp123456\")\nPosixPath('/tmp/tmp123456/datasets/default/default')\n",
            "masked_code": "from huggingface_hub import cached_assets_path\n\ncached_assets_path(library_name=\"datasets\", namespace=\"SQuAD\", subfolder=\"download\")\nPosixPath('/home/wauplin/.cache/huggingface/extra/datasets/SQuAD/download')\n\ncached_assets_path(library_name=\"datasets\", namespace=\"SQuAD\", subfolder=\"extracted\")\nPosixPath('/home/wauplin/.cache/huggingface/extra/datasets/SQuAD/extracted')\n\ncached_assets_path(library_name=\"datasets\", namespace=\"Helsinki-NLP/tatoeba_mt\")\nPosixPath('/home/wauplin/.cache/huggingface/extra/datasets/Helsinki-NLP--tatoeba_mt/default')\n\n<line_mask>\nPosixPath('/tmp/tmp123456/datasets/default/default')\n",
            "masked_line": "cached_assets_path(library_name=\"datasets\", assets_dir=\"/tmp/tmp123456\")",
            "answer": "cached_assets_path",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_71"
        },
        {
            "dependency": "huggingface-hub",
            "version": "==0.12.0",
            "time": "2023-01-25",
            "description": "This code defines a test class for testing Space API, specifically testing the functionality of retrieving repository information in a space.",
            "code": "@pytest.mark.usefixtures(\"fx_production_space\")\nclass TestSpaceAPI(unittest.TestCase):\n    repo_id: str\n    api: HfApi\n\n    def test_space(self) -> None:\n        api.repo_info(repo_id, repo_type=\"space\")",
            "masked_code": "<line_mask>\nclass TestSpaceAPI(unittest.TestCase):\n    repo_id: str\n    api: HfApi\n\n    def test_space(self) -> None:\n        api.repo_info(repo_id, repo_type=\"space\")",
            "masked_line": "@pytest.mark.usefixtures(\"fx_production_space\")",
            "answer": "fx_production_space",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_72"
        },
        {
            "dependency": "huggingface-hub",
            "version": "==0.12.0",
            "time": "2023-01-25",
            "description": "The code allows the user to like and unlike a model on the Hugging Face model hub, and check if the model is listed as liked.",
            "code": "from huggingface_hub import like, list_liked_repos, unlike\nlike(\"gpt2\")\n\"gpt2\" in list_liked_repos().models\nTrue\nunlike(\"gpt2\")\n\"gpt2\" in list_liked_repos().models\nFalse\n",
            "masked_code": "<line_mask>\nlike(\"gpt2\")\n\"gpt2\" in list_liked_repos().models\nTrue\nunlike(\"gpt2\")\n\"gpt2\" in list_liked_repos().models\nFalse\n",
            "masked_line": "from huggingface_hub import like, list_liked_repos, unlike",
            "answer": "like",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_73"
        },
        {
            "dependency": "huggingface-hub",
            "version": "==0.12.0",
            "time": "2023-01-25",
            "description": "The code allows for liking and unliking repositories on the Huggingface Hub.",
            "code": "from huggingface_hub import like, list_liked_repos, unlike\nlike(\"gpt2\")\n\"gpt2\" in list_liked_repos().models\nTrue\nunlike(\"gpt2\")\n\"gpt2\" in list_liked_repos().models\nFalse\n",
            "masked_code": "<line_mask>\nlike(\"gpt2\")\n\"gpt2\" in list_liked_repos().models\nTrue\nunlike(\"gpt2\")\n\"gpt2\" in list_liked_repos().models\nFalse\n",
            "masked_line": "from huggingface_hub import like, list_liked_repos, unlike",
            "answer": "unlike",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_74"
        },
        {
            "dependency": "huggingface-hub",
            "version": "==0.12.0",
            "time": "2023-01-25",
            "description": "This code retrieves a list of repositories liked by the user \"julien-c\" from the Hugging Face model hub. It then allows access to the username (user) and a list of liked model repositories (models).",
            "code": "from huggingface_hub import list_liked_repos\n\nlikes = list_liked_repos(\"julien-c\")\n\nlikes.user\n\"julien-c\"\n\nlikes.models\n[\"osanseviero/streamlit_1.15\", \"Xhaheen/ChatGPT_HF\", ...]\n",
            "masked_code": "<line_mask>\n\nlikes = list_liked_repos(\"julien-c\")\n\nlikes.user\n\"julien-c\"\n\nlikes.models\n[\"osanseviero/streamlit_1.15\", \"Xhaheen/ChatGPT_HF\", ...]\n",
            "masked_line": "from huggingface_hub import list_liked_repos",
            "answer": "list_liked_repos",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_75"
        },
        {
            "dependency": "huggingface-hub",
            "version": "==0.12.0",
            "time": "2023-01-25",
            "description": "The code retrieves information about the branches, tags, and commits in the specified repositories on the Hugging Face Model Hub using the Hugging Face API.",
            "code": "from huggingface_hub import HfApi\napi = HfApi()\napi.list_repo_refs(\"gpt2\")\nGitRefs(branches=[GitRefInfo(name='main', ref='refs/heads/main', target_commit='e7da7f221d5bf496a48136c0cd264e630fe9fcc8')], converts=[], tags=[])\n\napi.list_repo_refs(\"bigcode/the-stack\", repo_type='dataset')\nGitRefs(\n    branches=[\n        GitRefInfo(name='main', ref='refs/heads/main', target_commit='18edc1591d9ce72aa82f56c4431b3c969b210ae3'),\n        GitRefInfo(name='v1.1.a1', ref='refs/heads/v1.1.a1', target_commit='f9826b862d1567f3822d3d25649b0d6d22ace714')\n    ],\n    converts=[],\n    tags=[\n        GitRefInfo(name='v1.0', ref='refs/tags/v1.0', target_commit='c37a8cd1e382064d8aced5e05543c5f7753834da')\n    ]\n)\n",
            "masked_code": "from huggingface_hub import HfApi\napi = HfApi()\n<line_mask>\nGitRefs(branches=[GitRefInfo(name='main', ref='refs/heads/main', target_commit='e7da7f221d5bf496a48136c0cd264e630fe9fcc8')], converts=[], tags=[])\n\napi.list_repo_refs(\"bigcode/the-stack\", repo_type='dataset')\nGitRefs(\n    branches=[\n        GitRefInfo(name='main', ref='refs/heads/main', target_commit='18edc1591d9ce72aa82f56c4431b3c969b210ae3'),\n        GitRefInfo(name='v1.1.a1', ref='refs/heads/v1.1.a1', target_commit='f9826b862d1567f3822d3d25649b0d6d22ace714')\n    ],\n    converts=[],\n    tags=[\n        GitRefInfo(name='v1.0', ref='refs/tags/v1.0', target_commit='c37a8cd1e382064d8aced5e05543c5f7753834da')\n    ]\n)\n",
            "masked_line": "api.list_repo_refs(\"gpt2\")",
            "answer": "list_repo_refs",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_76"
        },
        {
            "dependency": "huggingface-hub",
            "version": "==0.13.0",
            "time": "2023-03-08",
            "description": "The code retrieves the information about the initial commit of the \"gpt2\" repository from the Hugging Face model hub, which is a system commit containing the `.gitattributes` file. It then creates a new empty branch named \"new_empty_branch\" based on the initial commit.",
            "code": "from huggingface_hub import HfApi\napi = HfApi()\n\n# Commits are sorted by date (last commit first)\ninitial_commit = api.list_repo_commits(\"gpt2\")[-1]\n\n# Initial commit is always a system commit containing the `.gitattributes` file.\ninitial_commit\nGitCommitInfo(\n    commit_id='9b865efde13a30c13e0a33e536cf3e4a5a9d71d8',\n    authors=['system'],\n    created_at=datetime.datetime(2019, 2, 18, 10, 36, 15, tzinfo=datetime.timezone.utc),\n    title='initial commit',\n    message='',\n    formatted_title=None,\n    formatted_message=None\n)\n\n# Create an empty branch by deriving from initial commit\napi.create_branch(\"gpt2\", \"new_empty_branch\", revision=initial_commit.commit_id)\n",
            "masked_code": "from huggingface_hub import HfApi\napi = HfApi()\n\n# Commits are sorted by date (last commit first)\n<line_mask>\n\n# Initial commit is always a system commit containing the `.gitattributes` file.\ninitial_commit\nGitCommitInfo(\n    commit_id='9b865efde13a30c13e0a33e536cf3e4a5a9d71d8',\n    authors=['system'],\n    created_at=datetime.datetime(2019, 2, 18, 10, 36, 15, tzinfo=datetime.timezone.utc),\n    title='initial commit',\n    message='',\n    formatted_title=None,\n    formatted_message=None\n)\n\n# Create an empty branch by deriving from initial commit\napi.create_branch(\"gpt2\", \"new_empty_branch\", revision=initial_commit.commit_id)\n",
            "masked_line": "initial_commit = api.list_repo_commits(\"gpt2\")[-1]",
            "answer": "list_repo_commits",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_77"
        },
        {
            "dependency": "huggingface-hub",
            "version": "==0.13.0",
            "time": "2023-03-08",
            "description": "The code duplicates a Space from one account to another account on the Hugging Face Hub platform. It allows the user to specify a custom destination id and set the visibility flag to private if needed.",
            "code": "from huggingface_hub import duplicate_space\n\n# Duplicate a Space to your account\nduplicate_space(\"multimodalart/dreambooth-training\")\nRepoUrl('https://huggingface.co/spaces/nateraw/dreambooth-training',...)\n\n# Can set custom destination id and visibility flag.\nduplicate_space(\"multimodalart/dreambooth-training\", to_id=\"my-dreambooth\", private=True)\nRepoUrl('https://huggingface.co/spaces/nateraw/my-dreambooth',...)\n",
            "masked_code": "from huggingface_hub import duplicate_space\n\n# Duplicate a Space to your account\nduplicate_space(\"multimodalart/dreambooth-training\")\nRepoUrl('https://huggingface.co/spaces/nateraw/dreambooth-training',...)\n\n# Can set custom destination id and visibility flag.\n<line_mask>\nRepoUrl('https://huggingface.co/spaces/nateraw/my-dreambooth',...)\n",
            "masked_line": "duplicate_space(\"multimodalart/dreambooth-training\", to_id=\"my-dreambooth\", private=True)",
            "answer": "duplicate_space",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_78"
        },
        {
            "dependency": "huggingface-hub",
            "version": "==0.14.0",
            "time": "2023-04-24",
            "description": "The code performs file system operations such as listing files, reading/writing files using a custom file system module called HfFileSystem.",
            "code": "import hffs\n\nfs = hffs.HfFileSystem()\n\n# List files\nfs.glob(\"my-username/my-model/*.bin\")\nfs.ls(\"datasets/my-username/my-dataset\", detail=False)\n\n# Read/write files\nwith fs.open(\"my-username/my-model/pytorch_model.bin\") as f:\n    data = f.read()\nwith fs.open(\"my-username/my-model/pytorch_model.bin\", \"wb\") as f:\n    f.write(data)\n",
            "masked_code": "import hffs\n\n<line_mask>\n\n# List files\nfs.glob(\"my-username/my-model/*.bin\")\nfs.ls(\"datasets/my-username/my-dataset\", detail=False)\n\n# Read/write files\nwith fs.open(\"my-username/my-model/pytorch_model.bin\") as f:\n    data = f.read()\nwith fs.open(\"my-username/my-model/pytorch_model.bin\", \"wb\") as f:\n    f.write(data)\n",
            "masked_line": "fs = hffs.HfFileSystem()",
            "answer": "HfFileSystem",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_79"
        },
        {
            "dependency": "huggingface-hub",
            "version": "==0.14.0",
            "time": "2023-04-24",
            "description": "The code creates a web server using Gradio and Hugging Face Hub that responds with a \"hello\" message when accessed via the \"/say_hello\" endpoint.",
            "code": "import gradio as gr\nfrom huggingface_hub import WebhooksServer, WebhookPayload\n\nwith gr.Blocks() as ui:\n    ...\n\napp = WebhooksServer(ui=ui, webhook_secret=\"my_secret_key\")\n\n@app.add_webhook(\"/say_hello\")\nasync def hello(payload: WebhookPayload):\n    return {\"message\": \"hello\"}\n\napp.run()\n",
            "masked_code": "import gradio as gr\nfrom huggingface_hub import WebhooksServer, WebhookPayload\n\nwith gr.Blocks() as ui:\n    ...\n\n<line_mask>\n\n@app.add_webhook(\"/say_hello\")\nasync def hello(payload: WebhookPayload):\n    return {\"message\": \"hello\"}\n\napp.run()\n",
            "masked_line": "app = WebhooksServer(ui=ui, webhook_secret=\"my_secret_key\")",
            "answer": "WebhooksServer",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_80"
        },
        {
            "dependency": "huggingface-hub",
            "version": "==0.14.0",
            "time": "2023-04-24",
            "description": "This code sets up a web server that listens for webhook events. When a dataset is updated, it triggers a training job.",
            "code": "from huggingface_hub import WebhooksServer, WebhookPayload\n\napp = WebhooksServer()\n\n@app.add_webhook\nasync def trigger_training(payload: WebhookPayload):\n    if payload.repo.type == \"dataset\" and payload.event.action == \"update\":\n        # Trigger a training job if a dataset is updated\n        ...\n\napp.run()\n",
            "masked_code": "from huggingface_hub import WebhooksServer, WebhookPayload\n\napp = WebhooksServer()\n\n<line_mask>\nasync def trigger_training(payload: WebhookPayload):\n    if payload.repo.type == \"dataset\" and payload.event.action == \"update\":\n        # Trigger a training job if a dataset is updated\n        ...\n\napp.run()\n",
            "masked_line": "@app.add_webhook",
            "answer": "add_webhook",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_81"
        },
        {
            "dependency": "huggingface-hub",
            "version": "==0.14.0",
            "time": "2023-04-24",
            "description": "The code defines a webhook endpoint 'trigger_training' which is used to trigger a training job if a dataset is updated. The function 'trigger_training' takes a WebhookPayload object as input, checks if the payload corresponds to an update action on a dataset in a repository, and then triggers a training job. The server is automatically started at the end of the first script, while the second script manually starts the server by calling the 'run' method on the 'trigger_training' function.",
            "code": "from huggingface_hub import webhook_endpoint, WebhookPayload\n\n@webhook_endpoint\nasync def trigger_training(payload: WebhookPayload):\n    if payload.repo.type == \"dataset\" and payload.event.action == \"update\":\n        # Trigger a training job if a dataset is updated\n        ...\n\n# Server is automatically started at the end of the script.\n\n\nfrom huggingface_hub import webhook_endpoint, WebhookPayload\n\n@webhook_endpoint\nasync def trigger_training(payload: WebhookPayload):\n    if payload.repo.type == \"dataset\" and payload.event.action == \"update\":\n        # Trigger a training job if a dataset is updated\n        ...\n\n# Start the server manually\ntrigger_training.run()\n",
            "masked_code": "<line_mask>\n\n@webhook_endpoint\nasync def trigger_training(payload: WebhookPayload):\n    if payload.repo.type == \"dataset\" and payload.event.action == \"update\":\n        # Trigger a training job if a dataset is updated\n        ...\n\n# Server is automatically started at the end of the script.\n\n\nfrom huggingface_hub import webhook_endpoint, WebhookPayload\n\n@webhook_endpoint\nasync def trigger_training(payload: WebhookPayload):\n    if payload.repo.type == \"dataset\" and payload.event.action == \"update\":\n        # Trigger a training job if a dataset is updated\n        ...\n\n# Start the server manually\ntrigger_training.run()\n",
            "masked_line": "from huggingface_hub import webhook_endpoint, WebhookPayload",
            "answer": "webhook_endpoint",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_82"
        },
        {
            "dependency": "huggingface-hub",
            "version": "==0.14.0",
            "time": "2023-04-24",
            "description": "The code defines a function `backend_factory` that creates a requests session with specified proxy settings for both HTTP and HTTPS connections. This function is then used to configure an HTTP backend with the provided proxy settings. Finally, the function `get_session()` is called to get the configured session.",
            "code": "def backend_factory() -> requests.Session:\n    session = requests.Session()\n    session.proxies = {\"http\": \"http://10.10.1.10:3128\", \"https\": \"https://10.10.1.11:1080\"}\n    return session\n\nconfigure_http_backend(backend_factory=backend_factory)\n\nsession = get_session()\n",
            "masked_code": "def backend_factory() -> requests.Session:\n    session = requests.Session()\n    session.proxies = {\"http\": \"http://10.10.1.10:3128\", \"https\": \"https://10.10.1.11:1080\"}\n    return session\n\n<line_mask>\n\nsession = get_session()\n",
            "masked_line": "configure_http_backend(backend_factory=backend_factory)",
            "answer": "configure_http_backend",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_83"
        },
        {
            "dependency": "huggingface-hub",
            "version": "==0.14.0",
            "time": "2023-04-24",
            "description": "The code sets up a factory function that creates a Requests Session with configured proxies for HTTP and HTTPS connections. It then sets this factory function as the default session factory using the huggingface_hub library. Finally, it obtains a session object using the configured factory function.",
            "code": "import requests\nfrom huggingface_hub import configure_http_backend, get_session\n\n# Create a factory function that returns a Session with configured proxies\ndef backend_factory() -> requests.Session:\n    session = requests.Session()\n    session.proxies = {\"http\": \"http://10.10.1.10:3128\", \"https\": \"https://10.10.1.11:1080\"}\n    return session\n\n# Set it as the default session factory\nconfigure_http_backend(backend_factory=backend_factory)\n\n# In practice, this is mostly done internally in `huggingface_hub`\nsession = get_session()\n",
            "masked_code": "import requests\n<line_mask>\n\n# Create a factory function that returns a Session with configured proxies\ndef backend_factory() -> requests.Session:\n    session = requests.Session()\n    session.proxies = {\"http\": \"http://10.10.1.10:3128\", \"https\": \"https://10.10.1.11:1080\"}\n    return session\n\n# Set it as the default session factory\nconfigure_http_backend(backend_factory=backend_factory)\n\n# In practice, this is mostly done internally in `huggingface_hub`\nsession = get_session()\n",
            "masked_line": "from huggingface_hub import configure_http_backend, get_session",
            "answer": "get_session",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_84"
        },
        {
            "dependency": "huggingface-hub",
            "version": "==0.15.0",
            "time": "2023-06-01",
            "description": "The code converts images into text descriptions of the objects in the image.",
            "code": "from huggingface_hub import InferenceClient\nclient = InferenceClient()\nclient.image_to_text(\"cat.jpg\")\n'a cat standing in a grassy field '\nclient.image_to_text(\"https://upload.wikimedia.org/wikipedia/commons/thumb/4/43/Cute_dog.jpg/320px-Cute_dog.jpg\")\n'a dog laying on the grass next to a flower pot '\n",
            "masked_code": "from huggingface_hub import InferenceClient\nclient = InferenceClient()\n<line_mask>\n'a cat standing in a grassy field '\nclient.image_to_text(\"https://upload.wikimedia.org/wikipedia/commons/thumb/4/43/Cute_dog.jpg/320px-Cute_dog.jpg\")\n'a dog laying on the grass next to a flower pot '\n",
            "masked_line": "client.image_to_text(\"cat.jpg\")",
            "answer": "image_to_text",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_85"
        },
        {
            "dependency": "huggingface-hub",
            "version": "==0.15.0",
            "time": "2023-06-01",
            "description": "The code converts the text \"Hello world\" into speech using an InferenceClient from the huggingface_hub library, and then saves the audio as a .wav file named \"hello_world\".",
            "code": "from pathlib import Path\nfrom huggingface_hub import InferenceClient\nclient = InferenceClient()\n\naudio = client.text_to_speech(\"Hello world\")\nPath(\"hello_world.wav\").write_bytes(audio)\n",
            "masked_code": "from pathlib import Path\nfrom huggingface_hub import InferenceClient\nclient = InferenceClient()\n\n<line_mask>\nPath(\"hello_world.wav\").write_bytes(audio)\n",
            "masked_line": "audio = client.text_to_speech(\"Hello world\")",
            "answer": "text_to_speech",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_86"
        },
        {
            "dependency": "huggingface-hub",
            "version": "==0.15.0",
            "time": "2023-06-01",
            "description": "This code instantiates a Hugging Face Hub API object, creates a future object to run the `whoami` method asynchronously, checks if the future task is completed, and retrieves the result of the asynchronous task.",
            "code": "from huggingface_hub import HfApi\napi = HfApi()\nfuture = api.run_as_future(api.whoami) # instant\nfuture.done()\nFalse\nfuture.result() # wait until complete and return result\n(...)\nfuture.done()\nTrue\n",
            "masked_code": "from huggingface_hub import HfApi\napi = HfApi()\n<line_mask>\nfuture.done()\nFalse\nfuture.result() # wait until complete and return result\n(...)\nfuture.done()\nTrue\n",
            "masked_line": "future = api.run_as_future(api.whoami) # instant",
            "answer": "run_as_future",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_87"
        },
        {
            "dependency": "huggingface-hub",
            "version": "==0.17.0",
            "time": "2023-09-11",
            "description": "This code checks if a repository exists on the Hugging Face Hub by calling the `repo_exists` function with the repository name as a parameter. It returns `True` if the repository exists and `False` if it does not.",
            "code": "from huggingface_hub import repo_exists\nrepo_exists(\"huggingface/transformers\")\nTrue\nrepo_exists(\"huggingface/not-a-repo\")\nFalse\n",
            "masked_code": "<line_mask>\nrepo_exists(\"huggingface/transformers\")\nTrue\nrepo_exists(\"huggingface/not-a-repo\")\nFalse\n",
            "masked_line": "from huggingface_hub import repo_exists",
            "answer": "repo_exists",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_88"
        },
        {
            "dependency": "huggingface-hub",
            "version": "==0.17.0",
            "time": "2023-09-11",
            "description": "This code checks if a specific file exists in a repository on the Hugging Face Hub.",
            "code": "from huggingface_hub import file_exists\nfile_exists(\"bigcode/starcoder\", \"config.json\")\nTrue\nfile_exists(\"bigcode/starcoder\", \"not-a-file\")\nFalse\nfile_exists(\"bigcode/not-a-repo\", \"config.json\")\nFalse\n",
            "masked_code": "<line_mask>\nfile_exists(\"bigcode/starcoder\", \"config.json\")\nTrue\nfile_exists(\"bigcode/starcoder\", \"not-a-file\")\nFalse\nfile_exists(\"bigcode/not-a-repo\", \"config.json\")\nFalse\n",
            "masked_line": "from huggingface_hub import file_exists",
            "answer": "file_exists",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_89"
        },
        {
            "dependency": "huggingface-hub",
            "version": "==0.17.0",
            "time": "2023-09-11",
            "description": "The code creates a repository named \"test-squash\" using the Hugging Face Hub API, uploads multiple files to the repository, and then squashes the commit history of the repository.",
            "code": "from huggingface_hub import HfApi\napi = HfApi()\n\n# Create repo\nrepo_id = api.create_repo(\"test-squash\").repo_id\n\n# Make a lot of commits.\napi.upload_file(repo_id=repo_id, path_in_repo=\"file.txt\", path_or_fileobj=b\"content\")\napi.upload_file(repo_id=repo_id, path_in_repo=\"lfs.bin\", path_or_fileobj=b\"content\")\napi.upload_file(repo_id=repo_id, path_in_repo=\"file.txt\", path_or_fileobj=b\"another_content\")\n\n# Squash history\napi.super_squash_history(repo_id=repo_id)\n",
            "masked_code": "from huggingface_hub import HfApi\napi = HfApi()\n\n# Create repo\nrepo_id = api.create_repo(\"test-squash\").repo_id\n\n# Make a lot of commits.\napi.upload_file(repo_id=repo_id, path_in_repo=\"file.txt\", path_or_fileobj=b\"content\")\napi.upload_file(repo_id=repo_id, path_in_repo=\"lfs.bin\", path_or_fileobj=b\"content\")\napi.upload_file(repo_id=repo_id, path_in_repo=\"file.txt\", path_or_fileobj=b\"another_content\")\n\n# Squash history\n<line_mask>\n",
            "masked_line": "api.super_squash_history(repo_id=repo_id)",
            "answer": "super_squash_history",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_90"
        },
        {
            "dependency": "huggingface-hub",
            "version": "==0.17.0",
            "time": "2023-09-11",
            "description": "The code is performing table question answering using a specified pre-trained model to answer the query \"How many stars does the transformers repository have?\" on the provided table data. The output provides the answer along with relevant information such as coordinates and aggregator.",
            "code": "from huggingface_hub import InferenceClient\nclient = InferenceClient()\nquery = \"How many stars does the transformers repository have?\"\ntable = {\"Repository\": [\"Transformers\", \"Datasets\", \"Tokenizers\"], \"Stars\": [\"36542\", \"4512\", \"3934\"]}\nclient.table_question_answering(table, query, model=\"google/tapas-base-finetuned-wtq\")\n{'answer': 'AVERAGE > 36542', 'coordinates': [[0, 1]], 'cells': ['36542'], 'aggregator': 'AVERAGE'}\n",
            "masked_code": "from huggingface_hub import InferenceClient\nclient = InferenceClient()\nquery = \"How many stars does the transformers repository have?\"\ntable = {\"Repository\": [\"Transformers\", \"Datasets\", \"Tokenizers\"], \"Stars\": [\"36542\", \"4512\", \"3934\"]}\n<line_mask>\n{'answer': 'AVERAGE > 36542', 'coordinates': [[0, 1]], 'cells': ['36542'], 'aggregator': 'AVERAGE'}\n",
            "masked_line": "client.table_question_answering(table, query, model=\"google/tapas-base-finetuned-wtq\")",
            "answer": "table_question_answering",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_91"
        },
        {
            "dependency": "huggingface-hub",
            "version": "==0.17.0",
            "time": "2023-09-11",
            "description": "The code enables translation of input text from English to German or French using different pre-trained models.",
            "code": "from huggingface_hub import InferenceClient\nclient = InferenceClient()\nclient.translation(\"My name is Wolfgang and I live in Berlin\")\n'Mein Name ist Wolfgang und ich lebe in Berlin.'\nclient.translation(\"My name is Wolfgang and I live in Berlin\", model=\"Helsinki-NLP/opus-mt-en-fr\")\n\"Je m'appelle Wolfgang et je vis  Berlin.\"\n",
            "masked_code": "from huggingface_hub import InferenceClient\nclient = InferenceClient()\n<line_mask>\n'Mein Name ist Wolfgang und ich lebe in Berlin.'\nclient.translation(\"My name is Wolfgang and I live in Berlin\", model=\"Helsinki-NLP/opus-mt-en-fr\")\n\"Je m'appelle Wolfgang et je vis  Berlin.\"\n",
            "masked_line": "client.translation(\"My name is Wolfgang and I live in Berlin\")",
            "answer": "translation",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_92"
        },
        {
            "dependency": "huggingface-hub",
            "version": "==0.18.0",
            "time": "2023-10-10",
            "description": "The code adds items to a collection on Hugging Face Hub related to climate data. The first item added is \"pierre-loic/climate-news-articles\" as a dataset. The second item added is \"datasets/climate_fever\" as a dataset with a note describing the dataset's methodology.",
            "code": "from huggingface_hub import add_collection_item\ncollection = add_collection_item(\n    collection_slug=\"davanstrien/climate-64f99dc2a5067f6b65531bab\",\n    item_id=\"pierre-loic/climate-news-articles\",\n    item_type=\"dataset\"\n)\ncollection.items[-1].item_id\n\"pierre-loic/climate-news-articles\"\n\nadd_collection_item(\n    collection_slug=\"davanstrien/climate-64f99dc2a5067f6b65531bab\",\n    item_id=\"datasets/climate_fever\",\n    item_type=\"dataset\",\n    note=\"This dataset adopts the FEVER methodology that consists of 1,535 real-world claims regarding climate-change collected on the internet.\"\n)\n",
            "masked_code": "<line_mask>\ncollection = add_collection_item(\n    collection_slug=\"davanstrien/climate-64f99dc2a5067f6b65531bab\",\n    item_id=\"pierre-loic/climate-news-articles\",\n    item_type=\"dataset\"\n)\ncollection.items[-1].item_id\n\"pierre-loic/climate-news-articles\"\n\nadd_collection_item(\n    collection_slug=\"davanstrien/climate-64f99dc2a5067f6b65531bab\",\n    item_id=\"datasets/climate_fever\",\n    item_type=\"dataset\",\n    note=\"This dataset adopts the FEVER methodology that consists of 1,535 real-world claims regarding climate-change collected on the internet.\"\n)\n",
            "masked_line": "from huggingface_hub import add_collection_item",
            "answer": "add_collection_item",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_93"
        },
        {
            "dependency": "huggingface-hub",
            "version": "==0.20.0",
            "time": "2023-12-20",
            "description": "The code retrieves a list of 411 pending access requests for the repository \"meta-llama/Llama-2-7b\" from Hugging Face Hub. Each request includes the username, full name, email, timestamp, status, and additional fields. Then, it accepts the access request from user \"Clem\" for the same repository.",
            "code": "from huggingface_hub import list_pending_access_requests, accept_access_request\n\n# List pending requests\nrequests = list_pending_access_requests(\"meta-llama/Llama-2-7b\")\nlen(requests)\n411\nrequests[0]\n[\n    AccessRequest(\n        username='clem',\n        fullname='Clem ',\n        email='***',\n        timestamp=datetime.datetime(2023, 11, 23, 18, 4, 53, 828000, tzinfo=datetime.timezone.utc),\n        status='pending',\n        fields=None,\n    ),\n    ...\n]\n\n# Accept Clem's request\naccept_access_request(\"meta-llama/Llama-2-7b\", \"clem\")\n",
            "masked_code": "from huggingface_hub import list_pending_access_requests, accept_access_request\n\n# List pending requests\n<line_mask>\nlen(requests)\n411\nrequests[0]\n[\n    AccessRequest(\n        username='clem',\n        fullname='Clem ',\n        email='***',\n        timestamp=datetime.datetime(2023, 11, 23, 18, 4, 53, 828000, tzinfo=datetime.timezone.utc),\n        status='pending',\n        fields=None,\n    ),\n    ...\n]\n\n# Accept Clem's request\naccept_access_request(\"meta-llama/Llama-2-7b\", \"clem\")\n",
            "masked_line": "requests = list_pending_access_requests(\"meta-llama/Llama-2-7b\")",
            "answer": "list_pending_access_requests",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_94"
        },
        {
            "dependency": "huggingface-hub",
            "version": "==0.20.0",
            "time": "2023-12-20",
            "description": "This code retrieves a list of 411 accepted access requests for the model \"Llama-2-7b\" from the Hugging Face model hub, including details such as the username, fullname, email, timestamp, and status of each request.",
            "code": "from huggingface_hub import list_accepted_access_requests\n\nrequests = list_accepted_access_requests(\"meta-llama/Llama-2-7b\")\nlen(requests)\n411\nrequests[0]\n[\n    AccessRequest(\n        username='clem',\n        fullname='Clem ',\n        email='***',\n        timestamp=datetime.datetime(2023, 11, 23, 18, 4, 53, 828000, tzinfo=datetime.timezone.utc),\n        status='accepted',\n        fields=None,\n    ),\n    ...\n]\n",
            "masked_code": "from huggingface_hub import list_accepted_access_requests\n\n<line_mask>\nlen(requests)\n411\nrequests[0]\n[\n    AccessRequest(\n        username='clem',\n        fullname='Clem ',\n        email='***',\n        timestamp=datetime.datetime(2023, 11, 23, 18, 4, 53, 828000, tzinfo=datetime.timezone.utc),\n        status='accepted',\n        fields=None,\n    ),\n    ...\n]\n",
            "masked_line": "requests = list_accepted_access_requests(\"meta-llama/Llama-2-7b\")",
            "answer": "list_accepted_access_requests",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_95"
        },
        {
            "dependency": "huggingface-hub",
            "version": "==0.20.0",
            "time": "2023-12-20",
            "description": "The code retrieves a list of rejected access requests for the repository \"meta-llama/Llama-2-7b\" from the Hugging Face Hub. Each access request includes information such as the username, full name, email, timestamp, status (rejected), and additional fields (if available).",
            "code": "from huggingface_hub import list_rejected_access_requests\n\nrequests = list_rejected_access_requests(\"meta-llama/Llama-2-7b\")\nlen(requests)\n411\nrequests[0]\n[\n    AccessRequest(\n        username='clem',\n        fullname='Clem ',\n        email='***',\n        timestamp=datetime.datetime(2023, 11, 23, 18, 4, 53, 828000, tzinfo=datetime.timezone.utc),\n        status='rejected',\n        fields=None,\n    ),\n    ...\n]\n",
            "masked_code": "from huggingface_hub import list_rejected_access_requests\n\n<line_mask>\nlen(requests)\n411\nrequests[0]\n[\n    AccessRequest(\n        username='clem',\n        fullname='Clem ',\n        email='***',\n        timestamp=datetime.datetime(2023, 11, 23, 18, 4, 53, 828000, tzinfo=datetime.timezone.utc),\n        status='rejected',\n        fields=None,\n    ),\n    ...\n]\n",
            "masked_line": "requests = list_rejected_access_requests(\"meta-llama/Llama-2-7b\")",
            "answer": "list_rejected_access_requests",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_96"
        },
        {
            "dependency": "huggingface-hub",
            "version": "==0.9.0",
            "time": "2022-08-23",
            "description": "The code retrieves and prints discussions from a specific repository on the Hugging Face model hub.",
            "code": "from huggingface_hub import get_repo_discussions\ndiscussions_list = list(get_repo_discussions(repo_id=\"bert-base-uncased\"))\n\nfrom huggingface_hub import get_repo_discussions\nfor discussion in get_repo_discussions(repo_id=\"bert-base-uncased\"):\n    print(discussion.num, discussion.title)\n",
            "masked_code": "<line_mask>\ndiscussions_list = list(get_repo_discussions(repo_id=\"bert-base-uncased\"))\n\nfrom huggingface_hub import get_repo_discussions\nfor discussion in get_repo_discussions(repo_id=\"bert-base-uncased\"):\n    print(discussion.num, discussion.title)\n",
            "masked_line": "from huggingface_hub import get_repo_discussions",
            "answer": "get_repo_discussions",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_97"
        },
        {
            "dependency": "imageio",
            "version": "==1.4",
            "time": "2015-11-18",
            "description": "This code defines a function called product that takes an iterable as input, multiplies all the elements in the iterable together, and returns the result. It then calculates and prints the product of the elements in two lists, [256, 1073741824] and an empty list respectively.",
            "code": "def product(iterable):\n    result = 1\n    for num in iterable:\n        result *= num\n    return result\n\nprint(product([2**8, 2**30]))\nprint(product([]))",
            "masked_code": "def product(iterable):\n    result = 1\n    for num in iterable:\n        result *= num\n    return result\n\nprint(product([2**8, 2**30]))\n<line_mask>",
            "masked_line": "print(product([]))",
            "answer": "product",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_98"
        },
        {
            "dependency": "imageio",
            "version": "==2.10.0",
            "time": "2021-10-27",
            "description": "This code reads an image from a specified file path, then writes the image to another file path in a different format.",
            "code": "import imageio.v3 as iio\nwith iio.imopen(\"/path/to/image.png\", \"r\") as file:\n    im = file.read()\n\nwith iio.imopen(\"/path/to/output.jpg\", \"w\") as file:\n    file.write(im)",
            "masked_code": "import imageio.v3 as iio\n<line_mask>\n    im = file.read()\n\nwith iio.imopen(\"/path/to/output.jpg\", \"w\") as file:\n    file.write(im)",
            "masked_line": "with iio.imopen(\"/path/to/image.png\", \"r\") as file:",
            "answer": "imopen",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_99"
        },
        {
            "dependency": "imageio",
            "version": "==2.11.0",
            "time": "2021-11-18",
            "description": "This code opens an image file located at \"/path/to/image.png\" and reads the image data. It then opens a new image file at \"/path/to/output.jpg\" and writes the same image data to that file.",
            "code": "import imageio.v3 as iio\nwith iio.imopen(\"/path/to/image.png\", \"r\") as file:\n    im = file.read()\n\nwith iio.imopen(\"/path/to/output.jpg\", \"w\") as file:\n    file.write(im)\n",
            "masked_code": "import imageio.v3 as iio\n<line_mask>\n    im = file.read()\n\nwith iio.imopen(\"/path/to/output.jpg\", \"w\") as file:\n    file.write(im)\n",
            "masked_line": "with iio.imopen(\"/path/to/image.png\", \"r\") as file:",
            "answer": "imopen",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_100"
        },
        {
            "dependency": "imageio",
            "version": "==2.10.5",
            "time": "2021-11-17",
            "description": "This code reads an image file from \"/path/to/image.png\" and then writes the same image to another file at \"/path/to/output.jpg\".",
            "code": "import imageio.v3 as iio\nwith iio.imopen(\"/path/to/image.png\", \"r\") as file:\n    im = file.read()\n\nwith iio.imopen(\"/path/to/output.jpg\", \"w\") as file:\n    file.write(im)",
            "masked_code": "import imageio.v3 as iio\nwith iio.imopen(\"/path/to/image.png\", \"r\") as file:\n    im = file.read()\n\n<line_mask>\n    file.write(im)",
            "masked_line": "with iio.imopen(\"/path/to/output.jpg\", \"w\") as file:",
            "answer": "imopen",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_101"
        },
        {
            "dependency": "imageio",
            "version": "==2.3.0",
            "time": "2018-03-20",
            "description": "The code creates a memory-mapped file 'temp.tif' with a shape of 256x256 and data type of float32. It then assigns a value of 1.0 to the element at position (255, 255), flushes the changes to the memory-mapped file, and retrieves the shape and data type of the memory-mapped file before finally deleting it. Later, it accesses the element at position (255, 255) of the memory-mapped file and returns the value 1.0.",
            "code": "memmap('temp.tif', shape=(256, 256), dtype='float32')\nim[255, 255] = 1.0\nim.flush()\nim.shape, im.dtype\n((256, 256), dtype('float32'))\ndel im\n\nmemmap('temp.tif', page=0)\nim[255, 255]\n1.0",
            "masked_code": "memmap('temp.tif', shape=(256, 256), dtype='float32')\nim[255, 255] = 1.0\nim.flush()\nim.shape, im.dtype\n((256, 256), dtype('float32'))\ndel im\n\n<line_mask>\nim[255, 255]\n1.0",
            "masked_line": "memmap('temp.tif', page=0)",
            "answer": "memmap",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_102"
        },
        {
            "dependency": "jax",
            "version": "==0.1.60",
            "time": "2020-03-17",
            "description": "This code defines a class called Special with two attributes x and y. It also includes methods tree_flatten and tree_unflatten for serialization and deserialization purposes.",
            "code": "@register_pytree_node_class\nclass Special:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    def tree_flatten(self):\n        return ((self.x, self.y), None)\n    @classmethod\n    def tree_unflatten(cls, aux_data, children):\n        return cls(*children)",
            "masked_code": "<line_mask>\nclass Special:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    def tree_flatten(self):\n        return ((self.x, self.y), None)\n    @classmethod\n    def tree_unflatten(cls, aux_data, children):\n        return cls(*children)",
            "masked_line": "@register_pytree_node_class",
            "answer": "register_pytree_node_class",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_103"
        },
        {
            "dependency": "jax",
            "version": "==0.1.63",
            "time": "2020-04-13",
            "description": "This Python code defines a custom JVP (Jacobean-Vector Product) for a function f with two input variables x and y. The function f computes the sine of x multiplied by y. The custom JVP function f_jvp calculates the JVP of the function f with respect to its inputs x and y, returning the output of f and the JVP with respect to x and y.",
            "code": "@jax.custom_jvp\ndef f(x, y):\n    return np.sin(x) * y\n\n@f.defjvp\ndef f_jvp(primals, tangents):\n    x, y = primals\n    x_dot, y_dot = tangents\n    primal_out = f(x, y)\n    tangent_out = np.cos(x) * x_dot * y - np.sin(x) * y_dot\n    return primal_out, tangent_out",
            "masked_code": "<line_mask>\ndef f(x, y):\n    return np.sin(x) * y\n\n@f.defjvp\ndef f_jvp(primals, tangents):\n    x, y = primals\n    x_dot, y_dot = tangents\n    primal_out = f(x, y)\n    tangent_out = np.cos(x) * x_dot * y - np.sin(x) * y_dot\n    return primal_out, tangent_out",
            "masked_line": "@jax.custom_jvp",
            "answer": "custom_jvp",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_104"
        },
        {
            "dependency": "jax",
            "version": "==0.1.63",
            "time": "2020-04-13",
            "description": "The code defines a custom Jacobian-vector product (JVP) for the function f(x, y), where f(x, y) = sin(x) * y.",
            "code": "@jax.custom_jvp\ndef f(x, y):\n    return np.sin(x) * y\n\n@f.defjvp\ndef f_jvp(primals, tangents):\n    x, y = primals\n    x_dot, y_dot = tangents\n    primal_out = f(x, y)\n    tangent_out = np.cos(x) * x_dot * y - np.sin(x) * y_dot\n    return primal_out, tangent_out",
            "masked_code": "@jax.custom_jvp\ndef f(x, y):\n    return np.sin(x) * y\n\n<line_mask>\ndef f_jvp(primals, tangents):\n    x, y = primals\n    x_dot, y_dot = tangents\n    primal_out = f(x, y)\n    tangent_out = np.cos(x) * x_dot * y - np.sin(x) * y_dot\n    return primal_out, tangent_out",
            "masked_line": "@f.defjvp",
            "answer": "defjvp",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_105"
        },
        {
            "dependency": "jax",
            "version": "==0.1.63",
            "time": "2020-04-13",
            "description": "This code defines a custom vector-Jacobian product (vjp) for a function f, which calculates the product of the sine of x and y. The custom vjp function calculates the forward and backward pass for the function f.",
            "code": "@jax.custom_vjp\ndef f(x, y):\n    return np.sin(x) * y\n\ndef f_fwd(x, y):\n    return f(x, y), (np.cos(x), np.sin(x), y)\n\ndef f_bwd(res, g):\n    cos_x, sin_x, y = res\n    return (cos_x * g * y, -sin_x * g)\n\nf.defvjp(f_fwd, f_bwd)",
            "masked_code": "<line_mask>\ndef f(x, y):\n    return np.sin(x) * y\n\ndef f_fwd(x, y):\n    return f(x, y), (np.cos(x), np.sin(x), y)\n\ndef f_bwd(res, g):\n    cos_x, sin_x, y = res\n    return (cos_x * g * y, -sin_x * g)\n\nf.defvjp(f_fwd, f_bwd)",
            "masked_line": "@jax.custom_vjp",
            "answer": "custom_vjp",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_106"
        },
        {
            "dependency": "jax",
            "version": "==0.1.63",
            "time": "2020-04-13",
            "description": "This code defines a custom vector-Jacobian product (VJP) for a function f that takes two inputs x and y, and returns the product of the sine of x with y. The VJP allows for calculating the gradient of f with respect to its inputs.",
            "code": "@jax.custom_vjp\ndef f(x, y):\n    return np.sin(x) * y\n\ndef f_fwd(x, y):\n    return f(x, y), (np.cos(x), np.sin(x), y)\n\ndef f_bwd(res, g):\n    cos_x, sin_x, y = res\n    return (cos_x * g * y, -sin_x * g)\n\nf.defvjp(f_fwd, f_bwd)",
            "masked_code": "@jax.custom_vjp\ndef f(x, y):\n    return np.sin(x) * y\n\ndef f_fwd(x, y):\n    return f(x, y), (np.cos(x), np.sin(x), y)\n\ndef f_bwd(res, g):\n    cos_x, sin_x, y = res\n    return (cos_x * g * y, -sin_x * g)\n\n<line_mask>",
            "masked_line": "f.defvjp(f_fwd, f_bwd)",
            "answer": "defvjp",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_107"
        },
        {
            "dependency": "jax",
            "version": "==0.1.69",
            "time": "2020-06-03",
            "description": "The code creates three parameters with different shapes using XLA operations and then creates a tuple with these parameters. Finally, it retrieves and flattens the shapes of the tuple and the first parameter.",
            "code": "c = xc.XlaBuilder(\"example\")\np0 = xb.parameter(c, 1, xc.shape_from_pyval(jnp.ones([1])))\np1 = xb.parameter(c, 2, xc.shape_from_pyval(jnp.ones([2])))\np2 = xb.parameter(c, 3, xc.shape_from_pyval(jnp.ones([3])))\no = xops.Tuple(c, [p0, p1, p2])\nflatten_shape(c.GetShape(o))\nflatten_shape(c.GetShape(p0))",
            "masked_code": "c = xc.XlaBuilder(\"example\")\np0 = xb.parameter(c, 1, xc.shape_from_pyval(jnp.ones([1])))\np1 = xb.parameter(c, 2, xc.shape_from_pyval(jnp.ones([2])))\np2 = xb.parameter(c, 3, xc.shape_from_pyval(jnp.ones([3])))\no = xops.Tuple(c, [p0, p1, p2])\nflatten_shape(c.GetShape(o))\n<line_mask>",
            "masked_line": "flatten_shape(c.GetShape(p0))",
            "answer": "flatten_shape",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_108"
        },
        {
            "dependency": "jax",
            "version": "==0.1.73",
            "time": "2020-07-22",
            "description": "The code is iterating and executing a training step using JAX profiler to trace the execution of the training process.",
            "code": "import jax\n\nwhile global_step < NUM_STEPS:\n    with jax.profiler.StepTraceContext(\"train\", step_num=global_step):\n        train_step()\n        global_step += 1\n",
            "masked_code": "import jax\n\nwhile global_step < NUM_STEPS:\n    <line_mask>\n        train_step()\n        global_step += 1\n",
            "masked_line": "with jax.profiler.StepTraceContext(\"train\", step_num=global_step):",
            "answer": "StepTraceContext",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_109"
        },
        {
            "dependency": "jax",
            "version": "==0.2.9",
            "time": "2021-01-27",
            "description": "The code defines a function named \"cond\" that takes a predicate, true function, false function, and operand as arguments. It then evaluates the predicate and calls either the true function or false function on the operand based on the result of the predicate evaluation.",
            "code": "def cond(pred, true_fun, false_fun, operand):\n    if pred:\n        return true_fun(operand)\n    else:\n        return false_fun(operand)\n\njax.lax.cond(\n    get_predicate_value(),\n    lambda _: 23,\n    lambda _: 42,\n    operand=None)",
            "masked_code": "<line_mask>\n    if pred:\n        return true_fun(operand)\n    else:\n        return false_fun(operand)\n\njax.lax.cond(\n    get_predicate_value(),\n    lambda _: 23,\n    lambda _: 42,\n    operand=None)",
            "masked_line": "def cond(pred, true_fun, false_fun, operand):",
            "answer": "cond",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_110"
        },
        {
            "dependency": "jax",
            "version": "==0.2.12",
            "time": "2021-04-01",
            "description": "This code performs a training loop for a machine learning model, specifying a step trace annotation for profiling purposes at each iteration. It increments the global step count until it reaches a specified number of steps (NUM_STEPS).",
            "code": "import jax\n\nwhile global_step < NUM_STEPS:\n    with jax.profiler.StepTraceAnnotation(\"train\", step_num=global_step):\n        train_step()\n        global_step += 1\n",
            "masked_code": "import jax\n\nwhile global_step < NUM_STEPS:\n    <line_mask>\n        train_step()\n        global_step += 1\n",
            "masked_line": "with jax.profiler.StepTraceAnnotation(\"train\", step_num=global_step):",
            "answer": "StepTraceAnnotation",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_111"
        },
        {
            "dependency": "jax",
            "version": "==0.2.11",
            "time": "2021-03-24",
            "description": "The code snippet runs a training loop for a machine learning model using JAX library, where the code uses JAX profiler to trace the execution steps of the training process.",
            "code": "import jax\n\nwhile global_step < NUM_STEPS:\n    with jax.profiler.StepTraceContext(\"train\", step_num=global_step):\n        train_step()\n        global_step += 1\n",
            "masked_code": "import jax\n\nwhile global_step < NUM_STEPS:\n    <line_mask>\n        train_step()\n        global_step += 1\n",
            "masked_line": "with jax.profiler.StepTraceContext(\"train\", step_num=global_step):",
            "answer": "StepTraceContext",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_112"
        },
        {
            "dependency": "jax",
            "version": "==0.2.13",
            "time": "2021-05-04",
            "description": "This code calculates the maximum value of each segment in the 'data' array based on the 'segment_ids'.",
            "code": "data = jnp.arange(6)\nsegment_ids = jnp.array([0, 0, 1, 1, 2, 2])\nsegment_max(data, segment_ids)\n\nfrom jax import jit\njit(segment_max, static_argnums=2)(data, segment_ids, 3)\n",
            "masked_code": "data = jnp.arange(6)\nsegment_ids = jnp.array([0, 0, 1, 1, 2, 2])\nsegment_max(data, segment_ids)\n\nfrom jax import jit\n<line_mask>\n",
            "masked_line": "jit(segment_max, static_argnums=2)(data, segment_ids, 3)",
            "answer": "segment_max",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_113"
        },
        {
            "dependency": "jax",
            "version": "==0.2.13",
            "time": "2021-05-04",
            "description": "This code calculates the minimum value for each segment defined by the segment_ids array from the data array.",
            "code": "data = jnp.arange(6)\nsegment_ids = jnp.array([0, 0, 1, 1, 2, 2])\nsegment_min(data, segment_ids)\n\nfrom jax import jit\njit(segment_min, static_argnums=2)(data, segment_ids, 3)\n",
            "masked_code": "data = jnp.arange(6)\nsegment_ids = jnp.array([0, 0, 1, 1, 2, 2])\nsegment_min(data, segment_ids)\n\nfrom jax import jit\n<line_mask>\n",
            "masked_line": "jit(segment_min, static_argnums=2)(data, segment_ids, 3)",
            "answer": "segment_min",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_114"
        },
        {
            "dependency": "jax",
            "version": "==0.2.20",
            "time": "2021-09-03",
            "description": "The code defines a function that computes the dot product of the transpose of a sparse matrix M and a vector v, then calls the function with a specific sparse matrix M and vector v.",
            "code": "@sparse.sparsify\ndef f(M, v):\n  return 2 * M.T @ v\n\nM = sparse.BCOO.fromdense(jnp.arange(12).reshape(3, 4))\n\nv = jnp.array([3, 4, 2])\n\nf(M, v)",
            "masked_code": "<line_mask>\ndef f(M, v):\n  return 2 * M.T @ v\n\nM = sparse.BCOO.fromdense(jnp.arange(12).reshape(3, 4))\n\nv = jnp.array([3, 4, 2])\n\nf(M, v)",
            "masked_line": "@sparse.sparsify",
            "answer": "sparsify",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_115"
        },
        {
            "dependency": "jax",
            "version": "==0.2.20",
            "time": "2021-09-03",
            "description": "The code initializes an array [1.0, 2.0, 3.0] using JAX library and retrieves the value of the array from the device.",
            "code": "import jax\nx = jax.numpy.array([1., 2., 3.])\njax.device_get(x)\n\nimport jax\njax.device_get(1)\n",
            "masked_code": "import jax\nx = jax.numpy.array([1., 2., 3.])\n<line_mask>\n\nimport jax\njax.device_get(1)\n",
            "masked_line": "jax.device_get(x)",
            "answer": "device_get",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_116"
        },
        {
            "dependency": "jax",
            "version": "==0.2.28",
            "time": "2022-02-02",
            "description": "The code defines a global input data array of shape (8, 2) and a callback function cb that returns a specific element from the global input data array based on the given index. It then creates a GlobalDeviceArray object gda from the callback function, global input shape, global mesh, and mesh axes.",
            "code": "global_input_shape = (8, 2)\nglobal_input_data = np.arange(prod(global_input_shape)).reshape(global_input_shape)\ndef cb(index):\n    return global_input_data[index]\ngda = GlobalDeviceArray.from_callback(global_input_shape, global_mesh, mesh_axes, cb)",
            "masked_code": "global_input_shape = (8, 2)\nglobal_input_data = np.arange(prod(global_input_shape)).reshape(global_input_shape)\ndef cb(index):\n    return global_input_data[index]\n<line_mask>",
            "masked_line": "gda = GlobalDeviceArray.from_callback(global_input_shape, global_mesh, mesh_axes, cb)",
            "answer": "from_callback",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_117"
        },
        {
            "dependency": "jax",
            "version": "==0.2.28",
            "time": "2022-02-02",
            "description": "The code defines a global input shape and data array in the form of a numpy array. It also defines a batched callback function that verifies the length of input indices and returns the corresponding data from the global input data array. Finally, it creates a GlobalDeviceArray object using the batched callback function and other specified parameters.",
            "code": "global_input_shape = (8, 2)\nglobal_input_data = np.arange(\n    prod(global_input_shape)).reshape(global_input_shape)\ndef batched_cb(indices):\n    self.assertEqual(len(indices),len(global_mesh.local_devices))\n    return [global_input_data[index] for index in indices]\ngda = GlobalDeviceArray.from_batched_callback(global_input_shape, global_mesh, mesh_axes, batched_cb)",
            "masked_code": "global_input_shape = (8, 2)\nglobal_input_data = np.arange(\n    prod(global_input_shape)).reshape(global_input_shape)\ndef batched_cb(indices):\n    self.assertEqual(len(indices),len(global_mesh.local_devices))\n    return [global_input_data[index] for index in indices]\n<line_mask>",
            "masked_line": "gda = GlobalDeviceArray.from_batched_callback(global_input_shape, global_mesh, mesh_axes, batched_cb)",
            "answer": "from_batched_callback",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_118"
        },
        {
            "dependency": "jax",
            "version": "==0.3.0",
            "time": "2022-02-10",
            "description": "The code defines a function f(x) that checks if x is not equal to 0, throws an error if x is 0, and then returns the result of 1/x. It then applies a checker to the function f and uses jax.jit to compile the function. Finally, it calls the compiled function with an input of 0, catches the error, and throws it.",
            "code": "def f(x):\n    checkify.check(x!=0, \"cannot be zero!\")\n    return 1/x\n\nchecked_f = checkify.checkify(f)\nerr, out = jax.jit(checked_f)(0)\nerr.throw()  # doctest: +IGNORE_EXCEPTION_DETAIL",
            "masked_code": "def f(x):\n    <line_mask>\n    return 1/x\n\nchecked_f = checkify.checkify(f)\nerr, out = jax.jit(checked_f)(0)\nerr.throw()  # doctest: +IGNORE_EXCEPTION_DETAIL",
            "masked_line": "checkify.check(x!=0, \"cannot be zero!\")",
            "answer": "check",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_119"
        },
        {
            "dependency": "jax",
            "version": "==0.3.0",
            "time": "2022-02-10",
            "description": "This code defines a function that takes a single input parameter, applies the sine function to the input, adds the input to the result and returns the sum. Then it utilizes a library to perform error checking on the function with respect to float type checks, specifically checking for errors when the input is infinity.",
            "code": "@jax.jit\ndef f(x):\n  y = jnp.sin(x)\n  return x+y\nerr, out = checkify.checkify(f, errors=checkify.float_checks)(jnp.inf)\nerr.throw()  # doctest: +IGNORE_EXCEPTION_DETAIL\n",
            "masked_code": "@jax.jit\ndef f(x):\n  y = jnp.sin(x)\n  return x+y\n<line_mask>\nerr.throw()  # doctest: +IGNORE_EXCEPTION_DETAIL\n",
            "masked_line": "err, out = checkify.checkify(f, errors=checkify.float_checks)(jnp.inf)",
            "answer": "checkify",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_120"
        },
        {
            "dependency": "jax",
            "version": "==0.3.14",
            "time": "2022-06-27",
            "description": "This code defines a neural network layer that calculates the dot product of weights and input data, applies a rectified linear activation function, and returns the resulting output.",
            "code": "import jax\n\n@jax.jit\ndef layer(w, x):\n  with jax.named_scope(\"dot_product\"):\n    logits = w.dot(x)\n  with jax.named_scope(\"activation\"):\n    return jax.nn.relu(logits)\n",
            "masked_code": "import jax\n\n@jax.jit\ndef layer(w, x):\n  with jax.named_scope(\"dot_product\"):\n    logits = w.dot(x)\n  <line_mask>\n    return jax.nn.relu(logits)\n",
            "masked_line": "with jax.named_scope(\"activation\"):",
            "answer": "named_scope",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_121"
        },
        {
            "dependency": "jax",
            "version": "==0.3.15",
            "time": "2022-07-22",
            "description": "This function executes the given 'body' function for a specified number of 'nsteps' times using an initial state 'init_state', and returns the final state after applying the 'body' function iteratively.",
            "code": "def for_loop(nsteps, body, init_state):\n  refs = tree_map(make_ref, init_state)\n  for i in range(nsteps):\n    body(i, refs)\n  return tree_map(ref_get, refs)\n",
            "masked_code": "<line_mask>\n  refs = tree_map(make_ref, init_state)\n  for i in range(nsteps):\n    body(i, refs)\n  return tree_map(ref_get, refs)\n",
            "masked_line": "def for_loop(nsteps, body, init_state):",
            "answer": "for_loop",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_122"
        },
        {
            "dependency": "jax",
            "version": "==0.3.15",
            "time": "2022-07-22",
            "description": "The code calculates the sum of 1.0 added 5 times and returns the final result.",
            "code": "with Scope() as s:\n    s.data = 0.\n    for i in s.range(5):\n      s.data += 1.\n    return s.data",
            "masked_code": "<line_mask>\n    s.data = 0.\n    for i in s.range(5):\n      s.data += 1.\n    return s.data",
            "masked_line": "with Scope() as s:",
            "answer": "Scope",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_123"
        },
        {
            "dependency": "jax",
            "version": "==0.3.9",
            "time": "2022-05-03",
            "description": "This code is responsible for managing asynchronous checkpoints during the training process. It deserializes the training state from a global async checkpoint manager, performs training steps at regular intervals, serializes the updated training state, and checks for errors. Finally, it serializes the final training state and waits for the process to finish.",
            "code": "manager = GlobalAsyncCheckpointManager()\n\ntrain_state = manager.deserialize(...)\n\nwhile ...:\n  if step % num_steps_between_checkpoints == 0:\n    manager.serialize(train_state)\n    train_state = train_step(train_state, input)\n    manager.check_for_errors()\n\nmanager.serialize(train_state)\nmanager.wait_until_finished()",
            "masked_code": "<line_mask>\n\ntrain_state = manager.deserialize(...)\n\nwhile ...:\n  if step % num_steps_between_checkpoints == 0:\n    manager.serialize(train_state)\n    train_state = train_step(train_state, input)\n    manager.check_for_errors()\n\nmanager.serialize(train_state)\nmanager.wait_until_finished()",
            "masked_line": "manager = GlobalAsyncCheckpointManager()",
            "answer": "GlobalAsyncCheckpointManager",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_124"
        },
        {
            "dependency": "jax",
            "version": "==0.4.21",
            "time": "2023-12-04",
            "description": "This code selects the appropriate code implementation based on the platform being used (CPU, TPU, or other platforms) by calling the platform_dependent function with the corresponding code implementations as arguments.",
            "code": "def cpu_code(*args): ...\ndef tpu_code(*args): ...\ndef other_platforms_code(*args): ...\nres = platform_dependent(*args, cpu=cpu_code, tpu=tpu_code,\n                         default=other_platforms_code)\n",
            "masked_code": "def cpu_code(*args): ...\ndef tpu_code(*args): ...\ndef other_platforms_code(*args): ...\n<line_mask>\n                         default=other_platforms_code)\n",
            "masked_line": "res = platform_dependent(*args, cpu=cpu_code, tpu=tpu_code,",
            "answer": "platform_dependent",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_125"
        },
        {
            "dependency": "jax",
            "version": "==0.4.24",
            "time": "2024-02-06",
            "description": "The code initializes JAX configuration using absl flags and runs the main function when the script is executed.",
            "code": "from absl import app\nimport jax\n...\n\nif __name__ == '__main__':\n  jax.config.config_with_absl()\n  app.run(main)\n",
            "masked_code": "from absl import app\nimport jax\n...\n\nif __name__ == '__main__':\n  <line_mask>\n  app.run(main)\n",
            "masked_line": "jax.config.config_with_absl()",
            "answer": "config_with_absl",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_126"
        },
        {
            "dependency": "jax",
            "version": "==0.4.6",
            "time": "2023-03-09",
            "description": "The code defines a class called Special with attributes x and y. It contains methods for flattening and unflattening the class instance into a tree structure.",
            "code": "@register_pytree_with_keys_class\nclass Special:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    def tree_flatten_with_keys(self):\n        return (((GetAttrKey('x'), self.x), (GetAttrKey('y'), self.y)), None)\n    @classmethod\n    def tree_unflatten(cls, aux_data, children):\n        return cls(*children)",
            "masked_code": "<line_mask>\nclass Special:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    def tree_flatten_with_keys(self):\n        return (((GetAttrKey('x'), self.x), (GetAttrKey('y'), self.y)), None)\n    @classmethod\n    def tree_unflatten(cls, aux_data, children):\n        return cls(*children)",
            "masked_line": "@register_pytree_with_keys_class",
            "answer": "register_pytree_with_keys_class",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_127"
        },
        {
            "dependency": "jax",
            "version": "==0.4.6",
            "time": "2023-03-09",
            "description": "This code defines a function called \"cb\" that takes an index as input and returns the element at that index in the global_input_data array. It then initializes a GlobalDeviceArray object \"gda\" using the GlobalDeviceArray.from_callback method with specified parameters. Finally, it accesses the shape of the addressable data at index 0, which is (4, 2).",
            "code": "def cb(index):\n    return global_input_data[index]\n\ngda = GlobalDeviceArray.from_callback(global_input_shape, global_mesh, mesh_axes, cb)\ngda.addressable_data(0).shape\n(4, 2)",
            "masked_code": "def cb(index):\n    return global_input_data[index]\n\n<line_mask>\ngda.addressable_data(0).shape\n(4, 2)",
            "masked_line": "gda = GlobalDeviceArray.from_callback(global_input_shape, global_mesh, mesh_axes, cb)",
            "answer": "from_callback",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_128"
        },
        {
            "dependency": "jax",
            "version": "==0.4.6",
            "time": "2023-03-09",
            "description": "The code defines a global input shape, mesh axes, global mesh, global input data, and a batched callback function. It then creates a GlobalDeviceArray object from the batched callback function, global input shape, global mesh, and mesh axes. Finally, it accesses the shape of the addressable data at index 0, which is (2, 2).",
            "code": "global_input_shape = (8, 2)\nmesh_axes = P('x')\nglobal_mesh = Mesh(np.array(jax.devices()).reshape(4, 2), ('x', 'y'))\nglobal_input_data = np.arange(math.prod(global_input_shape)).reshape(global_input_shape)\n\ndef batched_cb(indices):\n  assert len(indices) == len(global_mesh.local_devices)\n  return [global_input_data[index] for index in indices]\n\ngda = GlobalDeviceArray.from_batched_callback(global_input_shape, global_mesh, mesh_axes, batched_cb)\ngda.addressable_data(0).shape\n(2, 2)\n",
            "masked_code": "global_input_shape = (8, 2)\nmesh_axes = P('x')\nglobal_mesh = Mesh(np.array(jax.devices()).reshape(4, 2), ('x', 'y'))\nglobal_input_data = np.arange(math.prod(global_input_shape)).reshape(global_input_shape)\n\ndef batched_cb(indices):\n  assert len(indices) == len(global_mesh.local_devices)\n  return [global_input_data[index] for index in indices]\n\n<line_mask>\ngda.addressable_data(0).shape\n(2, 2)\n",
            "masked_line": "gda = GlobalDeviceArray.from_batched_callback(global_input_shape, global_mesh, mesh_axes, batched_cb)",
            "answer": "from_batched_callback",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_129"
        },
        {
            "dependency": "jax",
            "version": "==0.4.6",
            "time": "2023-03-09",
            "description": "The code defines a function named cb which takes a list of tuples as input. It iterates through each tuple, extracts the index and list of devices, retrieves an array from global_input_data using the index, and then creates a device buffer for each device in the list. Finally, it returns a list of device buffers. \n\nThe code then utilizes the cb function to create a GlobalDeviceArray object using a specific shape, mesh, mesh axes, and the cb function. \n\nFinally, the code accesses the shape of the addressable data at index 0 in the GlobalDeviceArray object, which returns a shape of (1, 2).",
            "code": "def cb(cb_inp):\n    dbs = []\n    for inp in cb_inp:\n        index, devices = inp\n        array = global_input_data[index]\n        dbs.extend([jax.device_put(array, device) for device in devices])\n    return dbs\n\ngda = GlobalDeviceArray.from_batched_callback_with_devices(\n    global_input_shape, global_mesh, mesh_axes, cb)\n\ngda.addressable_data(0).shape\n(1, 2)\n",
            "masked_code": "def cb(cb_inp):\n    dbs = []\n    for inp in cb_inp:\n        index, devices = inp\n        array = global_input_data[index]\n        dbs.extend([jax.device_put(array, device) for device in devices])\n    return dbs\n\n<line_mask>\n    global_input_shape, global_mesh, mesh_axes, cb)\n\ngda.addressable_data(0).shape\n(1, 2)\n",
            "masked_line": "gda = GlobalDeviceArray.from_batched_callback_with_devices(",
            "answer": "from_batched_callback_with_devices",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_130"
        },
        {
            "dependency": "jaxlib",
            "version": "==0.4.14",
            "time": "2023-07-27",
            "description": "The code checks if the data type of the random number generated using JAX is a subtype of the extended data types.",
            "code": "from jax import random\nfrom jax._src import dtypes\nkey = random.key(0)\njnp.issubdtype(key.dtype, dtypes.extended) \nTrue",
            "masked_code": "from jax import random\nfrom jax._src import dtypes\nkey = random.key(0)\n<line_mask>\nTrue",
            "masked_line": "jnp.issubdtype(key.dtype, dtypes.extended)",
            "answer": "extended",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_131"
        },
        {
            "dependency": "jaxlib",
            "version": "==0.4.2",
            "time": "2023-01-25",
            "description": "The code enforces a debug check to ensure that the input argument for function \"f\" is not equal to 0. If the input is 0, it raises an error with the message \"cannot be zero!\"",
            "code": "import jax\nimport jax.numpy as jnp\nfrom jax.experimental import checkify\ndef f(x):\n  checkify.debug_check(x!=0, \"cannot be zero!\")\n  return x\n_ = f(0)  # running without checkify means no debug_check is run.\nchecked_f = checkify.checkify(f)\nerr, out = jax.jit(checked_f)(0)  # running with checkify runs debug_check.\nerr.throw()  # doctest: +IGNORE_EXCEPTION_DETAIL\n",
            "masked_code": "import jax\nimport jax.numpy as jnp\nfrom jax.experimental import checkify\ndef f(x):\n  checkify.debug_check(x!=0, \"cannot be zero!\")\n  return x\n_ = f(0)  # running without checkify means no debug_check is run.\nchecked_f = checkify.checkify(f)\n<line_mask>\nerr.throw()  # doctest: +IGNORE_EXCEPTION_DETAIL\n",
            "masked_line": "err, out = jax.jit(checked_f)(0)  # running with checkify runs debug_check.",
            "answer": "debug_check",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_132"
        },
        {
            "dependency": "jaxlib",
            "version": "==0.4.21",
            "time": "2023-12-04",
            "description": "The code selects and executes a specific code block based on the platform. It passes arguments to the selected code block and executes it.",
            "code": "def cpu_code(*args): ...\ndef tpu_code(*args): ...\ndef other_platforms_code(*args): ...\nres = platform_dependent(*args, cpu=cpu_code, tpu=tpu_code,\n                         default=other_platforms_code)\n",
            "masked_code": "def cpu_code(*args): ...\ndef tpu_code(*args): ...\ndef other_platforms_code(*args): ...\n<line_mask>\n                         default=other_platforms_code)\n",
            "masked_line": "res = platform_dependent(*args, cpu=cpu_code, tpu=tpu_code,",
            "answer": "platform_dependent",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_133"
        },
        {
            "dependency": "jaxlib",
            "version": "==0.4.24",
            "time": "2024-02-06",
            "description": "The code sets up configuration for JAX using absl library and runs the main function when the script is executed.",
            "code": "from absl import app\nimport jax\n...\n\nif __name__ == '__main__':\n  jax.config.config_with_absl()\n  app.run(main)\n",
            "masked_code": "from absl import app\nimport jax\n...\n\nif __name__ == '__main__':\n  <line_mask>\n  app.run(main)\n",
            "masked_line": "jax.config.config_with_absl()",
            "answer": "config_with_absl",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_134"
        },
        {
            "dependency": "jaxlib",
            "version": "==0.4.6",
            "time": "2023-03-09",
            "description": "This code defines a class called Special with attributes x and y. It provides methods for flattening and unflattening the class instance into a tree structure.",
            "code": "@register_pytree_with_keys_class\nclass Special:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    def tree_flatten_with_keys(self):\n        return (((GetAttrKey('x'), self.x), (GetAttrKey('y'), self.y)), None)\n    @classmethod\n    def tree_unflatten(cls, aux_data, children):\n        return cls(*children)",
            "masked_code": "<line_mask>\nclass Special:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    def tree_flatten_with_keys(self):\n        return (((GetAttrKey('x'), self.x), (GetAttrKey('y'), self.y)), None)\n    @classmethod\n    def tree_unflatten(cls, aux_data, children):\n        return cls(*children)",
            "masked_line": "@register_pytree_with_keys_class",
            "answer": "register_pytree_with_keys_class",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_135"
        },
        {
            "dependency": "jaxlib",
            "version": "==0.4.6",
            "time": "2023-03-09",
            "description": "This code defines a global input shape of 8x8, creates a mesh with x and y axes, generates global input data as a 1D array of numbers from 0 to 63, defines a callback function that retrieves data from the global input data based on index, and initializes a GlobalDeviceArray object with specified parameters. Finally, it retrieves the shape of the addressable data at index 0 from the GlobalDeviceArray object.",
            "code": "global_input_shape = (8, 8)\nmesh_axes = P('x', 'y')\nglobal_mesh = Mesh(np.array(jax.devices()).reshape(2, 4), ('x', 'y'))\nglobal_input_data = np.arange(math.prod(global_input_shape)).reshape(global_input_shape)\n\ndef cb(index):\n    return global_input_data[index]\n\ngda = GlobalDeviceArray.from_callback(global_input_shape, global_mesh, mesh_axes, cb)\ngda.addressable_data(0).shape\n",
            "masked_code": "global_input_shape = (8, 8)\nmesh_axes = P('x', 'y')\nglobal_mesh = Mesh(np.array(jax.devices()).reshape(2, 4), ('x', 'y'))\nglobal_input_data = np.arange(math.prod(global_input_shape)).reshape(global_input_shape)\n\ndef cb(index):\n    return global_input_data[index]\n\n<line_mask>\ngda.addressable_data(0).shape\n",
            "masked_line": "gda = GlobalDeviceArray.from_callback(global_input_shape, global_mesh, mesh_axes, cb)",
            "answer": "from_callback",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_136"
        },
        {
            "dependency": "jaxlib",
            "version": "==0.4.6",
            "time": "2023-03-09",
            "description": "The code defines a global input shape, mesh axes, global mesh, global input data, and a batched callback function. The batched callback function receives a list of indices and returns values from the global input data corresponding to those indices. Finally, a GlobalDeviceArray is created from the batched callback function, global input shape, global mesh, and mesh axes, and the shape of the addressable data at index 0 is retrieved.",
            "code": "global_input_shape = (8, 2)\nmesh_axes = P('x')\nglobal_mesh = Mesh(np.array(jax.devices()).reshape(4, 2), ('x', 'y'))\nglobal_input_data = np.arange(math.prod(global_input_shape)).reshape(global_input_shape)\n\ndef batched_cb(indices):\n    assert len(indices) == len(global_mesh.local_devices)\n    return [global_input_data[index] for index in indices]\n\ngda = GlobalDeviceArray.from_batched_callback(global_input_shape, global_mesh, mesh_axes, batched_cb)\ngda.addressable_data(0).shape\n",
            "masked_code": "global_input_shape = (8, 2)\nmesh_axes = P('x')\nglobal_mesh = Mesh(np.array(jax.devices()).reshape(4, 2), ('x', 'y'))\nglobal_input_data = np.arange(math.prod(global_input_shape)).reshape(global_input_shape)\n\ndef batched_cb(indices):\n    assert len(indices) == len(global_mesh.local_devices)\n    return [global_input_data[index] for index in indices]\n\n<line_mask>\ngda.addressable_data(0).shape\n",
            "masked_line": "gda = GlobalDeviceArray.from_batched_callback(global_input_shape, global_mesh, mesh_axes, batched_cb)",
            "answer": "from_batched_callback",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_137"
        },
        {
            "dependency": "jaxlib",
            "version": "==0.4.6",
            "time": "2023-03-09",
            "description": "The code defines a function `cb` that takes a list of tuples as input, where each tuple contains an index and a list of devices. It then retrieves arrays from `global_input_data` based on the provided indices and creates device arrays using `jax.device_put` for each device in the list. Finally, it returns a list of device arrays.\n\nThe code then uses `GlobalDeviceArray.from_batched_callback_with_devices` to create a `GlobalDeviceArray` instance `gda` by passing in `global_input_shape`, `global_mesh`, `mesh_axes`, and the previously defined `cb` function.\n\nLastly, it retrieves the shape of the addressable data at index 0 from `gda` and returns `(1, 2)`.",
            "code": "def cb(cb_inp):\n    dbs = []\n    for inp in cb_inp:\n        index, devices = inp\n        array = global_input_data[index]\n        dbs.extend([jax.device_put(array, device) for device in devices])\n    return dbs\n\ngda = GlobalDeviceArray.from_batched_callback_with_devices(\n    global_input_shape, global_mesh, mesh_axes, cb)\n\ngda.addressable_data(0).shape\n(1, 2)\n",
            "masked_code": "def cb(cb_inp):\n    dbs = []\n    for inp in cb_inp:\n        index, devices = inp\n        array = global_input_data[index]\n        dbs.extend([jax.device_put(array, device) for device in devices])\n    return dbs\n\n<line_mask>\n    global_input_shape, global_mesh, mesh_axes, cb)\n\ngda.addressable_data(0).shape\n(1, 2)\n",
            "masked_line": "gda = GlobalDeviceArray.from_batched_callback_with_devices(",
            "answer": "from_batched_callback_with_devices",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_138"
        },
        {
            "dependency": "jedi",
            "version": "==0.17.0",
            "time": "2020-04-14",
            "description": "The code infers the module name of the import statement \"import json\" in the provided source code file.",
            "code": "from jedi import Script\nsource = 'import json'\nscript = Script(source, path='example.py')\nd = script.infer()[0]\nprint(d.module_name)  # doctest: +ELLIPSIS",
            "masked_code": "from jedi import Script\nsource = 'import json'\nscript = Script(source, path='example.py')\nd = script.infer()[0]\n<line_mask>",
            "masked_line": "print(d.module_name)  # doctest: +ELLIPSIS",
            "answer": "module_name",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_139"
        },
        {
            "dependency": "jedi",
            "version": "==0.17.0",
            "time": "2020-04-14",
            "description": "The code defines a function named f with two parameters, a and b with a default value of 1. The function has a documentation string \"Document for function f.\" and it prints out the docstring of the function f using different methods.",
            "code": "def f(a, b=1):\n    \"Document for function f.\"\n\nprint(doc)\nprint(script.infer(1, len('def f'))[0].docstring())\nprint(script.infer(1, len('def f'))[0].docstring(raw=True))",
            "masked_code": "def f(a, b=1):\n    \"Document for function f.\"\n\nprint(doc)\nprint(script.infer(1, len('def f'))[0].docstring())\n<line_mask>",
            "masked_line": "print(script.infer(1, len('def f'))[0].docstring(raw=True))",
            "answer": "docstring",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_140"
        },
        {
            "dependency": "jedi",
            "version": "==0.17.0",
            "time": "2020-04-14",
            "description": "This code uses the Jedi library to infer the full name of the function 'os.path.join' in the given Python source code.",
            "code": "import os\nos.path.join\n\nfrom jedi import Script\nsource = '''\nimport os\nos.path.join'''\nscript = Script(source, path='example.py')\nprint(script.infer(3, len('os.path.join'))[0].full_name)",
            "masked_code": "import os\nos.path.join\n\nfrom jedi import Script\nsource = '''\nimport os\nos.path.join'''\nscript = Script(source, path='example.py')\n<line_mask>",
            "masked_line": "print(script.infer(3, len('os.path.join'))[0].full_name)",
            "answer": "full_name",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_141"
        },
        {
            "dependency": "jedi",
            "version": "==0.16.0",
            "time": "2020-01-26",
            "description": "The code imports the `json` module and infers the module name using the Jedi library, then prints the module name.",
            "code": "from jedi import Script\nsource = 'import json'\nscript = Script(source, path='example.py')\nd = script.infer()[0]\nprint(d.module_name)  # doctest: +ELLIPSIS",
            "masked_code": "from jedi import Script\nsource = 'import json'\nscript = Script(source, path='example.py')\nd = script.infer()[0]\n<line_mask>",
            "masked_line": "print(d.module_name)  # doctest: +ELLIPSIS",
            "answer": "module_name",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_142"
        },
        {
            "dependency": "jedi",
            "version": "==0.16.0",
            "time": "2020-01-26",
            "description": "The code defines a function named f with two parameters, a and b, where b has a default value of 1. The code then prints out the docstring of the function f and the docstring without formatting characters.",
            "code": "def f(a, b=1):\n    \"Document for function f.\"\n\nprint(doc)\nprint(script.infer(1, len('def f'))[0].docstring())\nprint(script.infer(1, len('def f'))[0].docstring(raw=True))",
            "masked_code": "def f(a, b=1):\n    \"Document for function f.\"\n\nprint(doc)\nprint(script.infer(1, len('def f'))[0].docstring())\n<line_mask>",
            "masked_line": "print(script.infer(1, len('def f'))[0].docstring(raw=True))",
            "answer": "docstring",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_143"
        },
        {
            "dependency": "jedi",
            "version": "==0.16.0",
            "time": "2020-01-26",
            "description": "The code is using the Jedi library to infer the full name of the imported 'os.path.join' module and print it out.",
            "code": "import os\nos.path.join\n\nfrom jedi import Script\nsource = '''\nimport os\nos.path.join'''\nscript = Script(source, path='example.py')\nprint(script.infer(3, len('os.path.join'))[0].full_name)",
            "masked_code": "import os\nos.path.join\n\nfrom jedi import Script\nsource = '''\nimport os\nos.path.join'''\nscript = Script(source, path='example.py')\n<line_mask>",
            "masked_line": "print(script.infer(3, len('os.path.join'))[0].full_name)",
            "answer": "full_name",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_144"
        },
        {
            "dependency": "jedi",
            "version": "==0.8.0",
            "time": "2014-05-04",
            "description": "The code defines a function named \"f\" with two parameters, \"a\" and \"b\" with a default value of 1. It then creates a Script object with source, starting position of the function definition, and file name. Later, it retrieves and prints the docstring of the function \"f\".",
            "code": "def f(a, b=1):\n    \"Document for function f.\"\n\nscript = Script(source, 1, len('def f'), 'example.py')\ndoc = script.goto_definitions()[0].docstring()\nprint(doc)\nprint(script.goto_definitions()[0].docstring(raw=True))",
            "masked_code": "def f(a, b=1):\n    \"Document for function f.\"\n\nscript = Script(source, 1, len('def f'), 'example.py')\n<line_mask>\nprint(doc)\nprint(script.goto_definitions()[0].docstring(raw=True))",
            "masked_line": "doc = script.goto_definitions()[0].docstring()",
            "answer": "docstring",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_145"
        },
        {
            "dependency": "jedi",
            "version": "==0.8.1",
            "time": "2014-07-22",
            "description": "The code defines a function `func` and a list `x` with elements 'a', 'b', 'c'. It then evaluates the variables in the scope of the function and accesses the first four pairs of names in the scope using the Jedi library.",
            "code": "from jedi._compatibility import u\nfrom jedi.parser import Parser\nparser = Parser(u('''\nx = ['a', 'b', 'c']\ndef func():\n    y = None\n'''))\nscope = parser.module.subscopes[0]\n\nfrom jedi.evaluate import Evaluator\npairs = list(get_names_of_scope(Evaluator(), scope))\npairs[0]\npairs[1]\npairs[2]\npairs[3]                                        #doctest: +ELLIPSIS\n",
            "masked_code": "from jedi._compatibility import u\nfrom jedi.parser import Parser\nparser = Parser(u('''\nx = ['a', 'b', 'c']\ndef func():\n    y = None\n'''))\nscope = parser.module.subscopes[0]\n\nfrom jedi.evaluate import Evaluator\n<line_mask>\npairs[0]\npairs[1]\npairs[2]\npairs[3]                                        #doctest: +ELLIPSIS\n",
            "masked_line": "pairs = list(get_names_of_scope(Evaluator(), scope))",
            "answer": "get_names_of_scope",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_146"
        },
        {
            "dependency": "Jinja2",
            "version": "==2.7",
            "time": "2013-05-20",
            "description": "The code defines a function named extract_from_ast that takes an abstract syntax tree node and an optional argument babel_style. The function extracts translations from the AST node based on the specified style (default to Babel style). The function returns a list of extracted translations.",
            "code": "from jinja2 import Environment\nenv = Environment()\nnode = env.parse('{{ (_(\"foo\"), _(), ngettext(\"foo\", \"bar\", 42)) }}')\n\ndef extract_from_ast(node, babel_style=True):\n    # implementation here\n    pass\n\nlist(extract_from_ast(node))\nlist(extract_from_ast(node, babel_style=False))\n",
            "masked_code": "from jinja2 import Environment\nenv = Environment()\nnode = env.parse('{{ (_(\"foo\"), _(), ngettext(\"foo\", \"bar\", 42)) }}')\n\ndef extract_from_ast(node, babel_style=True):\n    # implementation here\n    pass\n\n<line_mask>\nlist(extract_from_ast(node, babel_style=False))\n",
            "masked_line": "list(extract_from_ast(node))",
            "answer": "extract_from_ast",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_147"
        },
        {
            "dependency": "Jinja2",
            "version": "==2.7",
            "time": "2013-05-20",
            "description": "This Python code defines two functions: 'is_undefined' checks if a variable is of type 'Undefined' and 'default' returns a default value if the input variable is undefined.",
            "code": "def is_undefined(var):\n    return isinstance(var, Undefined)\n\ndef default(var, default=''):\n    if is_undefined(var):\n        return default\n    return var",
            "masked_code": "<line_mask>\n    return isinstance(var, Undefined)\n\ndef default(var, default=''):\n    if is_undefined(var):\n        return default\n    return var",
            "masked_line": "def is_undefined(var):",
            "answer": "is_undefined",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_148"
        },
        {
            "dependency": "Jinja2",
            "version": "==2.7",
            "time": "2013-05-20",
            "description": "The code defines a template `t` containing a macro named `foo` that returns the value `'42'`. When accessing the `module` attribute of `t` and calling the `foo` macro, it returns `'23'` and `'42'` respectively.",
            "code": "t = Template('{% macro foo() %}42{% endmacro %}23')\nunicode(t.module)\nu'23'\nt.module.foo()\nu'42'",
            "masked_code": "t = Template('{% macro foo() %}42{% endmacro %}23')\n<line_mask>\nu'23'\nt.module.foo()\nu'42'",
            "masked_line": "unicode(t.module)",
            "answer": "module",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_149"
        },
        {
            "dependency": "keras",
            "version": "==0.3.1",
            "time": "2016-01-03",
            "description": "This code generates arrays of input data and labels from each line in a file, using a custom function to process each line. It then fits a model using the generated arrays in batches for a specified number of epochs.",
            "code": "def generate_arrays_from_file(path):\n    while 1:\n        f = open(path)\n        for line in f:\n            # create numpy arrays of input data\n            # and labels, from each line in the file\n            x, y = process_line(line)\n            yield x, y\n        f.close()\n\nmodel.fit_generator(generate_arrays_from_file('/my_file.txt'),\n                    samples_per_epoch=10000, nb_epoch=10)\n",
            "masked_code": "def generate_arrays_from_file(path):\n    while 1:\n        f = open(path)\n        for line in f:\n            # create numpy arrays of input data\n            # and labels, from each line in the file\n            x, y = process_line(line)\n            yield x, y\n        f.close()\n\n<line_mask>\n                    samples_per_epoch=10000, nb_epoch=10)\n",
            "masked_line": "model.fit_generator(generate_arrays_from_file('/my_file.txt'),",
            "answer": "fit_generator",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_151"
        },
        {
            "dependency": "keras",
            "version": "==0.3.1",
            "time": "2016-01-03",
            "description": "This code generates numpy arrays of input data and labels from each line in a file and feeds them to a neural network model for training.",
            "code": "def generate_arrays_from_file(path):\n    while 1:\n        f = open(path)\n        for line in f:\n            # create numpy arrays of input data\n            # and labels, from each line in the file\n            x1, x2, y = process_line(line)\n            yield {'input_1': x1, 'input_2': x2, 'output': y}\n        f.close()\n\ngraph.fit_generator(generate_arrays_from_file('/my_file.txt'),\n                    samples_per_epoch=10000, nb_epoch=10)\n",
            "masked_code": "def generate_arrays_from_file(path):\n    while 1:\n        f = open(path)\n        for line in f:\n            # create numpy arrays of input data\n            # and labels, from each line in the file\n            x1, x2, y = process_line(line)\n            yield {'input_1': x1, 'input_2': x2, 'output': y}\n        f.close()\n\n<line_mask>\n                    samples_per_epoch=10000, nb_epoch=10)\n",
            "masked_line": "graph.fit_generator(generate_arrays_from_file('/my_file.txt'),",
            "answer": "fit_generator",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_152"
        },
        {
            "dependency": "keras",
            "version": "==1.0.8",
            "time": "2016-08-28",
            "description": "The code snippet creates a sequential model consisting of two bidirectional LSTM layers, followed by a dense layer with 5 units and a softmax activation function. It then compiles the model using categorical crossentropy loss and the RMSprop optimizer.",
            "code": "model = Sequential()\nmodel.add(Bidirectional(LSTM(10, return_sequences=True), input_shape=(5, 10)))\nmodel.add(Bidirectional(LSTM(10)))\nmodel.add(Dense(5))\nmodel.add(Activation('softmax'))\nmodel.compile(loss='categorical_crossentropy', optimizer='rmsprop')",
            "masked_code": "model = Sequential()\n<line_mask>\nmodel.add(Bidirectional(LSTM(10)))\nmodel.add(Dense(5))\nmodel.add(Activation('softmax'))\nmodel.compile(loss='categorical_crossentropy', optimizer='rmsprop')",
            "masked_line": "model.add(Bidirectional(LSTM(10, return_sequences=True), input_shape=(5, 10)))",
            "answer": "Bidirectional",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_155"
        },
        {
            "dependency": "keras",
            "version": "==1.1.1",
            "time": "2016-10-31",
            "description": "This code has three main functionalities. \n\n1. Print the batch number at the beginning of every batch during model training.\n2. Plot the loss after every epoch during model training.\n3. Terminate some processes after finishing model training.",
            "code": "# Print the batch number at the beginning of every batch.\nbatch_print_callback = LambdaCallback(on_batch_begin=lambda batch, logs: print(batch))\n\n# Plot the loss after every epoch.\nimport numpy as np\nimport matplotlib.pyplot as plt\nplot_loss_callback = LambdaCallback(on_epoch_end=lambda epoch, logs: plt.plot(np.arange(epoch), logs['loss']))\n\n# Terminate some processes after having finished model training.\nprocesses = ...\ncleanup_callback = LambdaCallback(on_train_end=lambda logs: [p.terminate() for p in processes if p.is_alive()])\n\nmodel.fit(..., callbacks=[batch_print_callback, plot_loss_callback, cleanup_callback])\n",
            "masked_code": "# Print the batch number at the beginning of every batch.\n<line_mask>\n\n# Plot the loss after every epoch.\nimport numpy as np\nimport matplotlib.pyplot as plt\nplot_loss_callback = LambdaCallback(on_epoch_end=lambda epoch, logs: plt.plot(np.arange(epoch), logs['loss']))\n\n# Terminate some processes after having finished model training.\nprocesses = ...\ncleanup_callback = LambdaCallback(on_train_end=lambda logs: [p.terminate() for p in processes if p.is_alive()])\n\nmodel.fit(..., callbacks=[batch_print_callback, plot_loss_callback, cleanup_callback])\n",
            "masked_line": "batch_print_callback = LambdaCallback(on_batch_begin=lambda batch, logs: print(batch))",
            "answer": "LambdaCallback",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_156"
        },
        {
            "dependency": "keras",
            "version": "==1.2.0",
            "time": "2016-12-19",
            "description": "The code changes the default data type in Keras backend from 'float32' to 'float16' using the functions provided by Keras backend.",
            "code": "from keras import backend as K\nK.floatx()\n'float32'\nK.set_floatx('float16')\nK.floatx()\n'float16'\n",
            "masked_code": "from keras import backend as K\nK.floatx()\n'float32'\n<line_mask>\nK.floatx()\n'float16'\n",
            "masked_line": "K.set_floatx('float16')",
            "answer": "set_floatx",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_157"
        },
        {
            "dependency": "keras",
            "version": "==1.2.0",
            "time": "2016-12-19",
            "description": "The code defines and checks the types of variables, placeholders, and tensors in a Keras model.",
            "code": "from keras import backend as K\nnp_var = numpy.array([1, 2])\nK.is_keras_tensor(np_var)\nkeras_var = K.variable(np_var)\nK.is_keras_tensor(keras_var)  # A variable is not a Tensor.\nkeras_placeholder = K.placeholder(shape=(2, 4, 5))\nK.is_keras_tensor(keras_placeholder)  # A placeholder is a Tensor.\n",
            "masked_code": "from keras import backend as K\nnp_var = numpy.array([1, 2])\nK.is_keras_tensor(np_var)\nkeras_var = K.variable(np_var)\n<line_mask>\nkeras_placeholder = K.placeholder(shape=(2, 4, 5))\nK.is_keras_tensor(keras_placeholder)  # A placeholder is a Tensor.\n",
            "masked_line": "K.is_keras_tensor(keras_var)  # A variable is not a Tensor.",
            "answer": "is_keras_tensor",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_158"
        },
        {
            "dependency": "keras",
            "version": "==1.2.0",
            "time": "2016-12-19",
            "description": "The code checks if a placeholder tensor 'a' is sparse or not using keras backend, and then checks if another placeholder tensor 'b' is sparse or not.",
            "code": "from keras import backend as K\na = K.placeholder((2, 2), sparse=False)\nprint(K.is_sparse(a))\nb = K.placeholder((2, 2), sparse=True)\nprint(K.is_sparse(b))\n",
            "masked_code": "from keras import backend as K\na = K.placeholder((2, 2), sparse=False)\nprint(K.is_sparse(a))\nb = K.placeholder((2, 2), sparse=True)\n<line_mask>\n",
            "masked_line": "print(K.is_sparse(b))",
            "answer": "is_sparse",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_159"
        },
        {
            "dependency": "keras",
            "version": "==2.0.7",
            "time": "2017-08-21",
            "description": "This code defines a neural network model using the Keras framework. The model takes two inputs, each with different shapes. The inputs go through separate Dense layers with ReLU activation function before being subtracted from each other. The output of the subtraction is then passed through another Dense layer to generate the final output.",
            "code": "import keras\n\ninput1 = keras.layers.Input(shape=(16,))\nx1 = keras.layers.Dense(8, activation='relu')(input1)\ninput2 = keras.layers.Input(shape=(32,))\nx2 = keras.layers.Dense(8, activation='relu')(input2)\nsubtracted = keras.layers.Subtract()([x1, x2])\n\nout = keras.layers.Dense(4)(subtracted)\nmodel = keras.models.Model(inputs=[input1, input2], outputs=out)\n",
            "masked_code": "import keras\n\ninput1 = keras.layers.Input(shape=(16,))\nx1 = keras.layers.Dense(8, activation='relu')(input1)\ninput2 = keras.layers.Input(shape=(32,))\nx2 = keras.layers.Dense(8, activation='relu')(input2)\n<line_mask>\n\nout = keras.layers.Dense(4)(subtracted)\nmodel = keras.models.Model(inputs=[input1, input2], outputs=out)\n",
            "masked_line": "subtracted = keras.layers.Subtract()([x1, x2])",
            "answer": "Subtract",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_160"
        },
        {
            "dependency": "keras",
            "version": "==2.1.5",
            "time": "2018-03-06",
            "description": "This code generates time series data and corresponding targets with a given length and sampling rate. It then creates a generator for batching the data with specified batch size. The code asserts the correctness of the generator output for the first batch.",
            "code": "from keras.preprocessing.sequence import TimeseriesGenerator\nimport numpy as np\n\ndata = np.array([[i] for i in range(50)])\ntargets = np.array([[i] for i in range(50)])\n\ndata_gen = TimeseriesGenerator(data, targets,\n                               length=10, sampling_rate=2,\n                               batch_size=2)\nassert len(data_gen) == 20\n\nbatch_0 = data_gen[0]\nx, y = batch_0\nassert np.array_equal(x,\n                      np.array([[[0], [2], [4], [6], [8]],\n                                [[1], [3], [5], [7], [9]]]))\nassert np.array_equal(y,\n                      np.array([[10], [11]]))\n",
            "masked_code": "from keras.preprocessing.sequence import TimeseriesGenerator\nimport numpy as np\n\ndata = np.array([[i] for i in range(50)])\ntargets = np.array([[i] for i in range(50)])\n\n<line_mask>\n                               length=10, sampling_rate=2,\n                               batch_size=2)\nassert len(data_gen) == 20\n\nbatch_0 = data_gen[0]\nx, y = batch_0\nassert np.array_equal(x,\n                      np.array([[[0], [2], [4], [6], [8]],\n                                [[1], [3], [5], [7], [9]]]))\nassert np.array_equal(y,\n                      np.array([[10], [11]]))\n",
            "masked_line": "data_gen = TimeseriesGenerator(data, targets,",
            "answer": "TimeseriesGenerator",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_161"
        },
        {
            "dependency": "keras",
            "version": "==2.10.0",
            "time": "2022-08-02",
            "description": "The code creates a simple Tensorflow Keras model with one dense layer of size 1 and input shape of [10]. It then saves the model in the SavedModel format at the specified path '/tmp/simple_keras_model'. Finally, it loads the saved Keras model back and prints a summary of the new model.",
            "code": "import tensorflow as tf\n\n# Create a tf.keras model.\nmodel = tf.keras.Sequential()\nmodel.add(tf.keras.layers.Dense(1, input_shape=[10]))\nmodel.summary()\n\n# Save the tf.keras model in the SavedModel format.\npath = '/tmp/simple_keras_model'\ntf.compat.v1.keras.experimental.export_saved_model(model, path)\n\n# Load the saved keras model back.\nnew_model = tf.compat.v1.keras.experimental.load_from_saved_model(path)\nnew_model.summary()\n",
            "masked_code": "import tensorflow as tf\n\n# Create a tf.keras model.\nmodel = tf.keras.Sequential()\nmodel.add(tf.keras.layers.Dense(1, input_shape=[10]))\nmodel.summary()\n\n# Save the tf.keras model in the SavedModel format.\npath = '/tmp/simple_keras_model'\n<line_mask>\n\n# Load the saved keras model back.\nnew_model = tf.compat.v1.keras.experimental.load_from_saved_model(path)\nnew_model.summary()\n",
            "masked_line": "tf.compat.v1.keras.experimental.export_saved_model(model, path)",
            "answer": "export_saved_model",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_162"
        },
        {
            "dependency": "keras",
            "version": "==2.10.0",
            "time": "2022-08-02",
            "description": "The code creates a simple tf.keras model with one Dense layer and input shape of 10, then saves the model in the SavedModel format at a specified path. Finally, it loads the saved model back and displays its summary.",
            "code": "import tensorflow as tf\n\n# Create a tf.keras model.\nmodel = tf.keras.Sequential()\nmodel.add(tf.keras.layers.Dense(1, input_shape=[10]))\nmodel.summary()\n\n# Save the tf.keras model in the SavedModel format.\npath = '/tmp/simple_keras_model'\ntf.compat.v1.keras.experimental.export_saved_model(model, path)\n\n# Load the saved keras model back.\nnew_model = tf.compat.v1.keras.experimental.load_from_saved_model(path)\nnew_model.summary()\n",
            "masked_code": "import tensorflow as tf\n\n# Create a tf.keras model.\nmodel = tf.keras.Sequential()\nmodel.add(tf.keras.layers.Dense(1, input_shape=[10]))\nmodel.summary()\n\n# Save the tf.keras model in the SavedModel format.\npath = '/tmp/simple_keras_model'\ntf.compat.v1.keras.experimental.export_saved_model(model, path)\n\n# Load the saved keras model back.\n<line_mask>\nnew_model.summary()\n",
            "masked_line": "new_model = tf.compat.v1.keras.experimental.load_from_saved_model(path)",
            "answer": "load_from_saved_model",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_163"
        },
        {
            "dependency": "keras",
            "version": "==2.12.0",
            "time": "2023-02-23",
            "description": "The code creates an ExportArchive object to store an exported model. It tracks a given model and adds two endpoints: \"serve\" for serving the model with inference only, and \"call_inference\" and \"call_training\" for calling the model with inference and training, respectively. Finally, it writes out the ExportArchive object to a specified location.",
            "code": "export_archive = ExportArchive()\nexport_archive.track(model)\nexport_archive.add_endpoint(\n    name=\"serve\",\n    fn=model.call,\n    input_signature=[tf.TensorSpec(shape=(None, 3), dtype=tf.float32)],\n)\nexport_archive.write_out(\"path/to/location\")\n\nexport_archive = ExportArchive()\nexport_archive.track(model)\nexport_archive.add_endpoint(\n    name=\"call_inference\",\n    fn=lambda x: model.call(x, training=False),\n    input_signature=[tf.TensorSpec(shape=(None, 3), dtype=tf.float32)],\n)\nexport_archive.add_endpoint(\n    name=\"call_training\",\n    fn=lambda x: model.call(x, training=True),\n    input_signature=[tf.TensorSpec(shape=(None, 3), dtype=tf.float32)],\n)\nexport_archive.write_out(\"path/to/location\")\n",
            "masked_code": "export_archive = ExportArchive()\nexport_archive.track(model)\nexport_archive.add_endpoint(\n    name=\"serve\",\n    fn=model.call,\n    input_signature=[tf.TensorSpec(shape=(None, 3), dtype=tf.float32)],\n)\nexport_archive.write_out(\"path/to/location\")\n\n<line_mask>\nexport_archive.track(model)\nexport_archive.add_endpoint(\n    name=\"call_inference\",\n    fn=lambda x: model.call(x, training=False),\n    input_signature=[tf.TensorSpec(shape=(None, 3), dtype=tf.float32)],\n)\nexport_archive.add_endpoint(\n    name=\"call_training\",\n    fn=lambda x: model.call(x, training=True),\n    input_signature=[tf.TensorSpec(shape=(None, 3), dtype=tf.float32)],\n)\nexport_archive.write_out(\"path/to/location\")\n",
            "masked_line": "export_archive = ExportArchive()",
            "answer": "ExportArchive",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_164"
        },
        {
            "dependency": "keras",
            "version": "==2.12.0",
            "time": "2023-02-23",
            "description": "The code exports a model, tracks its usage, adds an endpoint for serving the model, saves optimizer variables, and writes out the model to a specific location. The code then loads the saved model and retrieves the optimizer variables.",
            "code": "export_archive = ExportArchive()\nexport_archive.track(model)\nexport_archive.add_endpoint(\n    name=\"serve\",\n    fn=model.call,\n    input_signature=[tf.TensorSpec(shape=(None, 3), dtype=tf.float32)],\n)\nexport_archive.add_variable_collection(\n    name=\"optimizer_variables\", variables=model.optimizer.variables)\nexport_archive.write_out(\"path/to/location\")\n\nrevived_object = tf.saved_model.load(\"path/to/location\")\noptimizer_variables = revived_object.optimizer_variables\n",
            "masked_code": "export_archive = ExportArchive()\nexport_archive.track(model)\nexport_archive.add_endpoint(\n    name=\"serve\",\n    fn=model.call,\n    input_signature=[tf.TensorSpec(shape=(None, 3), dtype=tf.float32)],\n)\n<line_mask>\n    name=\"optimizer_variables\", variables=model.optimizer.variables)\nexport_archive.write_out(\"path/to/location\")\n\nrevived_object = tf.saved_model.load(\"path/to/location\")\noptimizer_variables = revived_object.optimizer_variables\n",
            "masked_line": "export_archive.add_variable_collection(",
            "answer": "add_variable_collection",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_165"
        },
        {
            "dependency": "keras",
            "version": "==2.12.0",
            "time": "2023-02-23",
            "description": "The code defines different methods for preprocessing different types of input features (float, integer, and string) in a machine learning model. These methods include standardization, rescaling, discretization, indexing, and hashing, with the option of one-hot encoding the resulting discrete representations.",
            "code": "# Plain float values.\nFeatureSpace.float(name=None)\n\n# Float values to be preprocessed via featurewise standardization\n# (i.e. via a `keras.layers.Normalization` layer).\nFeatureSpace.float_normalized(name=None)\n\n# Float values to be preprocessed via linear rescaling\n# (i.e. via a `keras.layers.Rescaling` layer).\nFeatureSpace.float_rescaled(scale=1., offset=0., name=None)\n\n# Float values to be discretized. By default, the discrete\n# representation will then be one-hot encoded.\nFeatureSpace.float_discretized(\n    num_bins, bin_boundaries=None, output_mode=\"one_hot\", name=None)\n\n# Integer values to be indexed. By default, the discrete\n# representation will then be one-hot encoded.\nFeatureSpace.integer_categorical(\n    max_tokens=None, num_oov_indices=1, output_mode=\"one_hot\", name=None)\n\n# String values to be indexed. By default, the discrete\n# representation will then be one-hot encoded.\nFeatureSpace.string_categorical(\n    max_tokens=None, num_oov_indices=1, output_mode=\"one_hot\", name=None)\n\n# Integer values to be hashed into a fixed number of bins.\n# By default, the discrete representation will then be one-hot encoded.\nFeatureSpace.integer_hashed(num_bins, output_mode=\"one_hot\", name=None)\n\n# String values to be hashed into a fixed number of bins.\n# By default, the discrete representation will then be one-hot encoded.\nFeatureSpace.string_hashed(num_bins, output_mode=\"one_hot\", name=None)\n",
            "masked_code": "# Plain float values.\nFeatureSpace.float(name=None)\n\n# Float values to be preprocessed via featurewise standardization\n# (i.e. via a `keras.layers.Normalization` layer).\n<line_mask>\n\n# Float values to be preprocessed via linear rescaling\n# (i.e. via a `keras.layers.Rescaling` layer).\nFeatureSpace.float_rescaled(scale=1., offset=0., name=None)\n\n# Float values to be discretized. By default, the discrete\n# representation will then be one-hot encoded.\nFeatureSpace.float_discretized(\n    num_bins, bin_boundaries=None, output_mode=\"one_hot\", name=None)\n\n# Integer values to be indexed. By default, the discrete\n# representation will then be one-hot encoded.\nFeatureSpace.integer_categorical(\n    max_tokens=None, num_oov_indices=1, output_mode=\"one_hot\", name=None)\n\n# String values to be indexed. By default, the discrete\n# representation will then be one-hot encoded.\nFeatureSpace.string_categorical(\n    max_tokens=None, num_oov_indices=1, output_mode=\"one_hot\", name=None)\n\n# Integer values to be hashed into a fixed number of bins.\n# By default, the discrete representation will then be one-hot encoded.\nFeatureSpace.integer_hashed(num_bins, output_mode=\"one_hot\", name=None)\n\n# String values to be hashed into a fixed number of bins.\n# By default, the discrete representation will then be one-hot encoded.\nFeatureSpace.string_hashed(num_bins, output_mode=\"one_hot\", name=None)\n",
            "masked_line": "FeatureSpace.float_normalized(name=None)",
            "answer": "FeatureSpace",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_166"
        },
        {
            "dependency": "keras",
            "version": "==2.13.1",
            "time": "2023-06-27",
            "description": "The code calculates the F-beta score for a given beta value, precision, and recall values.",
            "code": "b2 = beta ** 2\nf_beta_score = (1 + b2) * (precision * recall) / (precision * b2 + recall)\n\nmetric = tf.keras.metrics.FBetaScore(beta=2.0, threshold=0.5)\ny_true = np.array([[1, 1, 1],\n                   [1, 0, 0],\n                   [1, 1, 0]], np.int32)\ny_pred = np.array([[0.2, 0.6, 0.7],\n                   [0.2, 0.6, 0.6],\n                   [0.6, 0.8, 0.0]], np.float32)\nmetric.update_state(y_true, y_pred)\nresult = metric.result()\nresult.numpy()\n",
            "masked_code": "b2 = beta ** 2\nf_beta_score = (1 + b2) * (precision * recall) / (precision * b2 + recall)\n\n<line_mask>\ny_true = np.array([[1, 1, 1],\n                   [1, 0, 0],\n                   [1, 1, 0]], np.int32)\ny_pred = np.array([[0.2, 0.6, 0.7],\n                   [0.2, 0.6, 0.6],\n                   [0.6, 0.8, 0.0]], np.float32)\nmetric.update_state(y_true, y_pred)\nresult = metric.result()\nresult.numpy()\n",
            "masked_line": "metric = tf.keras.metrics.FBetaScore(beta=2.0, threshold=0.5)",
            "answer": "FBetaScore",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_167"
        },
        {
            "dependency": "keras",
            "version": "==2.1.6",
            "time": "2018-04-23",
            "description": "This code creates two separate neural networks with one input layer and one hidden layer each, and then merges these two models by concatenating their output layers along axis 1.",
            "code": "model1 = Sequential()\nmodel1.add(Dense(32, input_dim=32))\nmodel2 = Sequential()\nmodel2.add(Dense(32, input_dim=32))\nmerged_model = Sequential()\nmerged_model.add(Merge([model1, model2], mode='concat', concat_axis=1))\n",
            "masked_code": "model1 = Sequential()\nmodel1.add(Dense(32, input_dim=32))\nmodel2 = Sequential()\nmodel2.add(Dense(32, input_dim=32))\nmerged_model = Sequential()\n<line_mask>\n",
            "masked_line": "merged_model.add(Merge([model1, model2], mode='concat', concat_axis=1))",
            "answer": "Merge",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_168"
        },
        {
            "dependency": "keras",
            "version": "==2.1.6",
            "time": "2018-04-23",
            "description": "This code generates time series data and corresponding targets with specified length, sampling rate, and batch size using the TimeSeriesGenerator class from Keras. It verifies the correctness of the generated data and targets for the first batch.",
            "code": "from keras.preprocessing.sequence import TimeseriesGenerator\nimport numpy as np\n\ndata = np.array([[i] for i in range(50)])\ntargets = np.array([[i] for i in range(50)])\n\ndata_gen = TimeseriesGenerator(data, targets,\n                               length=10, sampling_rate=2,\n                               batch_size=2)\nassert len(data_gen) == 20\n\nbatch_0 = data_gen[0]\nx, y = batch_0\nassert np.array_equal(x,\n                      np.array([[[0], [2], [4], [6], [8]],\n                                [[1], [3], [5], [7], [9]]]))\nassert np.array_equal(y,\n                      np.array([[10], [11]]))\n",
            "masked_code": "<line_mask>\nimport numpy as np\n\ndata = np.array([[i] for i in range(50)])\ntargets = np.array([[i] for i in range(50)])\n\ndata_gen = TimeseriesGenerator(data, targets,\n                               length=10, sampling_rate=2,\n                               batch_size=2)\nassert len(data_gen) == 20\n\nbatch_0 = data_gen[0]\nx, y = batch_0\nassert np.array_equal(x,\n                      np.array([[[0], [2], [4], [6], [8]],\n                                [[1], [3], [5], [7], [9]]]))\nassert np.array_equal(y,\n                      np.array([[10], [11]]))\n",
            "masked_line": "from keras.preprocessing.sequence import TimeseriesGenerator",
            "answer": "TimeseriesGenerator",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_169"
        },
        {
            "dependency": "keras",
            "version": "==2.2.3",
            "time": "2018-10-01",
            "description": "This Python code generates time series data and corresponding targets in batches using the TimeseriesGenerator from the Keras library. It creates batches of sequences with a specified length, sampling rate, and batch size.",
            "code": "from keras.preprocessing.sequence import TimeseriesGenerator\nimport numpy as np\n\ndata = np.array([[i] for i in range(50)])\ntargets = np.array([[i] for i in range(50)])\n\ndata_gen = TimeseriesGenerator(data, targets,\n                               length=10, sampling_rate=2,\n                               batch_size=2)\nassert len(data_gen) == 20\n\nbatch_0 = data_gen[0]\nx, y = batch_0\nassert np.array_equal(x,\n                      np.array([[[0], [2], [4], [6], [8]],\n                                [[1], [3], [5], [7], [9]]]))\nassert np.array_equal(y,\n                      np.array([[10], [11]]))\n",
            "masked_code": "from keras.preprocessing.sequence import TimeseriesGenerator\nimport numpy as np\n\ndata = np.array([[i] for i in range(50)])\ntargets = np.array([[i] for i in range(50)])\n\n<line_mask>\n                               length=10, sampling_rate=2,\n                               batch_size=2)\nassert len(data_gen) == 20\n\nbatch_0 = data_gen[0]\nx, y = batch_0\nassert np.array_equal(x,\n                      np.array([[[0], [2], [4], [6], [8]],\n                                [[1], [3], [5], [7], [9]]]))\nassert np.array_equal(y,\n                      np.array([[10], [11]]))\n",
            "masked_line": "data_gen = TimeseriesGenerator(data, targets,",
            "answer": "TimeseriesGenerator",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_170"
        },
        {
            "dependency": "keras",
            "version": "==2.2.5",
            "time": "2019-08-22",
            "description": "This code saves a Keras model to a specified file path using a file I/O proxy, then loads the saved model from the file path, and finally deletes the file from the file path.",
            "code": "with tf_file_io_proxy('keras.engine.saving.tf_file_io') as file_io_proxy:\n    gcs_filepath = file_io_proxy.get_filepath(filename='model.h5')\n    save_model(model, gcs_filepath)\n    file_io_proxy.assert_exists(gcs_filepath)\n    new_model_gcs = load_model(gcs_filepath)\n    file_io_proxy.delete_file(gcs_filepath)  # cleanup\n",
            "masked_code": "<line_mask>\n    gcs_filepath = file_io_proxy.get_filepath(filename='model.h5')\n    save_model(model, gcs_filepath)\n    file_io_proxy.assert_exists(gcs_filepath)\n    new_model_gcs = load_model(gcs_filepath)\n    file_io_proxy.delete_file(gcs_filepath)  # cleanup\n",
            "masked_line": "with tf_file_io_proxy('keras.engine.saving.tf_file_io') as file_io_proxy:",
            "answer": "tf_file_io_proxy",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_171"
        },
        {
            "dependency": "keras",
            "version": "==2.3.0",
            "time": "2019-09-17",
            "description": "This code defines a class MeanSquaredError that inherits from the Loss class. It has a method call that calculates the mean squared error between the predicted values y_pred and the actual values y_true.",
            "code": "class MeanSquaredError(Loss):\n    def call(self, y_true, y_pred):\n        y_pred = ops.convert_to_tensor(y_pred)\n        y_true = math_ops.cast(y_true, y_pred.dtype)\n        return K.mean(math_ops.square(y_pred - y_true), axis=-1)\n",
            "masked_code": "<line_mask>\n    def call(self, y_true, y_pred):\n        y_pred = ops.convert_to_tensor(y_pred)\n        y_true = math_ops.cast(y_true, y_pred.dtype)\n        return K.mean(math_ops.square(y_pred - y_true), axis=-1)\n",
            "masked_line": "class MeanSquaredError(Loss):",
            "answer": "Loss",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_172"
        },
        {
            "dependency": "keras",
            "version": "==2.3.1",
            "time": "2019-10-07",
            "description": "This code defines a class named MeanSquaredError, which extends from the Loss class. It has a method call that takes two parameters y_true and y_pred, converts them to tensors, calculates the mean squared error between the predicted values (y_pred) and the true values (y_true), and returns the result.",
            "code": "class MeanSquaredError(Loss):\n    def call(self, y_true, y_pred):\n        y_pred = ops.convert_to_tensor(y_pred)\n        y_true = math_ops.cast(y_true, y_pred.dtype)\n        return K.mean(math_ops.square(y_pred - y_true), axis=-1)\n",
            "masked_code": "<line_mask>\n    def call(self, y_true, y_pred):\n        y_pred = ops.convert_to_tensor(y_pred)\n        y_true = math_ops.cast(y_true, y_pred.dtype)\n        return K.mean(math_ops.square(y_pred - y_true), axis=-1)\n",
            "masked_line": "class MeanSquaredError(Loss):",
            "answer": "Loss",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_173"
        },
        {
            "dependency": "keras",
            "version": "==2.3.1",
            "time": "2019-10-07",
            "description": "The code defines three LambdaCallback functions: batch_print_callback, json_logging_callback, and cleanup_callback. \nbatch_print_callback prints the batch number at the beginning of each batch during model training. \njson_logging_callback logs the epoch number and loss value in a JSON format to a file called 'loss_log.json' at the end of each epoch, and closes the file at the end of model training. \ncleanup_callback terminates any processes that are still alive at the end of model training. \nThese LambdaCallback functions are then passed as callbacks to the model.fit function.",
            "code": "batch_print_callback = LambdaCallback(\n    on_batch_begin=lambda batch,logs: print(batch))\n\njson_log = open('loss_log.json', mode='wt', buffering=1)\njson_logging_callback = LambdaCallback(\n    on_epoch_end=lambda epoch, logs: json_log.write(\n        json.dumps({'epoch': epoch, 'loss': logs['loss']}) + '\\n'),\n    on_train_end=lambda logs: json_log.close()\n)\n\nprocesses = ...\ncleanup_callback = LambdaCallback(\n    on_train_end=lambda logs: [\n        p.terminate() for p in processes if p.is_alive()])\n\nmodel.fit(...,\n          callbacks=[batch_print_callback,\n                     json_logging_callback,\n                     cleanup_callback])\n",
            "masked_code": "<line_mask>\n    on_batch_begin=lambda batch,logs: print(batch))\n\njson_log = open('loss_log.json', mode='wt', buffering=1)\njson_logging_callback = LambdaCallback(\n    on_epoch_end=lambda epoch, logs: json_log.write(\n        json.dumps({'epoch': epoch, 'loss': logs['loss']}) + '\\n'),\n    on_train_end=lambda logs: json_log.close()\n)\n\nprocesses = ...\ncleanup_callback = LambdaCallback(\n    on_train_end=lambda logs: [\n        p.terminate() for p in processes if p.is_alive()])\n\nmodel.fit(...,\n          callbacks=[batch_print_callback,\n                     json_logging_callback,\n                     cleanup_callback])\n",
            "masked_line": "batch_print_callback = LambdaCallback(",
            "answer": "LambdaCallback",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_174"
        },
        {
            "dependency": "keras",
            "version": "==2.3.1",
            "time": "2019-10-07",
            "description": "This code defines a function that reads data from a file line by line, processes each line to create numpy arrays of input data and labels, and yields batches of data as dictionaries. The generated data is then used to train a model using model.fit_generator().",
            "code": "def generate_arrays_from_file(path):\n    while True:\n        with open(path) as f:\n            for line in f:\n                # create numpy arrays of input data\n                # and labels, from each line in the file\n                x1, x2, y = process_line(line)\n                yield ({'input_1': x1, 'input_2': x2}, {'output': y})\n\nmodel.fit_generator(generate_arrays_from_file('/my_file.txt'),\n                    steps_per_epoch=10000, epochs=10)\n",
            "masked_code": "def generate_arrays_from_file(path):\n    while True:\n        with open(path) as f:\n            for line in f:\n                # create numpy arrays of input data\n                # and labels, from each line in the file\n                x1, x2, y = process_line(line)\n                yield ({'input_1': x1, 'input_2': x2}, {'output': y})\n\n<line_mask>\n                    steps_per_epoch=10000, epochs=10)\n",
            "masked_line": "model.fit_generator(generate_arrays_from_file('/my_file.txt'),",
            "answer": "fit_generator",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_175"
        },
        {
            "dependency": "keras",
            "version": "==2.3.1",
            "time": "2019-10-07",
            "description": "This code initializes a sequential model, adds an embedding layer with input shape (10,), compiles the model using RMSprop optimizer and Mean Squared Error loss function, generates a random input array of shape (32, 10), and finally predicts the output using the model. The code then asserts that the shape of the output array is (32, 10, 64).",
            "code": "model = Sequential()\nmodel.add(Embedding(1000, 64, input_length=10))\ninput_array = np.random.randint(1000, size=(32, 10))\nmodel.compile('rmsprop', 'mse')\noutput_array = model.predict(input_array)\nassert output_array.shape == (32, 10, 64)\n",
            "masked_code": "model = Sequential()\n<line_mask>\ninput_array = np.random.randint(1000, size=(32, 10))\nmodel.compile('rmsprop', 'mse')\noutput_array = model.predict(input_array)\nassert output_array.shape == (32, 10, 64)\n",
            "masked_line": "model.add(Embedding(1000, 64, input_length=10))",
            "answer": "Embedding",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_176"
        },
        {
            "dependency": "keras",
            "version": "==2.3.1",
            "time": "2019-10-07",
            "description": "This code creates a neural network model with two input layers, each followed by a dense layer with 8 neurons and ReLU activation function. The output of the two dense layers is added together using the Add layer, and then passed through another dense layer with 4 neurons. The final model takes two inputs and produces a single output.",
            "code": "import keras\ninput1 = keras.layers.Input(shape=(16,))\nx1 = keras.layers.Dense(8, activation='relu')(input1)\ninput2 = keras.layers.Input(shape=(32,))\nx2 = keras.layers.Dense(8, activation='relu')(input2)\nadded = keras.layers.Add()([x1, x2])\nout = keras.layers.Dense(4)(added)\nmodel = keras.models.Model(inputs=[input1, input2], outputs=out)",
            "masked_code": "import keras\ninput1 = keras.layers.Input(shape=(16,))\nx1 = keras.layers.Dense(8, activation='relu')(input1)\ninput2 = keras.layers.Input(shape=(32,))\nx2 = keras.layers.Dense(8, activation='relu')(input2)\n<line_mask>\nout = keras.layers.Dense(4)(added)\nmodel = keras.models.Model(inputs=[input1, input2], outputs=out)",
            "masked_line": "added = keras.layers.Add()([x1, x2])",
            "answer": "Add",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_177"
        },
        {
            "dependency": "keras",
            "version": "==2.3.1",
            "time": "2019-10-07",
            "description": "This code implements a neural network model with two input layers, each connected to a dense layer with 8 units and ReLU activation function. The output is then calculated as the element-wise subtraction of the outputs from the two dense layers, followed by a dense layer with 4 units. The final model takes two sets of inputs and outputs a single vector.",
            "code": "import keras\ninput1 = keras.layers.Input(shape=(16,))\nx1 = keras.layers.Dense(8, activation='relu')(input1)\ninput2 = keras.layers.Input(shape=(32,))\nx2 = keras.layers.Dense(8, activation='relu')(input2)\nsubtracted = keras.layers.Subtract()([x1, x2])\nout = keras.layers.Dense(4)(subtracted)\nmodel = keras.models.Model(inputs=[input1, input2], outputs=out)",
            "masked_code": "import keras\ninput1 = keras.layers.Input(shape=(16,))\nx1 = keras.layers.Dense(8, activation='relu')(input1)\ninput2 = keras.layers.Input(shape=(32,))\nx2 = keras.layers.Dense(8, activation='relu')(input2)\n<line_mask>\nout = keras.layers.Dense(4)(subtracted)\nmodel = keras.models.Model(inputs=[input1, input2], outputs=out)",
            "masked_line": "subtracted = keras.layers.Subtract()([x1, x2])",
            "answer": "Subtract",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_178"
        },
        {
            "dependency": "keras",
            "version": "==2.3.1",
            "time": "2019-10-07",
            "description": "This code defines a neural network model with two Bidirectional LSTM layers followed by a Dense layer with 5 units and a softmax activation function. The model is compiled using categorical crossentropy loss and the rmsprop optimizer.",
            "code": "model = Sequential()\nmodel.add(Bidirectional(LSTM(10, return_sequences=True), input_shape=(5, 10)))\nmodel.add(Bidirectional(LSTM(10)))\nmodel.add(Dense(5))\nmodel.add(Activation('softmax'))\nmodel.compile(loss='categorical_crossentropy', optimizer='rmsprop')\n",
            "masked_code": "model = Sequential()\nmodel.add(Bidirectional(LSTM(10, return_sequences=True), input_shape=(5, 10)))\n<line_mask>\nmodel.add(Dense(5))\nmodel.add(Activation('softmax'))\nmodel.compile(loss='categorical_crossentropy', optimizer='rmsprop')\n",
            "masked_line": "model.add(Bidirectional(LSTM(10)))",
            "answer": "Bidirectional",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_179"
        },
        {
            "dependency": "keras",
            "version": "==2.3.1",
            "time": "2019-10-07",
            "description": "This code generates time series data and targets using a specified length and sampling rate, and then creates batches of data and targets with a specified batch size. It asserts the length of the data generator and checks the contents of the first batch against expected values.",
            "code": "from keras.preprocessing.sequence import TimeseriesGenerator\nimport numpy as np\n\ndata = np.array([[i] for i in range(50)])\ntargets = np.array([[i] for i in range(50)])\n\ndata_gen = TimeseriesGenerator(data, targets,\n                               length=10, sampling_rate=2,\n                               batch_size=2)\nassert len(data_gen) == 20\n\nbatch_0 = data_gen[0]\nx, y = batch_0\nassert np.array_equal(x,\n                      np.array([[[0], [2], [4], [6], [8]],\n                                [[1], [3], [5], [7], [9]]]))\nassert np.array_equal(y,\n                      np.array([[10], [11]]))\n",
            "masked_code": "<line_mask>\nimport numpy as np\n\ndata = np.array([[i] for i in range(50)])\ntargets = np.array([[i] for i in range(50)])\n\ndata_gen = TimeseriesGenerator(data, targets,\n                               length=10, sampling_rate=2,\n                               batch_size=2)\nassert len(data_gen) == 20\n\nbatch_0 = data_gen[0]\nx, y = batch_0\nassert np.array_equal(x,\n                      np.array([[[0], [2], [4], [6], [8]],\n                                [[1], [3], [5], [7], [9]]]))\nassert np.array_equal(y,\n                      np.array([[10], [11]]))\n",
            "masked_line": "from keras.preprocessing.sequence import TimeseriesGenerator",
            "answer": "TimeseriesGenerator",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_180"
        },
        {
            "dependency": "keras",
            "version": "==2.3.1",
            "time": "2019-10-07",
            "description": "This code saves a Keras model to a file, then loads the model from the saved file, and finally deletes the saved file.",
            "code": "with tf_file_io_proxy('keras.engine.saving.tf_file_io') as file_io_proxy:\n    gcs_filepath = file_io_proxy.get_filepath(filename='model.h5')\n    save_model(model, gcs_filepath)\n    file_io_proxy.assert_exists(gcs_filepath)\n    new_model_gcs = load_model(gcs_filepath)\n    file_io_proxy.delete_file(gcs_filepath)  # cleanup\n",
            "masked_code": "<line_mask>\n    gcs_filepath = file_io_proxy.get_filepath(filename='model.h5')\n    save_model(model, gcs_filepath)\n    file_io_proxy.assert_exists(gcs_filepath)\n    new_model_gcs = load_model(gcs_filepath)\n    file_io_proxy.delete_file(gcs_filepath)  # cleanup\n",
            "masked_line": "with tf_file_io_proxy('keras.engine.saving.tf_file_io') as file_io_proxy:",
            "answer": "tf_file_io_proxy",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_181"
        },
        {
            "dependency": "keras",
            "version": "==2.3.1",
            "time": "2019-10-07",
            "description": "The code converts a numpy array to a new array with the same data type as the Keras backend float type.",
            "code": "from keras import backend as K\nK.floatx()\narr = numpy.array([1.0, 2.0], dtype='float64')\narr.dtype\nnew_arr = K.cast_to_floatx(arr)\nnew_arr\nnew_arr.dtype\n",
            "masked_code": "from keras import backend as K\nK.floatx()\narr = numpy.array([1.0, 2.0], dtype='float64')\narr.dtype\n<line_mask>\nnew_arr\nnew_arr.dtype\n",
            "masked_line": "new_arr = K.cast_to_floatx(arr)",
            "answer": "cast_to_floatx",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_182"
        },
        {
            "dependency": "keras",
            "version": "==2.3.1",
            "time": "2019-10-07",
            "description": "The code normalizes the data format between 'channels_first' and 'channels_last' for Keras backend.",
            "code": "from keras import backend as K\nK.normalize_data_format(None)\n'channels_first'\nK.normalize_data_format('channels_last')\n'channels_last'\n",
            "masked_code": "from keras import backend as K\n<line_mask>\n'channels_first'\nK.normalize_data_format('channels_last')\n'channels_last'\n",
            "masked_line": "K.normalize_data_format(None)",
            "answer": "normalize_data_format",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_184"
        },
        {
            "dependency": "keras",
            "version": "==2.3.1",
            "time": "2019-10-07",
            "description": "This code creates two 2x2 placeholders in Keras and prints whether each of them is sparse or not.",
            "code": "from keras import backend as K\na = K.placeholder((2, 2), sparse=False)\nprint(K.is_sparse(a))\nb = K.placeholder((2, 2), sparse=True)\nprint(K.is_sparse(b))\n",
            "masked_code": "from keras import backend as K\na = K.placeholder((2, 2), sparse=False)\n<line_mask>\nb = K.placeholder((2, 2), sparse=True)\nprint(K.is_sparse(b))\n",
            "masked_line": "print(K.is_sparse(a))",
            "answer": "is_sparse",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_185"
        },
        {
            "dependency": "keras",
            "version": "==2.3.1",
            "time": "2019-10-07",
            "description": "This code defines a tensor placeholder with shape (2, 4, 5) using Keras backend, then creates a variable initialized with a numpy array values, and finally retrieves the shape of the variable.",
            "code": "from keras import backend as K\ninputs = K.placeholder(shape=(2, 4, 5))\nK.int_shape(inputs)\nval = np.array([[1, 2], [3, 4]])\nkvar = K.variable(value=val)\nK.int_shape(kvar)\n",
            "masked_code": "from keras import backend as K\ninputs = K.placeholder(shape=(2, 4, 5))\n<line_mask>\nval = np.array([[1, 2], [3, 4]])\nkvar = K.variable(value=val)\nK.int_shape(kvar)\n",
            "masked_line": "K.int_shape(inputs)",
            "answer": "int_shape",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_186"
        },
        {
            "dependency": "keras",
            "version": "==2.3.1",
            "time": "2019-10-07",
            "description": "This code creates a placeholder tensor with shape (2, 4, 5) using Keras backend, and then creates a variable tensor initialized with the value `[[1, 2], [3, 4]]`. Finally, the code checks the number of dimensions of the input tensor and the variable tensor.",
            "code": "from keras import backend as K\ninputs = K.placeholder(shape=(2, 4, 5))\nval = np.array([[1, 2], [3, 4]])\nkvar = K.variable(value=val)\nK.ndim(inputs)\nK.ndim(kvar)\n",
            "masked_code": "from keras import backend as K\ninputs = K.placeholder(shape=(2, 4, 5))\nval = np.array([[1, 2], [3, 4]])\nkvar = K.variable(value=val)\nK.ndim(inputs)\n<line_mask>\n",
            "masked_line": "K.ndim(kvar)",
            "answer": "ndim",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_187"
        },
        {
            "dependency": "keras",
            "version": "==2.3.1",
            "time": "2019-10-07",
            "description": "The code defines and prints the data types of placeholders and variables in the Keras backend, including specifying the shape and data types for the placeholders and variables.",
            "code": "from keras import backend as K\nprint(K.dtype(K.placeholder(shape=(2,4,5))))\nprint(K.dtype(K.placeholder(shape=(2,4,5), dtype='float32')))\nprint(K.dtype(K.placeholder(shape=(2,4,5), dtype='float64')))\nkvar = K.variable(np.array([[1, 2], [3, 4]]))\nprint(K.dtype(kvar))\nkvar = K.variable(np.array([[1, 2], [3, 4]]), dtype='float32')\nprint(K.dtype(kvar))\n",
            "masked_code": "from keras import backend as K\nprint(K.dtype(K.placeholder(shape=(2,4,5))))\nprint(K.dtype(K.placeholder(shape=(2,4,5), dtype='float32')))\nprint(K.dtype(K.placeholder(shape=(2,4,5), dtype='float64')))\nkvar = K.variable(np.array([[1, 2], [3, 4]]))\n<line_mask>\nkvar = K.variable(np.array([[1, 2], [3, 4]]), dtype='float32')\nprint(K.dtype(kvar))\n",
            "masked_line": "print(K.dtype(kvar))",
            "answer": "dtype",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_188"
        },
        {
            "dependency": "keras",
            "version": "==2.3.1",
            "time": "2019-10-07",
            "description": "The code defines and transposes a tensor variable, and then defines and transposes a placeholder tensor.",
            "code": "var = K.variable([[1, 2, 3], [4, 5, 6]])\nK.eval(var)\nvar_transposed = K.transpose(var)\nK.eval(var_transposed)\n\n\ninputs = K.placeholder((2, 3))\ninputs\ninput_transposed = K.transpose(inputs)\ninput_transposed\n",
            "masked_code": "var = K.variable([[1, 2, 3], [4, 5, 6]])\nK.eval(var)\n<line_mask>\nK.eval(var_transposed)\n\n\ninputs = K.placeholder((2, 3))\ninputs\ninput_transposed = K.transpose(inputs)\ninput_transposed\n",
            "masked_line": "var_transposed = K.transpose(var)",
            "answer": "transpose",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_189"
        },
        {
            "dependency": "keras",
            "version": "==2.3.1",
            "time": "2019-10-07",
            "description": "The code creates a Keras variable initialized with random values of shape (2, 3), and then tiles the identity matrix of shape (2, 2) to match the shape of the variable. Finally, it evaluates and returns the tiled identity matrix.",
            "code": "from keras import backend as K\nimport numpy as np\n\nkvar = K.variable(np.random.random((2, 3)))\nkvar_tile = K.tile(K.eye(2), (2, 3))\nK.eval(kvar_tile)\n",
            "masked_code": "from keras import backend as K\nimport numpy as np\n\nkvar = K.variable(np.random.random((2, 3)))\n<line_mask>\nK.eval(kvar_tile)\n",
            "masked_line": "kvar_tile = K.tile(K.eye(2), (2, 3))",
            "answer": "tile",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_190"
        },
        {
            "dependency": "keras",
            "version": "==2.3.1",
            "time": "2019-10-07",
            "description": "Calculate the batch dot product of x_batch and y_batch matrices along the specified axes.",
            "code": "inner_products = []\nfor xi, yi in zip(x, y):\n    inner_products.append(xi.dot(yi))\nresult = stack(inner_products)\n\n\nx_batch = K.ones(shape=(32, 20, 1))\ny_batch = K.ones(shape=(32, 30, 20))\nxy_batch_dot = K.batch_dot(x_batch, y_batch, axes=(1, 2))\nK.int_shape(xy_batch_dot)\n(32, 1, 30)\n",
            "masked_code": "inner_products = []\nfor xi, yi in zip(x, y):\n    inner_products.append(xi.dot(yi))\nresult = stack(inner_products)\n\n\nx_batch = K.ones(shape=(32, 20, 1))\ny_batch = K.ones(shape=(32, 30, 20))\n<line_mask>\nK.int_shape(xy_batch_dot)\n(32, 1, 30)\n",
            "masked_line": "xy_batch_dot = K.batch_dot(x_batch, y_batch, axes=(1, 2))",
            "answer": "batch_dot",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_192"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "The code defines a custom callback class `MyCallback` which sets a global variable `training_finished` to True when training ends. Additionally, it creates a neural network model with one input and one output, compiles it with mean squared error loss, and trains it on a single input-output pair using the defined callback. Finally, it asserts that `training_finished` variable is True, implying that training has successfully completed.",
            "code": "class MyCallback(tf.keras.callbacks.Callback):\n    def on_train_end(self, logs=None):\n        global training_finished\n        training_finished = True\n\nmodel = tf.keras.Sequential([tf.keras.layers.Dense(1, input_shape=(1,))])\nmodel.compile(loss='mean_squared_error')\nmodel.fit(tf.constant([[1.0]]), tf.constant([[1.0]]),\n          callbacks=[MyCallback()])\nassert training_finished == True\n",
            "masked_code": "<line_mask>\n    def on_train_end(self, logs=None):\n        global training_finished\n        training_finished = True\n\nmodel = tf.keras.Sequential([tf.keras.layers.Dense(1, input_shape=(1,))])\nmodel.compile(loss='mean_squared_error')\nmodel.fit(tf.constant([[1.0]]), tf.constant([[1.0]]),\n          callbacks=[MyCallback()])\nassert training_finished == True\n",
            "masked_line": "class MyCallback(tf.keras.callbacks.Callback):",
            "answer": "Callback",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_193"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "The code performs model training with specified loss function, optimizer, and metrics. It also uses a ModelCheckpoint callback to save the best model weights based on validation accuracy during training. Finally, it loads the best weights from the saved checkpoint file.",
            "code": "model.compile(loss=..., optimizer=...,\n              metrics=['accuracy'])\n\nEPOCHS = 10\ncheckpoint_filepath = '/tmp/checkpoint'\nmodel_checkpoint_callback = tf.keras.callbacks.ModelCheckpoint(\n    filepath=checkpoint_filepath,\n    save_weights_only=True,\n    monitor='val_accuracy',\n    mode='max',\n    save_best_only=True)\n\nmodel.fit(epochs=EPOCHS, callbacks=[model_checkpoint_callback])\n\nmodel.load_weights(checkpoint_filepath)\n",
            "masked_code": "model.compile(loss=..., optimizer=...,\n              metrics=['accuracy'])\n\nEPOCHS = 10\ncheckpoint_filepath = '/tmp/checkpoint'\n<line_mask>\n    filepath=checkpoint_filepath,\n    save_weights_only=True,\n    monitor='val_accuracy',\n    mode='max',\n    save_best_only=True)\n\nmodel.fit(epochs=EPOCHS, callbacks=[model_checkpoint_callback])\n\nmodel.load_weights(checkpoint_filepath)\n",
            "masked_line": "model_checkpoint_callback = tf.keras.callbacks.ModelCheckpoint(",
            "answer": "ModelCheckpoint",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_194"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "The code defines a scheduler function that adjusts the learning rate based on the epoch. If the epoch is less than 10, the learning rate remains the same, otherwise it decays exponentially. It then creates a Sequential model with a Dense layer of 10 units, compiles the model using stochastic gradient descent optimizer and mean squared error loss. A LearningRateScheduler callback is defined using the scheduler function to adjust the learning rate during training. Finally, the model is trained for 15 epochs and the learning rate of the optimizer is rounded to 5 decimal places after training.",
            "code": "def scheduler(epoch, lr):\n    if epoch < 10:\n        return lr\n    else:\n        return lr * tf.math.exp(-0.1)\n\nmodel = tf.keras.models.Sequential([tf.keras.layers.Dense(10)])\nmodel.compile(tf.keras.optimizers.SGD(), loss='mse')\nround(model.optimizer.lr.numpy(), 5)\n\ncallback = tf.keras.callbacks.LearningRateScheduler(scheduler)\nhistory = model.fit(np.arange(100).reshape(5, 20), np.zeros(5),\n                    epochs=15, callbacks=[callback], verbose=0)\nround(model.optimizer.lr.numpy(), 5)",
            "masked_code": "def scheduler(epoch, lr):\n    if epoch < 10:\n        return lr\n    else:\n        return lr * tf.math.exp(-0.1)\n\nmodel = tf.keras.models.Sequential([tf.keras.layers.Dense(10)])\nmodel.compile(tf.keras.optimizers.SGD(), loss='mse')\nround(model.optimizer.lr.numpy(), 5)\n\n<line_mask>\nhistory = model.fit(np.arange(100).reshape(5, 20), np.zeros(5),\n                    epochs=15, callbacks=[callback], verbose=0)\nround(model.optimizer.lr.numpy(), 5)",
            "masked_line": "callback = tf.keras.callbacks.LearningRateScheduler(scheduler)",
            "answer": "LearningRateScheduler",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_195"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "- Print the batch number at the beginning of every batch.\n- Stream the epoch loss to a file in JSON format.\n- Terminate some processes after having finished model training.",
            "code": "# Print the batch number at the beginning of every batch.\nbatch_print_callback = LambdaCallback(\n    on_batch_begin=lambda batch,logs: print(batch))\n\n# Stream the epoch loss to a file in JSON format. The file content\n# is not well-formed JSON but rather has a JSON object per line.\nimport json\njson_log = open('loss_log.json', mode='wt', buffering=1)\njson_logging_callback = LambdaCallback(\n    on_epoch_end=lambda epoch, logs: json_log.write(\n        json.dumps({'epoch': epoch, 'loss': logs['loss']}) + '\\n'),\n    on_train_end=lambda logs: json_log.close()\n)\n\n# Terminate some processes after having finished model training.\nprocesses = ...\ncleanup_callback = LambdaCallback(\n    on_train_end=lambda logs: [\n        p.terminate() for p in processes if p.is_alive()])\n\nmodel.fit(...,\n          callbacks=[batch_print_callback,\n                     json_logging_callback,\n                     cleanup_callback])\n",
            "masked_code": "# Print the batch number at the beginning of every batch.\n<line_mask>\n    on_batch_begin=lambda batch,logs: print(batch))\n\n# Stream the epoch loss to a file in JSON format. The file content\n# is not well-formed JSON but rather has a JSON object per line.\nimport json\njson_log = open('loss_log.json', mode='wt', buffering=1)\njson_logging_callback = LambdaCallback(\n    on_epoch_end=lambda epoch, logs: json_log.write(\n        json.dumps({'epoch': epoch, 'loss': logs['loss']}) + '\\n'),\n    on_train_end=lambda logs: json_log.close()\n)\n\n# Terminate some processes after having finished model training.\nprocesses = ...\ncleanup_callback = LambdaCallback(\n    on_train_end=lambda logs: [\n        p.terminate() for p in processes if p.is_alive()])\n\nmodel.fit(...,\n          callbacks=[batch_print_callback,\n                     json_logging_callback,\n                     cleanup_callback])\n",
            "masked_line": "batch_print_callback = LambdaCallback(",
            "answer": "LambdaCallback",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_196"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "This code calculates the Mean Absolute Error (MAE) between the true values (y_true) and the predicted values (y_pred) using the TensorFlow keras library. It also shows different ways to customize the calculation of MAE by setting parameters such as sample weights, reduction method, and the optimizer for model compilation.",
            "code": "loss = abs(y_true - y_pred)\nmae = tf.keras.losses.MeanAbsoluteError()\nmae(y_true, y_pred).numpy()\nmae(y_true, y_pred, sample_weight=[0.7, 0.3]).numpy()\nmae = tf.keras.losses.MeanAbsoluteError(reduction=tf.keras.losses.Reduction.SUM)\nmae(y_true, y_pred).numpy()\nmae = tf.keras.losses.MeanAbsoluteError(reduction=tf.keras.losses.Reduction.NONE)\nmae(y_true, y_pred).numpy()\nmodel.compile(optimizer='sgd', loss=tf.keras.losses.MeanAbsoluteError())",
            "masked_code": "loss = abs(y_true - y_pred)\nmae = tf.keras.losses.MeanAbsoluteError()\nmae(y_true, y_pred).numpy()\nmae(y_true, y_pred, sample_weight=[0.7, 0.3]).numpy()\nmae = tf.keras.losses.MeanAbsoluteError(reduction=tf.keras.losses.Reduction.SUM)\nmae(y_true, y_pred).numpy()\nmae = tf.keras.losses.MeanAbsoluteError(reduction=tf.keras.losses.Reduction.NONE)\nmae(y_true, y_pred).numpy()\n<line_mask>",
            "masked_line": "model.compile(optimizer='sgd', loss=tf.keras.losses.MeanAbsoluteError())",
            "answer": "MeanAbsoluteError",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_197"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "The code calculates the sum of the input values [1, 3, 5, 7] using the tf.keras.metrics.Sum() metric.",
            "code": "m = tf.keras.metrics.Sum()\nm.update_state([1, 3, 5, 7])\nm.result().numpy()\n16.0\n\nmodel.add_metric(tf.keras.metrics.Sum(name='sum_1')(outputs))\nmodel.compile(optimizer='sgd', loss='mse')\n",
            "masked_code": "m = tf.keras.metrics.Sum()\nm.update_state([1, 3, 5, 7])\nm.result().numpy()\n16.0\n\n<line_mask>\nmodel.compile(optimizer='sgd', loss='mse')\n",
            "masked_line": "model.add_metric(tf.keras.metrics.Sum(name='sum_1')(outputs))",
            "answer": "Sum",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_198"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "The code calculates the mean value of a set of numbers using tf.keras.metrics.Mean() object. It updates the mean value state with the provided numbers, calculates the mean value, resets the state, then updates the mean value state again with the provided numbers and sample weights, and calculates the new mean value. Finally, it adds the mean value as a metric to a model and compiles the model for training with optimizer 'sgd' and loss 'mse'.",
            "code": "m = tf.keras.metrics.Mean()\nm.update_state([1, 3, 5, 7])\nm.result().numpy()\n4.0\nm.reset_state()\nm.update_state([1, 3, 5, 7], sample_weight=[1, 1, 0, 0])\nm.result().numpy()\n2.0\nmodel.add_metric(tf.keras.metrics.Mean(name='mean_1')(outputs))\nmodel.compile(optimizer='sgd', loss='mse')\n",
            "masked_code": "m = tf.keras.metrics.Mean()\nm.update_state([1, 3, 5, 7])\nm.result().numpy()\n4.0\nm.reset_state()\nm.update_state([1, 3, 5, 7], sample_weight=[1, 1, 0, 0])\nm.result().numpy()\n2.0\n<line_mask>\nmodel.compile(optimizer='sgd', loss='mse')\n",
            "masked_line": "model.add_metric(tf.keras.metrics.Mean(name='mean_1')(outputs))",
            "answer": "Mean",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_199"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "The code calculates the accuracy of a model's predictions on a set of input data. It first initializes a accuracy metric and updates its state with the predicted and actual values. Then it resets the state, updates it again with sample weights, and returns the accuracy as a numpy array. It also compiles a model with stochastic gradient descent optimizer, mean squared error loss function, and accuracy metric for evaluation.",
            "code": "m = tf.keras.metrics.Accuracy()\nm.update_state([[1], [2], [3], [4]], [[0], [2], [3], [4]])\nm.result().numpy()\n0.75\n\nm.reset_state()\nm.update_state([[1], [2], [3], [4]], [[0], [2], [3], [4]],\n               sample_weight=[1, 1, 0, 0])\nm.result().numpy()\n0.5\n\nmodel.compile(optimizer='sgd',\n              loss='mse',\n              metrics=[tf.keras.metrics.Accuracy()])\n",
            "masked_code": "<line_mask>\nm.update_state([[1], [2], [3], [4]], [[0], [2], [3], [4]])\nm.result().numpy()\n0.75\n\nm.reset_state()\nm.update_state([[1], [2], [3], [4]], [[0], [2], [3], [4]],\n               sample_weight=[1, 1, 0, 0])\nm.result().numpy()\n0.5\n\nmodel.compile(optimizer='sgd',\n              loss='mse',\n              metrics=[tf.keras.metrics.Accuracy()])\n",
            "masked_line": "m = tf.keras.metrics.Accuracy()",
            "answer": "Accuracy",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_200"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "The code calculates binary accuracy metrics for a model's predictions. The first part updates the binary accuracy metric with given predictions and labels, then resets the state and updates the metric with sample weights included. Finally, it retrieves the computed binary accuracy as a numpy array. The second part compiles a model using stochastic gradient descent optimizer, mean squared error loss function, and binary accuracy as a metric.",
            "code": "m = tf.keras.metrics.BinaryAccuracy()\nm.update_state([[1], [1], [0], [0]], [[0.98], [1], [0], [0.6]])\nm.result().numpy()\n\nm.reset_state()\nm.update_state([[1], [1], [0], [0]], [[0.98], [1], [0], [0.6]],\n               sample_weight=[1, 0, 0, 1])\nm.result().numpy()\n\nmodel.compile(optimizer='sgd',\n              loss='mse',\n              metrics=[tf.keras.metrics.BinaryAccuracy()])\n",
            "masked_code": "m = tf.keras.metrics.BinaryAccuracy()\nm.update_state([[1], [1], [0], [0]], [[0.98], [1], [0], [0.6]])\nm.result().numpy()\n\nm.reset_state()\nm.update_state([[1], [1], [0], [0]], [[0.98], [1], [0], [0.6]],\n               sample_weight=[1, 0, 0, 1])\nm.result().numpy()\n\nmodel.compile(optimizer='sgd',\n              loss='mse',\n              <line_mask>\n",
            "masked_line": "metrics=[tf.keras.metrics.BinaryAccuracy()])",
            "answer": "BinaryAccuracy",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_201"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "The code calculates the top-k categorical accuracy metric for a model's predictions. It updates the metric's state with the true labels and model predictions, and then retrieves the metric result in numpy format. The metric value is calculated based on the proportion of correct predictions within the top k values.",
            "code": "m = tf.keras.metrics.TopKCategoricalAccuracy(k=1)\nm.update_state([[0, 0, 1], [0, 1, 0]],\n               [[0.1, 0.9, 0.8], [0.05, 0.95, 0]])\nm.result().numpy()\n0.5\n\nm.reset_state()\nm.update_state([[0, 0, 1], [0, 1, 0]],\n               [[0.1, 0.9, 0.8], [0.05, 0.95, 0]],\n               sample_weight=[0.7, 0.3])\nm.result().numpy()\n0.3\n",
            "masked_code": "<line_mask>\nm.update_state([[0, 0, 1], [0, 1, 0]],\n               [[0.1, 0.9, 0.8], [0.05, 0.95, 0]])\nm.result().numpy()\n0.5\n\nm.reset_state()\nm.update_state([[0, 0, 1], [0, 1, 0]],\n               [[0.1, 0.9, 0.8], [0.05, 0.95, 0]],\n               sample_weight=[0.7, 0.3])\nm.result().numpy()\n0.3\n",
            "masked_line": "m = tf.keras.metrics.TopKCategoricalAccuracy(k=1)",
            "answer": "TopKCategoricalAccuracy",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_202"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "The code calculates the number of false positives in a binary classification model by comparing the predicted values with the actual values. The `FalsePositives` metric object is initialized and updated with different sets of predictions and actual values. The `result()` method returns the final count of false positives as a numpy array.",
            "code": "m = tf.keras.metrics.FalsePositives()\nm.update_state([0, 1, 0, 0], [0, 0, 1, 1])\nm.result().numpy()\n2.0\n\nm.reset_state()\nm.update_state([0, 1, 0, 0], [0, 0, 1, 1], sample_weight=[0, 0, 1, 0])\nm.result().numpy()\n1.0\n\nmodel.compile(optimizer='sgd',\n              loss='mse',\n              metrics=[tf.keras.metrics.FalsePositives()])\n",
            "masked_code": "m = tf.keras.metrics.FalsePositives()\nm.update_state([0, 1, 0, 0], [0, 0, 1, 1])\nm.result().numpy()\n2.0\n\nm.reset_state()\nm.update_state([0, 1, 0, 0], [0, 0, 1, 1], sample_weight=[0, 0, 1, 0])\nm.result().numpy()\n1.0\n\nmodel.compile(optimizer='sgd',\n              loss='mse',\n              <line_mask>\n",
            "masked_line": "metrics=[tf.keras.metrics.FalsePositives()])",
            "answer": "FalsePositives",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_203"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "The code defines a FalseNegatives metric using TensorFlow's Keras module. It computes the number of false negatives in a classification problem by comparing predicted values with true labels, and can also consider sample weights for different instances. The metric can be used during model training to monitor the performance of the model in terms of false negatives.",
            "code": "m = tf.keras.metrics.FalseNegatives()\nm.update_state([0, 1, 1, 1], [0, 1, 0, 0])\nm.result().numpy()\n\nm.reset_state()\nm.update_state([0, 1, 1, 1], [0, 1, 0, 0], sample_weight=[0, 0, 1, 0])\nm.result().numpy()\n\nmodel.compile(optimizer='sgd',\n              loss='mse',\n              metrics=[tf.keras.metrics.FalseNegatives()])\n",
            "masked_code": "<line_mask>\nm.update_state([0, 1, 1, 1], [0, 1, 0, 0])\nm.result().numpy()\n\nm.reset_state()\nm.update_state([0, 1, 1, 1], [0, 1, 0, 0], sample_weight=[0, 0, 1, 0])\nm.result().numpy()\n\nmodel.compile(optimizer='sgd',\n              loss='mse',\n              metrics=[tf.keras.metrics.FalseNegatives()])\n",
            "masked_line": "m = tf.keras.metrics.FalseNegatives()",
            "answer": "FalseNegatives",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_204"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "This code snippet creates and utilizes the TrueNegatives metric from the tf.keras.metrics module in TensorFlow. The TrueNegatives metric calculates the number of true negative predictions in a binary classification problem. The code first initializes the TrueNegatives metric, updates its state with predicted and true labels, retrieves and prints the result as a numpy array. Then, it resets the metric's state, updates it with predicted and true labels along with sample weights, retrieves and prints the result as a numpy array. Finally, the code compiles a model using stochastic gradient descent optimizer, mean squared error loss function, and the TrueNegatives metric for evaluation.",
            "code": "m = tf.keras.metrics.TrueNegatives()\nm.update_state([0, 1, 0, 0], [1, 1, 0, 0])\nm.result().numpy()\n2.0\n\nm.reset_state()\nm.update_state([0, 1, 0, 0], [1, 1, 0, 0], sample_weight=[0, 0, 1, 0])\nm.result().numpy()\n1.0\nmodel.compile(optimizer='sgd',\n              loss='mse',\n              metrics=[tf.keras.metrics.TrueNegatives()])\n",
            "masked_code": "m = tf.keras.metrics.TrueNegatives()\nm.update_state([0, 1, 0, 0], [1, 1, 0, 0])\nm.result().numpy()\n2.0\n\nm.reset_state()\nm.update_state([0, 1, 0, 0], [1, 1, 0, 0], sample_weight=[0, 0, 1, 0])\nm.result().numpy()\n1.0\nmodel.compile(optimizer='sgd',\n              loss='mse',\n              <line_mask>\n",
            "masked_line": "metrics=[tf.keras.metrics.TrueNegatives()])",
            "answer": "TrueNegatives",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_205"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "The code calculates the number of true positives in a binary classification task. It first initializes a TruePositives metric object, updates its state with ground truth labels and predictions, retrieves the result as a numpy array, resets the state, updates the state with sample weights included, retrieves the updated result, and then compiles a model with the calculated true positives metric.",
            "code": "m = tf.keras.metrics.TruePositives()\nm.update_state([0, 1, 1, 1], [1, 0, 1, 1])\nm.result().numpy()\n2.0\n\nm.reset_state()\nm.update_state([0, 1, 1, 1], [1, 0, 1, 1], sample_weight=[0, 0, 1, 0])\nm.result().numpy()\n1.0\n\nmodel.compile(optimizer='sgd',\n              loss='mse',\n              metrics=[tf.keras.metrics.TruePositives()])\n",
            "masked_code": "<line_mask>\nm.update_state([0, 1, 1, 1], [1, 0, 1, 1])\nm.result().numpy()\n2.0\n\nm.reset_state()\nm.update_state([0, 1, 1, 1], [1, 0, 1, 1], sample_weight=[0, 0, 1, 0])\nm.result().numpy()\n1.0\n\nmodel.compile(optimizer='sgd',\n              loss='mse',\n              metrics=[tf.keras.metrics.TruePositives()])\n",
            "masked_line": "m = tf.keras.metrics.TruePositives()",
            "answer": "TruePositives",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_206"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "The code calculates the cosine similarity loss between the true values (y_true) and the predicted values (y_pred). It can be customized by adding sample weights, changing the reduction method, or specifying the axis for computation.",
            "code": "loss = -sum(l2_norm(y_true) * l2_norm(y_pred))\n\n\ncosine_loss = tf.keras.losses.CosineSimilarity(axis=1)\n\n\ncosine_loss(y_true, y_pred).numpy()\n\n\ncosine_loss(y_true, y_pred, sample_weight=[0.8, 0.2]).numpy()\n\n\ncosine_loss = tf.keras.losses.CosineSimilarity(axis=1,\n    reduction=tf.keras.losses.Reduction.SUM)\n\n\ncosine_loss(y_true, y_pred).numpy()\n\n\ncosine_loss = tf.keras.losses.CosineSimilarity(axis=1,\n    reduction=tf.keras.losses.Reduction.NONE)\n\n\ncosine_loss(y_true, y_pred).numpy()\n\n\nmodel.compile(optimizer='sgd', loss=tf.keras.losses.CosineSimilarity(axis=1))\n",
            "masked_code": "loss = -sum(l2_norm(y_true) * l2_norm(y_pred))\n\n\ncosine_loss = tf.keras.losses.CosineSimilarity(axis=1)\n\n\ncosine_loss(y_true, y_pred).numpy()\n\n\ncosine_loss(y_true, y_pred, sample_weight=[0.8, 0.2]).numpy()\n\n\n<line_mask>\n    reduction=tf.keras.losses.Reduction.SUM)\n\n\ncosine_loss(y_true, y_pred).numpy()\n\n\ncosine_loss = tf.keras.losses.CosineSimilarity(axis=1,\n    reduction=tf.keras.losses.Reduction.NONE)\n\n\ncosine_loss(y_true, y_pred).numpy()\n\n\nmodel.compile(optimizer='sgd', loss=tf.keras.losses.CosineSimilarity(axis=1))\n",
            "masked_line": "cosine_loss = tf.keras.losses.CosineSimilarity(axis=1,",
            "answer": "CosineSimilarity",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_207"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "This code calculates the Mean Absolute Error (MAE) between the true values (y_true) and the predicted values (y_pred) using different settings for reduction, such as SUM or NONE. Additionally, the code compiles a model using Stochastic Gradient Descent (SGD) optimizer and the MAE loss function.",
            "code": "loss = abs(y_true - y_pred)\nmae = tf.keras.losses.MeanAbsoluteError()\nmae(y_true, y_pred).numpy()\nmae(y_true, y_pred, sample_weight=[0.7, 0.3]).numpy()\nmae = tf.keras.losses.MeanAbsoluteError(reduction=tf.keras.losses.Reduction.SUM)\nmae(y_true, y_pred).numpy()\nmae = tf.keras.losses.MeanAbsoluteError(reduction=tf.keras.losses.Reduction.NONE)\nmae(y_true, y_pred).numpy()\nmodel.compile(optimizer='sgd', loss=tf.keras.losses.MeanAbsoluteError())\n",
            "masked_code": "loss = abs(y_true - y_pred)\nmae = tf.keras.losses.MeanAbsoluteError()\nmae(y_true, y_pred).numpy()\nmae(y_true, y_pred, sample_weight=[0.7, 0.3]).numpy()\nmae = tf.keras.losses.MeanAbsoluteError(reduction=tf.keras.losses.Reduction.SUM)\nmae(y_true, y_pred).numpy()\n<line_mask>\nmae(y_true, y_pred).numpy()\nmodel.compile(optimizer='sgd', loss=tf.keras.losses.MeanAbsoluteError())\n",
            "masked_line": "mae = tf.keras.losses.MeanAbsoluteError(reduction=tf.keras.losses.Reduction.NONE)",
            "answer": "MeanAbsoluteError",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_208"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "The code calculates the Mean Absolute Percentage Error (MAPE) between the true values (y_true) and the predicted values (y_pred) using different reduction methods such as SUM and NONE. It also demonstrates how to compile a model using MAPE as the loss function with the optimizer set to Stochastic Gradient Descent (SGD).",
            "code": "mape = tf.keras.losses.MeanAbsolutePercentageError()\nmape(y_true, y_pred).numpy()\n\nmape(y_true, y_pred, sample_weight=[0.7, 0.3]).numpy()\n\nmape = tf.keras.losses.MeanAbsolutePercentageError(\n    reduction=tf.keras.losses.Reduction.SUM)\nmape(y_true, y_pred).numpy()\n\nmape = tf.keras.losses.MeanAbsolutePercentageError(\n    reduction=tf.keras.losses.Reduction.NONE)\nmape(y_true, y_pred).numpy()\n\nmodel.compile(optimizer='sgd',\n              loss=tf.keras.losses.MeanAbsolutePercentageError())\n",
            "masked_code": "mape = tf.keras.losses.MeanAbsolutePercentageError()\nmape(y_true, y_pred).numpy()\n\nmape(y_true, y_pred, sample_weight=[0.7, 0.3]).numpy()\n\nmape = tf.keras.losses.MeanAbsolutePercentageError(\n    reduction=tf.keras.losses.Reduction.SUM)\nmape(y_true, y_pred).numpy()\n\n<line_mask>\n    reduction=tf.keras.losses.Reduction.NONE)\nmape(y_true, y_pred).numpy()\n\nmodel.compile(optimizer='sgd',\n              loss=tf.keras.losses.MeanAbsolutePercentageError())\n",
            "masked_line": "mape = tf.keras.losses.MeanAbsolutePercentageError(",
            "answer": "MeanAbsolutePercentageError",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_209"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "The code calculates the Mean Squared Logarithmic Error (MSLE) loss between two sets of true and predicted values, with optional sample weights, using TensorFlow's built-in loss function. The code also demonstrates different reduction options for the loss calculation and compiles a model with MSLE as the loss function and Stochastic Gradient Descent (SGD) as the optimizer.",
            "code": "y_true = [[0., 1.], [0., 0.]]\ny_pred = [[1., 1.], [1., 0.]]\nmsle = tf.keras.losses.MeanSquaredLogarithmicError()\nmsle(y_true, y_pred).numpy()\nmsle(y_true, y_pred, sample_weight=[0.7, 0.3]).numpy()\nmsle = tf.keras.losses.MeanSquaredLogarithmicError(\n    reduction=tf.keras.losses.Reduction.SUM)\nmsle(y_true, y_pred).numpy()\nmsle = tf.keras.losses.MeanSquaredLogarithmicError(\n    reduction=tf.keras.losses.Reduction.NONE)\nmsle(y_true, y_pred).numpy()\nmodel.compile(optimizer='sgd',\n              loss=tf.keras.losses.MeanSquaredLogarithmicError())\n",
            "masked_code": "y_true = [[0., 1.], [0., 0.]]\ny_pred = [[1., 1.], [1., 0.]]\nmsle = tf.keras.losses.MeanSquaredLogarithmicError()\nmsle(y_true, y_pred).numpy()\nmsle(y_true, y_pred, sample_weight=[0.7, 0.3]).numpy()\nmsle = tf.keras.losses.MeanSquaredLogarithmicError(\n    reduction=tf.keras.losses.Reduction.SUM)\nmsle(y_true, y_pred).numpy()\n<line_mask>\n    reduction=tf.keras.losses.Reduction.NONE)\nmsle(y_true, y_pred).numpy()\nmodel.compile(optimizer='sgd',\n              loss=tf.keras.losses.MeanSquaredLogarithmicError())\n",
            "masked_line": "msle = tf.keras.losses.MeanSquaredLogarithmicError(",
            "answer": "MeanSquaredLogarithmicError",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_210"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "The code calculates the Categorical Hinge loss between the true labels (y_true) and the predicted labels (y_pred) in a neural network model. It uses different parameters for the loss calculation such as sample weights, reduction method, and optimization method (sgd).",
            "code": "h = tf.keras.losses.CategoricalHinge()\nh(y_true, y_pred).numpy()\n\nh(y_true, y_pred, sample_weight=[1, 0]).numpy()\n\nh = tf.keras.losses.CategoricalHinge(\n    reduction=tf.keras.losses.Reduction.SUM)\nh(y_true, y_pred).numpy()\n\nh = tf.keras.losses.CategoricalHinge(\n    reduction=tf.keras.losses.Reduction.NONE)\nh(y_true, y_pred).numpy()\n\nmodel.compile(optimizer='sgd', loss=tf.keras.losses.CategoricalHinge())\n",
            "masked_code": "h = tf.keras.losses.CategoricalHinge()\nh(y_true, y_pred).numpy()\n\nh(y_true, y_pred, sample_weight=[1, 0]).numpy()\n\nh = tf.keras.losses.CategoricalHinge(\n    reduction=tf.keras.losses.Reduction.SUM)\nh(y_true, y_pred).numpy()\n\n<line_mask>\n    reduction=tf.keras.losses.Reduction.NONE)\nh(y_true, y_pred).numpy()\n\nmodel.compile(optimizer='sgd', loss=tf.keras.losses.CategoricalHinge())\n",
            "masked_line": "h = tf.keras.losses.CategoricalHinge(",
            "answer": "CategoricalHinge",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_211"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "Calculate and update the root mean squared error metric based on the input data and sample weight provided.",
            "code": "m = tf.keras.metrics.RootMeanSquaredError()\nm.update_state([[0, 1], [0, 0]], [[1, 1], [0, 0]])\nm.result().numpy()\nm.reset_state()\nm.update_state([[0, 1], [0, 0]], [[1, 1], [0, 0]],\n               sample_weight=[1, 0])\nm.result().numpy()",
            "masked_code": "<line_mask>\nm.update_state([[0, 1], [0, 0]], [[1, 1], [0, 0]])\nm.result().numpy()\nm.reset_state()\nm.update_state([[0, 1], [0, 0]], [[1, 1], [0, 0]],\n               sample_weight=[1, 0])\nm.result().numpy()",
            "masked_line": "m = tf.keras.metrics.RootMeanSquaredError()",
            "answer": "RootMeanSquaredError",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_212"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "The function of the code is to calculate the Log-cosh error metric for a given set of predicted values and true values in a machine learning model.",
            "code": "logcosh = log((exp(x) + exp(-x))/2)\n\n\nm = tf.keras.metrics.LogCoshError()\nm.update_state([[0, 1], [0, 0]], [[1, 1], [0, 0]])\nm.result().numpy()\n\n\nm.reset_state()\nm.update_state([[0, 1], [0, 0]], [[1, 1], [0, 0]],\n               sample_weight=[1, 0])\nm.result().numpy()\n\n\nmodel.compile(optimizer='sgd',\n              loss='mse',\n              metrics=[tf.keras.metrics.LogCoshError()])\n",
            "masked_code": "logcosh = log((exp(x) + exp(-x))/2)\n\n\n<line_mask>\nm.update_state([[0, 1], [0, 0]], [[1, 1], [0, 0]])\nm.result().numpy()\n\n\nm.reset_state()\nm.update_state([[0, 1], [0, 0]], [[1, 1], [0, 0]],\n               sample_weight=[1, 0])\nm.result().numpy()\n\n\nmodel.compile(optimizer='sgd',\n              loss='mse',\n              metrics=[tf.keras.metrics.LogCoshError()])\n",
            "masked_line": "m = tf.keras.metrics.LogCoshError()",
            "answer": "LogCoshError",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_213"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "The code calculates the Poisson loss for a given ground truth array `y_true` and a prediction array `y_pred` using TensorFlow's Poisson loss function. It demonstrates different ways to compute the Poisson loss with varying reductions (NONE, SUM) and sample weights. Finally, it compiles a model using stochastic gradient descent optimizer and Poisson loss function.",
            "code": "y_true = [[0., 1.], [0., 0.]]\ny_pred = [[1., 1.], [0., 0.]]\np = tf.keras.losses.Poisson()\np(y_true, y_pred).numpy()\np(y_true, y_pred, sample_weight=[0.8, 0.2]).numpy()\np = tf.keras.losses.Poisson(reduction=tf.keras.losses.Reduction.SUM)\np(y_true, y_pred).numpy()\np = tf.keras.losses.Poisson(reduction=tf.keras.losses.Reduction.NONE)\np(y_true, y_pred).numpy()\nmodel.compile(optimizer='sgd', loss=tf.keras.losses.Poisson())\n",
            "masked_code": "y_true = [[0., 1.], [0., 0.]]\ny_pred = [[1., 1.], [0., 0.]]\np = tf.keras.losses.Poisson()\np(y_true, y_pred).numpy()\np(y_true, y_pred, sample_weight=[0.8, 0.2]).numpy()\np = tf.keras.losses.Poisson(reduction=tf.keras.losses.Reduction.SUM)\np(y_true, y_pred).numpy()\n<line_mask>\np(y_true, y_pred).numpy()\nmodel.compile(optimizer='sgd', loss=tf.keras.losses.Poisson())\n",
            "masked_line": "p = tf.keras.losses.Poisson(reduction=tf.keras.losses.Reduction.NONE)",
            "answer": "Poisson",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_214"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "The code initializes two dense layers, `layer_a` and `layer_b`, with different constant initializers. It then applies `layer_a` on input data `[1., 2., 3.]` and retrieves its weights. Next, it applies `layer_b` on input data `[10., 20., 30.]` and retrieves its weights. Finally, it sets the weights of `layer_b` to be the same as the weights of `layer_a` and retrieves the updated weights of `layer_b`.",
            "code": "layer_a = tf.keras.layers.Dense(1,\n  kernel_initializer=tf.constant_initializer(1.))\na_out = layer_a(tf.convert_to_tensor([[1., 2., 3.]]))\nlayer_a.get_weights()\nlayer_b = tf.keras.layers.Dense(1,\n  kernel_initializer=tf.constant_initializer(2.))\nb_out = layer_b(tf.convert_to_tensor([[10., 20., 30.]]))\nlayer_b.get_weights()\nlayer_b.set_weights(layer_a.get_weights())\nlayer_b.get_weights()",
            "masked_code": "layer_a = tf.keras.layers.Dense(1,\n  kernel_initializer=tf.constant_initializer(1.))\na_out = layer_a(tf.convert_to_tensor([[1., 2., 3.]]))\nlayer_a.get_weights()\nlayer_b = tf.keras.layers.Dense(1,\n  kernel_initializer=tf.constant_initializer(2.))\nb_out = layer_b(tf.convert_to_tensor([[10., 20., 30.]]))\nlayer_b.get_weights()\n<line_mask>\nlayer_b.get_weights()",
            "masked_line": "layer_b.set_weights(layer_a.get_weights())",
            "answer": "set_weights",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_215"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "This code defines a neural network layer with 3 input nodes and 2 output nodes. It adds two metrics to the layer to calculate the maximum and minimum values of the output. The resulting metrics are named 'max' and 'min'.",
            "code": "input = tf.keras.layers.Input(shape=(3,))\nd = tf.keras.layers.Dense(2)\noutput = d(input)\nd.add_metric(tf.reduce_max(output), name='max')\nd.add_metric(tf.reduce_min(output), name='min')\n[m.name for m in d.metrics]\n['max', 'min']",
            "masked_code": "input = tf.keras.layers.Input(shape=(3,))\nd = tf.keras.layers.Dense(2)\noutput = d(input)\nd.add_metric(tf.reduce_max(output), name='max')\nd.add_metric(tf.reduce_min(output), name='min')\n<line_mask>\n['max', 'min']",
            "masked_line": "[m.name for m in d.metrics]",
            "answer": "metrics",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_216"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "The code initializes two dense layers, layer_a and layer_b, with different constant initializers for their kernels. It then calculates the output of layer_a with input [[1., 2., 3.]], retrieves the weights of layer_a, calculates the output of layer_b with input [[10., 20., 30.]], retrieves the weights of layer_b, sets the weights of layer_b to be the same as the weights of layer_a, and finally retrieves the weights of layer_b again.",
            "code": "layer_a = tf.keras.layers.Dense(1,\n  kernel_initializer=tf.constant_initializer(1.))\na_out = layer_a(tf.convert_to_tensor([[1., 2., 3.]]))\nlayer_a.get_weights()\nlayer_b = tf.keras.layers.Dense(1,\n  kernel_initializer=tf.constant_initializer(2.))\nb_out = layer_b(tf.convert_to_tensor([[10., 20., 30.]]))\nlayer_b.get_weights()\nlayer_b.set_weights(layer_a.get_weights())\nlayer_b.get_weights()",
            "masked_code": "layer_a = tf.keras.layers.Dense(1,\n  kernel_initializer=tf.constant_initializer(1.))\na_out = layer_a(tf.convert_to_tensor([[1., 2., 3.]]))\n<line_mask>\nlayer_b = tf.keras.layers.Dense(1,\n  kernel_initializer=tf.constant_initializer(2.))\nb_out = layer_b(tf.convert_to_tensor([[10., 20., 30.]]))\nlayer_b.get_weights()\nlayer_b.set_weights(layer_a.get_weights())\nlayer_b.get_weights()",
            "masked_line": "layer_a.get_weights()",
            "answer": "get_weights",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_217"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "The code defines two neural network models with one hidden layer and 8 units, using mean squared error loss and RMSprop optimizer with a learning rate of 0.001. The models are trained on input data of size (10, 4) and target data of size (10, 8).",
            "code": "model = tf.keras.Sequential([\n  tf.keras.layers.InputLayer(input_shape=(4,)),\n  tf.keras.layers.Dense(8)])\nmodel.compile(tf.optimizers.RMSprop(0.001), loss='mse')\nmodel.fit(np.zeros((10, 4)),\n          np.ones((10, 8)))\n\nmodel = tf.keras.Sequential([\n  tf.keras.layers.Dense(8, input_shape=(4,))])\nmodel.compile(tf.optimizers.RMSprop(0.001), loss='mse')\nmodel.fit(np.zeros((10, 4)),\n          np.ones((10, 8)))\n",
            "masked_code": "model = tf.keras.Sequential([\n  <line_mask>\n  tf.keras.layers.Dense(8)])\nmodel.compile(tf.optimizers.RMSprop(0.001), loss='mse')\nmodel.fit(np.zeros((10, 4)),\n          np.ones((10, 8)))\n\nmodel = tf.keras.Sequential([\n  tf.keras.layers.Dense(8, input_shape=(4,))])\nmodel.compile(tf.optimizers.RMSprop(0.001), loss='mse')\nmodel.fit(np.zeros((10, 4)),\n          np.ones((10, 8)))\n",
            "masked_line": "tf.keras.layers.InputLayer(input_shape=(4,)),",
            "answer": "InputLayer",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_218"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "The code creates a neural network model using TensorFlow and Keras to perform a regression task. It defines an input layer with shape (3,), adds a dense layer with 2 units, compiles the model with Adam optimizer and mean squared error loss, and uses mean absolute error as a metric. It then trains the model on random data, evaluates the metrics, and checks that the metrics are reset to 0 after calling model.reset_metrics().",
            "code": "inputs = tf.keras.layers.Input(shape=(3,))\noutputs = tf.keras.layers.Dense(2)(inputs)\nmodel = tf.keras.models.Model(inputs=inputs, outputs=outputs)\nmodel.compile(optimizer=\"Adam\", loss=\"mse\", metrics=[\"mae\"])\n\nx = np.random.random((2, 3))\ny = np.random.randint(0, 2, (2, 2))\n_ = model.fit(x, y, verbose=0)\nassert all(float(m.result()) for m in model.metrics)\n\nmodel.reset_metrics()\nassert all(float(m.result()) == 0 for m in model.metrics)",
            "masked_code": "inputs = tf.keras.layers.Input(shape=(3,))\noutputs = tf.keras.layers.Dense(2)(inputs)\nmodel = tf.keras.models.Model(inputs=inputs, outputs=outputs)\nmodel.compile(optimizer=\"Adam\", loss=\"mse\", metrics=[\"mae\"])\n\nx = np.random.random((2, 3))\ny = np.random.randint(0, 2, (2, 2))\n_ = model.fit(x, y, verbose=0)\nassert all(float(m.result()) for m in model.metrics)\n\n<line_mask>\nassert all(float(m.result()) == 0 for m in model.metrics)",
            "masked_line": "model.reset_metrics()",
            "answer": "reset_metrics",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_219"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "The code defines a TensorFlow model and a function called 'serve' that serves as a wrapper for the model. The 'serve' function takes any number of positional and keyword arguments, passes them to the model, applies postprocessing steps, and returns the outputs. The code also defines argument and keyword argument specifications for the model and saves the model at a specified path, specifying the 'serving_default' signature using the 'serve' function.",
            "code": "model = tf.keras.Model(...)\n\n@tf.function\ndef serve(*args, **kwargs):\n  outputs = model(*args, **kwargs)\n  # Apply postprocessing steps, or add additional outputs.\n  ...\n  return outputs\n\n# arg_specs is `[tf.TensorSpec(...), ...]`. kwarg_specs, in this example, is\n# an empty dict since functional models do not use keyword arguments.\narg_specs, kwarg_specs = model.save_spec()\n\nmodel.save(path, signatures={\n  'serving_default': serve.get_concrete_function(*arg_specs, **kwarg_specs)\n})\n",
            "masked_code": "model = tf.keras.Model(...)\n\n@tf.function\ndef serve(*args, **kwargs):\n  outputs = model(*args, **kwargs)\n  # Apply postprocessing steps, or add additional outputs.\n  ...\n  return outputs\n\n# arg_specs is `[tf.TensorSpec(...), ...]`. kwarg_specs, in this example, is\n# an empty dict since functional models do not use keyword arguments.\n<line_mask>\n\nmodel.save(path, signatures={\n  'serving_default': serve.get_concrete_function(*arg_specs, **kwarg_specs)\n})\n",
            "masked_line": "arg_specs, kwarg_specs = model.save_spec()",
            "answer": "save_spec",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_220"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "This code defines a custom initializer class called ExampleRandomNormal that generates random values from a normal distribution with specified mean and standard deviation when initializing weights in a neural network model.",
            "code": "import tensorflow as tf\n\nclass ExampleRandomNormal(tf.keras.initializers.Initializer):\n\n  def __init__(self, mean, stddev):\n    self.mean = mean\n    self.stddev = stddev\n\n  def __call__(self, shape, dtype=None, **kwargs):\n    return tf.random.normal(\n        shape, mean=self.mean, stddev=self.stddev, dtype=dtype)\n\n  def get_config(self):  # To support serialization\n    return {\"mean\": self.mean, \"stddev\": self.stddev}\n",
            "masked_code": "import tensorflow as tf\n\n<line_mask>\n\n  def __init__(self, mean, stddev):\n    self.mean = mean\n    self.stddev = stddev\n\n  def __call__(self, shape, dtype=None, **kwargs):\n    return tf.random.normal(\n        shape, mean=self.mean, stddev=self.stddev, dtype=dtype)\n\n  def get_config(self):  # To support serialization\n    return {\"mean\": self.mean, \"stddev\": self.stddev}\n",
            "masked_line": "class ExampleRandomNormal(tf.keras.initializers.Initializer):",
            "answer": "Initializer",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_223"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "The code defines and applies two instances of the LeakyReLU activation function with different alpha values to a list of input values, which returns the output after applying the activation function. The LeakyReLU function returns the input values if they are positive, and multiplies negative input values by a small gradient (alpha) to prevent the dying ReLU problem.",
            "code": "layer = tf.keras.layers.LeakyReLU()\noutput = layer([-3.0, -1.0, 0.0, 2.0])\nlist(output.numpy())\n[-0.9, -0.3, 0.0, 2.0]\nlayer = tf.keras.layers.LeakyReLU(alpha=0.1)\noutput = layer([-3.0, -1.0, 0.0, 2.0])\nlist(output.numpy())\n[-0.3, -0.1, 0.0, 2.0]\n",
            "masked_code": "<line_mask>\noutput = layer([-3.0, -1.0, 0.0, 2.0])\nlist(output.numpy())\n[-0.9, -0.3, 0.0, 2.0]\nlayer = tf.keras.layers.LeakyReLU(alpha=0.1)\noutput = layer([-3.0, -1.0, 0.0, 2.0])\nlist(output.numpy())\n[-0.3, -0.1, 0.0, 2.0]\n",
            "masked_line": "layer = tf.keras.layers.LeakyReLU()",
            "answer": "LeakyReLU",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_224"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "The code applies the softmax function to the input array and returns the result. Additionally, it applies a mask to the input array before applying the softmax function and returns the result.",
            "code": "inp = np.asarray([1., 2., 1.])\nlayer = tf.keras.layers.Softmax()\nlayer(inp).numpy()\narray([0.21194157, 0.5761169 , 0.21194157], dtype=float32)\nmask = np.asarray([True, False, True], dtype=bool)\nlayer(inp, mask).numpy()\narray([0.5, 0. , 0.5], dtype=float32)",
            "masked_code": "inp = np.asarray([1., 2., 1.])\n<line_mask>\nlayer(inp).numpy()\narray([0.21194157, 0.5761169 , 0.21194157], dtype=float32)\nmask = np.asarray([True, False, True], dtype=bool)\nlayer(inp, mask).numpy()\narray([0.5, 0. , 0.5], dtype=float32)",
            "masked_line": "layer = tf.keras.layers.Softmax()",
            "answer": "Softmax",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_225"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "The code performs convolutional operation with a 1D kernel on randomly generated tensors of certain shapes. The Conv1D layer is applied with 32 filters, a kernel size of 3, and ReLU activation function. The code outputs the shape of the resulting tensor after convolution operation.",
            "code": "input_shape = (4, 10, 128)\nx = tf.random.normal(input_shape)\ny = tf.keras.layers.Conv1D(\n32, 3, activation='relu',input_shape=input_shape[1:])(x)\nprint(y.shape)\n\ninput_shape = (4, 7, 10, 128)\nx = tf.random.normal(input_shape)\ny = tf.keras.layers.Conv1D(\n32, 3, activation='relu', input_shape=input_shape[2:])(x)\nprint(y.shape)\n",
            "masked_code": "input_shape = (4, 10, 128)\nx = tf.random.normal(input_shape)\ny = tf.keras.layers.Conv1D(\n32, 3, activation='relu',input_shape=input_shape[1:])(x)\nprint(y.shape)\n\ninput_shape = (4, 7, 10, 128)\nx = tf.random.normal(input_shape)\n<line_mask>\n32, 3, activation='relu', input_shape=input_shape[2:])(x)\nprint(y.shape)\n",
            "masked_line": "y = tf.keras.layers.Conv1D(",
            "answer": "Conv1D",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_226"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "The code performs 3D convolution on randomly generated tensor data with specified input shapes, using 2 filters and a relu activation function. The resulting tensor shape is printed out for each input shape provided.",
            "code": "input_shape =(4, 28, 28, 28, 1)\nx = tf.random.normal(input_shape)\ny = tf.keras.layers.Conv3D(\n2, 3, activation='relu', input_shape=input_shape[1:])(x)\nprint(y.shape)\n(4, 26, 26, 26, 2)\n\ninput_shape = (4, 7, 28, 28, 28, 1)\nx = tf.random.normal(input_shape)\ny = tf.keras.layers.Conv3D(\n2, 3, activation='relu', input_shape=input_shape[2:])(x)\nprint(y.shape)\n(4, 7, 26, 26, 26, 2)\n",
            "masked_code": "input_shape =(4, 28, 28, 28, 1)\nx = tf.random.normal(input_shape)\ny = tf.keras.layers.Conv3D(\n2, 3, activation='relu', input_shape=input_shape[1:])(x)\nprint(y.shape)\n(4, 26, 26, 26, 2)\n\ninput_shape = (4, 7, 28, 28, 28, 1)\nx = tf.random.normal(input_shape)\n<line_mask>\n2, 3, activation='relu', input_shape=input_shape[2:])(x)\nprint(y.shape)\n(4, 7, 26, 26, 26, 2)\n",
            "masked_line": "y = tf.keras.layers.Conv3D(",
            "answer": "Conv3D",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_227"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "The code initializes a 5-dimensional tensor with shape (2, 1, 2, 1, 3), then applies 3D upsampling with a factor of 2 along each dimension, resulting in a tensor with shape (2, 2, 4, 2, 3).",
            "code": "input_shape = (2, 1, 2, 1, 3)\nx = tf.constant(1, shape=input_shape)\ny = tf.keras.layers.UpSampling3D(size=2)(x)\nprint(y.shape)\n(2, 2, 4, 2, 3)",
            "masked_code": "input_shape = (2, 1, 2, 1, 3)\nx = tf.constant(1, shape=input_shape)\n<line_mask>\nprint(y.shape)\n(2, 2, 4, 2, 3)",
            "masked_line": "y = tf.keras.layers.UpSampling3D(size=2)(x)",
            "answer": "UpSampling3D",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_228"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "The code pads a 3D input tensor with zeroes to increase its spatial dimensions.",
            "code": "input_shape = (1, 1, 2, 2, 3)\nx = np.arange(np.prod(input_shape)).reshape(input_shape)\ny = tf.keras.layers.ZeroPadding3D(padding=2)(x)\nprint(y.shape)\n(1, 5, 6, 6, 3)",
            "masked_code": "input_shape = (1, 1, 2, 2, 3)\nx = np.arange(np.prod(input_shape)).reshape(input_shape)\n<line_mask>\nprint(y.shape)\n(1, 5, 6, 6, 3)",
            "masked_line": "y = tf.keras.layers.ZeroPadding3D(padding=2)(x)",
            "answer": "ZeroPadding3D",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_229"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "This code crops the input tensor `x` along the spatial dimensions by discarding the specified number of rows and columns from the top, bottom, left, and right side of the tensor. The output tensor `y` has a shape of (2, 24, 20, 3).",
            "code": "input_shape = (2, 28, 28, 3)\nx = np.arange(np.prod(input_shape)).reshape(input_shape)\ny = tf.keras.layers.Cropping2D(cropping=((2, 2), (4, 4)))(x)\nprint(y.shape)\n(2, 24, 20, 3)",
            "masked_code": "input_shape = (2, 28, 28, 3)\nx = np.arange(np.prod(input_shape)).reshape(input_shape)\n<line_mask>\nprint(y.shape)\n(2, 24, 20, 3)",
            "masked_line": "y = tf.keras.layers.Cropping2D(cropping=((2, 2), (4, 4)))(x)",
            "answer": "Cropping2D",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_230"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "This code performs 3D cropping on the input tensor x, removing 2 units from the start and 4 units from the end of the first dimension, 2 units from the start and 2 units from the end of the second dimension, and 2 units from the start and 1 unit from the end of the third dimension.",
            "code": "input_shape = (2, 28, 28, 10, 3)\nx = np.arange(np.prod(input_shape)).reshape(input_shape)\ny = tf.keras.layers.Cropping3D(cropping=(2, 4, 2))(x)\nprint(y.shape)\n(2, 24, 20, 6, 3)",
            "masked_code": "input_shape = (2, 28, 28, 10, 3)\nx = np.arange(np.prod(input_shape)).reshape(input_shape)\n<line_mask>\nprint(y.shape)\n(2, 24, 20, 6, 3)",
            "masked_line": "y = tf.keras.layers.Cropping3D(cropping=(2, 4, 2))(x)",
            "answer": "Cropping3D",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_231"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "The code masks specific timesteps in the input data for an LSTM model, setting the values at timesteps 3 and 5 to 0 to be skipped during the LSTM calculation.",
            "code": "samples, timesteps, features = 32, 10, 8\ninputs = np.random.random([samples, timesteps, features]).astype(np.float32)\ninputs[:, 3, :] = 0.\ninputs[:, 5, :] = 0.\n\nmodel = tf.keras.models.Sequential()\nmodel.add(tf.keras.layers.Masking(mask_value=0.,\n                                  input_shape=(timesteps, features)))\nmodel.add(tf.keras.layers.LSTM(32))\n\noutput = model(inputs)\n# The time step 3 and 5 will be skipped from LSTM calculation.\n",
            "masked_code": "samples, timesteps, features = 32, 10, 8\ninputs = np.random.random([samples, timesteps, features]).astype(np.float32)\ninputs[:, 3, :] = 0.\ninputs[:, 5, :] = 0.\n\nmodel = tf.keras.models.Sequential()\n<line_mask>\n                                  input_shape=(timesteps, features)))\nmodel.add(tf.keras.layers.LSTM(32))\n\noutput = model(inputs)\n# The time step 3 and 5 will be skipped from LSTM calculation.\n",
            "masked_line": "model.add(tf.keras.layers.Masking(mask_value=0.,",
            "answer": "Masking",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_232"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "The code uses a ReLU activation function to transform input values. It sets negative values to 0 while leaving non-negative values unchanged.",
            "code": "layer = tf.keras.layers.Activation('relu')\noutput = layer([-3.0, -1.0, 0.0, 2.0])\nlist(output.numpy())\n[0.0, 0.0, 0.0, 2.0]\nlayer = tf.keras.layers.Activation(tf.nn.relu)\noutput = layer([-3.0, -1.0, 0.0, 2.0])\nlist(output.numpy())\n[0.0, 0.0, 0.0, 2.0]",
            "masked_code": "layer = tf.keras.layers.Activation('relu')\noutput = layer([-3.0, -1.0, 0.0, 2.0])\nlist(output.numpy())\n[0.0, 0.0, 0.0, 2.0]\n<line_mask>\noutput = layer([-3.0, -1.0, 0.0, 2.0])\nlist(output.numpy())\n[0.0, 0.0, 0.0, 2.0]",
            "masked_line": "layer = tf.keras.layers.Activation(tf.nn.relu)",
            "answer": "Activation",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_233"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "The code defines a convolutional neural network model using TensorFlow. The model has a convolutional layer with 64 filters and a 3x3 kernel size, taking an input shape of (3, 32, 32). Afterwards, a flattening layer is added to convert the output shape to (None, 640).",
            "code": "model = tf.keras.Sequential()\nmodel.add(tf.keras.layers.Conv2D(64, 3, 3, input_shape=(3, 32, 32)))\nmodel.output_shape\n(None, 1, 10, 64)\n\nmodel.add(Flatten())\nmodel.output_shape\n(None, 640)\n",
            "masked_code": "model = tf.keras.Sequential()\nmodel.add(tf.keras.layers.Conv2D(64, 3, 3, input_shape=(3, 32, 32)))\nmodel.output_shape\n(None, 1, 10, 64)\n\n<line_mask>\nmodel.output_shape\n(None, 640)\n",
            "masked_line": "model.add(Flatten())",
            "answer": "Flatten",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_234"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "The code defines a neural network model using Keras with two input layers of different shapes. Each input is passed through a dense layer with ReLU activation function. The output of the two dense layers is then subtracted element-wise. Finally, the result is passed through another dense layer to produce the output of shape (4).",
            "code": "import keras\n\ninput1 = keras.layers.Input(shape=(16,))\nx1 = keras.layers.Dense(8, activation='relu')(input1)\ninput2 = keras.layers.Input(shape=(32,))\nx2 = keras.layers.Dense(8, activation='relu')(input2)\n# Equivalent to subtracted = keras.layers.subtract([x1, x2])\nsubtracted = keras.layers.Subtract()([x1, x2])\n\nout = keras.layers.Dense(4)(subtracted)\nmodel = keras.models.Model(inputs=[input1, input2], outputs=out)\n",
            "masked_code": "import keras\n\ninput1 = keras.layers.Input(shape=(16,))\nx1 = keras.layers.Dense(8, activation='relu')(input1)\ninput2 = keras.layers.Input(shape=(32,))\nx2 = keras.layers.Dense(8, activation='relu')(input2)\n# Equivalent to subtracted = keras.layers.subtract([x1, x2])\n<line_mask>\n\nout = keras.layers.Dense(4)(subtracted)\nmodel = keras.models.Model(inputs=[input1, input2], outputs=out)\n",
            "masked_line": "subtracted = keras.layers.Subtract()([x1, x2])",
            "answer": "Subtract",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_235"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "The code concatenates two sets of arrays along a specific axis using TensorFlow's Concatenate function. The first set of arrays, x and y, are reshaped arrays created using NumPy's arange function. The second set of arrays, x1 and x2, are created by applying dense layers to reshaped arrays generated using NumPy's arange function. Finally, the concatenated array concatted is created by concatenating x1 and x2 along the default axis.",
            "code": "x = np.arange(20).reshape(2, 2, 5)\nprint(x)\ny = np.arange(20, 30).reshape(2, 1, 5)\nprint(y)\ntf.keras.layers.Concatenate(axis=1)([x, y])\n\nx1 = tf.keras.layers.Dense(8)(np.arange(10).reshape(5, 2))\nx2 = tf.keras.layers.Dense(8)(np.arange(10, 20).reshape(5, 2))\nconcatted = tf.keras.layers.Concatenate()([x1, x2])\nconcatted.shape",
            "masked_code": "x = np.arange(20).reshape(2, 2, 5)\nprint(x)\ny = np.arange(20, 30).reshape(2, 1, 5)\nprint(y)\n<line_mask>\n\nx1 = tf.keras.layers.Dense(8)(np.arange(10).reshape(5, 2))\nx2 = tf.keras.layers.Dense(8)(np.arange(10, 20).reshape(5, 2))\nconcatted = tf.keras.layers.Concatenate()([x1, x2])\nconcatted.shape",
            "masked_line": "tf.keras.layers.Concatenate(axis=1)([x, y])",
            "answer": "Concatenate",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_236"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "The code calculates the global average pooling along the Time axis for a 3D tensor x with shape (2, 3, 4), resulting in a new tensor y with shape (2, 4).",
            "code": "input_shape = (2, 3, 4)\nx = tf.random.normal(input_shape)\ny = tf.keras.layers.GlobalAveragePooling1D()(x)\nprint(y.shape)\n(2, 4)",
            "masked_code": "input_shape = (2, 3, 4)\nx = tf.random.normal(input_shape)\n<line_mask>\nprint(y.shape)\n(2, 4)",
            "masked_line": "y = tf.keras.layers.GlobalAveragePooling1D()(x)",
            "answer": "GlobalAveragePooling1D",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_237"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "The code initializes an input shape of (2, 4, 5, 3), creates a random tensor of that shape using TensorFlow, applies a global average pooling operation along the spatial dimensions of the tensor, and prints the shape of the resulting tensor which is (2, 3).",
            "code": "input_shape = (2, 4, 5, 3)\nx = tf.random.normal(input_shape)\ny = tf.keras.layers.GlobalAveragePooling2D()(x)\nprint(y.shape)\n(2, 3)",
            "masked_code": "input_shape = (2, 4, 5, 3)\nx = tf.random.normal(input_shape)\n<line_mask>\nprint(y.shape)\n(2, 3)",
            "masked_line": "y = tf.keras.layers.GlobalAveragePooling2D()(x)",
            "answer": "GlobalAveragePooling2D",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_238"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "This code defines a two-layer LSTM neural network model with 128 units in each layer. It takes input data `x` with shape `(batch_size, sentence_max_length, n_features)` and processes it through the LSTM layers to generate an output `result`.",
            "code": "batch_size = 3\nsentence_max_length = 5\nn_features = 2\nnew_shape = (batch_size, sentence_max_length, n_features)\nx = tf.constant(np.reshape(np.arange(30), new_shape), dtype = tf.float32)\n\nrnn_cells = [tf.keras.layers.LSTMCell(128) for _ in range(2)]\nstacked_lstm = tf.keras.layers.StackedRNNCells(rnn_cells)\nlstm_layer = tf.keras.layers.RNN(stacked_lstm)\n\nresult = lstm_layer(x)\n",
            "masked_code": "batch_size = 3\nsentence_max_length = 5\nn_features = 2\nnew_shape = (batch_size, sentence_max_length, n_features)\nx = tf.constant(np.reshape(np.arange(30), new_shape), dtype = tf.float32)\n\nrnn_cells = [tf.keras.layers.LSTMCell(128) for _ in range(2)]\n<line_mask>\nlstm_layer = tf.keras.layers.RNN(stacked_lstm)\n\nresult = lstm_layer(x)\n",
            "masked_line": "stacked_lstm = tf.keras.layers.StackedRNNCells(rnn_cells)",
            "answer": "StackedRNNCells",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_239"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "Calculate the mean and variance of data points in each row of an array, normalize the data points, and then apply gamma and beta scaling to each data point.",
            "code": "data = tf.constant(np.arange(10).reshape(5, 2) * 10, dtype=tf.float32)\nprint(data)\n\n\nlayer = tf.keras.layers.LayerNormalization(axis=1)\noutput = layer(data)\nprint(output)\n\n\nmean_i = sum(x_i[j] for j in range(k)) / k\nvar_i = sum((x_i[j] - mean_i) ** 2 for j in range(k)) / k\n\n\nx_i_normalized = (x_i - mean_i) / sqrt(var_i + epsilon)\n\n\noutput_i = x_i_normalized * gamma + beta\n",
            "masked_code": "data = tf.constant(np.arange(10).reshape(5, 2) * 10, dtype=tf.float32)\nprint(data)\n\n\n<line_mask>\noutput = layer(data)\nprint(output)\n\n\nmean_i = sum(x_i[j] for j in range(k)) / k\nvar_i = sum((x_i[j] - mean_i) ** 2 for j in range(k)) / k\n\n\nx_i_normalized = (x_i - mean_i) / sqrt(var_i + epsilon)\n\n\noutput_i = x_i_normalized * gamma + beta\n",
            "masked_line": "layer = tf.keras.layers.LayerNormalization(axis=1)",
            "answer": "LayerNormalization",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_240"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "The code performs category crossing on two input lists, combining them into pairs using a specified separator.",
            "code": "inp_1 = ['a', 'b', 'c']\ninp_2 = ['d', 'e', 'f']\nlayer = tf.keras.layers.experimental.preprocessing.CategoryCrossing()\nlayer([inp_1, inp_2])\n\ninp_1 = ['a', 'b', 'c']\ninp_2 = ['d', 'e', 'f']\nlayer = tf.keras.layers.experimental.preprocessing.CategoryCrossing(\n   separator='-')\nlayer([inp_1, inp_2])",
            "masked_code": "inp_1 = ['a', 'b', 'c']\ninp_2 = ['d', 'e', 'f']\n<line_mask>\nlayer([inp_1, inp_2])\n\ninp_1 = ['a', 'b', 'c']\ninp_2 = ['d', 'e', 'f']\nlayer = tf.keras.layers.experimental.preprocessing.CategoryCrossing(\n   separator='-')\nlayer([inp_1, inp_2])",
            "masked_line": "layer = tf.keras.layers.experimental.preprocessing.CategoryCrossing()",
            "answer": "CategoryCrossing",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_241"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "The code is performing category encoding using different output modes: \"one_hot\", \"multi_hot\", and \"count\" for encoding input values into numerical representation based on the specified parameters.",
            "code": "layer = tf.keras.layers.CategoryEncoding(\n          num_tokens=4, output_mode=\"one_hot\")\nlayer([3, 2, 0, 1])\n\n\nlayer = tf.keras.layers.CategoryEncoding(\n          num_tokens=4, output_mode=\"multi_hot\")\nlayer([[0, 1], [0, 0], [1, 2], [3, 1]])\n\n\nlayer = tf.keras.layers.CategoryEncoding(\n          num_tokens=4, output_mode=\"count\")\ncount_weights = np.array([[.1, .2], [.1, .1], [.2, .3], [.4, .2]])\nlayer([[0, 1], [0, 0], [1, 2], [3, 1]], count_weights=count_weights)\n",
            "masked_code": "layer = tf.keras.layers.CategoryEncoding(\n          num_tokens=4, output_mode=\"one_hot\")\nlayer([3, 2, 0, 1])\n\n\n<line_mask>\n          num_tokens=4, output_mode=\"multi_hot\")\nlayer([[0, 1], [0, 0], [1, 2], [3, 1]])\n\n\nlayer = tf.keras.layers.CategoryEncoding(\n          num_tokens=4, output_mode=\"count\")\ncount_weights = np.array([[.1, .2], [.1, .1], [.2, .3], [.4, .2]])\nlayer([[0, 1], [0, 0], [1, 2], [3, 1]], count_weights=count_weights)\n",
            "masked_line": "layer = tf.keras.layers.CategoryEncoding(",
            "answer": "CategoryEncoding",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_242"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "The code initializes two Dense layers with different constant initializers, applies the layers to input tensors, retrieves the weights of the layers, sets the weights of the second layer to be the same as the weights of the first layer, and then retrieves the updated weights of the second layer.",
            "code": "layer_a = tf.keras.layers.Dense(1,\n  kernel_initializer=tf.constant_initializer(1.))\na_out = layer_a(tf.convert_to_tensor([[1., 2., 3.]]))\nlayer_a.get_weights()\nlayer_b = tf.keras.layers.Dense(1,\n  kernel_initializer=tf.constant_initializer(2.))\nb_out = layer_b(tf.convert_to_tensor([[10., 20., 30.]]))\nlayer_b.get_weights()\nlayer_b.set_weights(layer_a.get_weights())\nlayer_b.get_weights()",
            "masked_code": "layer_a = tf.keras.layers.Dense(1,\n  kernel_initializer=tf.constant_initializer(1.))\na_out = layer_a(tf.convert_to_tensor([[1., 2., 3.]]))\nlayer_a.get_weights()\nlayer_b = tf.keras.layers.Dense(1,\n  kernel_initializer=tf.constant_initializer(2.))\nb_out = layer_b(tf.convert_to_tensor([[10., 20., 30.]]))\nlayer_b.get_weights()\nlayer_b.set_weights(layer_a.get_weights())\n<line_mask>",
            "masked_line": "layer_b.get_weights()",
            "answer": "get_weights",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_243"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "The code performs 3D convolution on randomly generated data using TensorFlow. It creates two 3D convolutional layers with 2 filters, relu activation, and different input shapes, and prints the shape of the output tensor for each convolutional layer.",
            "code": "input_shape =(4, 28, 28, 28, 1)\nx = tf.random.normal(input_shape)\ny = tf.keras.layers.Conv3D(\n2, 3, activation='relu', input_shape=input_shape[1:])(x)\nprint(y.shape)\n(4, 26, 26, 26, 2)\n\ninput_shape = (4, 7, 28, 28, 28, 1)\nx = tf.random.normal(input_shape)\ny = tf.keras.layers.Conv3D(\n2, 3, activation='relu', input_shape=input_shape[2:])(x)\nprint(y.shape)\n(4, 7, 26, 26, 26, 2)\n",
            "masked_code": "input_shape =(4, 28, 28, 28, 1)\nx = tf.random.normal(input_shape)\n<line_mask>\n2, 3, activation='relu', input_shape=input_shape[1:])(x)\nprint(y.shape)\n(4, 26, 26, 26, 2)\n\ninput_shape = (4, 7, 28, 28, 28, 1)\nx = tf.random.normal(input_shape)\ny = tf.keras.layers.Conv3D(\n2, 3, activation='relu', input_shape=input_shape[2:])(x)\nprint(y.shape)\n(4, 7, 26, 26, 26, 2)\n",
            "masked_line": "y = tf.keras.layers.Conv3D(",
            "answer": "Conv3D",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_245"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "The code creates a deep learning model with a convolutional layer with 64 filters, each of size 3x3, taking an input shape of 3 channels, each of size 32x32. It then adds a Flatten layer to the model.",
            "code": "model = tf.keras.Sequential()\nmodel.add(tf.keras.layers.Conv2D(64, 3, 3, input_shape=(3, 32, 32)))\nmodel.output_shape\nmodel.add(Flatten())\nmodel.output_shape\n",
            "masked_code": "model = tf.keras.Sequential()\nmodel.add(tf.keras.layers.Conv2D(64, 3, 3, input_shape=(3, 32, 32)))\nmodel.output_shape\n<line_mask>\nmodel.output_shape\n",
            "masked_line": "model.add(Flatten())",
            "answer": "Flatten",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_246"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "The first code snippet creates a custom learning rate scheduler using ExponentialDecay in the Keras library, with an initial learning rate of 1e-2, decay steps of 10000, and decay rate of 0.9. It then uses this scheduler to initialize a stochastic gradient descent (SGD) optimizer.\n\nThe second code snippet defines a custom learning rate schedule class that divides the initial learning rate by the step (plus 1) when called. It then uses this custom learning rate scheduler to initialize a SGD optimizer in TensorFlow.",
            "code": "lr_schedule = keras.optimizers.schedules.ExponentialDecay(\n    initial_learning_rate=1e-2,\n    decay_steps=10000,\n    decay_rate=0.9)\noptimizer = keras.optimizers.SGD(learning_rate=lr_schedule)\n\n\nclass MyLRSchedule(tf.keras.optimizers.schedules.LearningRateSchedule):\n\n  def __init__(self, initial_learning_rate):\n    self.initial_learning_rate = initial_learning_rate\n\n  def __call__(self, step):\n     return self.initial_learning_rate / (step + 1)\n\noptimizer = tf.keras.optimizers.SGD(learning_rate=MyLRSchedule(0.1))\n",
            "masked_code": "lr_schedule = keras.optimizers.schedules.ExponentialDecay(\n    initial_learning_rate=1e-2,\n    decay_steps=10000,\n    decay_rate=0.9)\noptimizer = keras.optimizers.SGD(learning_rate=lr_schedule)\n\n\n<line_mask>\n\n  def __init__(self, initial_learning_rate):\n    self.initial_learning_rate = initial_learning_rate\n\n  def __call__(self, step):\n     return self.initial_learning_rate / (step + 1)\n\noptimizer = tf.keras.optimizers.SGD(learning_rate=MyLRSchedule(0.1))\n",
            "masked_line": "class MyLRSchedule(tf.keras.optimizers.schedules.LearningRateSchedule):",
            "answer": "LearningRateSchedule",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_247"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "This code defines a function `decayed_learning_rate(step)` that calculates a learning rate based on an exponential decay formula. The learning rate is calculated as the initial learning rate multiplied by the decay rate raised to the power of the step divided by the number of decay steps. The code then uses this decayed learning rate to create a learning rate schedule using TensorFlow's ExponentialDecay function, and it compiles a model using stochastic gradient descent optimizer with this learning rate schedule. Finally, the model is trained on the provided data and labels for 5 epochs.",
            "code": "def decayed_learning_rate(step):\n  return initial_learning_rate * decay_rate ^ (step / decay_steps)\n\n\ninitial_learning_rate = 0.1\nlr_schedule = tf.keras.optimizers.schedules.ExponentialDecay(\n    initial_learning_rate,\n    decay_steps=100000,\n    decay_rate=0.96,\n    staircase=True)\n\nmodel.compile(optimizer=tf.keras.optimizers.SGD(learning_rate=lr_schedule),\n              loss='sparse_categorical_crossentropy',\n              metrics=['accuracy'])\n\nmodel.fit(data, labels, epochs=5)\n",
            "masked_code": "def decayed_learning_rate(step):\n  return initial_learning_rate * decay_rate ^ (step / decay_steps)\n\n\ninitial_learning_rate = 0.1\n<line_mask>\n    initial_learning_rate,\n    decay_steps=100000,\n    decay_rate=0.96,\n    staircase=True)\n\nmodel.compile(optimizer=tf.keras.optimizers.SGD(learning_rate=lr_schedule),\n              loss='sparse_categorical_crossentropy',\n              metrics=['accuracy'])\n\nmodel.fit(data, labels, epochs=5)\n",
            "masked_line": "lr_schedule = tf.keras.optimizers.schedules.ExponentialDecay(",
            "answer": "ExponentialDecay",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_248"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "The code defines a piecewise constant learning rate decay schedule based on the given boundaries and values, and calculates the learning rate based on the current step during optimization.",
            "code": "step = tf.Variable(0, trainable=False)\nboundaries = [100000, 110000]\nvalues = [1.0, 0.5, 0.1]\nlearning_rate_fn = keras.optimizers.schedules.PiecewiseConstantDecay(\n    boundaries, values)\n\n# Later, whenever we perform an optimization step, we pass in the step.\nlearning_rate = learning_rate_fn(step)\n",
            "masked_code": "step = tf.Variable(0, trainable=False)\nboundaries = [100000, 110000]\nvalues = [1.0, 0.5, 0.1]\n<line_mask>\n    boundaries, values)\n\n# Later, whenever we perform an optimization step, we pass in the step.\nlearning_rate = learning_rate_fn(step)\n",
            "masked_line": "learning_rate_fn = keras.optimizers.schedules.PiecewiseConstantDecay(",
            "answer": "PiecewiseConstantDecay",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_249"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "This function calculates a decayed learning rate based on the step number provided as input. It uses a cosine decay formula with a specified decay steps parameter, alpha value, and initial learning rate.",
            "code": "def decayed_learning_rate(step):\n  step = min(step, decay_steps)\n  cosine_decay = 0.5 * (1 + cos(pi * step / decay_steps))\n  decayed = (1 - alpha) * cosine_decay + alpha\n  return initial_learning_rate * decayed\n\n\ndecay_steps = 1000\nlr_decayed_fn = tf.keras.optimizers.schedules.CosineDecay(\n    initial_learning_rate, decay_steps)\n",
            "masked_code": "def decayed_learning_rate(step):\n  step = min(step, decay_steps)\n  cosine_decay = 0.5 * (1 + cos(pi * step / decay_steps))\n  decayed = (1 - alpha) * cosine_decay + alpha\n  return initial_learning_rate * decayed\n\n\ndecay_steps = 1000\n<line_mask>\n    initial_learning_rate, decay_steps)\n",
            "masked_line": "lr_decayed_fn = tf.keras.optimizers.schedules.CosineDecay(",
            "answer": "CosineDecay",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_250"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "This function calculates a decayed learning rate based on the step, decay_steps, alpha, beta, num_periods, pi, and initial_learning_rate parameters provided. It combines linear decay and cosine decay formulas to compute the decayed learning rate.",
            "code": "def decayed_learning_rate(step):\n  step = min(step, decay_steps)\n  linear_decay = (decay_steps - step) / decay_steps\n  cosine_decay = 0.5 * (\n      1 + cos(pi * 2 * num_periods * step / decay_steps))\n  decayed = (alpha + linear_decay) * cosine_decay + beta\n  return initial_learning_rate * decayed\n\n\ndecay_steps = 1000\nlr_decayed_fn = (\n  tf.keras.experimental.LinearCosineDecay(\n    initial_learning_rate, decay_steps))\n",
            "masked_code": "def decayed_learning_rate(step):\n  step = min(step, decay_steps)\n  linear_decay = (decay_steps - step) / decay_steps\n  cosine_decay = 0.5 * (\n      1 + cos(pi * 2 * num_periods * step / decay_steps))\n  decayed = (alpha + linear_decay) * cosine_decay + beta\n  return initial_learning_rate * decayed\n\n\ndecay_steps = 1000\nlr_decayed_fn = (\n  <line_mask>\n    initial_learning_rate, decay_steps))\n",
            "masked_line": "tf.keras.experimental.LinearCosineDecay(",
            "answer": "LinearCosineDecay",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_251"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "The code initializes an RMSprop optimizer, creates a neural network model with a single layer of 10 neurons, compiles the model using the optimizer and mean squared error loss, prepares data and labels for training, prints 'Training' to the console, fits the model to the data and labels, and then returns the length of the weights in the optimizer.",
            "code": "opt = tf.keras.optimizers.RMSprop()\nm = tf.keras.models.Sequential([tf.keras.layers.Dense(10)])\nm.compile(opt, loss='mse')\ndata = np.arange(100).reshape(5, 20)\nlabels = np.zeros(5)\nprint('Training'); results = m.fit(data, labels)\nlen(opt.get_weights())",
            "masked_code": "opt = tf.keras.optimizers.RMSprop()\nm = tf.keras.models.Sequential([tf.keras.layers.Dense(10)])\nm.compile(opt, loss='mse')\ndata = np.arange(100).reshape(5, 20)\nlabels = np.zeros(5)\nprint('Training'); results = m.fit(data, labels)\n<line_mask>",
            "masked_line": "len(opt.get_weights())",
            "answer": "get_weights",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_252"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "The code initializes a neural network model with 1 layer of 10 neurons and compiles it using RMSprop optimizer with mean squared error loss. It then trains the model on a dataset of shape (5, 20) with zero labels. After training, it sets new weights for the optimizer and returns the number of iterations performed.",
            "code": "opt = tf.keras.optimizers.RMSprop()\nm = tf.keras.models.Sequential([tf.keras.layers.Dense(10)])\nm.compile(opt, loss='mse')\ndata = np.arange(100).reshape(5, 20)\nlabels = np.zeros(5)\nprint('Training'); results = m.fit(data, labels)\nnew_weights = [np.array(10), np.ones([20, 10]), np.zeros([10])]\nopt.set_weights(new_weights)\nopt.iterations",
            "masked_code": "opt = tf.keras.optimizers.RMSprop()\nm = tf.keras.models.Sequential([tf.keras.layers.Dense(10)])\nm.compile(opt, loss='mse')\ndata = np.arange(100).reshape(5, 20)\nlabels = np.zeros(5)\nprint('Training'); results = m.fit(data, labels)\nnew_weights = [np.array(10), np.ones([20, 10]), np.zeros([10])]\n<line_mask>\nopt.iterations",
            "masked_line": "opt.set_weights(new_weights)",
            "answer": "set_weights",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_253"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "This code generates time-series sequences from data and targets, with a specified length, sampling rate, and batch size. It then verifies the length of the generated data is 20, extracts the first batch, and checks if the input (x) and output (y) sequences of the batch match the expected values.",
            "code": "from keras.preprocessing.sequence import TimeseriesGenerator\nimport numpy as np\ndata = np.array([[i] for i in range(50)])\ntargets = np.array([[i] for i in range(50)])\ndata_gen = TimeseriesGenerator(data, targets,\n                               length=10, sampling_rate=2,\n                               batch_size=2)\nassert len(data_gen) == 20\nbatch_0 = data_gen[0]\nx, y = batch_0\nassert np.array_equal(x,\n                      np.array([[[0], [2], [4], [6], [8]],\n                                [[1], [3], [5], [7], [9]]]))\nassert np.array_equal(y,\n                      np.array([[10], [11]]))\n",
            "masked_code": "from keras.preprocessing.sequence import TimeseriesGenerator\nimport numpy as np\ndata = np.array([[i] for i in range(50)])\ntargets = np.array([[i] for i in range(50)])\n<line_mask>\n                               length=10, sampling_rate=2,\n                               batch_size=2)\nassert len(data_gen) == 20\nbatch_0 = data_gen[0]\nx, y = batch_0\nassert np.array_equal(x,\n                      np.array([[[0], [2], [4], [6], [8]],\n                                [[1], [3], [5], [7], [9]]]))\nassert np.array_equal(y,\n                      np.array([[10], [11]]))\n",
            "masked_line": "data_gen = TimeseriesGenerator(data, targets,",
            "answer": "TimeseriesGenerator",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_254"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "The code applies different variants of the rectified linear activation function to the input array \"foo\" and returns the result as a numpy array.",
            "code": "foo = tf.constant([-10, -5, 0.0, 5, 10], dtype = tf.float32)\ntf.keras.activations.relu(foo).numpy()\ntf.keras.activations.relu(foo, alpha=0.5).numpy()\ntf.keras.activations.relu(foo, max_value=5).numpy()\ntf.keras.activations.relu(foo, threshold=5).numpy()\n",
            "masked_code": "foo = tf.constant([-10, -5, 0.0, 5, 10], dtype = tf.float32)\ntf.keras.activations.relu(foo).numpy()\ntf.keras.activations.relu(foo, alpha=0.5).numpy()\n<line_mask>\ntf.keras.activations.relu(foo, threshold=5).numpy()\n",
            "masked_line": "tf.keras.activations.relu(foo, max_value=5).numpy()",
            "answer": "relu",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_255"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "The code applies the Gaussian Error Linear Unit (GELU) activation function to a given input array x, with and without the approximate parameter set to True. The output arrays y are then printed.",
            "code": "x = tf.constant([-3.0, -1.0, 0.0, 1.0, 3.0], dtype=tf.float32)\ny = tf.keras.activations.gelu(x)\ny.numpy()\narray([-0.00404951, -0.15865529,  0.        ,  0.8413447 ,  2.9959507 ],\n    dtype=float32)\ny = tf.keras.activations.gelu(x, approximate=True)\ny.numpy()\narray([-0.00363752, -0.15880796,  0.        ,  0.841192  ,  2.9963627 ],\n    dtype=float32)\n",
            "masked_code": "x = tf.constant([-3.0, -1.0, 0.0, 1.0, 3.0], dtype=tf.float32)\n<line_mask>\ny.numpy()\narray([-0.00404951, -0.15865529,  0.        ,  0.8413447 ,  2.9959507 ],\n    dtype=float32)\ny = tf.keras.activations.gelu(x, approximate=True)\ny.numpy()\narray([-0.00363752, -0.15880796,  0.        ,  0.841192  ,  2.9963627 ],\n    dtype=float32)\n",
            "masked_line": "y = tf.keras.activations.gelu(x)",
            "answer": "gelu",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_256"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "The code uses the `tf.keras.activations.get` function to retrieve various activation functions by passing in different arguments: the string 'softmax', the softmax activation function itself, None, the abs function, and the string 'abcd'.",
            "code": "tf.keras.activations.get('softmax')\ntf.keras.activations.get(tf.keras.activations.softmax)\ntf.keras.activations.get(None)\ntf.keras.activations.get(abs)\ntf.keras.activations.get('abcd')\n",
            "masked_code": "tf.keras.activations.get('softmax')\ntf.keras.activations.get(tf.keras.activations.softmax)\ntf.keras.activations.get(None)\n<line_mask>\ntf.keras.activations.get('abcd')\n",
            "masked_line": "tf.keras.activations.get(abs)",
            "answer": "get",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_257"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "The code converts the input array to a floating point array and returns a new array with data type float32.",
            "code": "cast_to_floatx(arr)\nnew_arr\narray([1.,  2.], dtype=float32)\nnew_arr.dtype\ndtype('float32')",
            "masked_code": "<line_mask>\nnew_arr\narray([1.,  2.], dtype=float32)\nnew_arr.dtype\ndtype('float32')",
            "masked_line": "cast_to_floatx(arr)",
            "answer": "cast_to_floatx",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_258"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "The code creates two placeholders of shape (2, 2) using TensorFlow's Keras backend, with the first placeholder set as non-sparse (sparse=False) and the second placeholder set as sparse (sparse=True). The code then checks if each placeholder is sparse or not, and prints a boolean value indicating whether each placeholder is sparse or not.",
            "code": "a = tf.keras.backend.placeholder((2, 2), sparse=False)\nprint(tf.keras.backend.is_sparse(a))\nFalse\nb = tf.keras.backend.placeholder((2, 2), sparse=True)\nprint(tf.keras.backend.is_sparse(b))\nTrue",
            "masked_code": "a = tf.keras.backend.placeholder((2, 2), sparse=False)\n<line_mask>\nFalse\nb = tf.keras.backend.placeholder((2, 2), sparse=True)\nprint(tf.keras.backend.is_sparse(b))\nTrue",
            "masked_line": "print(tf.keras.backend.is_sparse(a))",
            "answer": "is_sparse",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_259"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "The code creates and checks various types of keras tensors and variables.",
            "code": "np_var = np.array([1, 2])\ntf.keras.backend.is_keras_tensor(np_var)\nkeras_var = tf.keras.backend.variable(np_var)\ntf.keras.backend.is_keras_tensor(keras_var)\nkeras_placeholder = tf.keras.backend.placeholder(shape=(2, 4, 5))\ntf.keras.backend.is_keras_tensor(keras_placeholder)\nkeras_input = tf.keras.layers.Input([10])\ntf.keras.backend.is_keras_tensor(keras_input)\nkeras_layer_output = tf.keras.layers.Dense(10)(keras_input)\ntf.keras.backend.is_keras_tensor(keras_layer_output)",
            "masked_code": "np_var = np.array([1, 2])\n<line_mask>\nkeras_var = tf.keras.backend.variable(np_var)\ntf.keras.backend.is_keras_tensor(keras_var)\nkeras_placeholder = tf.keras.backend.placeholder(shape=(2, 4, 5))\ntf.keras.backend.is_keras_tensor(keras_placeholder)\nkeras_input = tf.keras.layers.Input([10])\ntf.keras.backend.is_keras_tensor(keras_input)\nkeras_layer_output = tf.keras.layers.Dense(10)(keras_input)\ntf.keras.backend.is_keras_tensor(keras_layer_output)",
            "masked_line": "tf.keras.backend.is_keras_tensor(np_var)",
            "answer": "is_keras_tensor",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_260"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "The code creates a tensor object 'kvar' with a specified value, and then obtains its shape using the TensorFlow backend. It also creates a placeholder 'input' tensor with a specified shape and obtains its shape using the TensorFlow backend.",
            "code": "val = np.array([[1, 2], [3, 4]])\nkvar = tf.keras.backend.variable(value=val)\ntf.keras.backend.shape(kvar)\ninput = tf.keras.backend.placeholder(shape=(2, 4, 5))\ntf.keras.backend.shape(input)",
            "masked_code": "val = np.array([[1, 2], [3, 4]])\nkvar = tf.keras.backend.variable(value=val)\n<line_mask>\ninput = tf.keras.backend.placeholder(shape=(2, 4, 5))\ntf.keras.backend.shape(input)",
            "masked_line": "tf.keras.backend.shape(kvar)",
            "answer": "shape",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_261"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "This code creates a placeholder tensor with shape (2, 4, 5), and then determines the shape of the tensor. Next, it creates a variable tensor with value [[1, 2], [3, 4]] and determines the shape of the variable tensor, which is (2, 2).",
            "code": "input = tf.keras.backend.placeholder(shape=(2, 4, 5))\ntf.keras.backend.int_shape(input)\n(2, 4, 5)\nval = np.array([[1, 2], [3, 4]])\nkvar = tf.keras.backend.variable(value=val)\ntf.keras.backend.int_shape(kvar)\n(2, 2)",
            "masked_code": "input = tf.keras.backend.placeholder(shape=(2, 4, 5))\n<line_mask>\n(2, 4, 5)\nval = np.array([[1, 2], [3, 4]])\nkvar = tf.keras.backend.variable(value=val)\ntf.keras.backend.int_shape(kvar)\n(2, 2)",
            "masked_line": "tf.keras.backend.int_shape(input)",
            "answer": "int_shape",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_262"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "The code creates a placeholder array with shape (2, 4, 5) using TensorFlow backend, and then creates a variable array with values [[1, 2], [3, 4]]. It then calculates and returns the number of dimensions of the placeholder array and the variable array, which are 3 and 2 respectively.",
            "code": "input = tf.keras.backend.placeholder(shape=(2, 4, 5))\nval = np.array([[1, 2], [3, 4]])\nkvar = tf.keras.backend.variable(value=val)\ntf.keras.backend.ndim(input)\n3\ntf.keras.backend.ndim(kvar)\n2",
            "masked_code": "input = tf.keras.backend.placeholder(shape=(2, 4, 5))\nval = np.array([[1, 2], [3, 4]])\nkvar = tf.keras.backend.variable(value=val)\ntf.keras.backend.ndim(input)\n3\n<line_mask>\n2",
            "masked_line": "tf.keras.backend.ndim(kvar)",
            "answer": "ndim",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_263"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "The code defines placeholder tensors of different shapes and data types using TensorFlow's backend functions, and also creates variables with specific values and data types. It then checks and returns the data type of the created variables.",
            "code": "tf.keras.backend.dtype(tf.keras.backend.placeholder(shape=(2,4,5)))\ntf.keras.backend.dtype(tf.keras.backend.placeholder(shape=(2,4,5), dtype='float32'))\ntf.keras.backend.dtype(tf.keras.backend.placeholder(shape=(2,4,5), dtype='float64'))\nkvar = tf.keras.backend.variable(np.array([[1, 2], [3, 4]]))\ntf.keras.backend.dtype(kvar)\nkvar = tf.keras.backend.variable(np.array([[1, 2], [3, 4]]), dtype='float32')\ntf.keras.backend.dtype(kvar)",
            "masked_code": "tf.keras.backend.dtype(tf.keras.backend.placeholder(shape=(2,4,5)))\n<line_mask>\ntf.keras.backend.dtype(tf.keras.backend.placeholder(shape=(2,4,5), dtype='float64'))\nkvar = tf.keras.backend.variable(np.array([[1, 2], [3, 4]]))\ntf.keras.backend.dtype(kvar)\nkvar = tf.keras.backend.variable(np.array([[1, 2], [3, 4]]), dtype='float32')\ntf.keras.backend.dtype(kvar)",
            "masked_line": "tf.keras.backend.dtype(tf.keras.backend.placeholder(shape=(2,4,5), dtype='float32'))",
            "answer": "dtype",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_264"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "This code initializes different tensors filled with zeros using TensorFlow's Keras backend, with specific shapes and data types.",
            "code": "kvar = tf.keras.backend.zeros((3,4))\nA = tf.constant([1,2,3])\nkvar2 = tf.keras.backend.zeros(A.shape) # [0., 0., 0.]\nkvar3 = tf.keras.backend.zeros(A.shape,dtype=tf.int32)\nkvar4 = tf.keras.backend.zeros([2,3])",
            "masked_code": "<line_mask>\nA = tf.constant([1,2,3])\nkvar2 = tf.keras.backend.zeros(A.shape) # [0., 0., 0.]\nkvar3 = tf.keras.backend.zeros(A.shape,dtype=tf.int32)\nkvar4 = tf.keras.backend.zeros([2,3])",
            "masked_line": "kvar = tf.keras.backend.zeros((3,4))",
            "answer": "zeros",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_265"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "This code calculates a moving average using a momentum update formula, then calculates a new value based on the moving average.",
            "code": "x = tf.Variable(0.0)\nmomentum=0.9\nx = x * momentum + value * (1 - momentum)\nmoving_average_update(x, value = 2.0, momentum=momentum).numpy()\nx.numpy()\nnum_updates = 1.0\nx_zdb = x/(1 - momentum**num_updates)\nx_zdb.numpy()\n",
            "masked_code": "x = tf.Variable(0.0)\nmomentum=0.9\nx = x * momentum + value * (1 - momentum)\n<line_mask>\nx.numpy()\nnum_updates = 1.0\nx_zdb = x/(1 - momentum**num_updates)\nx_zdb.numpy()\n",
            "masked_line": "moving_average_update(x, value = 2.0, momentum=momentum).numpy()",
            "answer": "moving_average_update",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_266"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "The code calculates the dot product of two tensors x and y using TensorFlow's backend operations.",
            "code": "x = tf.keras.backend.placeholder(shape=(2, 3))\ny = tf.keras.backend.placeholder(shape=(3, 4))\nxy = tf.keras.backend.dot(x, y)\n\nx = tf.keras.backend.placeholder(shape=(32, 28, 3))\ny = tf.keras.backend.placeholder(shape=(3, 4))\nxy = tf.keras.backend.dot(x, y)\n\nx = tf.keras.backend.random_uniform_variable(shape=(2, 3), low=0, high=1)\ny = tf.keras.backend.ones((4, 3, 5))\nxy = tf.keras.backend.dot(x, y)\ntf.keras.backend.int_shape(xy)",
            "masked_code": "x = tf.keras.backend.placeholder(shape=(2, 3))\ny = tf.keras.backend.placeholder(shape=(3, 4))\nxy = tf.keras.backend.dot(x, y)\n\nx = tf.keras.backend.placeholder(shape=(32, 28, 3))\ny = tf.keras.backend.placeholder(shape=(3, 4))\nxy = tf.keras.backend.dot(x, y)\n\nx = tf.keras.backend.random_uniform_variable(shape=(2, 3), low=0, high=1)\ny = tf.keras.backend.ones((4, 3, 5))\n<line_mask>\ntf.keras.backend.int_shape(xy)",
            "masked_line": "xy = tf.keras.backend.dot(x, y)",
            "answer": "dot",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_267"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "This code implements the rectified linear activation function (ReLU) with different parameters such as alpha, max_value, and threshold on a given input array.",
            "code": "foo = tf.constant([-10, -5, 0.0, 5, 10], dtype = tf.float32)\ntf.keras.activations.relu(foo).numpy()\ntf.keras.activations.relu(foo, alpha=0.5).numpy()\ntf.keras.activations.relu(foo, max_value=5).numpy()\ntf.keras.activations.relu(foo, threshold=5).numpy()\n",
            "masked_code": "foo = tf.constant([-10, -5, 0.0, 5, 10], dtype = tf.float32)\n<line_mask>\ntf.keras.activations.relu(foo, alpha=0.5).numpy()\ntf.keras.activations.relu(foo, max_value=5).numpy()\ntf.keras.activations.relu(foo, threshold=5).numpy()\n",
            "masked_line": "tf.keras.activations.relu(foo).numpy()",
            "answer": "relu",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_268"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "The code calculates the categorical crossentropy loss between two sets of probability distributions.",
            "code": "a = tf.constant([1., 0., 0., 0., 1., 0., 0., 0., 1.], shape=[3,3])\nb = tf.constant([.9, .05, .05, .05, .89, .06, .05, .01, .94], shape=[3,3])\nloss = tf.keras.backend.categorical_crossentropy(a, b)\nloss = tf.keras.backend.categorical_crossentropy(a, a)\nprint(np.around(loss, 5))",
            "masked_code": "a = tf.constant([1., 0., 0., 0., 1., 0., 0., 0., 1.], shape=[3,3])\nb = tf.constant([.9, .05, .05, .05, .89, .06, .05, .01, .94], shape=[3,3])\n<line_mask>\nloss = tf.keras.backend.categorical_crossentropy(a, a)\nprint(np.around(loss, 5))",
            "masked_line": "loss = tf.keras.backend.categorical_crossentropy(a, b)",
            "answer": "categorical_crossentropy",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_269"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "The code defines a test function that saves a keras Sequential model with specified layers and compiles it with specified loss and optimizer. The saved model is then loaded back into memory.",
            "code": "@testing_utils.run_with_all_saved_model_formats\ndef test_foo(self):\n    save_format = testing_utils.get_save_format()\n    saved_model_dir = '/tmp/saved_model/'\n    model = keras.models.Sequential()\n    model.add(keras.layers.Dense(2, input_shape=(3,)))\n    model.add(keras.layers.Dense(3))\n    model.compile(loss='mse', optimizer='sgd', metrics=['acc'])\n\n    keras.models.save_model(model, saved_model_dir, save_format=save_format)\n    model = keras.models.load_model(saved_model_dir)",
            "masked_code": "<line_mask>\ndef test_foo(self):\n    save_format = testing_utils.get_save_format()\n    saved_model_dir = '/tmp/saved_model/'\n    model = keras.models.Sequential()\n    model.add(keras.layers.Dense(2, input_shape=(3,)))\n    model.add(keras.layers.Dense(3))\n    model.compile(loss='mse', optimizer='sgd', metrics=['acc'])\n\n    keras.models.save_model(model, saved_model_dir, save_format=save_format)\n    model = keras.models.load_model(saved_model_dir)",
            "masked_line": "@testing_utils.run_with_all_saved_model_formats",
            "answer": "run_with_all_saved_model_formats",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_270"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "This code calculates the mean squared error between two arrays y_true and y_pred.",
            "code": "y_true = np.random.randint(0, 2, size=(2, 3))\ny_pred = np.random.random(size=(2, 3))\nloss = tf.keras.losses.mean_squared_error(y_true, y_pred)\nassert loss.shape == (2,)\nassert np.array_equal(\n    loss.numpy(), np.mean(np.square(y_true - y_pred), axis=-1))\n",
            "masked_code": "y_true = np.random.randint(0, 2, size=(2, 3))\ny_pred = np.random.random(size=(2, 3))\n<line_mask>\nassert loss.shape == (2,)\nassert np.array_equal(\n    loss.numpy(), np.mean(np.square(y_true - y_pred), axis=-1))\n",
            "masked_line": "loss = tf.keras.losses.mean_squared_error(y_true, y_pred)",
            "answer": "mean_squared_error",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_271"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "The code calculates the mean absolute error between two arrays y_true and y_pred and asserts that the shape of the calculated loss is (2,) and it is equal to the mean absolute error calculated using numpy.",
            "code": "y_true = np.random.randint(0, 2, size=(2, 3))\ny_pred = np.random.random(size=(2, 3))\nloss = tf.keras.losses.mean_absolute_error(y_true, y_pred)\nassert loss.shape == (2,)\nassert np.array_equal(\n    loss.numpy(), np.mean(np.abs(y_true - y_pred), axis=-1))\n",
            "masked_code": "y_true = np.random.randint(0, 2, size=(2, 3))\ny_pred = np.random.random(size=(2, 3))\n<line_mask>\nassert loss.shape == (2,)\nassert np.array_equal(\n    loss.numpy(), np.mean(np.abs(y_true - y_pred), axis=-1))\n",
            "masked_line": "loss = tf.keras.losses.mean_absolute_error(y_true, y_pred)",
            "answer": "mean_absolute_error",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_272"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "This code calculates the categorical hinge loss between true and predicted values for a classification task with 3 classes. It then computes the positive and negative terms of the loss and verifies that the loss is computed correctly.",
            "code": "y_true = np.random.randint(0, 3, size=(2,))\ny_true = tf.keras.utils.to_categorical(y_true, num_classes=3)\ny_pred = np.random.random(size=(2, 3))\nloss = tf.keras.losses.categorical_hinge(y_true, y_pred)\nassert loss.shape == (2,)\npos = np.sum(y_true * y_pred, axis=-1)\nneg = np.amax((1. - y_true) * y_pred, axis=-1)\nassert np.array_equal(loss.numpy(), np.maximum(0., neg - pos + 1.))",
            "masked_code": "y_true = np.random.randint(0, 3, size=(2,))\ny_true = tf.keras.utils.to_categorical(y_true, num_classes=3)\ny_pred = np.random.random(size=(2, 3))\n<line_mask>\nassert loss.shape == (2,)\npos = np.sum(y_true * y_pred, axis=-1)\nneg = np.amax((1. - y_true) * y_pred, axis=-1)\nassert np.array_equal(loss.numpy(), np.maximum(0., neg - pos + 1.))",
            "masked_line": "loss = tf.keras.losses.categorical_hinge(y_true, y_pred)",
            "answer": "categorical_hinge",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_273"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "Calculate the cosine similarity between two sets of vectors y_true and y_pred along axis 1 and return the calculated cosine similarity values.",
            "code": "y_true = [[0., 1.], [1., 1.], [1., 1.]]\ny_pred = [[1., 0.], [1., 1.], [-1., -1.]]\nloss = tf.keras.losses.cosine_similarity(y_true, y_pred, axis=1)\nloss.numpy()\narray([-0., -0.999, 0.999], dtype=float32)",
            "masked_code": "y_true = [[0., 1.], [1., 1.], [1., 1.]]\ny_pred = [[1., 0.], [1., 1.], [-1., -1.]]\n<line_mask>\nloss.numpy()\narray([-0., -0.999, 0.999], dtype=float32)",
            "masked_line": "loss = tf.keras.losses.cosine_similarity(y_true, y_pred, axis=1)",
            "answer": "cosine_similarity",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_274"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "The code calculates the binary accuracy between the true labels (y_true) and the predicted labels (y_pred) for a binary classification task.",
            "code": "y_true = [[1], [1], [0], [0]]\ny_pred = [[1], [1], [0], [0]]\nm = tf.keras.metrics.binary_accuracy(y_true, y_pred)\nassert m.shape == (4,)\nm.numpy()\narray([1., 1., 1., 1.], dtype=float32)",
            "masked_code": "y_true = [[1], [1], [0], [0]]\ny_pred = [[1], [1], [0], [0]]\n<line_mask>\nassert m.shape == (4,)\nm.numpy()\narray([1., 1., 1., 1.], dtype=float32)",
            "masked_line": "m = tf.keras.metrics.binary_accuracy(y_true, y_pred)",
            "answer": "binary_accuracy",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_275"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "This code calculates the categorical accuracy between the true and predicted values of two arrays.",
            "code": "y_true = [[0, 0, 1], [0, 1, 0]]\ny_pred = [[0.1, 0.9, 0.8], [0.05, 0.95, 0]]\nm = tf.keras.metrics.categorical_accuracy(y_true, y_pred)\nassert m.shape == (2,)\nm.numpy()\narray([0., 1.], dtype=float32)",
            "masked_code": "y_true = [[0, 0, 1], [0, 1, 0]]\ny_pred = [[0.1, 0.9, 0.8], [0.05, 0.95, 0]]\n<line_mask>\nassert m.shape == (2,)\nm.numpy()\narray([0., 1.], dtype=float32)",
            "masked_line": "m = tf.keras.metrics.categorical_accuracy(y_true, y_pred)",
            "answer": "categorical_accuracy",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_276"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "The code calculates the sparse categorical accuracy between the true labels y_true and the predicted labels y_pred. It returns an array of accuracy values corresponding to each sample in y_true.",
            "code": "y_true = [2, 1]\ny_pred = [[0.1, 0.9, 0.8], [0.05, 0.95, 0]]\nm = tf.keras.metrics.sparse_categorical_accuracy(y_true, y_pred)\nassert m.shape == (2,)\nm.numpy()\narray([0., 1.], dtype=float32)",
            "masked_code": "y_true = [2, 1]\ny_pred = [[0.1, 0.9, 0.8], [0.05, 0.95, 0]]\n<line_mask>\nassert m.shape == (2,)\nm.numpy()\narray([0., 1.], dtype=float32)",
            "masked_line": "m = tf.keras.metrics.sparse_categorical_accuracy(y_true, y_pred)",
            "answer": "sparse_categorical_accuracy",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_277"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "Calculate the top k categorical accuracy between the true and predicted values for each sample in the input arrays y_true and y_pred.",
            "code": "y_true = [[0, 0, 1], [0, 1, 0]]\ny_pred = [[0.1, 0.9, 0.8], [0.05, 0.95, 0]]\nm = tf.keras.metrics.top_k_categorical_accuracy(y_true, y_pred, k=3)\nassert m.shape == (2,)\nm.numpy()\narray([1., 1.], dtype=float32)",
            "masked_code": "y_true = [[0, 0, 1], [0, 1, 0]]\ny_pred = [[0.1, 0.9, 0.8], [0.05, 0.95, 0]]\n<line_mask>\nassert m.shape == (2,)\nm.numpy()\narray([1., 1.], dtype=float32)",
            "masked_line": "m = tf.keras.metrics.top_k_categorical_accuracy(y_true, y_pred, k=3)",
            "answer": "top_k_categorical_accuracy",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_278"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "The code uses the tf.keras.activations.get() function to retrieve the activation function specified as a parameter. It tries to retrieve the 'softmax' activation function, the softmax activation function itself, None, the abs function, and 'abcd', respectively.",
            "code": "tf.keras.activations.get('softmax')\ntf.keras.activations.get(tf.keras.activations.softmax)\ntf.keras.activations.get(None)\ntf.keras.activations.get(abs)\ntf.keras.activations.get('abcd')",
            "masked_code": "tf.keras.activations.get('softmax')\ntf.keras.activations.get(tf.keras.activations.softmax)\n<line_mask>\ntf.keras.activations.get(abs)\ntf.keras.activations.get('abcd')",
            "masked_line": "tf.keras.activations.get(None)",
            "answer": "get",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_279"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "The code retrieves the activation function specified in the argument passed to the tf.keras.activations.get() function. It can return predefined activation functions like 'softmax', 'abs', or custom activation functions specified by the user. If the argument passed is None or does not match any predefined activation function, it will return an error.",
            "code": "tf.keras.activations.get('softmax')\ntf.keras.activations.get(tf.keras.activations.softmax)\ntf.keras.activations.get(None)\ntf.keras.activations.get(abs)\ntf.keras.activations.get('abcd')",
            "masked_code": "tf.keras.activations.get('softmax')\n<line_mask>\ntf.keras.activations.get(None)\ntf.keras.activations.get(abs)\ntf.keras.activations.get('abcd')",
            "masked_line": "tf.keras.activations.get(tf.keras.activations.softmax)",
            "answer": "get",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_280"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "The code initializes two arrays of ones, x and y, each with a shape of (10, 1), and then packs them into a dataset using the pack_x_y_sample_weight function from the tf.keras.utils module. Finally, it unpacks the data into variables x and y.",
            "code": "x = tf.ones((10, 1))\ndata = tf.keras.utils.pack_x_y_sample_weight(x)\ny = tf.ones((10, 1))\ndata = tf.keras.utils.pack_x_y_sample_weight(x, y)\nx, y = data",
            "masked_code": "x = tf.ones((10, 1))\ndata = tf.keras.utils.pack_x_y_sample_weight(x)\ny = tf.ones((10, 1))\n<line_mask>\nx, y = data",
            "masked_line": "data = tf.keras.utils.pack_x_y_sample_weight(x, y)",
            "answer": "pack_x_y_sample_weight",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_281"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "The code constructs a neural network model using TensorFlow/Keras with one input layer and one output layer. The input layer has a shape of (32,) and the output layer applies a softmax activation function with 16 units.",
            "code": "x = Input(shape=(32,))\ny = Dense(16, activation='softmax')(x)\nmodel = Model(x, y)\n\n\nx = Input(shape=(32,))\ny = tf.square(x)\nmodel = Model(x, y)\n\n\nx = Input(type_spec=tf.RaggedTensorSpec(shape=[None, None], dtype=tf.float32, ragged_rank=1))\ny = x.values\nmodel = Model(x, y)\n",
            "masked_code": "x = Input(shape=(32,))\ny = Dense(16, activation='softmax')(x)\nmodel = Model(x, y)\n\n\nx = Input(shape=(32,))\ny = tf.square(x)\nmodel = Model(x, y)\n\n\n<line_mask>\ny = x.values\nmodel = Model(x, y)\n",
            "masked_line": "x = Input(type_spec=tf.RaggedTensorSpec(shape=[None, None], dtype=tf.float32, ragged_rank=1))",
            "answer": "Input",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_282"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "This code defines a custom layer in TensorFlow that adds a variable named \"name1\" without tracking it manually, and then tracks another variable named \"name2\" within the layer.",
            "code": "class TestLayer(tf.keras.Layer):\n  def build():\n    with no_manual_dependency_tracking_scope(self):\n      var = self.add_variable(\"name1\")  # Creates a var and doesn't track it\n    self._track_trackable(\"name2\", var)  # We track variable with name `name2`\n",
            "masked_code": "class TestLayer(tf.keras.Layer):\n  def build():\n    <line_mask>\n      var = self.add_variable(\"name1\")  # Creates a var and doesn't track it\n    self._track_trackable(\"name2\", var)  # We track variable with name `name2`\n",
            "masked_line": "with no_manual_dependency_tracking_scope(self):",
            "answer": "no_manual_dependency_tracking_scope",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_283"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "The code defines a neural network model with two input layers of different shapes, each connected to a dense layer with ReLU activation function. The output of these layers are then multiplied element-wise, followed by another dense layer with 4 units. Finally, a model is created with the defined inputs and outputs.",
            "code": "x1 = np.arange(3.0)\nx2 = np.arange(3.0)\ntf.keras.layers.multiply([x1, x2])\n\ninput1 = tf.keras.layers.Input(shape=(16,))\nx1 = tf.keras.layers.Dense(8, activation='relu')(input1)\ninput2 = tf.keras.layers.Input(shape=(32,))\nx2 = tf.keras.layers.Dense(8, activation='relu')(input2)\nout = tf.keras.layers.multiply([x1,x2])\nout = tf.keras.layers.Dense(4)(out)\nmodel = tf.keras.models.Model(inputs=[input1, input2], outputs=out)",
            "masked_code": "x1 = np.arange(3.0)\nx2 = np.arange(3.0)\ntf.keras.layers.multiply([x1, x2])\n\ninput1 = tf.keras.layers.Input(shape=(16,))\nx1 = tf.keras.layers.Dense(8, activation='relu')(input1)\ninput2 = tf.keras.layers.Input(shape=(32,))\nx2 = tf.keras.layers.Dense(8, activation='relu')(input2)\n<line_mask>\nout = tf.keras.layers.Dense(4)(out)\nmodel = tf.keras.models.Model(inputs=[input1, input2], outputs=out)",
            "masked_line": "out = tf.keras.layers.multiply([x1,x2])",
            "answer": "multiply",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_285"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "The code zips and then unzips datasets, once with tuples and once with dictionaries.",
            "code": "ds1 = tf.data.Dataset.from_tensor_slices([1, 2, 3])\nds2 = tf.data.Dataset.from_tensor_slices([4, 5, 6])\nds_zipped_tuple = tf.data.Dataset.zip((ds1, ds2))\nds_unzipped_tuple = _unzip_dataset(ds_zipped_tuple)\nds_zipped_dict = tf.data.Dataset.zip({'ds1': ds1, 'ds2': ds2})\nds_unzipped_dict = _unzip_dataset(ds_zipped_dict)",
            "masked_code": "ds1 = tf.data.Dataset.from_tensor_slices([1, 2, 3])\nds2 = tf.data.Dataset.from_tensor_slices([4, 5, 6])\nds_zipped_tuple = tf.data.Dataset.zip((ds1, ds2))\n<line_mask>\nds_zipped_dict = tf.data.Dataset.zip({'ds1': ds1, 'ds2': ds2})\nds_unzipped_dict = _unzip_dataset(ds_zipped_dict)",
            "masked_line": "ds_unzipped_tuple = _unzip_dataset(ds_zipped_tuple)",
            "answer": "_unzip_dataset",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_287"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "The code defines two RNN models, model_1 and model_2, which are guaranteed to create their own variables. It then calls the models with input and state to get output and next state. Finally, it asserts that both models have weights and that the weights of model_1 are not equal to the weights of model_2.",
            "code": "set_keras_style()\n\nmodel_1 = RNNModel(name=\"model_1\")\nmodel_2 = RNNModel(name=\"model_2\")\n\n# model_1 and model_2 are guaranteed to create their own variables.\noutput_1, next_state_1 = model_1(input, state)\noutput_2, next_state_2 = model_2(input, state)\n\nassert len(model_1.weights) > 0\nassert len(model_2.weights) > 0\nassert(model_1.weights != model_2.weights)\n",
            "masked_code": "<line_mask>\n\nmodel_1 = RNNModel(name=\"model_1\")\nmodel_2 = RNNModel(name=\"model_2\")\n\n# model_1 and model_2 are guaranteed to create their own variables.\noutput_1, next_state_1 = model_1(input, state)\noutput_2, next_state_2 = model_2(input, state)\n\nassert len(model_1.weights) > 0\nassert len(model_2.weights) > 0\nassert(model_1.weights != model_2.weights)\n",
            "masked_line": "set_keras_style()",
            "answer": "set_keras_style",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_288"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "The given code calculates a cosine decay learning rate based on the global step, decay steps, alpha, and initial learning rate.",
            "code": "global_step = min(global_step, decay_steps)\ncosine_decay = 0.5 * (1 + cos(pi * global_step / decay_steps))\ndecayed = (1 - alpha) * cosine_decay + alpha\ndecayed_learning_rate = learning_rate * decayed\n\n\ndecay_steps = 1000\nlr_decayed = cosine_decay(learning_rate, global_step, decay_steps)\n",
            "masked_code": "global_step = min(global_step, decay_steps)\ncosine_decay = 0.5 * (1 + cos(pi * global_step / decay_steps))\ndecayed = (1 - alpha) * cosine_decay + alpha\ndecayed_learning_rate = learning_rate * decayed\n\n\ndecay_steps = 1000\n<line_mask>\n",
            "masked_line": "lr_decayed = cosine_decay(learning_rate, global_step, decay_steps)",
            "answer": "cosine_decay",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_290"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "The code generates a random RGB image with dimensions 100x100 and converts it first to a PIL image object and then to a NumPy array.",
            "code": "from PIL import Image\nimport numpy as np\nimport tensorflow as tf\n\nimg_data = np.random.random(size=(100, 100, 3))\nimg = tf.keras.preprocessing.image.array_to_img(img_data)\narray = tf.keras.preprocessing.image.img_to_array(img)\n",
            "masked_code": "from PIL import Image\nimport numpy as np\nimport tensorflow as tf\n\nimg_data = np.random.random(size=(100, 100, 3))\nimg = tf.keras.preprocessing.image.array_to_img(img_data)\n<line_mask>\n",
            "masked_line": "array = tf.keras.preprocessing.image.img_to_array(img)",
            "answer": "img_to_array",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_291"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "The code pads sequences in a list to a specified length.",
            "code": "sequence = [[1], [2, 3], [4, 5, 6]]\ntf.keras.preprocessing.sequence.pad_sequences(sequence)\n\ntf.keras.preprocessing.sequence.pad_sequences(sequence, value=-1)\n\ntf.keras.preprocessing.sequence.pad_sequences(sequence, padding='post')\n\ntf.keras.preprocessing.sequence.pad_sequences(sequence, maxlen=2)\n",
            "masked_code": "sequence = [[1], [2, 3], [4, 5, 6]]\ntf.keras.preprocessing.sequence.pad_sequences(sequence)\n\ntf.keras.preprocessing.sequence.pad_sequences(sequence, value=-1)\n\ntf.keras.preprocessing.sequence.pad_sequences(sequence, padding='post')\n\n<line_mask>\n",
            "masked_line": "tf.keras.preprocessing.sequence.pad_sequences(sequence, maxlen=2)",
            "answer": "pad_sequences",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_292"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "The code creates a simple neural network model with one input layer of 3 units, one hidden layer of 5 units, and a softmax output layer. It then saves the model to a file and loads it back. It generates 10 random samples of input data with 3 features and checks if the predictions made by the original and loaded models are close.",
            "code": "model = tf.keras.Sequential([\n    tf.keras.layers.Dense(5, input_shape=(3,)),\n    tf.keras.layers.Softmax()])\nmodel.save('/tmp/model')\nloaded_model = tf.keras.models.load_model('/tmp/model')\nx = tf.random.uniform((10, 3))\nassert np.allclose(model.predict(x), loaded_model.predict(x))",
            "masked_code": "model = tf.keras.Sequential([\n    tf.keras.layers.Dense(5, input_shape=(3,)),\n    tf.keras.layers.Softmax()])\nmodel.save('/tmp/model')\n<line_mask>\nx = tf.random.uniform((10, 3))\nassert np.allclose(model.predict(x), loaded_model.predict(x))",
            "masked_line": "loaded_model = tf.keras.models.load_model('/tmp/model')",
            "answer": "load_model",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_293"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "The code creates a simple neural network model using tf.keras, saves the model in the SavedModel format, and then loads the saved model back for use.",
            "code": "import tensorflow as tf\n\n# Create a tf.keras model.\nmodel = tf.keras.Sequential()\nmodel.add(tf.keras.layers.Dense(1, input_shape=[10]))\nmodel.summary()\n\n# Save the tf.keras model in the SavedModel format.\npath = '/tmp/simple_keras_model'\ntf.keras.experimental.export_saved_model(model, path)\n\n# Load the saved keras model back.\nnew_model = tf.keras.experimental.load_from_saved_model(path)\nnew_model.summary()\n",
            "masked_code": "import tensorflow as tf\n\n# Create a tf.keras model.\nmodel = tf.keras.Sequential()\nmodel.add(tf.keras.layers.Dense(1, input_shape=[10]))\nmodel.summary()\n\n# Save the tf.keras model in the SavedModel format.\npath = '/tmp/simple_keras_model'\n<line_mask>\n\n# Load the saved keras model back.\nnew_model = tf.keras.experimental.load_from_saved_model(path)\nnew_model.summary()\n",
            "masked_line": "tf.keras.experimental.export_saved_model(model, path)",
            "answer": "export_saved_model",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_294"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "The code creates a simple tf.keras model with one Dense layer and an input shape of 10. It then saves the model in the SavedModel format at a specified path. Finally, it loads the saved model back and displays a summary of the new model.",
            "code": "import tensorflow as tf\n\n# Create a tf.keras model.\nmodel = tf.keras.Sequential()\nmodel.add(tf.keras.layers.Dense(1, input_shape=[10]))\nmodel.summary()\n\n# Save the tf.keras model in the SavedModel format.\npath = '/tmp/simple_keras_model'\ntf.keras.experimental.export_saved_model(model, path)\n\n# Load the saved keras model back.\nnew_model = tf.keras.experimental.load_from_saved_model(path)\nnew_model.summary()\n",
            "masked_code": "import tensorflow as tf\n\n# Create a tf.keras model.\nmodel = tf.keras.Sequential()\nmodel.add(tf.keras.layers.Dense(1, input_shape=[10]))\nmodel.summary()\n\n# Save the tf.keras model in the SavedModel format.\npath = '/tmp/simple_keras_model'\ntf.keras.experimental.export_saved_model(model, path)\n\n# Load the saved keras model back.\n<line_mask>\nnew_model.summary()\n",
            "masked_line": "new_model = tf.keras.experimental.load_from_saved_model(path)",
            "answer": "load_from_saved_model",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_295"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "The code defines a custom class Foo with an attribute _input and a method value that returns a constant value. It then registers the conversion function for Foo objects to return their value, and registers the custom tensor type for Foo objects in Keras. Finally, it creates a Keras Lambda layer that wraps input_ with Foo object.",
            "code": "class Foo(object):\n  def __init__(self, input_):\n    self._input = input_\n  def value(self):\n    return tf.constant(42.)\n\ntf.register_tensor_conversion_function(\n    Foo, lambda x, *args, **kwargs: x.value())\n\ntf.keras.__internal__.utils.register_symbolic_tensor_type(Foo)\n\nlayer = tf.keras.layers.Lambda(lambda input_: Foo(input_))\n",
            "masked_code": "class Foo(object):\n  def __init__(self, input_):\n    self._input = input_\n  def value(self):\n    return tf.constant(42.)\n\ntf.register_tensor_conversion_function(\n    Foo, lambda x, *args, **kwargs: x.value())\n\n<line_mask>\n\nlayer = tf.keras.layers.Lambda(lambda input_: Foo(input_))\n",
            "masked_line": "tf.keras.__internal__.utils.register_symbolic_tensor_type(Foo)",
            "answer": "register_symbolic_tensor_type",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_296"
        },
        {
            "dependency": "keras",
            "version": "==2.6.0",
            "time": "2021-08-04",
            "description": "This code defines a deep learning model using TensorFlow's Keras API with an input layer of shape (100,) and data type 'int32', followed by an Embedding layer, LSTM layer, and three Dense layers with RELU activation function. The model outputs a single unit with a sigmoid activation function. Finally, the code generates a visualization of the model's architecture and saves it as an image file.",
            "code": "input = tf.keras.Input(shape=(100,), dtype='int32', name='input')\nx = tf.keras.layers.Embedding(\n    output_dim=512, input_dim=10000, input_length=100)(input)\nx = tf.keras.layers.LSTM(32)(x)\nx = tf.keras.layers.Dense(64, activation='relu')(x)\nx = tf.keras.layers.Dense(64, activation='relu')(x)\nx = tf.keras.layers.Dense(64, activation='relu')(x)\noutput = tf.keras.layers.Dense(1, activation='sigmoid', name='output')(x)\nmodel = tf.keras.Model(inputs=[input], outputs=[output])\ndot_img_file = '/tmp/model_1.png'\ntf.keras.utils.plot_model(model, to_file=dot_img_file, show_shapes=True)\n",
            "masked_code": "input = tf.keras.Input(shape=(100,), dtype='int32', name='input')\nx = tf.keras.layers.Embedding(\n    output_dim=512, input_dim=10000, input_length=100)(input)\nx = tf.keras.layers.LSTM(32)(x)\nx = tf.keras.layers.Dense(64, activation='relu')(x)\nx = tf.keras.layers.Dense(64, activation='relu')(x)\nx = tf.keras.layers.Dense(64, activation='relu')(x)\noutput = tf.keras.layers.Dense(1, activation='sigmoid', name='output')(x)\nmodel = tf.keras.Model(inputs=[input], outputs=[output])\ndot_img_file = '/tmp/model_1.png'\n<line_mask>\n",
            "masked_line": "tf.keras.utils.plot_model(model, to_file=dot_img_file, show_shapes=True)",
            "answer": "plot_model",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_297"
        },
        {
            "dependency": "keras",
            "version": "==2.7.0",
            "time": "2021-10-27",
            "description": "The code defines a neural network model with a single hidden layer of 10 nodes using TensorFlow's Keras API. It then compiles the model, prepares training and testing datasets, and trains the model for 10 epochs.",
            "code": "strategy = utils.get_strategy()\nwith strategy.scope():\n  model = tf.keras.Sequential([tf.keras.layers.Dense(10)])\n\nmodel.compile(...)\ntrain_ds, test_ds = ...\nmodel.fit(train_ds, validation_data=test_ds, epochs=10)\n",
            "masked_code": "<line_mask>\nwith strategy.scope():\n  model = tf.keras.Sequential([tf.keras.layers.Dense(10)])\n\nmodel.compile(...)\ntrain_ds, test_ds = ...\nmodel.fit(train_ds, validation_data=test_ds, epochs=10)\n",
            "masked_line": "strategy = utils.get_strategy()",
            "answer": "get_strategy",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_298"
        },
        {
            "dependency": "keras",
            "version": "==2.7.0",
            "time": "2021-10-27",
            "description": "The code sets the global policy for mixed precision training to 'mixed_float16', checks the global policy, creates a dense layer with a dtype policy of mixed float16, creates another dense layer with a dtype policy of float64, and finally changes the global policy to 'float32'.",
            "code": "tf.keras.mixed_precision.set_global_policy('mixed_float16')\ntf.keras.mixed_precision.global_policy()\ntf.keras.layers.Dense(10).dtype_policy\ntf.keras.layers.Dense(10, dtype='float64').dtype_policy\ntf.keras.mixed_precision.set_global_policy('float32')",
            "masked_code": "tf.keras.mixed_precision.set_global_policy('mixed_float16')\ntf.keras.mixed_precision.global_policy()\ntf.keras.layers.Dense(10).dtype_policy\ntf.keras.layers.Dense(10, dtype='float64').dtype_policy\n<line_mask>",
            "masked_line": "tf.keras.mixed_precision.set_global_policy('float32')",
            "answer": "set_global_policy",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_299"
        },
        {
            "dependency": "keras",
            "version": "==2.7.0",
            "time": "2021-10-27",
            "description": "The code calculates the accuracy of a model by comparing the predicted values with the actual values.",
            "code": "m1 = tf.keras.metrics.Accuracy()\n_ = m1.update_state([[1], [2]], [[0], [2]])\n\nm2 = tf.keras.metrics.Accuracy()\n_ = m2.update_state([[3], [4]], [[3], [4]])\n\nm2.merge_state([m1])\nm2.result().numpy()\n0.75",
            "masked_code": "m1 = tf.keras.metrics.Accuracy()\n_ = m1.update_state([[1], [2]], [[0], [2]])\n\nm2 = tf.keras.metrics.Accuracy()\n_ = m2.update_state([[3], [4]], [[3], [4]])\n\n<line_mask>\nm2.result().numpy()\n0.75",
            "masked_line": "m2.merge_state([m1])",
            "answer": "merge_state",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_300"
        },
        {
            "dependency": "keras",
            "version": "==2.9.0",
            "time": "2022-04-22",
            "description": "The code extracts the text parts and floats (numbers with decimals) from the input text \"Text 1.0 Text\". The text parts are stored in a list while the floats are stored in an array.",
            "code": "text_parts, floats = _FloatExtractor()(\"Text 1.0 Text\")\ntext_parts\n['Text ', ' Text']\nfloats\narray([1.])",
            "masked_code": "<line_mask>\ntext_parts\n['Text ', ' Text']\nfloats\narray([1.])",
            "masked_line": "text_parts, floats = _FloatExtractor()(\"Text 1.0 Text\")",
            "answer": "_FloatExtractor",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_301"
        },
        {
            "dependency": "librosa",
            "version": "==0.10.0",
            "time": "2023-02-18",
            "description": "The code generates a plot of the values from 0 to 11 on the y-axis, with the y-axis labels formatted using a custom ChromaFJSFormatter from the librosa.display module, with intervals set to \"ji5\" and bins_per_octave set to 12. The ylabel of the plot is set to 'Pitch class'.",
            "code": "import matplotlib.pyplot as plt\nimport numpy as np\nimport librosa.display.ChromaFJSFormatter\n\nvalues = np.arange(12)\nfig, ax = plt.subplots()\nax.plot(values)\nax.yaxis.set_major_formatter(librosa.display.ChromaFJSFormatter(intervals=\"ji5\", bins_per_octave=12))\nax.set(ylabel='Pitch class')",
            "masked_code": "import matplotlib.pyplot as plt\nimport numpy as np\nimport librosa.display.ChromaFJSFormatter\n\nvalues = np.arange(12)\nfig, ax = plt.subplots()\nax.plot(values)\n<line_mask>\nax.set(ylabel='Pitch class')",
            "masked_line": "ax.yaxis.set_major_formatter(librosa.display.ChromaFJSFormatter(intervals=\"ji5\", bins_per_octave=12))",
            "answer": "ChromaFJSFormatter",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_302"
        },
        {
            "dependency": "librosa",
            "version": "==0.10.0",
            "time": "2023-02-18",
            "description": "The code compares the intervals generated by 3-limit tuning to Pythagorean tuning and 12-TET. It also creates interval sets with specific limits using different tuning methods.",
            "code": "# Compare 3-limit tuning to Pythagorean tuning and 12-TET\nlibrosa.plimit_intervals(primes=[3], bins_per_octave=12)\n# Pythagorean intervals:\nlibrosa.pythagorean_intervals(bins_per_octave=12)\n# 12-TET intervals:\n2**(np.arange(12)/12)\n\n# Create a 7-bin, 5-limit interval set\nlibrosa.plimit_intervals(primes=[3, 5], bins_per_octave=7)\n\n# The same example, but now in factored form\nlibrosa.plimit_intervals(primes=[3, 5], bins_per_octave=7, return_factors=True)\n",
            "masked_code": "# Compare 3-limit tuning to Pythagorean tuning and 12-TET\n<line_mask>\n# Pythagorean intervals:\nlibrosa.pythagorean_intervals(bins_per_octave=12)\n# 12-TET intervals:\n2**(np.arange(12)/12)\n\n# Create a 7-bin, 5-limit interval set\nlibrosa.plimit_intervals(primes=[3, 5], bins_per_octave=7)\n\n# The same example, but now in factored form\nlibrosa.plimit_intervals(primes=[3, 5], bins_per_octave=7, return_factors=True)\n",
            "masked_line": "librosa.plimit_intervals(primes=[3], bins_per_octave=12)",
            "answer": "plimit_intervals",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_303"
        },
        {
            "dependency": "librosa",
            "version": "==0.10.0",
            "time": "2023-02-18",
            "description": "The code converts musical intervals to Just Intonation frequencies.",
            "code": "librosa.interval_to_fjs(3/2, unison='C')\nlibrosa.interval_to_fjs(4/3, unison='F')\nlibrosa.interval_to_fjs(5/4, unison='A')\nlibrosa.interval_to_fjs(6/5, unison='A')\nlibrosa.interval_to_fjs(25/14, unison='F#')\nlibrosa.interval_to_fjs(25/14, unison='F#', unicode=False)",
            "masked_code": "librosa.interval_to_fjs(3/2, unison='C')\nlibrosa.interval_to_fjs(4/3, unison='F')\nlibrosa.interval_to_fjs(5/4, unison='A')\nlibrosa.interval_to_fjs(6/5, unison='A')\nlibrosa.interval_to_fjs(25/14, unison='F#')\n<line_mask>",
            "masked_line": "librosa.interval_to_fjs(25/14, unison='F#', unicode=False)",
            "answer": "interval_to_fjs",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_304"
        },
        {
            "dependency": "librosa",
            "version": "==0.2.0",
            "time": "2013-12-14",
            "description": "The code calculates the Constant-Q Transform (CQT) of an audio signal 'y' with a given sampling rate 'sr' using the specified basis filters.",
            "code": "y, sr = librosa.load('file.wav')\nC = librosa.cqt(y, sr)\n\nC = librosa.cqt(y, sr, fmin=librosa.midi_to_hz(36), fmax=librosa.midi_to_hz(96))\n\nbasis = librosa.filters.constant_q(sr, ...)\nC = librosa.cqt(y, sr, basis=basis)",
            "masked_code": "y, sr = librosa.load('file.wav')\n<line_mask>\n\nC = librosa.cqt(y, sr, fmin=librosa.midi_to_hz(36), fmax=librosa.midi_to_hz(96))\n\nbasis = librosa.filters.constant_q(sr, ...)\nC = librosa.cqt(y, sr, basis=basis)",
            "masked_line": "C = librosa.cqt(y, sr)",
            "answer": "cqt",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_305"
        },
        {
            "dependency": "librosa",
            "version": "==0.2.0",
            "time": "2013-12-14",
            "description": "The code calculates the short-time Fourier transform (STFT) of the input signal 'y' using a window size of 2048 samples and a hop length of 512 samples. It then applies a phase vocoder with a speedup factor of 2.0 to the STFT result to obtain a faster version of the signal 'y' (y_fast). Similarly, another phase vocoder with a slowdown factor of 1/3 is applied to the STFT result to obtain a slower version of the signal 'y' (y_slow).",
            "code": "librosa.stft(y, n_fft=2048, hop_length=512)\nD_fast  = librosa.phase_vocoder(D, 2.0, hop_length=512)\ny_fast  = librosa.istft(D_fast, hop_length=512)\nD_slow  = librosa.phase_vocoder(D, 1./3, hop_length=512)\ny_slow  = librosa.istft(D_slow, hop_length=512)",
            "masked_code": "librosa.stft(y, n_fft=2048, hop_length=512)\nD_fast  = librosa.phase_vocoder(D, 2.0, hop_length=512)\ny_fast  = librosa.istft(D_fast, hop_length=512)\n<line_mask>\ny_slow  = librosa.istft(D_slow, hop_length=512)",
            "masked_line": "D_slow  = librosa.phase_vocoder(D, 1./3, hop_length=512)",
            "answer": "phase_vocoder",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_306"
        },
        {
            "dependency": "librosa",
            "version": "==0.2.0",
            "time": "2013-12-14",
            "description": "The code converts musical notes in string format to their corresponding MIDI note numbers.",
            "code": "librosa.note_to_midi('C')\nlibrosa.note_to_midi('C#3')\nlibrosa.note_to_midi('f4')\nlibrosa.note_to_midi('Bb-1')\nlibrosa.note_to_midi('A!8')",
            "masked_code": "librosa.note_to_midi('C')\nlibrosa.note_to_midi('C#3')\nlibrosa.note_to_midi('f4')\n<line_mask>\nlibrosa.note_to_midi('A!8')",
            "masked_line": "librosa.note_to_midi('Bb-1')",
            "answer": "note_to_midi",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_307"
        },
        {
            "dependency": "librosa",
            "version": "==0.2.0",
            "time": "2013-12-14",
            "description": "The code calculates the recurrence matrix based on the Mel-frequency cepstral coefficients (MFCC) extracted from the audio signal. The recurrence matrix can be computed with different parameters such as the number of nearest neighbors (k), width, distance metric (cosine), and symmetric setting.",
            "code": "mfcc    = librosa.feature.mfcc(y=y, sr=sr)\nR       = librosa.segment.recurrence_matrix(mfcc)\n\nR       = librosa.segment.recurrence_matrix(mfcc, k=5)\n\nR       = librosa.segment.recurrence_matrix(mfcc, width=7)\n\nR       = librosa.segment.recurrence_matrix(mfcc, metric='cosine')\n\nR       = librosa.segment.recurrence_matrix(mfcc, sym=True)\n",
            "masked_code": "mfcc    = librosa.feature.mfcc(y=y, sr=sr)\n<line_mask>\n\nR       = librosa.segment.recurrence_matrix(mfcc, k=5)\n\nR       = librosa.segment.recurrence_matrix(mfcc, width=7)\n\nR       = librosa.segment.recurrence_matrix(mfcc, metric='cosine')\n\nR       = librosa.segment.recurrence_matrix(mfcc, sym=True)\n",
            "masked_line": "R       = librosa.segment.recurrence_matrix(mfcc)",
            "answer": "recurrence_matrix",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_308"
        },
        {
            "dependency": "librosa",
            "version": "==0.2.1",
            "time": "2014-01-24",
            "description": "The code segments audio data into 10 segments and creates annotations for each segment.",
            "code": "\nboundaries = librosa.segment.agglomerative(data, k=10)\nboundary_times = librosa.frames_to_time(boundaries, sr=sr, hop_length=hop_length)\ntime_start, time_end = boundaries[:-1], boundaries[1:]\nlabels = ['Segment #%03d' % i for i in range(len(time_start))]\nlibrosa.output.annotation('segments.csv', time_start, time_end, annotations=annotations)\n",
            "masked_code": "\nboundaries = librosa.segment.agglomerative(data, k=10)\nboundary_times = librosa.frames_to_time(boundaries, sr=sr, hop_length=hop_length)\ntime_start, time_end = boundaries[:-1], boundaries[1:]\nlabels = ['Segment #%03d' % i for i in range(len(time_start))]\n<line_mask>\n",
            "masked_line": "librosa.output.annotation('segments.csv', time_start, time_end, annotations=annotations)",
            "answer": "annotation",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_309"
        },
        {
            "dependency": "librosa",
            "version": "==0.2.1",
            "time": "2014-01-24",
            "description": "This code decomposes a spectrogram matrix S into two matrices W and H using the librosa library. It then sorts the values of W along different axes and extracts specific rows based on certain criteria. Finally, it sorts H based on the indices extracted from W sorting.",
            "code": "W, H = librosa.decompose.decompose(S)\nW_sort = librosa.util.axis_sort(W)\nW_sort = librosa.util.axis_sort(W, value=np.argmin)\nW_sort_rows = librosa.util.axis_sort(W, axis=0)\nW_sort, idx = librosa.util.axis_sort(W, index=True)\nH_sort = H[index, :]\n",
            "masked_code": "W, H = librosa.decompose.decompose(S)\n<line_mask>\nW_sort = librosa.util.axis_sort(W, value=np.argmin)\nW_sort_rows = librosa.util.axis_sort(W, axis=0)\nW_sort, idx = librosa.util.axis_sort(W, index=True)\nH_sort = H[index, :]\n",
            "masked_line": "W_sort = librosa.util.axis_sort(W)",
            "answer": "axis_sort",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_310"
        },
        {
            "dependency": "librosa",
            "version": "==0.3.0",
            "time": "2014-06-30",
            "description": "The code calculates the pitch frequencies for a constant-Q transform with 24 bins per octave and a range starting from 55 Hz, then applies pitch tuning with a specified value of 0.25. Subsequently, it extracts pitches and magnitudes using the ifptrack algorithm and filters out pitches based on magnitudes above the median, before applying pitch tuning again.",
            "code": "freqs = librosa.cqt_frequencies(24, 55, tuning=0.25)\nlibrosa.feature.pitch_tuning(freqs)\n0.25\n\npitches, magnitudes, stft = librosa.feature.ifptrack(y, sr)\npitches = pitches[magnitudes > np.median(magnitudes)]\nlibrosa.feature.pitch_tuning(pitches)\n",
            "masked_code": "freqs = librosa.cqt_frequencies(24, 55, tuning=0.25)\nlibrosa.feature.pitch_tuning(freqs)\n0.25\n\npitches, magnitudes, stft = librosa.feature.ifptrack(y, sr)\npitches = pitches[magnitudes > np.median(magnitudes)]\n<line_mask>\n",
            "masked_line": "librosa.feature.pitch_tuning(pitches)",
            "answer": "pitch_tuning",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_311"
        },
        {
            "dependency": "librosa",
            "version": "==0.3.1",
            "time": "2014-11-14",
            "description": "The code calculates the duration of audio signal loaded using Librosa library, with and without centering the short-time Fourier transform (STFT).",
            "code": "y, sr = librosa.load(librosa.util.example_audio())\nd = librosa.get_duration(y=y, sr=sr)\nd\n\n\nS = librosa.stft(y)\nd = librosa.get_duration(S=S, sr=sr)\n\n\nS_left = librosa.stft(y, center=False)\nd = librosa.get_duration(S=S_left, sr=sr)\n",
            "masked_code": "y, sr = librosa.load(librosa.util.example_audio())\nd = librosa.get_duration(y=y, sr=sr)\nd\n\n\nS = librosa.stft(y)\n<line_mask>\n\n\nS_left = librosa.stft(y, center=False)\nd = librosa.get_duration(S=S_left, sr=sr)\n",
            "masked_line": "d = librosa.get_duration(S=S, sr=sr)",
            "answer": "get_duration",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_312"
        },
        {
            "dependency": "librosa",
            "version": "==0.4.0",
            "time": "2015-06-07",
            "description": "The code segment performs time lag filtering on a given dataset by converting it to lag domain, applying a filtering function, and then converting it back to recurrence domain. Additionally, it applies a diagonal median filtering with specific parameters to filter a given dataset.",
            "code": "data_tl = librosa.segment.recurrence_to_lag(data)\ndata_filtered_tl = function(data_tl)\ndata_filtered = librosa.segment.lag_to_recurrence(data_filtered_tl)\n\ndiagonal_median = librosa.segment.timelag_filter(median_filter)\nrec_filtered = diagonal_median(rec, size=(1, 5), mode='mirror')",
            "masked_code": "data_tl = librosa.segment.recurrence_to_lag(data)\ndata_filtered_tl = function(data_tl)\ndata_filtered = librosa.segment.lag_to_recurrence(data_filtered_tl)\n\n<line_mask>\nrec_filtered = diagonal_median(rec, size=(1, 5), mode='mirror')",
            "masked_line": "diagonal_median = librosa.segment.timelag_filter(median_filter)",
            "answer": "timelag_filter",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_313"
        },
        {
            "dependency": "librosa",
            "version": "==0.4.0",
            "time": "2015-06-07",
            "description": "This code defines a function named subsegment that takes in data, frames, and n_segments as input parameters. It then initializes an empty list called boundaries. The function does some computation (not provided in the code snippet) and returns an array of boundaries. The code snippet also provides an example usage of the subsegment function by loading an audio file using librosa, extracting beats and tempo, computing the constant-Q transform (cqt), and then calling the subsegment function with cqt, beats, and n_segments=2 arguments. Finally, it prints the result of the subsegment function.",
            "code": "import numpy as np\nimport librosa\n\ndef subsegment(data, frames, n_segments):\n    boundaries = []\n    # Your code here\n    return np.array(boundaries)\n\n# Example usage\ny, sr = librosa.load(librosa.util.example_audio_file(), duration=15)\ntempo, beats = librosa.beat.beat_track(y=y, sr=sr, hop_length=512)\ncqt = librosa.cqt(y, sr=sr, hop_length=512)\nsubseg = subsegment(cqt, beats, n_segments=2)\nprint(subseg)",
            "masked_code": "import numpy as np\nimport librosa\n\ndef subsegment(data, frames, n_segments):\n    boundaries = []\n    # Your code here\n    return np.array(boundaries)\n\n# Example usage\ny, sr = librosa.load(librosa.util.example_audio_file(), duration=15)\ntempo, beats = librosa.beat.beat_track(y=y, sr=sr, hop_length=512)\ncqt = librosa.cqt(y, sr=sr, hop_length=512)\n<line_mask>\nprint(subseg)",
            "masked_line": "subseg = subsegment(cqt, beats, n_segments=2)",
            "answer": "subsegment",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_314"
        },
        {
            "dependency": "librosa",
            "version": "==0.4.0",
            "time": "2015-06-07",
            "description": "The code loads a stereo audio file and extracts the left and right channels into a NumPy array with a shape of (2, 1355168). It then converts the stereo audio into a monophonic audio signal and returns a NumPy array with a shape of (1355168,).",
            "code": "y, sr = librosa.load(librosa.util.example_audio_file(), mono=False)\ny.shape\n(2, 1355168)\ny_mono = librosa.to_mono(y)\ny_mono.shape",
            "masked_code": "y, sr = librosa.load(librosa.util.example_audio_file(), mono=False)\ny.shape\n(2, 1355168)\n<line_mask>\ny_mono.shape",
            "masked_line": "y_mono = librosa.to_mono(y)",
            "answer": "to_mono",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_315"
        },
        {
            "dependency": "librosa",
            "version": "==0.4.0",
            "time": "2015-06-07",
            "description": "This code calculates the frequency of musical notes.",
            "code": "# Get the frequency of a note\nlibrosa.note_to_hz('C')\narray([ 16.352])\n# Or multiple notes\nlibrosa.note_to_hz(['A3', 'A4', 'A5'])\narray([ 220.,  440.,  880.])\n# Or notes with tuning deviations\nlibrosa.note_to_hz('C2-32', round_midi=False)\narray([ 64.209])\n",
            "masked_code": "# Get the frequency of a note\nlibrosa.note_to_hz('C')\narray([ 16.352])\n# Or multiple notes\n<line_mask>\narray([ 220.,  440.,  880.])\n# Or notes with tuning deviations\nlibrosa.note_to_hz('C2-32', round_midi=False)\narray([ 64.209])\n",
            "masked_line": "librosa.note_to_hz(['A3', 'A4', 'A5'])",
            "answer": "note_to_hz",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_316"
        },
        {
            "dependency": "librosa",
            "version": "==0.4.0",
            "time": "2015-06-07",
            "description": "The code generates a sparse representation of a Hann window of size 32 with different sparsity levels (quantile=0.01 and quantile=0.1) using the librosa library.",
            "code": "x = scipy.signal.hann(32)\nx_sparse = librosa.util.sparsify_rows(x, quantile=0.01)\nx_sparse.todense()\nx_sparse = librosa.util.sparsify_rows(x, quantile=0.1)\nx_sparse.todense()\n",
            "masked_code": "x = scipy.signal.hann(32)\nx_sparse = librosa.util.sparsify_rows(x, quantile=0.01)\nx_sparse.todense()\n<line_mask>\nx_sparse.todense()\n",
            "masked_line": "x_sparse = librosa.util.sparsify_rows(x, quantile=0.1)",
            "answer": "sparsify_rows",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_317"
        },
        {
            "dependency": "librosa",
            "version": "==0.4.1",
            "time": "2015-10-16",
            "description": "The code generates click sounds at specified beat frames or time intervals in a audio signal.",
            "code": "y_beats = librosa.clicks(frames=beats, sr=sr)\ny_beats = librosa.clicks(frames=beats, sr=sr, length=len(y))\ntimes = librosa.frames_to_time(beats, sr=sr)\ny_beat_times = librosa.clicks(times=times, sr=sr)\ny_beat_times880 = librosa.clicks(times=times, sr=sr, click_freq=880, click_duration=0.5)",
            "masked_code": "<line_mask>\ny_beats = librosa.clicks(frames=beats, sr=sr, length=len(y))\ntimes = librosa.frames_to_time(beats, sr=sr)\ny_beat_times = librosa.clicks(times=times, sr=sr)\ny_beat_times880 = librosa.clicks(times=times, sr=sr, click_freq=880, click_duration=0.5)",
            "masked_line": "y_beats = librosa.clicks(frames=beats, sr=sr)",
            "answer": "clicks",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_318"
        },
        {
            "dependency": "librosa",
            "version": "==0.5.0",
            "time": "2017-02-17",
            "description": "This code generates a plot with the values from the numpy array 'values' and customizes the y-axis labels using a ChromaFormatter from the librosa display module. The y-axis label is set to 'Pitch class'.",
            "code": "import matplotlib.pyplot as plt\nvalues = np.arange(12)\nplt.figure()\nax = plt.gca()\nax.plot(values)\nax.yaxis.set_major_formatter(librosa.display.ChromaFormatter())\nax.set_ylabel('Pitch class')",
            "masked_code": "import matplotlib.pyplot as plt\nvalues = np.arange(12)\nplt.figure()\nax = plt.gca()\nax.plot(values)\n<line_mask>\nax.set_ylabel('Pitch class')",
            "masked_line": "ax.yaxis.set_major_formatter(librosa.display.ChromaFormatter())",
            "answer": "ChromaFormatter",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_319"
        },
        {
            "dependency": "librosa",
            "version": "==0.5.0",
            "time": "2017-02-17",
            "description": "The function of this code is to trim the leading and trailing silence from an audio signal using the librosa library in Python. The trim_audio_signal function takes an audio signal as input and returns the trimmed audio signal as well as the indices of the trimmed audio signal. Finally, the code loads an audio file, trims the silence from the audio signal, and prints the duration of the original and trimmed audio signals.",
            "code": "# Trim leading and trailing silence from an audio signal.\n\nimport numpy as np\nimport librosa\n\ndef trim_audio_signal(y, top_db=60, ref=np.max, frame_length=2048, hop_length=512):\n    y_trimmed, index = librosa.effects.trim(y, top_db=top_db, ref=ref, frame_length=frame_length, hop_length=hop_length)\n    return y_trimmed, index\n\n# Load some audio\ny, sr = librosa.load(librosa.util.example_audio_file())\n# Trim the beginning and ending silence\nyt, index = trim_audio_signal(y)\n# Print the durations\nprint(librosa.get_duration(y), librosa.get_duration(yt))\n",
            "masked_code": "# Trim leading and trailing silence from an audio signal.\n\nimport numpy as np\nimport librosa\n\ndef trim_audio_signal(y, top_db=60, ref=np.max, frame_length=2048, hop_length=512):\n    <line_mask>\n    return y_trimmed, index\n\n# Load some audio\ny, sr = librosa.load(librosa.util.example_audio_file())\n# Trim the beginning and ending silence\nyt, index = trim_audio_signal(y)\n# Print the durations\nprint(librosa.get_duration(y), librosa.get_duration(yt))\n",
            "masked_line": "y_trimmed, index = librosa.effects.trim(y, top_db=top_db, ref=ref, frame_length=frame_length, hop_length=hop_length)",
            "answer": "trim",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_320"
        },
        {
            "dependency": "librosa",
            "version": "==0.4.3",
            "time": "2016-05-17",
            "description": "The code extracts Mel Spectrogram and Log Amplitude features from an audio file using librosa library and stores them in a pipeline using sklearn.",
            "code": "import sklearn.pipeline\nMS = librosa.util.FeatureExtractor(librosa.feature.melspectrogram,\n                                   sr=22050, n_fft=2048,\n                                   n_mels=128, fmax=8000)\nLA = librosa.util.FeatureExtractor(librosa.logamplitude,\n                                   ref_power=np.max)\nFeatures = sklearn.pipeline.Pipeline([('MelSpectrogram', MS),\n                                      ('LogAmplitude', LA)])\ny, sr = librosa.load(librosa.util.example_audio_file())\nF = Features.transform([y])",
            "masked_code": "import sklearn.pipeline\n<line_mask>\n                                   sr=22050, n_fft=2048,\n                                   n_mels=128, fmax=8000)\nLA = librosa.util.FeatureExtractor(librosa.logamplitude,\n                                   ref_power=np.max)\nFeatures = sklearn.pipeline.Pipeline([('MelSpectrogram', MS),\n                                      ('LogAmplitude', LA)])\ny, sr = librosa.load(librosa.util.example_audio_file())\nF = Features.transform([y])",
            "masked_line": "MS = librosa.util.FeatureExtractor(librosa.feature.melspectrogram,",
            "answer": "FeatureExtractor",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_321"
        },
        {
            "dependency": "librosa",
            "version": "==0.4.3",
            "time": "2016-05-17",
            "description": "The code displays a spectrogram plot using the input matrix S, with frequency ticks labeled on the y-axis in Hertz format.",
            "code": "librosa.display.specshow(S)\nlibrosa.display.frequency_ticks()\nlibrosa.display.frequency_ticks(locations, frequencies)\nlibrosa.display.frequency_ticks(frequencies, freq_fmt='Hz')\nlibrosa.display.frequency_ticks(frequencies, axis='y')",
            "masked_code": "librosa.display.specshow(S)\nlibrosa.display.frequency_ticks()\nlibrosa.display.frequency_ticks(locations, frequencies)\n<line_mask>\nlibrosa.display.frequency_ticks(frequencies, axis='y')",
            "masked_line": "librosa.display.frequency_ticks(frequencies, freq_fmt='Hz')",
            "answer": "frequency_ticks",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_322"
        },
        {
            "dependency": "librosa",
            "version": "==0.6.2",
            "time": "2018-08-09",
            "description": "Calculate the root mean square energy of a given audio signal by computing the RMSE of its magnitude spectrogram.",
            "code": "y, sr = librosa.load(librosa.util.example_audio_file())\nlibrosa.feature.rmse(y=y)\n\nS, phase = librosa.magphase(librosa.stft(y))\nrms = librosa.feature.rmse(S=S)\n\nS = librosa.magphase(librosa.stft(y, window=np.ones, center=False))[0]\nlibrosa.feature.rmse(S=S)",
            "masked_code": "y, sr = librosa.load(librosa.util.example_audio_file())\n<line_mask>\n\nS, phase = librosa.magphase(librosa.stft(y))\nrms = librosa.feature.rmse(S=S)\n\nS = librosa.magphase(librosa.stft(y, window=np.ones, center=False))[0]\nlibrosa.feature.rmse(S=S)",
            "masked_line": "librosa.feature.rmse(y=y)",
            "answer": "rmse",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_323"
        },
        {
            "dependency": "librosa",
            "version": "==0.7.1",
            "time": "2019-10-09",
            "description": "The code applies shearing transformation to a 3x3 identity matrix E along the specified axis using the provided shear factor. The function `librosa.util.shear` shears the matrix E based on the factor and axis input parameters.",
            "code": "E = np.eye(3)\nlibrosa.util.shear(E, factor=-1, axis=-1)\narray([[1., 1., 1.],\n       [0., 0., 0.],\n       [0., 0., 0.]])\nlibrosa.util.shear(E, factor=-1, axis=0)\narray([[1., 0., 0.],\n       [1., 0., 0.],\n       [1., 0., 0.]])\nlibrosa.util.shear(E, factor=1, axis=-1)\narray([[1., 0., 0.],\n       [0., 0., 1.],\n       [0., 1., 0.]])",
            "masked_code": "E = np.eye(3)\n<line_mask>\narray([[1., 1., 1.],\n       [0., 0., 0.],\n       [0., 0., 0.]])\nlibrosa.util.shear(E, factor=-1, axis=0)\narray([[1., 0., 0.],\n       [1., 0., 0.],\n       [1., 0., 0.]])\nlibrosa.util.shear(E, factor=1, axis=-1)\narray([[1., 0., 0.],\n       [0., 0., 1.],\n       [0., 1., 0.]])",
            "masked_line": "librosa.util.shear(E, factor=-1, axis=-1)",
            "answer": "shear",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_324"
        },
        {
            "dependency": "librosa",
            "version": "==0.7.1",
            "time": "2019-10-09",
            "description": "The code creates two arrays, y_left and y_right, filled with ones and negative ones respectively. It then stacks these arrays horizontally to create a stereo signal representation and prints the result. It finally stacks the arrays vertically to create another stereo signal representation and prints the result.",
            "code": "y_left = np.ones(5)\ny_right = -np.ones(5)\ny_stereo = librosa.util.stack([y_left, y_right], axis=0)\ny_stereo\narray([[ 1.,  1.,  1.,  1.,  1.],\n       [-1., -1., -1., -1., -1.]])\ny_stereo.flags\n\ny_stereo = librosa.util.stack([y_left, y_right], axis=-1)\ny_stereo\narray([[ 1., -1.],\n       [ 1., -1.],\n       [ 1., -1.],\n       [ 1., -1.],\n       [ 1., -1.]])\ny_stereo.flags\n",
            "masked_code": "y_left = np.ones(5)\ny_right = -np.ones(5)\ny_stereo = librosa.util.stack([y_left, y_right], axis=0)\ny_stereo\narray([[ 1.,  1.,  1.,  1.,  1.],\n       [-1., -1., -1., -1., -1.]])\ny_stereo.flags\n\n<line_mask>\ny_stereo\narray([[ 1., -1.],\n       [ 1., -1.],\n       [ 1., -1.],\n       [ 1., -1.],\n       [ 1., -1.]])\ny_stereo.flags\n",
            "masked_line": "y_stereo = librosa.util.stack([y_left, y_right], axis=-1)",
            "answer": "stack",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_325"
        },
        {
            "dependency": "librosa",
            "version": "==0.8.0",
            "time": "2020-07-22",
            "description": "The code generates a plot displaying the A-weighting of constant-Q (CQT) frequencies in the frequency range of C1.",
            "code": "import matplotlib.pyplot as plt\nfreqs = librosa.cqt_frequencies(108, librosa.note_to_hz('C1'))\nweights = librosa.frequency_weighting(freqs, 'A')\nfig, ax = plt.subplots()\nax.plot(freqs, weights)\nax.set(xlabel='Frequency (Hz)', ylabel='Weighting (log10)',\n       title='A-Weighting of CQT frequencies')",
            "masked_code": "import matplotlib.pyplot as plt\nfreqs = librosa.cqt_frequencies(108, librosa.note_to_hz('C1'))\n<line_mask>\nfig, ax = plt.subplots()\nax.plot(freqs, weights)\nax.set(xlabel='Frequency (Hz)', ylabel='Weighting (log10)',\n       title='A-Weighting of CQT frequencies')",
            "masked_line": "weights = librosa.frequency_weighting(freqs, 'A')",
            "answer": "frequency_weighting",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_326"
        },
        {
            "dependency": "librosa",
            "version": "==0.8.0",
            "time": "2020-07-22",
            "description": "This code generates a plot showing the weightings of CQT frequencies for different weightings (ABCDZ) using librosa library.",
            "code": "import matplotlib.pyplot as plt\nfreqs = librosa.cqt_frequencies(108, librosa.note_to_hz('C1'))\nweightings = 'ABCDZ'\nweights = librosa.multi_frequency_weighting(freqs, weightings)\nfig, ax = plt.subplots()\nfor label, w in zip(weightings, weights):\n    ax.plot(freqs, w, label=label)\nax.set(xlabel='Frequency (Hz)', ylabel='Weighting (log10)',\n       title='Weightings of CQT frequencies')\nax.legend()",
            "masked_code": "import matplotlib.pyplot as plt\nfreqs = librosa.cqt_frequencies(108, librosa.note_to_hz('C1'))\nweightings = 'ABCDZ'\n<line_mask>\nfig, ax = plt.subplots()\nfor label, w in zip(weightings, weights):\n    ax.plot(freqs, w, label=label)\nax.set(xlabel='Frequency (Hz)', ylabel='Weighting (log10)',\n       title='Weightings of CQT frequencies')\nax.legend()",
            "masked_line": "weights = librosa.multi_frequency_weighting(freqs, weightings)",
            "answer": "multi_frequency_weighting",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_327"
        },
        {
            "dependency": "librosa",
            "version": "==0.8.0",
            "time": "2020-07-22",
            "description": "The given code converts MIDI notes to corresponding Indian classical music svara symbols based on the provided Sa (tonic note). The output includes the svara symbols for the given MIDI notes in the specified format and representation.",
            "code": "librosa.midi_svara_h([60, 61, 62], Sa=60)\n['S', 'r', 'R']\nlibrosa.midi_to_svara_h([60, 61, 62], Sa=67)\n['m', 'M', 'P']\nlibrosa.midi_to_svara_h([60, 61, 62], Sa=67, unicode=False)\n['m,', 'M,', 'P,']\nlibrosa.midi_to_svara_h([72, 73, 74], Sa=60, abbr=False)\n['Sa', 're', 'Re']",
            "masked_code": "librosa.midi_svara_h([60, 61, 62], Sa=60)\n['S', 'r', 'R']\nlibrosa.midi_to_svara_h([60, 61, 62], Sa=67)\n['m', 'M', 'P']\nlibrosa.midi_to_svara_h([60, 61, 62], Sa=67, unicode=False)\n['m,', 'M,', 'P,']\n<line_mask>\n['Sa', 're', 'Re']",
            "masked_line": "librosa.midi_to_svara_h([72, 73, 74], Sa=60, abbr=False)",
            "answer": "midi_to_svara_h",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_328"
        },
        {
            "dependency": "librosa",
            "version": "==0.8.0",
            "time": "2020-07-22",
            "description": "The code converts frequency values to svara symbols based on the provided Sa (tonic) and mela (scale) in Carnatic music tradition.",
            "code": "librosa.hz_to_svara_c([261/2, 261, 261*2], Sa=261, mela='kanakangi')\n['S', 'S', 'S']\n\nfreqs = librosa.cqt_frequencies(12, fmin=261)\nlibrosa.hz_to_svara_c(freqs, Sa=freqs[0], mela=36)\n['S', 'R', 'R', 'R', 'G', 'M', 'M', 'P', 'D', 'D', 'D', 'N']\n",
            "masked_code": "<line_mask>\n['S', 'S', 'S']\n\nfreqs = librosa.cqt_frequencies(12, fmin=261)\nlibrosa.hz_to_svara_c(freqs, Sa=freqs[0], mela=36)\n['S', 'R', 'R', 'R', 'G', 'M', 'M', 'P', 'D', 'D', 'D', 'N']\n",
            "masked_line": "librosa.hz_to_svara_c([261/2, 261, 261*2], Sa=261, mela='kanakangi')",
            "answer": "hz_to_svara_c",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_329"
        },
        {
            "dependency": "librosa",
            "version": "==0.8.0",
            "time": "2020-07-22",
            "description": "The code converts Mela number to Svara name or vice versa.",
            "code": "librosa.mela_to_svara(1)\nlibrosa.mela_to_svara(19)\nlibrosa.mela_to_svara(31)\nlibrosa.mela_to_svara(34)\nlibrosa.mela_to_svara(36)\nlibrosa.mela_to_svara('chalanatta')",
            "masked_code": "librosa.mela_to_svara(1)\n<line_mask>\nlibrosa.mela_to_svara(31)\nlibrosa.mela_to_svara(34)\nlibrosa.mela_to_svara(36)\nlibrosa.mela_to_svara('chalanatta')",
            "masked_line": "librosa.mela_to_svara(19)",
            "answer": "mela_to_svara",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_330"
        },
        {
            "dependency": "librosa",
            "version": "==0.8.0",
            "time": "2020-07-22",
            "description": "The code converts musical key names to a list of notes, taking into account sharps, double-sharps, flats, and double-flats as needed.",
            "code": "# `C:maj` will use all sharps\nlibrosa.key_to_notes('C:maj')\n['C', 'C', 'D', 'D', 'E', 'F', 'F', 'G', 'G', 'A', 'A', 'B']\n\n# `A:min` has the same notes\nlibrosa.key_to_notes('A:min')\n['C', 'C', 'D', 'D', 'E', 'F', 'F', 'G', 'G', 'A', 'A', 'B']\n\n# `A:min` will use sharps, but spell note 0 (`C`) as `B`\nlibrosa.key_to_notes('A#:min')\n['B', 'C', 'D', 'D', 'E', 'E', 'F', 'G', 'G', 'A', 'A', 'B']\n\n# `G:maj` will use a double-sharp to spell note 7 (`G`) as `F`:\nlibrosa.key_to_notes('G#:maj')\n['B', 'C', 'D', 'D', 'E', 'E', 'F', 'F', 'G', 'A', 'A', 'B']\n\n# `F:min` will use double-flats\nlibrosa.key_to_notes('Fb:min')\n['D', 'D', 'E', 'E', 'F', 'F', 'G', 'A', 'A', 'B', 'B', 'C']\n",
            "masked_code": "# `C:maj` will use all sharps\nlibrosa.key_to_notes('C:maj')\n['C', 'C', 'D', 'D', 'E', 'F', 'F', 'G', 'G', 'A', 'A', 'B']\n\n# `A:min` has the same notes\nlibrosa.key_to_notes('A:min')\n['C', 'C', 'D', 'D', 'E', 'F', 'F', 'G', 'G', 'A', 'A', 'B']\n\n# `A:min` will use sharps, but spell note 0 (`C`) as `B`\n<line_mask>\n['B', 'C', 'D', 'D', 'E', 'E', 'F', 'G', 'G', 'A', 'A', 'B']\n\n# `G:maj` will use a double-sharp to spell note 7 (`G`) as `F`:\nlibrosa.key_to_notes('G#:maj')\n['B', 'C', 'D', 'D', 'E', 'E', 'F', 'F', 'G', 'A', 'A', 'B']\n\n# `F:min` will use double-flats\nlibrosa.key_to_notes('Fb:min')\n['D', 'D', 'E', 'E', 'F', 'F', 'G', 'A', 'A', 'B', 'B', 'C']\n",
            "masked_line": "librosa.key_to_notes('A#:min')",
            "answer": "key_to_notes",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_331"
        },
        {
            "dependency": "librosa",
            "version": "==0.8.0",
            "time": "2020-07-22",
            "description": "This code snippet converts musical keys to the corresponding degrees in a scale.",
            "code": "librosa.key_to_degrees('C:maj')\narray([ 0,  2,  4,  5,  7,  9, 11])\nlibrosa.key_to_degrees('C#:maj')\narray([ 1,  3,  5,  6,  8, 10,  0])\nlibrosa.key_to_degrees('A:min')\narray([ 9, 11,  0,  2,  4,  5,  7])",
            "masked_code": "<line_mask>\narray([ 0,  2,  4,  5,  7,  9, 11])\nlibrosa.key_to_degrees('C#:maj')\narray([ 1,  3,  5,  6,  8, 10,  0])\nlibrosa.key_to_degrees('A:min')\narray([ 9, 11,  0,  2,  4,  5,  7])",
            "masked_line": "librosa.key_to_degrees('C:maj')",
            "answer": "key_to_degrees",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_332"
        },
        {
            "dependency": "librosa",
            "version": "==0.8.0",
            "time": "2020-07-22",
            "description": "The code sets the data directory for librosa library, then loads two audio files named 'brahms' and 'vibeace' using librosa, with the 'hq' option set to True for the second file.",
            "code": "import os\nos.environ['LIBROSA_DATA_DIR'] = '/path/to/store/data'\nimport librosa\ny, sr = librosa.load(librosa.example('brahms'))\ny, sr = librosa.load(librosa.example('vibeace', hq=True))",
            "masked_code": "import os\nos.environ['LIBROSA_DATA_DIR'] = '/path/to/store/data'\nimport librosa\n<line_mask>\ny, sr = librosa.load(librosa.example('vibeace', hq=True))",
            "masked_line": "y, sr = librosa.load(librosa.example('brahms'))",
            "answer": "example",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_333"
        },
        {
            "dependency": "librosa",
            "version": "==0.8.0",
            "time": "2020-07-22",
            "description": "The code finds the local minima in a given numpy array along the specified axis.",
            "code": "x = np.array([1, 0, 1, 2, -1, 0, -2, 1])\nlibrosa.util.localmin(x)\narray([False,  True, False, False,  True, False,  True, False])\n\nx = np.array([[1,0,1], [2, -1, 0], [2, 1, 3]])\nlibrosa.util.localmin(x, axis=0)\narray([[False, False, False],\n       [False,  True,  True],\n       [False, False, False]])\n\nlibrosa.util.localmin(x, axis=1)\narray([[False,  True, False],\n       [False,  True, False],\n       [False,  True, False]])\n",
            "masked_code": "x = np.array([1, 0, 1, 2, -1, 0, -2, 1])\n<line_mask>\narray([False,  True, False, False,  True, False,  True, False])\n\nx = np.array([[1,0,1], [2, -1, 0], [2, 1, 3]])\nlibrosa.util.localmin(x, axis=0)\narray([[False, False, False],\n       [False,  True,  True],\n       [False, False, False]])\n\nlibrosa.util.localmin(x, axis=1)\narray([[False,  True, False],\n       [False,  True, False],\n       [False,  True, False]])\n",
            "masked_line": "librosa.util.localmin(x)",
            "answer": "localmin",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_334"
        },
        {
            "dependency": "librosa",
            "version": "==0.9.0",
            "time": "2022-02-07",
            "description": "The code generates a Vandermonde matrix using numpy, and then checks for uniqueness along the rows and columns of the matrix.",
            "code": "x = np.vander(np.arange(5))\nx\narray([[  0,   0,   0,   0,   1],\n   [  1,   1,   1,   1,   1],\n   [ 16,   8,   4,   2,   1],\n   [ 81,  27,   9,   3,   1],\n   [256,  64,  16,   4,   1]])\n# Check uniqueness along rows\nlibrosa.util.is_unique(x, axis=0)\narray([ True,  True,  True,  True, False])\n# Check uniqueness along columns\nlibrosa.util.is_unique(x, axis=-1)\narray([False, False,  True,  True,  True])",
            "masked_code": "x = np.vander(np.arange(5))\nx\narray([[  0,   0,   0,   0,   1],\n   [  1,   1,   1,   1,   1],\n   [ 16,   8,   4,   2,   1],\n   [ 81,  27,   9,   3,   1],\n   [256,  64,  16,   4,   1]])\n# Check uniqueness along rows\nlibrosa.util.is_unique(x, axis=0)\narray([ True,  True,  True,  True, False])\n# Check uniqueness along columns\n<line_mask>\narray([False, False,  True,  True,  True])",
            "masked_line": "librosa.util.is_unique(x, axis=-1)",
            "answer": "is_unique",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_335"
        },
        {
            "dependency": "MarkupSafe",
            "version": "==2.0.0",
            "time": "2021-05-11",
            "description": "The code escapes special characters in a string to prevent HTML injection attacks.",
            "code": "value = escape(\"<User 1>\")\nvalue\nMarkup('&lt;User 1&gt;')\nescape(str(value))\nMarkup('&amp;lt;User 1&amp;gt;')\nescape(soft_str(value))\nMarkup('&lt;User 1&gt;')",
            "masked_code": "value = escape(\"<User 1>\")\nvalue\nMarkup('&lt;User 1&gt;')\nescape(str(value))\nMarkup('&amp;lt;User 1&amp;gt;')\n<line_mask>\nMarkup('&lt;User 1&gt;')",
            "masked_line": "escape(soft_str(value))",
            "answer": "soft_str",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_336"
        },
        {
            "dependency": "MarkupSafe",
            "version": "==1.1.1",
            "time": "2019-02-23",
            "description": "The code is escaping special characters in a string, such as < and >, by replacing them with their corresponding HTML entities.",
            "code": "value = escape('<User 1>')\nvalue\nMarkup('&lt;User 1&gt;')\nescape(str(value))\nMarkup('&amp;lt;User 1&amp;gt;')\nescape(soft_unicode(value))\nMarkup('&lt;User 1&gt;')",
            "masked_code": "value = escape('<User 1>')\nvalue\nMarkup('&lt;User 1&gt;')\nescape(str(value))\nMarkup('&amp;lt;User 1&amp;gt;')\n<line_mask>\nMarkup('&lt;User 1&gt;')",
            "masked_line": "escape(soft_unicode(value))",
            "answer": "soft_unicode",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_337"
        },
        {
            "dependency": "packaging",
            "version": "==22.0",
            "time": "2022-12-07",
            "description": "The code checks if the given version is a pre-release version.",
            "code": "Version(\"1.2.3\").is_prerelease\nVersion(\"1.2.3a1\").is_prerelease\nVersion(\"1.2.3b1\").is_prerelease\nVersion(\"1.2.3rc1\").is_prerelease\nVersion(\"1.2.3dev1\").is_prerelease",
            "masked_code": "Version(\"1.2.3\").is_prerelease\nVersion(\"1.2.3a1\").is_prerelease\n<line_mask>\nVersion(\"1.2.3rc1\").is_prerelease\nVersion(\"1.2.3dev1\").is_prerelease",
            "masked_line": "Version(\"1.2.3b1\").is_prerelease",
            "answer": "is_prerelease",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_338"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==1.7.0",
            "time": "2020-02-20",
            "description": "The code creates a main program using Fluid, defines a data variable \"rlt\" with shape [1, 1] and float32 data type, and then converts the main program to a string and prints it.",
            "code": "import paddle.fluid as fluid\n\nprog = fluid.default_main_program()\nrlt = fluid.layers.data(\"fake_data\", shape=[1,1], dtype='float32')\ndebug_str = prog.to_string(throw_on_error=True, with_details=False)\nprint(debug_str)",
            "masked_code": "import paddle.fluid as fluid\n\nprog = fluid.default_main_program()\nrlt = fluid.layers.data(\"fake_data\", shape=[1,1], dtype='float32')\n<line_mask>\nprint(debug_str)",
            "masked_line": "debug_str = prog.to_string(throw_on_error=True, with_details=False)",
            "answer": "to_string",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_339"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==1.7.0",
            "time": "2020-02-20",
            "description": "This code defines a custom layer in Python using PaddlePaddle's fluid library. The layer consists of a list of linear transformation modules, each with input and output dimensions of 10. In the forward function of the layer, it iterates over the list of linear modules, applies them to the input tensor, and returns the final output tensor after the transformations.",
            "code": "import paddle.fluid as fluid\nimport numpy as np\n\nclass MyLayer(fluid.Layer):\n    def __init__(self):\n        super(MyLayer, self).__init__()\n        self.linears = fluid.dygraph.LayerList(\n            [fluid.dygraph.Linear(10, 10) for i in range(10)])\n\n    def forward(self, x):\n        # LayerList can act as an iterable, or be indexed using ints\n        for i, l in enumerate(self.linears):\n            x = self.linears[i // 2](x) + l(x)\n        return x",
            "masked_code": "import paddle.fluid as fluid\nimport numpy as np\n\nclass MyLayer(fluid.Layer):\n    def __init__(self):\n        super(MyLayer, self).__init__()\n        <line_mask>\n            [fluid.dygraph.Linear(10, 10) for i in range(10)])\n\n    def forward(self, x):\n        # LayerList can act as an iterable, or be indexed using ints\n        for i, l in enumerate(self.linears):\n            x = self.linears[i // 2](x) + l(x)\n        return x",
            "masked_line": "self.linears = fluid.dygraph.LayerList(",
            "answer": "LayerList",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_340"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==1.7.0",
            "time": "2020-02-20",
            "description": "The code initializes a GRU decoder cell with a hidden size of 128 and uses a training helper to decode the target embedding sequence based on the target sequence length provided. The decoder processes the input sequence dynamically and returns the outputs of the decoding process.",
            "code": "import paddle.fluid as fluid\nimport paddle.fluid.layers as layers\ntrg_emb = fluid.data(name=\"trg_emb\",\n                     shape=[None, None, 128],\n                     dtype=\"float32\")\ntrg_seq_length = fluid.data(name=\"trg_seq_length\",\n                            shape=[None],\n                            dtype=\"int64\")\nhelper = layers.TrainingHelper(trg_emb, trg_seq_length)\ndecoder_cell = layers.GRUCell(hidden_size=128)\ndecoder = layers.BasicDecoder(decoder_cell, helper)\noutputs = layers.dynamic_decode(\n    decoder,\n    inits=decoder_cell.get_initial_states(trg_emb),\n    is_test=False)",
            "masked_code": "import paddle.fluid as fluid\nimport paddle.fluid.layers as layers\ntrg_emb = fluid.data(name=\"trg_emb\",\n                     shape=[None, None, 128],\n                     dtype=\"float32\")\ntrg_seq_length = fluid.data(name=\"trg_seq_length\",\n                            shape=[None],\n                            dtype=\"int64\")\n<line_mask>\ndecoder_cell = layers.GRUCell(hidden_size=128)\ndecoder = layers.BasicDecoder(decoder_cell, helper)\noutputs = layers.dynamic_decode(\n    decoder,\n    inits=decoder_cell.get_initial_states(trg_emb),\n    is_test=False)",
            "masked_line": "helper = layers.TrainingHelper(trg_emb, trg_seq_length)",
            "answer": "TrainingHelper",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_341"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==1.7.0",
            "time": "2020-02-20",
            "description": "The code defines a basic TensorFlow model for a language translation task using GRU cells for decoding. The model uses an embedding layer, an output layer, a greedy embedding helper, and a decoder with GRU cell for decoding. The dynamic_decode function is used to perform decoding based on the defined model.",
            "code": "import paddle.fluid as fluid\nimport paddle.fluid.layers as layers\ntrg_emb = fluid.data(name=\"trg_emb\",\n                     shape=[None, None, 128],\n                     dtype=\"float32\")\n\ntrg_embeder = lambda x: fluid.embedding(\n    x, size=[10000, 128], param_attr=fluid.ParamAttr(name=\"trg_embedding\"))\noutput_layer = lambda x: layers.fc(x,\n                                size=10000,\n                                num_flatten_dims=len(x.shape) - 1,\n                                param_attr=fluid.ParamAttr(name=\n                                                        \"output_w\"),\n                                bias_attr=False)\nhelper = layers.GreedyEmbeddingHelper(trg_embeder, start_tokens=0, end_token=1)\ndecoder_cell = layers.GRUCell(hidden_size=128)\ndecoder = layers.BasicDecoder(decoder_cell, helper, output_fn=output_layer)\noutputs = layers.dynamic_decode(\n    decoder=decoder, inits=decoder_cell.get_initial_states(encoder_output))",
            "masked_code": "import paddle.fluid as fluid\nimport paddle.fluid.layers as layers\ntrg_emb = fluid.data(name=\"trg_emb\",\n                     shape=[None, None, 128],\n                     dtype=\"float32\")\n\ntrg_embeder = lambda x: fluid.embedding(\n    x, size=[10000, 128], param_attr=fluid.ParamAttr(name=\"trg_embedding\"))\noutput_layer = lambda x: layers.fc(x,\n                                size=10000,\n                                num_flatten_dims=len(x.shape) - 1,\n                                param_attr=fluid.ParamAttr(name=\n                                                        \"output_w\"),\n                                bias_attr=False)\n<line_mask>\ndecoder_cell = layers.GRUCell(hidden_size=128)\ndecoder = layers.BasicDecoder(decoder_cell, helper, output_fn=output_layer)\noutputs = layers.dynamic_decode(\n    decoder=decoder, inits=decoder_cell.get_initial_states(encoder_output))",
            "masked_line": "helper = layers.GreedyEmbeddingHelper(trg_embeder, start_tokens=0, end_token=1)",
            "answer": "GreedyEmbeddingHelper",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_342"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==1.7.0",
            "time": "2020-02-20",
            "description": "The code defines a decoder model for sequence generation using a GRU cell. The model takes an input sequence, embeds it using a target embedding layer, processes it through a GRU cell, and generates an output sequence using a fully connected layer. The decoder is initialized with the initial state from an encoder output and dynamically generates the output sequence.",
            "code": "import paddle.fluid as fluid\nimport paddle.fluid.layers as layers\ntrg_emb = fluid.data(name=\"trg_emb\",\n                     shape=[None, None, 128],\n                     dtype=\"float32\")\n\ntrg_embeder = lambda x: fluid.embedding(\n    x, size=[10000, 128], param_attr=fluid.ParamAttr(name=\"trg_embedding\"))\noutput_layer = lambda x: layers.fc(x,\n                                size=10000,\n                                num_flatten_dims=len(x.shape) - 1,\n                                param_attr=fluid.ParamAttr(name=\n                                                        \"output_w\"),\n                                bias_attr=False)\nhelper = layers.SampleEmbeddingHelper(trg_embeder, start_tokens=0, end_token=1)\ndecoder_cell = layers.GRUCell(hidden_size=128)\ndecoder = layers.BasicDecoder(decoder_cell, helper, output_fn=output_layer)\noutputs = layers.dynamic_decode(\n    decoder=decoder, inits=decoder_cell.get_initial_states(encoder_output))",
            "masked_code": "import paddle.fluid as fluid\nimport paddle.fluid.layers as layers\ntrg_emb = fluid.data(name=\"trg_emb\",\n                     shape=[None, None, 128],\n                     dtype=\"float32\")\n\ntrg_embeder = lambda x: fluid.embedding(\n    x, size=[10000, 128], param_attr=fluid.ParamAttr(name=\"trg_embedding\"))\noutput_layer = lambda x: layers.fc(x,\n                                size=10000,\n                                num_flatten_dims=len(x.shape) - 1,\n                                param_attr=fluid.ParamAttr(name=\n                                                        \"output_w\"),\n                                bias_attr=False)\n<line_mask>\ndecoder_cell = layers.GRUCell(hidden_size=128)\ndecoder = layers.BasicDecoder(decoder_cell, helper, output_fn=output_layer)\noutputs = layers.dynamic_decode(\n    decoder=decoder, inits=decoder_cell.get_initial_states(encoder_output))",
            "masked_line": "helper = layers.SampleEmbeddingHelper(trg_embeder, start_tokens=0, end_token=1)",
            "answer": "SampleEmbeddingHelper",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_343"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==1.7.0",
            "time": "2020-02-20",
            "description": "The code defines a language model using the GRU cell. It takes an input sequence of embeddings, applies an embedding layer, and uses the GRU cell to generate the output sequence. The output layer is a fully connected layer that maps the GRU cell output to a sequence of 10000 classes. The decoding process is performed dynamically using the BasicDecoder with a SampleEmbeddingHelper to assist in generating the output sequence.",
            "code": "import paddle.fluid as fluid\nimport paddle.fluid.layers as layers\ntrg_emb = fluid.data(name=\"trg_emb\",\n                     shape=[None, None, 128],\n                     dtype=\"float32\")\n\ntrg_embeder = lambda x: fluid.embedding(\n    x, size=[10000, 128], param_attr=fluid.ParamAttr(name=\"trg_embedding\"))\noutput_layer = lambda x: layers.fc(x,\n                                size=10000,\n                                num_flatten_dims=len(x.shape) - 1,\n                                param_attr=fluid.ParamAttr(name=\n                                                        \"output_w\"),\n                                bias_attr=False)\nhelper = layers.SampleEmbeddingHelper(trg_embeder, start_tokens=0, end_token=1)\ndecoder_cell = layers.GRUCell(hidden_size=128)\ndecoder = layers.BasicDecoder(decoder_cell, helper, output_fn=output_layer)\noutputs = layers.dynamic_decode(\n    decoder=decoder, inits=decoder_cell.get_initial_states(encoder_output))",
            "masked_code": "import paddle.fluid as fluid\nimport paddle.fluid.layers as layers\ntrg_emb = fluid.data(name=\"trg_emb\",\n                     shape=[None, None, 128],\n                     dtype=\"float32\")\n\ntrg_embeder = lambda x: fluid.embedding(\n    x, size=[10000, 128], param_attr=fluid.ParamAttr(name=\"trg_embedding\"))\noutput_layer = lambda x: layers.fc(x,\n                                size=10000,\n                                num_flatten_dims=len(x.shape) - 1,\n                                param_attr=fluid.ParamAttr(name=\n                                                        \"output_w\"),\n                                bias_attr=False)\nhelper = layers.SampleEmbeddingHelper(trg_embeder, start_tokens=0, end_token=1)\ndecoder_cell = layers.GRUCell(hidden_size=128)\n<line_mask>\noutputs = layers.dynamic_decode(\n    decoder=decoder, inits=decoder_cell.get_initial_states(encoder_output))",
            "masked_line": "decoder = layers.BasicDecoder(decoder_cell, helper, output_fn=output_layer)",
            "answer": "BasicDecoder",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_344"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==1.7.0",
            "time": "2020-02-20",
            "description": "This code defines input data 'img' with shape [64, 784], creates weight 'fc_w' with shape [784, 200] and bias 'fc_b' with shape [200], and retrieves parameters from the default main program.",
            "code": "import paddle.fluid as fluid\ndata = fluid.data(name=\"img\", shape=[64, 784])\nw = fluid.layers.create_parameter(shape=[784, 200], dtype='float32', name='fc_w')\nb = fluid.layers.create_parameter(shape=[200], dtype='float32', name='fc_b')\nlist_para  = fluid.io.get_program_parameter(  fluid.default_main_program() )",
            "masked_code": "import paddle.fluid as fluid\ndata = fluid.data(name=\"img\", shape=[64, 784])\nw = fluid.layers.create_parameter(shape=[784, 200], dtype='float32', name='fc_w')\nb = fluid.layers.create_parameter(shape=[200], dtype='float32', name='fc_b')\n<line_mask>",
            "masked_line": "list_para  = fluid.io.get_program_parameter(  fluid.default_main_program() )",
            "answer": "get_program_parameter",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_345"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==1.7.0",
            "time": "2020-02-20",
            "description": "This code creates a neural network model with an input data shape of [64, 784], a weight matrix of shape [784, 200], and a bias vector of shape [200]. It also retrieves a list of persistent variables in the default main program.",
            "code": "import paddle.fluid as fluid\ndata = fluid.data(name=\"img\", shape=[64, 784])\nw = fluid.layers.create_parameter(shape=[784, 200], dtype='float32', name='fc_w')\nb = fluid.layers.create_parameter(shape=[200], dtype='float32', name='fc_b')\nlist_para  = fluid.io.get_program_persistable_vars(  fluid.default_main_program() )",
            "masked_code": "import paddle.fluid as fluid\ndata = fluid.data(name=\"img\", shape=[64, 784])\nw = fluid.layers.create_parameter(shape=[784, 200], dtype='float32', name='fc_w')\nb = fluid.layers.create_parameter(shape=[200], dtype='float32', name='fc_b')\n<line_mask>",
            "masked_line": "list_para  = fluid.io.get_program_persistable_vars(  fluid.default_main_program() )",
            "answer": "get_program_persistable_vars",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_346"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==1.7.0",
            "time": "2020-02-20",
            "description": "The code calculates the fused embedding sequence pooling for the input data with specified dictionary size and embedding dimensions, using the specified padding index.",
            "code": "import numpy as np\nimport paddle.fluid as fluid\n\ndict_size = 20\ndata_t = fluid.layers.data(name='word', shape=[1], dtype='int64', lod_level=1)\npadding_idx = np.random.randint(1, 10)\nout = fluid.contrib.fused_embedding_seq_pool(\n    input=data_t,\n    size=[dict_size, 32],\n    param_attr='w',\n    padding_idx=padding_idx,\n    is_sparse=False)",
            "masked_code": "import numpy as np\nimport paddle.fluid as fluid\n\ndict_size = 20\ndata_t = fluid.layers.data(name='word', shape=[1], dtype='int64', lod_level=1)\npadding_idx = np.random.randint(1, 10)\n<line_mask>\n    input=data_t,\n    size=[dict_size, 32],\n    param_attr='w',\n    padding_idx=padding_idx,\n    is_sparse=False)",
            "masked_line": "out = fluid.contrib.fused_embedding_seq_pool(",
            "answer": "fused_embedding_seq_pool",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_347"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==1.7.0",
            "time": "2020-02-20",
            "description": "The code calculates the value of 'out' based on a conditional statement comparing 'a' and 'b', where if 'a' is less than 'b', 'out' is assigned the value of 'a + (a * b)', otherwise 'out' is assigned the value of 'b * b'.",
            "code": "import paddle.fluid as fluid\na = fluid.data(name='a', shape=[-1, 1], dtype='float32')\nb = fluid.data(name='b', shape=[-1, 1], dtype='float32')\nc = a * b\nout = fluid.layers.cond(a < b, lambda: a + c, lambda: b * b)\n",
            "masked_code": "import paddle.fluid as fluid\na = fluid.data(name='a', shape=[-1, 1], dtype='float32')\nb = fluid.data(name='b', shape=[-1, 1], dtype='float32')\nc = a * b\n<line_mask>\n",
            "masked_line": "out = fluid.layers.cond(a < b, lambda: a + c, lambda: b * b)",
            "answer": "cond",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_348"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==1.7.0",
            "time": "2020-02-20",
            "description": "This code defines and prints the parameters of a sequential model with two linear layers, where the first layer has 10 input features and 3 output features, and the second layer has 3 input features and 10 output features, without bias.",
            "code": "import paddle.fluid as fluid\n\nwith fluid.dygraph.guard():\n    fc1 = fluid.Linear(10, 3)\n    fc2 = fluid.Linear(3, 10, bias_attr=False)\n    model = fluid.dygraph.Sequential(fc1, fc2)\n    for name, param in model.named_parameters():\n        print(name, param)",
            "masked_code": "import paddle.fluid as fluid\n\nwith fluid.dygraph.guard():\n    fc1 = fluid.Linear(10, 3)\n    fc2 = fluid.Linear(3, 10, bias_attr=False)\n    model = fluid.dygraph.Sequential(fc1, fc2)\n    <line_mask>\n        print(name, param)",
            "masked_line": "for name, param in model.named_parameters():",
            "answer": "named_parameters",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_349"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==1.7.0",
            "time": "2020-02-20",
            "description": "This code creates a linear transformation network with two fully connected layers using the PaddlePaddle framework in Python.",
            "code": "import paddle.fluid as fluid\n\nwith fluid.dygraph.guard():\n    fc1 = fluid.Linear(10, 3)\n    fc2 = fluid.Linear(3, 10, bias_attr=False)\n    model = fluid.dygraph.Sequential(fc1, fc2)\n    for prefix, layer in model.named_sublayers():\n        print(prefix, layer)",
            "masked_code": "import paddle.fluid as fluid\n\nwith fluid.dygraph.guard():\n    fc1 = fluid.Linear(10, 3)\n    fc2 = fluid.Linear(3, 10, bias_attr=False)\n    model = fluid.dygraph.Sequential(fc1, fc2)\n    <line_mask>\n        print(prefix, layer)",
            "masked_line": "for prefix, layer in model.named_sublayers():",
            "answer": "named_sublayers",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_350"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==1.7.0",
            "time": "2020-02-20",
            "description": "The code saves and loads the state dictionary of an embedding layer in a parallel context using PaddlePaddle's dygraph module.",
            "code": "import paddle.fluid as fluid\nwith fluid.dygraph.guard():\n    strategy=dygraph.parallel.prepare_context()\n    emb = fluid.dygraph.Embedding([10, 10])\n    emb = dygraph.parallel.DataParallel(emb, strategy)\n\n    state_dict = emb.state_dict()\n    fluid.save_dygraph( state_dict, \"paddle_dy\")\n\n    para_state_dict, _ = fluid.load_dygraph( \"paddle_dy\")\n\n    emb.set_dict( para_state_dict )",
            "masked_code": "import paddle.fluid as fluid\nwith fluid.dygraph.guard():\n    strategy=dygraph.parallel.prepare_context()\n    emb = fluid.dygraph.Embedding([10, 10])\n    emb = dygraph.parallel.DataParallel(emb, strategy)\n\n    state_dict = emb.state_dict()\n    fluid.save_dygraph( state_dict, \"paddle_dy\")\n\n    para_state_dict, _ = fluid.load_dygraph( \"paddle_dy\")\n\n    <line_mask>",
            "masked_line": "emb.set_dict( para_state_dict )",
            "answer": "set_dict",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_351"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==1.7.0",
            "time": "2020-02-20",
            "description": "The code creates an Embedding layer using PaddlePaddle's fluid.dygraph module, utilizes DataParallel to parallelize the process, saves the state dictionary of the Embedding layer to a file named \"paddle_dy\", loads the state dictionary from the file, and then updates the Embedding layer's parameters with the loaded dictionary.",
            "code": "import paddle.fluid as fluid\nwith fluid.dygraph.guard():\n    strategy=dygraph.parallel.prepare_context()\n    emb = fluid.dygraph.Embedding([10, 10])\n    emb = dygraph.parallel.DataParallel(emb, strategy)\n\n    state_dict = emb.state_dict()\n    fluid.save_dygraph( state_dict, \"paddle_dy\")\n    \n    para_state_dict, _ = fluid.load_dygraph( \"paddle_dy\")\n\n    emb.load_dict( para_state_dict )",
            "masked_code": "import paddle.fluid as fluid\nwith fluid.dygraph.guard():\n    strategy=dygraph.parallel.prepare_context()\n    emb = fluid.dygraph.Embedding([10, 10])\n    emb = dygraph.parallel.DataParallel(emb, strategy)\n\n    state_dict = emb.state_dict()\n    fluid.save_dygraph( state_dict, \"paddle_dy\")\n    \n    para_state_dict, _ = fluid.load_dygraph( \"paddle_dy\")\n\n    <line_mask>",
            "masked_line": "emb.load_dict( para_state_dict )",
            "answer": "load_dict",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_352"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==1.7.0",
            "time": "2020-02-20",
            "description": "The code parses a program protobuf file (.pbtxt) and saves the output in a specified directory.",
            "code": "from paddle.fluid.incubate.fleet.utils.fleet_util import FleetUtil\nfleet_util = FleetUtil()\nprogram_path = \"./program.pbtxt\"\nis_text = True\noutput_dir = \"/tmp/\"\nfleet_util.parse_program_proto(program_path, is_text, output_dir)",
            "masked_code": "from paddle.fluid.incubate.fleet.utils.fleet_util import FleetUtil\nfleet_util = FleetUtil()\nprogram_path = \"./program.pbtxt\"\nis_text = True\noutput_dir = \"/tmp/\"\n<line_mask>",
            "masked_line": "fleet_util.parse_program_proto(program_path, is_text, output_dir)",
            "answer": "parse_program_proto",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_353"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==1.6.3",
            "time": "2020-01-10",
            "description": "The code creates an Adam optimizer with a learning rate of 0.001 using PaddlePaddle's Fluid library. It then saves the optimizer's state dictionary to a file named \"opt_adam\" and loads the optimizer's state dictionary from the same file.",
            "code": "import paddle.fluid as fluid\n\nwith fluid.dygraph.guard():\n    adam = fluid.optimizer.Adam(0.001)\n\n    state_dict = adam.state_dict()\n    fluid.save_optimizer(state_dict, \"opt_adam\")\n\n    fluid.load_optimizer(\"opt_adam\")",
            "masked_code": "import paddle.fluid as fluid\n\nwith fluid.dygraph.guard():\n    adam = fluid.optimizer.Adam(0.001)\n\n    state_dict = adam.state_dict()\n    fluid.save_optimizer(state_dict, \"opt_adam\")\n\n    <line_mask>",
            "masked_line": "fluid.load_optimizer(\"opt_adam\")",
            "answer": "load_optimizer",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_354"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==1.7.1",
            "time": "2020-03-09",
            "description": "This code defines a neural network with a single fully connected layer, computes the mean of the hidden layer outputs, and then minimizes the loss using the SGD optimizer with a learning rate of 0.01. Finally, it prints out all the parameters of the neural network.",
            "code": "import paddle.fluid as fluid\n\nprogram = fluid.default_main_program()\ndata = fluid.data(name='x', shape=[None, 13], dtype='float32')\nhidden = fluid.layers.fc(input=data, size=10)\nloss = fluid.layers.mean(hidden)\nfluid.optimizer.SGD(learning_rate=0.01).minimize(loss)\n\nfor param in program.all_parameters():\n    print(param)",
            "masked_code": "import paddle.fluid as fluid\n\nprogram = fluid.default_main_program()\ndata = fluid.data(name='x', shape=[None, 13], dtype='float32')\nhidden = fluid.layers.fc(input=data, size=10)\nloss = fluid.layers.mean(hidden)\nfluid.optimizer.SGD(learning_rate=0.01).minimize(loss)\n\n<line_mask>\n    print(param)",
            "masked_line": "for param in program.all_parameters():",
            "answer": "all_parameters",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_355"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==1.7.2",
            "time": "2020-04-09",
            "description": "This code segment performs index sampling on the input data 'x' based on the indices provided in 'index'.",
            "code": "import paddle.fluid as fluid\nimport numpy as np\n\nx = fluid.data(name='x', shape=[-1, 5], dtype='float64')\nindex = fluid.data(name='index', shape=[-1, 3], dtype='int32')\noutput = fluid.contrib.layers.index_sample(x=x, index=index)",
            "masked_code": "import paddle.fluid as fluid\nimport numpy as np\n\nx = fluid.data(name='x', shape=[-1, 5], dtype='float64')\nindex = fluid.data(name='index', shape=[-1, 3], dtype='int32')\n<line_mask>",
            "masked_line": "output = fluid.contrib.layers.index_sample(x=x, index=index)",
            "answer": "index_sample",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_356"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==1.8.0",
            "time": "2020-04-30",
            "description": "This code performs instance normalization on the input tensor x with a shape of [1, 3, 1, 2]. Instance normalization normalizes the values of each channel independently across each spatial location in the input tensor.",
            "code": "import paddle.fluid as fluid\nfrom paddle.fluid.dygraph.base import to_variable\nimport numpy as np\nimport paddle\n\n# x's shape is [1, 3, 1, 2] \nx = np.array([[[[1.0, 8.0]], [[10.0, 5.0]], [[4.0, 6.0]]]]).astype('float32')\nwith fluid.dygraph.guard():\n    x = to_variable(x)\n    instanceNorm = paddle.nn.InstanceNorm(3)\n    ret = instanceNorm(x)\n    # ret's shape is [1, 3, 1, 2]; value is [-1 1 0.999999 -0.999999 -0.999995 0.999995] \n    print(ret)",
            "masked_code": "import paddle.fluid as fluid\nfrom paddle.fluid.dygraph.base import to_variable\nimport numpy as np\nimport paddle\n\n# x's shape is [1, 3, 1, 2] \nx = np.array([[[[1.0, 8.0]], [[10.0, 5.0]], [[4.0, 6.0]]]]).astype('float32')\nwith fluid.dygraph.guard():\n    x = to_variable(x)\n    <line_mask>\n    ret = instanceNorm(x)\n    # ret's shape is [1, 3, 1, 2]; value is [-1 1 0.999999 -0.999999 -0.999995 0.999995] \n    print(ret)",
            "masked_line": "instanceNorm = paddle.nn.InstanceNorm(3)",
            "answer": "InstanceNorm",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_357"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==1.8.0",
            "time": "2020-04-30",
            "description": "The code performs dropout regularization with a dropout probability of 0.5 on the input tensor 'x' in both training and evaluation modes using the PaddlePaddle library.",
            "code": "import paddle.fluid as fluid\nfrom paddle.fluid.dygraph.base import to_variable\nimport numpy as np\n\nx = np.random.random(size=(3, 10, 3, 7)).astype('float32')\nwith fluid.dygraph.guard():\n    x = to_variable(x)\n    m = fluid.dygraph.Dropout(p=0.5)\n    droped_train = m(x)\n    # switch to eval mode\n    m.eval()\n    droped_eval = m(x)",
            "masked_code": "import paddle.fluid as fluid\nfrom paddle.fluid.dygraph.base import to_variable\nimport numpy as np\n\nx = np.random.random(size=(3, 10, 3, 7)).astype('float32')\nwith fluid.dygraph.guard():\n    x = to_variable(x)\n    <line_mask>\n    droped_train = m(x)\n    # switch to eval mode\n    m.eval()\n    droped_eval = m(x)",
            "masked_line": "m = fluid.dygraph.Dropout(p=0.5)",
            "answer": "Dropout",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_358"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==1.8.0",
            "time": "2020-04-30",
            "description": "Calculate the trace of a complex matrix along specified dimensions with an offset of 1 and return a tensor with shape [3].",
            "code": "import paddle\nimport paddle.fluid.dygraph as dg\nimport numpy as np\n\ncase1 = np.random.randn(3, 10, 10).astype('float64') + 1j * np.random.randn(3, 10, 10).astype('float64')\n\nwith dg.guard():\n    case1 = dg.to_variable(case1)\n    data1 = paddle.complex.trace(case1, offset=1, dim1=1, dim2=2) # data1.shape = [3]",
            "masked_code": "import paddle\nimport paddle.fluid.dygraph as dg\nimport numpy as np\n\ncase1 = np.random.randn(3, 10, 10).astype('float64') + 1j * np.random.randn(3, 10, 10).astype('float64')\n\nwith dg.guard():\n    case1 = dg.to_variable(case1)\n    <line_mask>",
            "masked_line": "data1 = paddle.complex.trace(case1, offset=1, dim1=1, dim2=2) # data1.shape = [3]",
            "answer": "trace",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_359"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==1.8.0",
            "time": "2020-04-30",
            "description": "The code calculates the rank attention mechanism using the provided input data and rank offsets. It utilizes the parameters specified to determine the attention weights for ranking, with a maximum rank of 3.",
            "code": "import paddle.fluid as fluid\nimport numpy as np\n\ninput = fluid.data(name=\"input\", shape=[None, 2], dtype=\"float32\")\nrank_offset = fluid.data(name=\"rank_offset\", shape=[None, 7], dtype=\"int32\")\nout = fluid.contrib.layers.rank_attention(input=input,\n                                          rank_offset=rank_offset,\n                                          rank_param_shape=[18,3],\n                                          rank_param_attr=\n                                            fluid.ParamAttr(learning_rate=1.0,\n                                                          name=\"ubm_rank_param.w_0\",\n                                                          initializer=\n                                                          fluid.initializer.Xavier(uniform=False)),\n                                          max_rank=3)",
            "masked_code": "import paddle.fluid as fluid\nimport numpy as np\n\ninput = fluid.data(name=\"input\", shape=[None, 2], dtype=\"float32\")\nrank_offset = fluid.data(name=\"rank_offset\", shape=[None, 7], dtype=\"int32\")\n<line_mask>\n                                          rank_offset=rank_offset,\n                                          rank_param_shape=[18,3],\n                                          rank_param_attr=\n                                            fluid.ParamAttr(learning_rate=1.0,\n                                                          name=\"ubm_rank_param.w_0\",\n                                                          initializer=\n                                                          fluid.initializer.Xavier(uniform=False)),\n                                          max_rank=3)",
            "masked_line": "out = fluid.contrib.layers.rank_attention(input=input,",
            "answer": "rank_attention",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_360"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==1.8.0",
            "time": "2020-04-30",
            "description": "This code snippet enables and disables dynamic graph mode in PaddlePaddle by using the functions enable_dygraph() and disable_dygraph(). It then prints out the current state of dynamic graph mode, which will be True after enabling and False after disabling.",
            "code": "import paddle.fluid as fluid\n\nfluid.enable_dygraph()  # Now we are in dygragh mode\nprint(fluid.dygraph.enabled())  # True\nfluid.disable_dygraph()\nprint(fluid.dygraph.enabled())  # False",
            "masked_code": "import paddle.fluid as fluid\n\nfluid.enable_dygraph()  # Now we are in dygragh mode\n<line_mask>\nfluid.disable_dygraph()\nprint(fluid.dygraph.enabled())  # False",
            "masked_line": "print(fluid.dygraph.enabled())  # True",
            "answer": "enabled",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_361"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==1.8.0",
            "time": "2020-04-30",
            "description": "This code enables and disables the dygraph mode in PaddlePaddle's fluid framework and checks if the code is currently in dygraph mode.",
            "code": "import paddle.fluid as fluid\n\nfluid.enable_dygraph()  # Now we are in dygragh mode\nprint(fluid.in_dygraph_mode())  # True\nfluid.disable_dygraph()\nprint(fluid.in_dygraph_mode())  # False",
            "masked_code": "import paddle.fluid as fluid\n\n<line_mask>\nprint(fluid.in_dygraph_mode())  # True\nfluid.disable_dygraph()\nprint(fluid.in_dygraph_mode())  # False",
            "masked_line": "fluid.enable_dygraph()  # Now we are in dygragh mode",
            "answer": "enable_dygraph",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_362"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==1.8.0",
            "time": "2020-04-30",
            "description": "The code switches the execution mode to dygraph mode, checks if the execution mode is in dygraph mode, switches the execution mode back to imperative mode, and then checks if the execution mode is in dygraph mode.",
            "code": "import paddle.fluid as fluid\n\nfluid.enable_dygraph()  # Now we are in dygragh mode\nprint(fluid.in_dygraph_mode())  # True\nfluid.disable_dygraph()\nprint(fluid.in_dygraph_mode())  # False",
            "masked_code": "import paddle.fluid as fluid\n\nfluid.enable_dygraph()  # Now we are in dygragh mode\nprint(fluid.in_dygraph_mode())  # True\n<line_mask>\nprint(fluid.in_dygraph_mode())  # False",
            "masked_line": "fluid.disable_dygraph()",
            "answer": "disable_dygraph",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_363"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==1.8.0",
            "time": "2020-04-30",
            "description": "The code calculates the logarithm of each element in the input array x, using natural logarithm with base 1. The input array x is a 2x1 array with dtype float32. The result is stored in the variable res. The code then creates an executor using CPU, executes the operation using the input array x_i, and prints the result which is an array of natural logarithms of the input elements.",
            "code": "import paddle\nimport paddle.fluid as fluid\nimport numpy as np\n# Graph Organizing\nx = fluid.data(name=\"x\", shape=[2,1], dtype=\"float32\")\nres = fluid.layers.log1p(x)\n# Create an executor using CPU as an example\nexe = fluid.Executor(fluid.CPUPlace())\n# Execute\nx_i = np.array([[0], [1]]).astype(np.float32)\nres_val, = exe.run(fluid.default_main_program(), feed={'x':x_i}, fetch_list=[res])\nprint(res_val) # [[0.], [0.6931472]]",
            "masked_code": "import paddle\nimport paddle.fluid as fluid\nimport numpy as np\n# Graph Organizing\nx = fluid.data(name=\"x\", shape=[2,1], dtype=\"float32\")\n<line_mask>\n# Create an executor using CPU as an example\nexe = fluid.Executor(fluid.CPUPlace())\n# Execute\nx_i = np.array([[0], [1]]).astype(np.float32)\nres_val, = exe.run(fluid.default_main_program(), feed={'x':x_i}, fetch_list=[res])\nprint(res_val) # [[0.], [0.6931472]]",
            "masked_line": "res = fluid.layers.log1p(x)",
            "answer": "log1p",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_364"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==1.8.0",
            "time": "2020-04-30",
            "description": "The code performs element-wise clamping on a numpy array, setting values below 3.5 to 3.5 and values above 5.0 to 5.0 for the first clamp operation. For the second clamp operation, it sets values below 2.5 to 2.5.",
            "code": "import paddle\nimport paddle.fluid as fluid\nimport numpy as np\n\nin1 = np.array([[1.2,3.5],\n                [4.5,6.4]]).astype('float32')\nwith fluid.dygraph.guard():\n    x1 = fluid.dygraph.to_variable(in1)\n    out1 = fluid.layers.clamp(x1, min=3.5, max=5.0)\n    out2 = fluid.layers.clamp(x1, min=2.5)\n    print(out1.numpy())\n    # [[3.5, 3.5]\n    # [4.5, 5.0]]\n    print(out2.numpy())\n    # [[2.5, 3.5]\n    # [[4.5, 6.4]",
            "masked_code": "import paddle\nimport paddle.fluid as fluid\nimport numpy as np\n\nin1 = np.array([[1.2,3.5],\n                [4.5,6.4]]).astype('float32')\nwith fluid.dygraph.guard():\n    x1 = fluid.dygraph.to_variable(in1)\n    <line_mask>\n    out2 = fluid.layers.clamp(x1, min=2.5)\n    print(out1.numpy())\n    # [[3.5, 3.5]\n    # [4.5, 5.0]]\n    print(out2.numpy())\n    # [[2.5, 3.5]\n    # [[4.5, 6.4]",
            "masked_line": "out1 = fluid.layers.clamp(x1, min=3.5, max=5.0)",
            "answer": "clamp",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_365"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==1.8.0",
            "time": "2020-04-30",
            "description": "The code performs element-wise multiplication of tensor1 and tensor2, adds the result to the input tensor, and then scales the result by a constant value of 1.0.",
            "code": "import paddle\nimport paddle.fluid as fluid\ninput = fluid.data(name='input', dtype='float32', shape=[3, 4])\ntensor1 = fluid.data(name='tenosr1', dtype='float32', shape=[1, 4])\ntensor2 = fluid.data(name='tensor2', dtype='float32', shape=[3, 4])\ndata = fluid.layers.addcmul(input, tensor1, tensor2, value=1.0)",
            "masked_code": "import paddle\nimport paddle.fluid as fluid\ninput = fluid.data(name='input', dtype='float32', shape=[3, 4])\ntensor1 = fluid.data(name='tenosr1', dtype='float32', shape=[1, 4])\ntensor2 = fluid.data(name='tensor2', dtype='float32', shape=[3, 4])\n<line_mask>",
            "masked_line": "data = fluid.layers.addcmul(input, tensor1, tensor2, value=1.0)",
            "answer": "addcmul",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_366"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==1.8.0",
            "time": "2020-04-30",
            "description": "This code calculates the dot product of two randomly generated arrays of floats and prints the result.",
            "code": "import paddle\nimport paddle.fluid as fluid\nimport numpy as np\n\nwith fluid.dygraph.guard():\n  x = fluid.dygraph.to_variable(np.random.uniform(0.1, 1, [10]).astype(np.float32))\n  y = fluid.dygraph.to_variable(np.random.uniform(1, 3, [10]).astype(np.float32))\n  z = fluid.layers.dot(x, y)\n  print(z.numpy())",
            "masked_code": "import paddle\nimport paddle.fluid as fluid\nimport numpy as np\n\nwith fluid.dygraph.guard():\n  x = fluid.dygraph.to_variable(np.random.uniform(0.1, 1, [10]).astype(np.float32))\n  y = fluid.dygraph.to_variable(np.random.uniform(1, 3, [10]).astype(np.float32))\n  <line_mask>\n  print(z.numpy())",
            "masked_line": "z = fluid.layers.dot(x, y)",
            "answer": "dot",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_367"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==1.8.0",
            "time": "2020-04-30",
            "description": "The code generates random integers within a specified range and shape.",
            "code": "import paddle.fluid as fluid\n\n# example 1:\n# attr shape is a list which doesn't contain tensor Variable.\nresult_1 = fluid.layers.randint(low=-5, high=5, shape=[3, 4], dtype=\"int64\")\n\n# example 2:\n# attr shape is a list which contains tensor Variable.\ndim_1 = fluid.layers.fill_constant([1],\"int64\",3)\ndim_2 = fluid.layers.fill_constant([1],\"int32\",5)\nresult_2 = fluid.layers.randint(low=-5, high=5, shape=[dim_1, dim_2], dtype=\"int32\")\n\n# example 3:\n# attr shape is a Variable, the data type must be int64 or int32.\nvar_shape = fluid.data(name='var_shape', shape=[2], dtype=\"int64\")\nresult_3 = fluid.layers.randint(low=-5, high=5, shape=var_shape, dtype=\"int32\")\nvar_shape_int32 = fluid.data(name='var_shape_int32', shape=[2], dtype=\"int32\")\nresult_4 = fluid.layers.randint(low=-5, high=5, shape=var_shape_int32, dtype=\"int64\")\n\n# example 4:\n# Input only one parameter\n# low=0, high=10, shape=[1], dtype='int64'\nresult_4 = fluid.layers.randint(10)",
            "masked_code": "import paddle.fluid as fluid\n\n# example 1:\n# attr shape is a list which doesn't contain tensor Variable.\nresult_1 = fluid.layers.randint(low=-5, high=5, shape=[3, 4], dtype=\"int64\")\n\n# example 2:\n# attr shape is a list which contains tensor Variable.\ndim_1 = fluid.layers.fill_constant([1],\"int64\",3)\ndim_2 = fluid.layers.fill_constant([1],\"int32\",5)\nresult_2 = fluid.layers.randint(low=-5, high=5, shape=[dim_1, dim_2], dtype=\"int32\")\n\n# example 3:\n# attr shape is a Variable, the data type must be int64 or int32.\nvar_shape = fluid.data(name='var_shape', shape=[2], dtype=\"int64\")\n<line_mask>\nvar_shape_int32 = fluid.data(name='var_shape_int32', shape=[2], dtype=\"int32\")\nresult_4 = fluid.layers.randint(low=-5, high=5, shape=var_shape_int32, dtype=\"int64\")\n\n# example 4:\n# Input only one parameter\n# low=0, high=10, shape=[1], dtype='int64'\nresult_4 = fluid.layers.randint(10)",
            "masked_line": "result_3 = fluid.layers.randint(low=-5, high=5, shape=var_shape, dtype=\"int32\")",
            "answer": "randint",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_368"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==1.8.0",
            "time": "2020-04-30",
            "description": "This code compares two arrays of integers element-wise and returns a boolean array indicating whether the elements are equal.",
            "code": "import paddle.fluid as fluid\nimport numpy as np\nlabel = fluid.layers.assign(np.array([3, 3], dtype=\"int32\"))\nlimit = fluid.layers.assign(np.array([3, 2], dtype=\"int32\"))\nout1 = fluid.layers.elementwise_equal(x=label, y=limit) #out1=[True, False]",
            "masked_code": "import paddle.fluid as fluid\nimport numpy as np\nlabel = fluid.layers.assign(np.array([3, 3], dtype=\"int32\"))\nlimit = fluid.layers.assign(np.array([3, 2], dtype=\"int32\"))\n<line_mask>",
            "masked_line": "out1 = fluid.layers.elementwise_equal(x=label, y=limit) #out1=[True, False]",
            "answer": "elementwise_equal",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_369"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==1.8.0",
            "time": "2020-04-30",
            "description": "This code snippet uses the PaddlePaddle library to perform rolling operation on a numpy array. The `roll` function shifts the elements of the input array along the specified dimensions. It demonstrates two examples: \n1. Rolling the elements of the array by 1 shift without specifying dimension.\n2. Rolling the elements of the array by 1 shift along the 0th dimension.",
            "code": "import numpy as np\nimport paddle.fluid as fluid\n\ndata = np.array([[1.0, 2.0, 3.0],\n                 [4.0, 5.0, 6.0],\n                 [7.0, 8.0, 9.0]])\nwith fluid.dygraph.guard():\n    x = fluid.dygraph.to_variable(data)\n    out_z1 = fluid.layers.roll(x, shifts=1)\n    print(out_z1.numpy())\n    #[[9. 1. 2.]\n    # [3. 4. 5.]\n    # [6. 7. 8.]]\n    out_z2 = fluid.layers.roll(x, shifts=1, dims=0)\n    print(out_z2.numpy())\n    #[[7. 8. 9.]\n    # [1. 2. 3.]\n    # [4. 5. 6.]]",
            "masked_code": "import numpy as np\nimport paddle.fluid as fluid\n\ndata = np.array([[1.0, 2.0, 3.0],\n                 [4.0, 5.0, 6.0],\n                 [7.0, 8.0, 9.0]])\nwith fluid.dygraph.guard():\n    x = fluid.dygraph.to_variable(data)\n    out_z1 = fluid.layers.roll(x, shifts=1)\n    print(out_z1.numpy())\n    #[[9. 1. 2.]\n    # [3. 4. 5.]\n    # [6. 7. 8.]]\n    <line_mask>\n    print(out_z2.numpy())\n    #[[7. 8. 9.]\n    # [1. 2. 3.]\n    # [4. 5. 6.]]",
            "masked_line": "out_z2 = fluid.layers.roll(x, shifts=1, dims=0)",
            "answer": "roll",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_370"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==1.8.0",
            "time": "2020-04-30",
            "description": "The code calculates the log softmax function for the input data along the last dimension using the PaddlePaddle framework.",
            "code": "import paddle.fluid as fluid\nimport numpy as np\n\ndata = np.array([[[-2.0, 3.0, -4.0, 5.0],\n                [3.0, -4.0, 5.0, -6.0],\n                [-7.0, -8.0, 8.0, 9.0]],\n               [[1.0, -2.0, -3.0, 4.0],\n                [-5.0, 6.0, 7.0, -8.0],\n                [6.0, 7.0, 8.0, 9.0]]]).astype('float32')\nwith fluid.dygraph.guard():\n    data = fluid.dygraph.to_variable(data)\n    res = fluid.layers.log_softmax(data, -1)",
            "masked_code": "import paddle.fluid as fluid\nimport numpy as np\n\ndata = np.array([[[-2.0, 3.0, -4.0, 5.0],\n                [3.0, -4.0, 5.0, -6.0],\n                [-7.0, -8.0, 8.0, 9.0]],\n               [[1.0, -2.0, -3.0, 4.0],\n                [-5.0, 6.0, 7.0, -8.0],\n                [6.0, 7.0, 8.0, 9.0]]]).astype('float32')\nwith fluid.dygraph.guard():\n    data = fluid.dygraph.to_variable(data)\n    <line_mask>",
            "masked_line": "res = fluid.layers.log_softmax(data, -1)",
            "answer": "log_softmax",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_371"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==1.8.0",
            "time": "2020-04-30",
            "description": "This code creates a neural network model using PaddlePaddle framework that takes an input array of shape [2, 3], fills it with value 2.0 using the full_like function, runs the model on a CPU device, feeds an input array of [[1, 2, 3], [4, 5, 6]] to the model, and retrieves the output array which is filled with 2.0 values. The output is printed as [array([[2., 2., 2.], [2., 2., 2.]], dtype=float32)].",
            "code": "import paddle\nimport paddle.fluid as fluid\nimport numpy as np\ninput = fluid.data(name='input', dtype='float32', shape=[2, 3])\noutput = fluid.layers.full_like(input, 2.0)\nexe = fluid.Executor(fluid.CPUPlace())\nexe.run(fluid.default_startup_program())\nimg=np.array([[1, 2, 3], [4, 5, 6]]).astype(np.float32)\nres = exe.run(fluid.default_main_program(), feed={'input':img}, fetch_list=[output])\nprint(res) # [array([[2., 2., 2.], [2., 2., 2.]], dtype=float32)]",
            "masked_code": "import paddle\nimport paddle.fluid as fluid\nimport numpy as np\ninput = fluid.data(name='input', dtype='float32', shape=[2, 3])\n<line_mask>\nexe = fluid.Executor(fluid.CPUPlace())\nexe.run(fluid.default_startup_program())\nimg=np.array([[1, 2, 3], [4, 5, 6]]).astype(np.float32)\nres = exe.run(fluid.default_main_program(), feed={'input':img}, fetch_list=[output])\nprint(res) # [array([[2., 2., 2.], [2., 2., 2.]], dtype=float32)]",
            "masked_line": "output = fluid.layers.full_like(input, 2.0)",
            "answer": "full_like",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_372"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==1.8.0",
            "time": "2020-04-30",
            "description": "This code creates a sequence of numbers ranging from 0 to 6 with a step size of 2 using the PaddlePaddle library in Python.",
            "code": "import paddle.fluid as fluid\ndata = fluid.layers.arange(0, 10, 2, 'int32')\n\nimport paddle.fluid as fluid\nwith fluid.dygraph.guard():\n    x = fluid.layers.arange(0, 6, 2) \n    # x: [0, 2, 4]\n    # x dtype: float32",
            "masked_code": "import paddle.fluid as fluid\ndata = fluid.layers.arange(0, 10, 2, 'int32')\n\nimport paddle.fluid as fluid\nwith fluid.dygraph.guard():\n    <line_mask>\n    # x: [0, 2, 4]\n    # x dtype: float32",
            "masked_line": "x = fluid.layers.arange(0, 6, 2)",
            "answer": "arange",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_373"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==1.8.0",
            "time": "2020-04-30",
            "description": "This code defines variables with specific shapes and values using the PaddlePaddle library. It creates arrays filled with specific values and data types, such as integers, floats, and booleans, and also demonstrates how to use both constant values and variable tensors to fill the arrays.",
            "code": "import paddle.fluid as fluid\n\ndata1 = fluid.layers.full(shape=[2,1], fill_value=0, dtype='int64') # data1=[[0],[0]]\ndata2 = fluid.layers.full(shape=[2,1], fill_value=5, dtype='int64', device='gpu') # data2=[[5],[5]]\n\n# attr shape is a list which contains Variable Tensor.\npositive_2 = fluid.layers.fill_constant([1], \"int32\", 2)\ndata3 = fluid.layers.full(shape=[1, positive_2], dtype='float32', fill_value=1.5) # data3=[1.5, 1.5]\n\n# attr shape is an Variable Tensor.\nshape = fluid.layers.fill_constant([1,2], \"int32\", 2) # shape=[2,2]\ndata4 = fluid.layers.full(shape=shape, dtype='bool', fill_value=True) # data4=[[True,True],[True,True]]\n\n# attr value is an Variable Tensor.\nval = fluid.layers.fill_constant([1], \"float32\", 2.0) # val=[2.0]\ndata5 = fluid.layers.full(shape=[2,1], fill_value=val, dtype='float32') #data5=[[2.0],[2.0]]",
            "masked_code": "import paddle.fluid as fluid\n\ndata1 = fluid.layers.full(shape=[2,1], fill_value=0, dtype='int64') # data1=[[0],[0]]\ndata2 = fluid.layers.full(shape=[2,1], fill_value=5, dtype='int64', device='gpu') # data2=[[5],[5]]\n\n# attr shape is a list which contains Variable Tensor.\npositive_2 = fluid.layers.fill_constant([1], \"int32\", 2)\ndata3 = fluid.layers.full(shape=[1, positive_2], dtype='float32', fill_value=1.5) # data3=[1.5, 1.5]\n\n# attr shape is an Variable Tensor.\nshape = fluid.layers.fill_constant([1,2], \"int32\", 2) # shape=[2,2]\n<line_mask>\n\n# attr value is an Variable Tensor.\nval = fluid.layers.fill_constant([1], \"float32\", 2.0) # val=[2.0]\ndata5 = fluid.layers.full(shape=[2,1], fill_value=val, dtype='float32') #data5=[[2.0],[2.0]]",
            "masked_line": "data4 = fluid.layers.full(shape=shape, dtype='bool', fill_value=True) # data4=[[True,True],[True,True]]",
            "answer": "full",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_374"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==1.8.0",
            "time": "2020-04-30",
            "description": "The code calculates the lower triangular portion of the input matrix x with different settings for the diagonal elements.",
            "code": "import paddle.fluid as fluid\n\ndata = np.arange(1, 13, dtype=\"int64\").reshape(3,-1)\nx = fluid.data(shape=(-1, 4), dtype='int64', name='x')\nexe = fluid.Executor(fluid.CPUPlace())\n\ntril = fluid.layers.tril(x)\ntril_out, = exe.run(fluid.default_main_program(), feed={\"x\": data},\n    fetch_list=[tril], return_numpy=True)\n\ntril = fluid.layers.tril(x, diagonal=2)\ntril_out, = exe.run(fluid.default_main_program(), feed={\"x\": data},\n    fetch_list=[tril], return_numpy=True)\n\ntril = fluid.layers.tril(x, diagonal=-1)\ntril_out, = exe.run(fluid.default_main_program(), feed={\"x\": data},\n    fetch_list=[tril], return_numpy=True)",
            "masked_code": "import paddle.fluid as fluid\n\ndata = np.arange(1, 13, dtype=\"int64\").reshape(3,-1)\nx = fluid.data(shape=(-1, 4), dtype='int64', name='x')\nexe = fluid.Executor(fluid.CPUPlace())\n\ntril = fluid.layers.tril(x)\ntril_out, = exe.run(fluid.default_main_program(), feed={\"x\": data},\n    fetch_list=[tril], return_numpy=True)\n\ntril = fluid.layers.tril(x, diagonal=2)\ntril_out, = exe.run(fluid.default_main_program(), feed={\"x\": data},\n    fetch_list=[tril], return_numpy=True)\n\n<line_mask>\ntril_out, = exe.run(fluid.default_main_program(), feed={\"x\": data},\n    fetch_list=[tril], return_numpy=True)",
            "masked_line": "tril = fluid.layers.tril(x, diagonal=-1)",
            "answer": "tril",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_375"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==1.8.0",
            "time": "2020-04-30",
            "description": "The code creates an InMemoryDataset using the PaddlePaddle framework, loads data from \"a.txt\" and \"b.txt\" into memory, and preprocesses each instance in the dataset.",
            "code": "import paddle.fluid as fluid\ndataset = fluid.DatasetFactory().create_dataset(\"InMemoryDataset\")\nfilelist = [\"a.txt\", \"b.txt\"]\ndataset.set_filelist(filelist)\ndataset.load_into_memory()\ndataset.preprocess_instance()",
            "masked_code": "import paddle.fluid as fluid\ndataset = fluid.DatasetFactory().create_dataset(\"InMemoryDataset\")\nfilelist = [\"a.txt\", \"b.txt\"]\ndataset.set_filelist(filelist)\ndataset.load_into_memory()\n<line_mask>",
            "masked_line": "dataset.preprocess_instance()",
            "answer": "preprocess_instance",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_377"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==1.8.0",
            "time": "2020-04-30",
            "description": "The code creates an in-memory dataset using PaddlePaddle's fluid framework, loads files \"a.txt\" and \"b.txt\" into memory, and sets the current phase to 1.",
            "code": "import paddle.fluid as fluid\ndataset = fluid.DatasetFactory().create_dataset(\"InMemoryDataset\")\nfilelist = [\"a.txt\", \"b.txt\"]\ndataset.set_filelist(filelist)\ndataset.load_into_memory()\ndataset.set_current_phase(1)",
            "masked_code": "import paddle.fluid as fluid\ndataset = fluid.DatasetFactory().create_dataset(\"InMemoryDataset\")\nfilelist = [\"a.txt\", \"b.txt\"]\ndataset.set_filelist(filelist)\ndataset.load_into_memory()\n<line_mask>",
            "masked_line": "dataset.set_current_phase(1)",
            "answer": "set_current_phase",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_378"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==1.8.0",
            "time": "2020-04-30",
            "description": "This code creates an in-memory dataset using PaddlePaddle, loads data from \"a.txt\" and \"b.txt\" files into memory, preprocesses the instances in the dataset, and then trains a model using the dataset.",
            "code": "import paddle.fluid as fluid\ndataset = fluid.DatasetFactory().create_dataset(\"InMemoryDataset\")\nfilelist = [\"a.txt\", \"b.txt\"]\ndataset.set_filelist(filelist)\ndataset.load_into_memory()\ndataset.preprocess_instance()\nexe.train_from_dataset(dataset)\ndataset.postprocess_instance()",
            "masked_code": "import paddle.fluid as fluid\ndataset = fluid.DatasetFactory().create_dataset(\"InMemoryDataset\")\nfilelist = [\"a.txt\", \"b.txt\"]\ndataset.set_filelist(filelist)\ndataset.load_into_memory()\ndataset.preprocess_instance()\nexe.train_from_dataset(dataset)\n<line_mask>",
            "masked_line": "dataset.postprocess_instance()",
            "answer": "postprocess_instance",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_379"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==1.8.0",
            "time": "2020-04-30",
            "description": "The code sets and prints the random seed value in a PaddlePaddle program. The default random seed is set to 0, but it can be modified using the `global_seed` method to control the randomness of the program's operations.",
            "code": "import paddle.fluid as fluid\nprog = fluid.default_main_program()\nprint(prog.random_seed)\n## 0\n## the default random seed is 0\n\nprog.global_seed(102)\nprog1 = fluid.default_main_program()\nprint(prog1.random_seed)\n## 102\n## the random seed is 102",
            "masked_code": "import paddle.fluid as fluid\nprog = fluid.default_main_program()\nprint(prog.random_seed)\n## 0\n## the default random seed is 0\n\n<line_mask>\nprog1 = fluid.default_main_program()\nprint(prog1.random_seed)\n## 102\n## the random seed is 102",
            "masked_line": "prog.global_seed(102)",
            "answer": "global_seed",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_380"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==1.8.0",
            "time": "2020-04-30",
            "description": "This code creates a list of linear layers with input and output sizes of 10, and inserts another linear layer with the same size into the list at index 3. It then prints whether the layer at index 3 in the list is the same as the newly inserted layer.",
            "code": "import paddle.fluid as fluid\n\nwith fluid.dygraph.guard():\n    linears = fluid.dygraph.LayerList([fluid.dygraph.Linear(10, 10) for i in range(10)])\n    another = fluid.dygraph.Linear(10, 10)\n    linears.insert(3, another)\n    print(linears[3] is another)  # True",
            "masked_code": "import paddle.fluid as fluid\n\nwith fluid.dygraph.guard():\n    linears = fluid.dygraph.LayerList([fluid.dygraph.Linear(10, 10) for i in range(10)])\n    another = fluid.dygraph.Linear(10, 10)\n    <line_mask>\n    print(linears[3] is another)  # True",
            "masked_line": "linears.insert(3, another)",
            "answer": "insert",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_381"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==1.8.0",
            "time": "2020-04-30",
            "description": "The code creates two lists of linear layers, then extends the first list with the elements from the second list. Finally, it prints the length of the merged list and checks if the first element of the second list is the same as the eleventh element of the merged list.",
            "code": "import paddle.fluid as fluid\n\nwith fluid.dygraph.guard():\n    linears = fluid.dygraph.LayerList([fluid.dygraph.Linear(10, 10) for i in range(10)])\n    another_list = fluid.dygraph.LayerList([fluid.dygraph.Linear(10, 10) for i in range(5)])\n    linears.extend(another_list)\n    print(len(linears))  # 15\n    print(another_list[0] is linears[10])  # True",
            "masked_code": "import paddle.fluid as fluid\n\nwith fluid.dygraph.guard():\n    linears = fluid.dygraph.LayerList([fluid.dygraph.Linear(10, 10) for i in range(10)])\n    another_list = fluid.dygraph.LayerList([fluid.dygraph.Linear(10, 10) for i in range(5)])\n    <line_mask>\n    print(len(linears))  # 15\n    print(another_list[0] is linears[10])  # True",
            "masked_line": "linears.extend(another_list)",
            "answer": "extend",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_382"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==1.7.2",
            "time": "2020-04-09",
            "description": "This code defines a function that creates a neural network model using a single fully connected layer to make predictions based on input data with 13 features. It then sets up an inferencer object with the defined inference program and specified parameter path for making predictions on new data using the trained model.",
            "code": "def inference_program():\n    x = fluid.layers.data(name='x', shape=[13], dtype='float32')\n    y_predict = fluid.layers.fc(input=x, size=1, act=None)\n    return y_predict\n\nplace = fluid.CPUPlace()\ninferencer = fluid.Inferencer(\n    infer_func=inference_program, param_path=\"/tmp/model\", place=place)",
            "masked_code": "def inference_program():\n    x = fluid.layers.data(name='x', shape=[13], dtype='float32')\n    y_predict = fluid.layers.fc(input=x, size=1, act=None)\n    return y_predict\n\nplace = fluid.CPUPlace()\n<line_mask>\n    infer_func=inference_program, param_path=\"/tmp/model\", place=place)",
            "masked_line": "inferencer = fluid.Inferencer(",
            "answer": "Inferencer",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_383"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==1.7.2",
            "time": "2020-04-09",
            "description": "This code snippet initializes and loads trainer arguments from a specified checkpoint directory, with provided serial number, trainer ID, and a list of specific trainer arguments.",
            "code": "param_path = \"./checkpoint/\"\nserial = 7\ntrainer_id = 2\ntrainer_args = [\"epoch_id\", \"step_id\"]\n\n_load_trainer_args(checkpoint_dir=param_path, serial=serial,\ntrainer_id=trainer_id, trainer_args=trainer_args)",
            "masked_code": "param_path = \"./checkpoint/\"\nserial = 7\ntrainer_id = 2\ntrainer_args = [\"epoch_id\", \"step_id\"]\n\n<line_mask>\ntrainer_id=trainer_id, trainer_args=trainer_args)",
            "masked_line": "_load_trainer_args(checkpoint_dir=param_path, serial=serial,",
            "answer": "_load_trainer_args",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_384"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==1.8.1",
            "time": "2020-05-15",
            "description": "The code initializes two 2x2 matrices, x with all elements set to 1 and y with all elements set to 0, adds them together element-wise, and then prints the resulting matrix.",
            "code": "import paddle.fluid as fluid\n\nfluid.enable_imperative()  # Now we are in imperative mode\nx = fluid.layers.ones( (2, 2), \"float32\")\ny = fluid.layers.zeros( (2, 2), \"float32\")\nz = x + y\nprint( z.numpy() )   #[[1, 1], [1, 1]]",
            "masked_code": "import paddle.fluid as fluid\n\n<line_mask>\nx = fluid.layers.ones( (2, 2), \"float32\")\ny = fluid.layers.zeros( (2, 2), \"float32\")\nz = x + y\nprint( z.numpy() )   #[[1, 1], [1, 1]]",
            "masked_line": "fluid.enable_imperative()  # Now we are in imperative mode",
            "answer": "enable_imperative",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_385"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==1.8.1",
            "time": "2020-05-15",
            "description": "The code initializes two 2x2 matrices with ones and zeros, adds them together element-wise, and prints the result in the form of a numpy array.",
            "code": "import paddle.fluid as fluid\n\nfluid.enable_imperative()  # Now we are in imperative mode\nx = fluid.layers.ones( (2, 2), \"float32\")\ny = fluid.layers.zeros( (2, 2), \"float32\")\nz = x + y\nprint( z.numpy() )   #[[1, 1], [1, 1]]\nfluid.disable_imperative() # Now we are in declarative mode",
            "masked_code": "import paddle.fluid as fluid\n\nfluid.enable_imperative()  # Now we are in imperative mode\nx = fluid.layers.ones( (2, 2), \"float32\")\ny = fluid.layers.zeros( (2, 2), \"float32\")\nz = x + y\nprint( z.numpy() )   #[[1, 1], [1, 1]]\n<line_mask>",
            "masked_line": "fluid.disable_imperative() # Now we are in declarative mode",
            "answer": "disable_imperative",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_386"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==1.8.3",
            "time": "2020-07-13",
            "description": "The code adjusts the brightness of a randomly generated image with shape (500, 500, 3) by applying a brightness transformation with a factor of 0.4.",
            "code": "import numpy as np\nfrom paddle.incubate.hapi.vision.transforms import BrightnessTransform\ntransform = BrightnessTransform(0.4)\nfake_img = np.random.rand(500, 500, 3).astype('float32')\nfake_img = transform(fake_img)\nprint(fake_img.shape)",
            "masked_code": "import numpy as np\nfrom paddle.incubate.hapi.vision.transforms import BrightnessTransform\n<line_mask>\nfake_img = np.random.rand(500, 500, 3).astype('float32')\nfake_img = transform(fake_img)\nprint(fake_img.shape)",
            "masked_line": "transform = BrightnessTransform(0.4)",
            "answer": "BrightnessTransform",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_387"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==1.8.3",
            "time": "2020-07-13",
            "description": "The code generates a random image with size 500x500x3, and applies a contrast transformation with a factor of 0.4 to the image. It then prints the shape of the transformed image.",
            "code": "import numpy as np\nfrom paddle.incubate.hapi.vision.transforms import ContrastTransform\ntransform = ContrastTransform(0.4)\nfake_img = np.random.rand(500, 500, 3).astype('float32')\nfake_img = transform(fake_img)\nprint(fake_img.shape)",
            "masked_code": "import numpy as np\n<line_mask>\ntransform = ContrastTransform(0.4)\nfake_img = np.random.rand(500, 500, 3).astype('float32')\nfake_img = transform(fake_img)\nprint(fake_img.shape)",
            "masked_line": "from paddle.incubate.hapi.vision.transforms import ContrastTransform",
            "answer": "ContrastTransform",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_388"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==1.8.3",
            "time": "2020-07-13",
            "description": "The code applies a saturation transformation with a factor of 0.4 to a randomly generated RGB image with dimensions 500x500.",
            "code": "import numpy as np\nfrom paddle.incubate.hapi.vision.transforms import SaturationTransform\ntransform = SaturationTransform(0.4)\nfake_img = np.random.rand(500, 500, 3).astype('float32')\n\nfake_img = transform(fake_img)\nprint(fake_img.shape)",
            "masked_code": "import numpy as np\n<line_mask>\ntransform = SaturationTransform(0.4)\nfake_img = np.random.rand(500, 500, 3).astype('float32')\n\nfake_img = transform(fake_img)\nprint(fake_img.shape)",
            "masked_line": "from paddle.incubate.hapi.vision.transforms import SaturationTransform",
            "answer": "SaturationTransform",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_389"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==1.8.3",
            "time": "2020-07-13",
            "description": "The code applies a hue transformation with a value of 0.4 to a randomly generated image with dimensions 500x500x3, and then prints the shape of the transformed image.",
            "code": "import numpy as np\nfrom paddle.incubate.hapi.vision.transforms import HueTransform\ntransform = HueTransform(0.4)\nfake_img = np.random.rand(500, 500, 3).astype('float32')\nfake_img = transform(fake_img)\nprint(fake_img.shape)",
            "masked_code": "import numpy as np\nfrom paddle.incubate.hapi.vision.transforms import HueTransform\n<line_mask>\nfake_img = np.random.rand(500, 500, 3).astype('float32')\nfake_img = transform(fake_img)\nprint(fake_img.shape)",
            "masked_line": "transform = HueTransform(0.4)",
            "answer": "HueTransform",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_390"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==1.8.3",
            "time": "2020-07-13",
            "description": "The code applies color jitter transformation to a randomly generated image with 3 channels, resulting in an image shape of (500, 500, 3).",
            "code": "import numpy as np\nfrom paddle.incubate.hapi.vision.transforms import ColorJitter\ntransform = ColorJitter(0.4)\nfake_img = np.random.rand(500, 500, 3).astype('float32')\nfake_img = transform(fake_img)\nprint(fake_img.shape)",
            "masked_code": "import numpy as np\n<line_mask>\ntransform = ColorJitter(0.4)\nfake_img = np.random.rand(500, 500, 3).astype('float32')\nfake_img = transform(fake_img)\nprint(fake_img.shape)",
            "masked_line": "from paddle.incubate.hapi.vision.transforms import ColorJitter",
            "answer": "ColorJitter",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_391"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==1.8.3",
            "time": "2020-07-13",
            "description": "This code defines a Mish activation function using the PaddlePaddle framework. The input data 'x_data' is created as a numpy array and reshaped. Then, the Mish activation function is applied to the input data 'x'. The code sets up the execution environment, runs the computation using a CPU or a CUDA place, and finally prints the output after running the computation.",
            "code": "import paddle.fluid as fluid\nimport numpy as np\n\nDATATYPE='float32'\n\nx_data = np.array([i for i in range(1,5)]).reshape([1,1,4]).astype(DATATYPE)\n\nx = fluid.data(name=\"x\", shape=[None,1,4], dtype=DATATYPE)\ny = fluid.layers.mish(x)\n\nplace = fluid.CPUPlace()\n# place = fluid.CUDAPlace(0)\nexe = fluid.Executor(place)\nout, = exe.run(feed={'x':x_data}, fetch_list=[y.name])\nprint(out)  # [[0.66666667, 1.66666667, 3., 4.]]\n",
            "masked_code": "import paddle.fluid as fluid\nimport numpy as np\n\nDATATYPE='float32'\n\nx_data = np.array([i for i in range(1,5)]).reshape([1,1,4]).astype(DATATYPE)\n\nx = fluid.data(name=\"x\", shape=[None,1,4], dtype=DATATYPE)\n<line_mask>\n\nplace = fluid.CPUPlace()\n# place = fluid.CUDAPlace(0)\nexe = fluid.Executor(place)\nout, = exe.run(feed={'x':x_data}, fetch_list=[y.name])\nprint(out)  # [[0.66666667, 1.66666667, 3., 4.]]\n",
            "masked_line": "y = fluid.layers.mish(x)",
            "answer": "mish",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_392"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==2.0.0",
            "time": "2021-01-21",
            "description": "The code initializes a user-defined role maker for distributed training in a worker role. It sets specific worker and server endpoints for communication and then initializes the fleet. It also uses fleet utility functions to get file shards for files \"file1\", \"file2\", and \"file3\", and prints the result.",
            "code": "import paddle.distributed.fleet as fleet\nfrom paddle.distributed.fleet import UserDefinedRoleMaker\n\nrole = UserDefinedRoleMaker(\n    is_collective=False,\n    init_gloo=False,\n    current_id=0,\n    role=fleet.Role.WORKER,\n    worker_endpoints=[\"127.0.0.1:6003\", \"127.0.0.1:6004\"],\n    server_endpoints=[\"127.0.0.1:6001\", \"127.0.0.1:6002\"])\nfleet.init(role)\n\nfiles = fleet.util.get_file_shard([\"file1\", \"file2\", \"file3\"])\nprint(files)",
            "masked_code": "import paddle.distributed.fleet as fleet\nfrom paddle.distributed.fleet import UserDefinedRoleMaker\n\nrole = UserDefinedRoleMaker(\n    is_collective=False,\n    init_gloo=False,\n    current_id=0,\n    role=fleet.Role.WORKER,\n    worker_endpoints=[\"127.0.0.1:6003\", \"127.0.0.1:6004\"],\n    server_endpoints=[\"127.0.0.1:6001\", \"127.0.0.1:6002\"])\nfleet.init(role)\n\n<line_mask>\nprint(files)",
            "masked_line": "files = fleet.util.get_file_shard([\"file1\", \"file2\", \"file3\"])",
            "answer": "get_file_shard",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_393"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==2.0.0",
            "time": "2021-01-21",
            "description": "The code initializes a role for a worker in a distributed training setup using PaddlePaddle. It sets up the worker with specific endpoints for communication and prints a message indicating it is worker 0.",
            "code": "import paddle.distributed.fleet as fleet\nfrom paddle.distributed.fleet import UserDefinedRoleMaker\n\nrole = UserDefinedRoleMaker(\n    is_collective=False,\n    init_gloo=False,\n    current_id=0,\n    role=fleet.Role.WORKER,\n    worker_endpoints=[\"127.0.0.1:6003\", \"127.0.0.1:6004\"],\n    server_endpoints=[\"127.0.0.1:6001\", \"127.0.0.1:6002\"])\nfleet.init(role)\n\nfleet.util.print_on_rank(\"I'm worker 0\", 0)",
            "masked_code": "import paddle.distributed.fleet as fleet\nfrom paddle.distributed.fleet import UserDefinedRoleMaker\n\nrole = UserDefinedRoleMaker(\n    is_collective=False,\n    init_gloo=False,\n    current_id=0,\n    role=fleet.Role.WORKER,\n    worker_endpoints=[\"127.0.0.1:6003\", \"127.0.0.1:6004\"],\n    server_endpoints=[\"127.0.0.1:6001\", \"127.0.0.1:6002\"])\nfleet.init(role)\n\n<line_mask>",
            "masked_line": "fleet.util.print_on_rank(\"I'm worker 0\", 0)",
            "answer": "print_on_rank",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_394"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==2.0.0",
            "time": "2021-01-21",
            "description": "This code creates a LocalFS client object, creates a file named \"test_is_file\" using the touch method, checks if the file exists using the is_file method and prints True, and finally deletes the file using the delete method.",
            "code": "from paddle.distributed.fleet.utils import LocalFS\nclient = LocalFS()\nclient.touch(\"test_is_file\")\nprint(client.is_file(\"test_is_file\")) # True\nclient.delete(\"test_is_file\")",
            "masked_code": "from paddle.distributed.fleet.utils import LocalFS\nclient = LocalFS()\nclient.touch(\"test_is_file\")\n<line_mask>\nclient.delete(\"test_is_file\")",
            "masked_line": "print(client.is_file(\"test_is_file\")) # True",
            "answer": "is_file",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_395"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==2.0.0",
            "time": "2021-01-21",
            "description": "The code creates a LocalFS client object, creates a directory named \"test_is_dir\" using the client object, checks if \"test_is_file\" is a directory (returns True), and then deletes the \"test_is_dir\" directory.",
            "code": "from paddle.distributed.fleet.utils import LocalFS\nclient = LocalFS()\nclient.mkdirs(\"test_is_dir\")\nprint(client.is_dir(\"test_is_file\")) # True\nclient.delete(\"test_is_dir\")",
            "masked_code": "from paddle.distributed.fleet.utils import LocalFS\nclient = LocalFS()\nclient.mkdirs(\"test_is_dir\")\n<line_mask>\nclient.delete(\"test_is_dir\")",
            "masked_line": "print(client.is_dir(\"test_is_file\")) # True",
            "answer": "is_dir",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_396"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==2.0.0",
            "time": "2021-01-21",
            "description": "The code creates a LocalFS client, creates a file named \"test_mv_src\", moves the file \"test_mv_src\" to \"test_mv_dst\", and then deletes the file \"test_mv_dst\".",
            "code": "from paddle.distributed.fleet.utils import LocalFS\nclient = LocalFS()\nclient.touch(\"test_mv_src\")\nclient.mv(\"test_mv_src\", \"test_mv_dst\")\nclient.delete(\"test_mv_dst\")",
            "masked_code": "from paddle.distributed.fleet.utils import LocalFS\nclient = LocalFS()\nclient.touch(\"test_mv_src\")\n<line_mask>\nclient.delete(\"test_mv_dst\")",
            "masked_line": "client.mv(\"test_mv_src\", \"test_mv_dst\")",
            "answer": "mv",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_397"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==2.0.0",
            "time": "2021-01-21",
            "description": "The code calculates the forward pass of a linear neural network on a randomly generated input data, computes the mean loss of the output, and performs backward propagation to update the network parameters using the SGD optimizer with gradient clipping by value.",
            "code": "import paddle\n\nx = paddle.uniform([10, 10], min=-1.0, max=1.0, dtype='float32')\nlinear = paddle.nn.Linear(in_features=10, out_features=10, \n                          weight_attr=paddle.ParamAttr(need_clip=True), \n                          bias_attr=paddle.ParamAttr(need_clip=False))\nout = linear(x)\nloss = paddle.mean(out)\nloss.backward()\n\nclip = paddle.nn.ClipGradByValue(min=-1, max=1)\nsdg = paddle.optimizer.SGD(learning_rate=0.1, parameters=linear.parameters(), grad_clip=clip)\nsdg.step()",
            "masked_code": "import paddle\n\nx = paddle.uniform([10, 10], min=-1.0, max=1.0, dtype='float32')\nlinear = paddle.nn.Linear(in_features=10, out_features=10, \n                          weight_attr=paddle.ParamAttr(need_clip=True), \n                          bias_attr=paddle.ParamAttr(need_clip=False))\nout = linear(x)\nloss = paddle.mean(out)\nloss.backward()\n\n<line_mask>\nsdg = paddle.optimizer.SGD(learning_rate=0.1, parameters=linear.parameters(), grad_clip=clip)\nsdg.step()",
            "masked_line": "clip = paddle.nn.ClipGradByValue(min=-1, max=1)",
            "answer": "ClipGradByValue",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_398"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==2.0.0",
            "time": "2021-01-21",
            "description": "This code snippet generates random data, passes it through a linear neural network, calculates the mean loss, performs backpropagation to update the model weights, clips the gradients for better training stability, and then performs a single step of optimization using the SGD optimizer.",
            "code": "import paddle\n\nx = paddle.uniform([10, 10], min=-1.0, max=1.0, dtype='float32')\nlinear = paddle.nn.Linear(in_features=10, out_features=10, \n                          weight_attr=paddle.ParamAttr(need_clip=True), \n                          bias_attr=paddle.ParamAttr(need_clip=False))\nout = linear(x)\nloss = paddle.mean(out)\nloss.backward()\n\nclip = paddle.nn.ClipGradByNorm(clip_norm=1.0)\nsdg = paddle.optimizer.SGD(learning_rate=0.1, parameters=linear.parameters(), grad_clip=clip)\nsdg.step()",
            "masked_code": "import paddle\n\nx = paddle.uniform([10, 10], min=-1.0, max=1.0, dtype='float32')\nlinear = paddle.nn.Linear(in_features=10, out_features=10, \n                          weight_attr=paddle.ParamAttr(need_clip=True), \n                          bias_attr=paddle.ParamAttr(need_clip=False))\nout = linear(x)\nloss = paddle.mean(out)\nloss.backward()\n\n<line_mask>\nsdg = paddle.optimizer.SGD(learning_rate=0.1, parameters=linear.parameters(), grad_clip=clip)\nsdg.step()",
            "masked_line": "clip = paddle.nn.ClipGradByNorm(clip_norm=1.0)",
            "answer": "ClipGradByNorm",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_399"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==2.0.0",
            "time": "2021-01-21",
            "description": "This code snippet creates a linear neural network model using PaddlePaddle, trains it using stochastic gradient descent (SGD) optimizer with clipping of gradients by global norm to prevent exploding gradients, and updates the model parameters based on the computed gradients.",
            "code": "import paddle\n\nx = paddle.uniform([10, 10], min=-1.0, max=1.0, dtype='float32')\nlinear = paddle.nn.Linear(in_features=10, out_features=10, \n                          weight_attr=paddle.ParamAttr(need_clip=True), \n                          bias_attr=paddle.ParamAttr(need_clip=False))\nout = linear(x)\nloss = paddle.mean(out)\nloss.backward()\n\nclip = paddle.nn.ClipGradByGlobalNorm(clip_norm=1.0)\nsdg = paddle.optimizer.SGD(learning_rate=0.1, parameters=linear.parameters(), grad_clip=clip)\nsdg.step()",
            "masked_code": "import paddle\n\nx = paddle.uniform([10, 10], min=-1.0, max=1.0, dtype='float32')\nlinear = paddle.nn.Linear(in_features=10, out_features=10, \n                          weight_attr=paddle.ParamAttr(need_clip=True), \n                          bias_attr=paddle.ParamAttr(need_clip=False))\nout = linear(x)\nloss = paddle.mean(out)\nloss.backward()\n\n<line_mask>\nsdg = paddle.optimizer.SGD(learning_rate=0.1, parameters=linear.parameters(), grad_clip=clip)\nsdg.step()",
            "masked_line": "clip = paddle.nn.ClipGradByGlobalNorm(clip_norm=1.0)",
            "answer": "ClipGradByGlobalNorm",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_400"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==2.0.0",
            "time": "2021-01-21",
            "description": "The code flattens a multi-dimensional NumPy array into a 2D tensor starting from axis 1 and stopping at axis 2.",
            "code": "import paddle\nimport numpy as np\n\ninp_np = np.ones([5, 2, 3, 4]).astype('float32')\ninp_np = paddle.to_tensor(inp_np)\nflatten = paddle.nn.Flatten(start_axis=1, stop_axis=2)\nflatten_res = flatten(inp_np)",
            "masked_code": "import paddle\nimport numpy as np\n\ninp_np = np.ones([5, 2, 3, 4]).astype('float32')\ninp_np = paddle.to_tensor(inp_np)\n<line_mask>\nflatten_res = flatten(inp_np)",
            "masked_line": "flatten = paddle.nn.Flatten(start_axis=1, stop_axis=2)",
            "answer": "Flatten",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_401"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==2.1.0",
            "time": "2021-05-13",
            "description": "The code generates a random tensor of shape (100, 3, 224, 224) using PaddlePaddle and then applies the Unfold operation with kernel size=[3, 3]. It returns the unfolded tensor.",
            "code": "import paddle\nimport paddle.nn as nn\n\nx = paddle.randn((100,3,224,224))\nunfold = nn.Unfold(kernel_sizes=[3, 3])\nresult = unfold(x)\nprint(result)",
            "masked_code": "import paddle\nimport paddle.nn as nn\n\nx = paddle.randn((100,3,224,224))\n<line_mask>\nresult = unfold(x)\nprint(result)",
            "masked_line": "unfold = nn.Unfold(kernel_sizes=[3, 3])",
            "answer": "Unfold",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_402"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==2.1.0",
            "time": "2021-05-13",
            "description": "This code creates a dictionary of different types of convolutional layers using PaddlePaddle framework and initializes a LayerDict with these layers. It then demonstrates clearing the LayerDict and checking its length.",
            "code": "import paddle\nfrom collections import OrderedDict\n\nsublayers = OrderedDict([\n    ('conv1d', paddle.nn.Conv1D(3, 2, 3)),\n    ('conv2d', paddle.nn.Conv2D(3, 2, 3)),\n    ('conv3d', paddle.nn.Conv3D(4, 6, (3, 3, 3))),\n])\n\nlayer_dict = paddle.nn.LayerDict(sublayers=sublayers)\nlen(layer_dict)\n#3\n\nlayer_dict.clear()\nlen(layer_dict)\n#0",
            "masked_code": "import paddle\nfrom collections import OrderedDict\n\nsublayers = OrderedDict([\n    ('conv1d', paddle.nn.Conv1D(3, 2, 3)),\n    ('conv2d', paddle.nn.Conv2D(3, 2, 3)),\n    ('conv3d', paddle.nn.Conv3D(4, 6, (3, 3, 3))),\n])\n\nlayer_dict = paddle.nn.LayerDict(sublayers=sublayers)\nlen(layer_dict)\n#3\n\n<line_mask>\nlen(layer_dict)\n#0",
            "masked_line": "layer_dict.clear()",
            "answer": "clear",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_403"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==2.1.0",
            "time": "2021-05-13",
            "description": "This code creates a dictionary of different convolutional layers using PaddlePaddle's nn module. It then creates a LayerDict using the sublayers dictionary. The code then shows the length of the layer_dict which is 3. It then removes the 'conv2d' key from the layer_dict and shows the updated length, which is 2.",
            "code": "import paddle\nfrom collections import OrderedDict\n\nsublayers = OrderedDict([\n    ('conv1d', paddle.nn.Conv1D(3, 2, 3)),\n    ('conv2d', paddle.nn.Conv2D(3, 2, 3)),\n    ('conv3d', paddle.nn.Conv3D(4, 6, (3, 3, 3))),\n])\n\nlayer_dict = paddle.nn.LayerDict(sublayers=sublayers)\nlen(layer_dict)\n#3\n\nlayer_dict.pop('conv2d')\nlen(layer_dict)\n#2",
            "masked_code": "import paddle\nfrom collections import OrderedDict\n\nsublayers = OrderedDict([\n    ('conv1d', paddle.nn.Conv1D(3, 2, 3)),\n    ('conv2d', paddle.nn.Conv2D(3, 2, 3)),\n    ('conv3d', paddle.nn.Conv3D(4, 6, (3, 3, 3))),\n])\n\nlayer_dict = paddle.nn.LayerDict(sublayers=sublayers)\nlen(layer_dict)\n#3\n\n<line_mask>\nlen(layer_dict)\n#2",
            "masked_line": "layer_dict.pop('conv2d')",
            "answer": "pop",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_404"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==2.1.0",
            "time": "2021-05-13",
            "description": "The code creates a dictionary of convolutional layers using different dimensions (1D, 2D, and 3D) and then prints the keys of the layer dictionary.",
            "code": "import paddle\nfrom collections import OrderedDict\n\nsublayers = OrderedDict([\n    ('conv1d', paddle.nn.Conv1D(3, 2, 3)),\n    ('conv2d', paddle.nn.Conv2D(3, 2, 3)),\n    ('conv3d', paddle.nn.Conv3D(4, 6, (3, 3, 3))),\n])\n\nlayer_dict = paddle.nn.LayerDict(sublayers=sublayers)\nfor k in layer_dict.keys():\n    print(k)",
            "masked_code": "import paddle\nfrom collections import OrderedDict\n\nsublayers = OrderedDict([\n    ('conv1d', paddle.nn.Conv1D(3, 2, 3)),\n    ('conv2d', paddle.nn.Conv2D(3, 2, 3)),\n    ('conv3d', paddle.nn.Conv3D(4, 6, (3, 3, 3))),\n])\n\nlayer_dict = paddle.nn.LayerDict(sublayers=sublayers)\n<line_mask>\n    print(k)",
            "masked_line": "for k in layer_dict.keys():",
            "answer": "keys",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_405"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==2.1.0",
            "time": "2021-05-13",
            "description": "This code defines a dictionary of convolutional layers using PaddlePaddle framework. The keys in the dictionary represent the type of convolutional layer (1D, 2D, or 3D) and the corresponding values are instances of the respective convolutional layer classes with specified parameters such as input channels, output channels, and kernel size. Finally, it prints out the key-value pairs of the layer names and their corresponding convolutional layer objects.",
            "code": "import paddle\nfrom collections import OrderedDict\n\nsublayers = OrderedDict([\n    ('conv1d', paddle.nn.Conv1D(3, 2, 3)),\n    ('conv2d', paddle.nn.Conv2D(3, 2, 3)),\n    ('conv3d', paddle.nn.Conv3D(4, 6, (3, 3, 3))),\n])\n\nlayer_dict = paddle.nn.LayerDict(sublayers=sublayers)\nfor k, v in layer_dict.items():\n    print(k, \":\", v)\n\n#conv1d : Conv1D(3, 2, kernel_size=[3], data_format=NCL)\n#conv2d : Conv2D(3, 2, kernel_size=[3, 3], data_format=NCHW)\n#conv3d : Conv3D(4, 6, kernel_size=[3, 3, 3], data_format=NCDHW)",
            "masked_code": "import paddle\nfrom collections import OrderedDict\n\nsublayers = OrderedDict([\n    ('conv1d', paddle.nn.Conv1D(3, 2, 3)),\n    ('conv2d', paddle.nn.Conv2D(3, 2, 3)),\n    ('conv3d', paddle.nn.Conv3D(4, 6, (3, 3, 3))),\n])\n\nlayer_dict = paddle.nn.LayerDict(sublayers=sublayers)\n<line_mask>\n    print(k, \":\", v)\n\n#conv1d : Conv1D(3, 2, kernel_size=[3], data_format=NCL)\n#conv2d : Conv2D(3, 2, kernel_size=[3, 3], data_format=NCHW)\n#conv3d : Conv3D(4, 6, kernel_size=[3, 3, 3], data_format=NCDHW)",
            "masked_line": "for k, v in layer_dict.items():",
            "answer": "items",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_406"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==2.1.0",
            "time": "2021-05-13",
            "description": "This code defines a dictionary of convolutional layers with different dimensions and kernel sizes using the PaddlePaddle library. It then creates a LayerDict object using the dictionary of layers. Finally, it prints out the details of each convolutional layer including the type (Conv1D, Conv2D, Conv3D), number of input and output channels, kernel size, and data format.",
            "code": "import paddle\nfrom collections import OrderedDict\n\nsublayers = OrderedDict([\n    ('conv1d', paddle.nn.Conv1D(3, 2, 3)),\n    ('conv2d', paddle.nn.Conv2D(3, 2, 3)),\n    ('conv3d', paddle.nn.Conv3D(4, 6, (3, 3, 3))),\n])\n\nlayer_dict = paddle.nn.LayerDict(sublayers=sublayers)\nfor v in layer_dict.values():\n    print(v)\n\n#Conv1D(3, 2, kernel_size=[3], data_format=NCL)\n#Conv2D(3, 2, kernel_size=[3, 3], data_format=NCHW)\n#Conv3D(4, 6, kernel_size=[3, 3, 3], data_format=NCDHW)",
            "masked_code": "import paddle\nfrom collections import OrderedDict\n\nsublayers = OrderedDict([\n    ('conv1d', paddle.nn.Conv1D(3, 2, 3)),\n    ('conv2d', paddle.nn.Conv2D(3, 2, 3)),\n    ('conv3d', paddle.nn.Conv3D(4, 6, (3, 3, 3))),\n])\n\nlayer_dict = paddle.nn.LayerDict(sublayers=sublayers)\n<line_mask>\n    print(v)\n\n#Conv1D(3, 2, kernel_size=[3], data_format=NCL)\n#Conv2D(3, 2, kernel_size=[3, 3], data_format=NCHW)\n#Conv3D(4, 6, kernel_size=[3, 3, 3], data_format=NCDHW)",
            "masked_line": "for v in layer_dict.values():",
            "answer": "values",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_407"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==2.1.0",
            "time": "2021-05-13",
            "description": "This code creates and updates a dictionary of layers in a neural network model using the PaddlePaddle framework. The code includes layers such as Conv1D, Conv2D, Conv3D, and ReLU, and prints out the key-value pairs in the updated dictionary.",
            "code": "import paddle\nfrom collections import OrderedDict\n\nsublayers = OrderedDict([\n    ('conv1d', paddle.nn.Conv1D(3, 2, 3)),\n    ('conv2d', paddle.nn.Conv2D(3, 2, 3)),\n    ('conv3d', paddle.nn.Conv3D(4, 6, (3, 3, 3))),\n])\n\nnew_sublayers = OrderedDict([\n    ('relu', paddle.nn.ReLU()),\n    ('conv2d', paddle.nn.Conv2D(4, 2, 4)),\n])\nlayer_dict = paddle.nn.LayerDict(sublayers=sublayers)\n\nlayer_dict.update(new_sublayers)\n\nfor k, v in layer_dict.items():\n    print(k, \":\", v)\n#conv1d : Conv1D(3, 2, kernel_size=[3], data_format=NCL)\n#conv2d : Conv2D(4, 2, kernel_size=[4, 4], data_format=NCHW)\n#conv3d : Conv3D(4, 6, kernel_size=[3, 3, 3], data_format=NCDHW)\n#relu : ReLU()",
            "masked_code": "import paddle\nfrom collections import OrderedDict\n\nsublayers = OrderedDict([\n    ('conv1d', paddle.nn.Conv1D(3, 2, 3)),\n    ('conv2d', paddle.nn.Conv2D(3, 2, 3)),\n    ('conv3d', paddle.nn.Conv3D(4, 6, (3, 3, 3))),\n])\n\nnew_sublayers = OrderedDict([\n    ('relu', paddle.nn.ReLU()),\n    ('conv2d', paddle.nn.Conv2D(4, 2, 4)),\n])\nlayer_dict = paddle.nn.LayerDict(sublayers=sublayers)\n\n<line_mask>\n\nfor k, v in layer_dict.items():\n    print(k, \":\", v)\n#conv1d : Conv1D(3, 2, kernel_size=[3], data_format=NCL)\n#conv2d : Conv2D(4, 2, kernel_size=[4, 4], data_format=NCHW)\n#conv3d : Conv3D(4, 6, kernel_size=[3, 3, 3], data_format=NCDHW)\n#relu : ReLU()",
            "masked_line": "layer_dict.update(new_sublayers)",
            "answer": "update",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_408"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==2.1.0",
            "time": "2021-05-13",
            "description": "The code initializes a parallel environment using the `paddle.distributed` module, generates a random tensor of shape [2, 3], creates a new process group consisting of ranks 2, 4, and 6, and performs an all-reduce operation on the `tindata` tensor using the created process group.",
            "code": "import paddle\npaddle.distributed.init_parallel_env()\ntindata = paddle.randn(shape=[2, 3])\ngp = paddle.distributed.new_group([2,4,6])\npaddle.distributed.all_reduce(tindata, group=gp, use_calc_stream=False)",
            "masked_code": "import paddle\npaddle.distributed.init_parallel_env()\ntindata = paddle.randn(shape=[2, 3])\n<line_mask>\npaddle.distributed.all_reduce(tindata, group=gp, use_calc_stream=False)",
            "masked_line": "gp = paddle.distributed.new_group([2,4,6])",
            "answer": "new_group",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_409"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==2.1.0",
            "time": "2021-05-13",
            "description": "The code initializes a parallel environment using PaddlePaddle, generates a 2x3 tensor filled with random numbers, performs an all_reduce operation on the tensor across all parallel processes, and waits for the operation to complete.",
            "code": "import paddle\n\npaddle.distributed.init_parallel_env()\ntindata = paddle.randn(shape=[2, 3])\npaddle.distributed.all_reduce(tindata, use_calc_stream=True)\npaddle.distributed.wait(tindata)",
            "masked_code": "import paddle\n\npaddle.distributed.init_parallel_env()\ntindata = paddle.randn(shape=[2, 3])\npaddle.distributed.all_reduce(tindata, use_calc_stream=True)\n<line_mask>",
            "masked_line": "paddle.distributed.wait(tindata)",
            "answer": "wait",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_410"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==2.1.0",
            "time": "2021-05-13",
            "description": "This code enables distributed computing using the PaddlePaddle framework. It initializes the parallel environment, then sends data from rank 0 to rank 1, while receiving data at other ranks. Finally, it converts the data to a numpy array.",
            "code": "import paddle\nfrom paddle.distributed import init_parallel_env\ninit_parallel_env()\nif paddle.distributed.ParallelEnv().rank == 0:\n    data = paddle.to_tensor([7, 8, 9])\n    paddle.distributed.send(data, dst=1)\nelse:\n    data = paddle.to_tensor([1,2,3])\n    paddle.distributed.recv(data, src=0)\nout = data.numpy()",
            "masked_code": "import paddle\nfrom paddle.distributed import init_parallel_env\ninit_parallel_env()\nif paddle.distributed.ParallelEnv().rank == 0:\n    data = paddle.to_tensor([7, 8, 9])\n    <line_mask>\nelse:\n    data = paddle.to_tensor([1,2,3])\n    paddle.distributed.recv(data, src=0)\nout = data.numpy()",
            "masked_line": "paddle.distributed.send(data, dst=1)",
            "answer": "send",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_411"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==2.1.0",
            "time": "2021-05-13",
            "description": "The code sends and receives data between parallel processes using PaddlePaddle. If the rank of the current process is 0, it sends a tensor [7, 8, 9] to process 1. If the rank is not 0, it receives a tensor from process 0 and stores it in a variable. Finally, it converts the received tensor to a numpy array and stores it in the variable 'out'.",
            "code": "import paddle\nfrom paddle.distributed import init_parallel_env\ninit_parallel_env()\nif paddle.distributed.ParallelEnv().rank == 0:\n    data = paddle.to_tensor([7, 8, 9])\n    paddle.distributed.send(data, dst=1)\nelse:\n    data = paddle.to_tensor([1,2,3])\n    paddle.distributed.recv(data, src=0)\nout = data.numpy()",
            "masked_code": "import paddle\nfrom paddle.distributed import init_parallel_env\ninit_parallel_env()\nif paddle.distributed.ParallelEnv().rank == 0:\n    data = paddle.to_tensor([7, 8, 9])\n    paddle.distributed.send(data, dst=1)\nelse:\n    data = paddle.to_tensor([1,2,3])\n    <line_mask>\nout = data.numpy()",
            "masked_line": "paddle.distributed.recv(data, src=0)",
            "answer": "recv",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_412"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==2.1.0",
            "time": "2021-05-13",
            "description": "This code performs convolutional neural network operations on input data using paddle library in Python. It includes convolution, batch normalization, ReLU activation, max pooling, fully connected layer, and mean loss calculation.",
            "code": "import paddle\nimport paddle.nn.functional as F\npaddle.enable_static()\ndata = paddle.static.data(name='X', shape=[None, 1, 28, 28], dtype='float32')\nconv2d = paddle.static.nn.conv2d(input=data, num_filters=6, filter_size=3)\n\nwith paddle.static.amp.bf16_guard():\n    bn = paddle.static.nn.batch_norm(input=conv2d, act=\"relu\")\n    pool = F.max_pool2d(bn, kernel_size=2, stride=2)\n    hidden = paddle.static.nn.fc(pool, size=10)\n    loss = paddle.mean(hidden)",
            "masked_code": "import paddle\nimport paddle.nn.functional as F\npaddle.enable_static()\ndata = paddle.static.data(name='X', shape=[None, 1, 28, 28], dtype='float32')\nconv2d = paddle.static.nn.conv2d(input=data, num_filters=6, filter_size=3)\n\n<line_mask>\n    bn = paddle.static.nn.batch_norm(input=conv2d, act=\"relu\")\n    pool = F.max_pool2d(bn, kernel_size=2, stride=2)\n    hidden = paddle.static.nn.fc(pool, size=10)\n    loss = paddle.mean(hidden)",
            "masked_line": "with paddle.static.amp.bf16_guard():",
            "answer": "bf16_guard",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_413"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==2.1.0",
            "time": "2021-05-13",
            "description": "The code generates a random image with dimensions 400x300x3, saves it as 'fake.jpg', reads the image file, decodes it using jpeg format, and prints the shape of the decoded image.",
            "code": "import cv2\nimport paddle\n\nfake_img = (np.random.random(\n            (400, 300, 3)) * 255).astype('uint8')\n\ncv2.imwrite('fake.jpg', fake_img)\n\nimg_bytes = paddle.vision.ops.read_file('fake.jpg')\nimg = paddle.vision.ops.decode_jpeg(img_bytes)\n\nprint(img.shape)",
            "masked_code": "import cv2\nimport paddle\n\nfake_img = (np.random.random(\n            (400, 300, 3)) * 255).astype('uint8')\n\ncv2.imwrite('fake.jpg', fake_img)\n\nimg_bytes = paddle.vision.ops.read_file('fake.jpg')\n<line_mask>\n\nprint(img.shape)",
            "masked_line": "img = paddle.vision.ops.decode_jpeg(img_bytes)",
            "answer": "decode_jpeg",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_414"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==2.1.0",
            "time": "2021-05-13",
            "description": "The code demonstrates creating a linear neural network layer using the paddle library in Python. It then showcases changing the data type of the layer's weight to float64, moving the layer to the CPU device, and moving the layer to a CUDA pinned place device while changing the layout of the weight tensor accordingly.",
            "code": "import paddle\n\nlinear=paddle.nn.Linear(2, 2)\nlinear.weight\n#Parameter containing:\n#Tensor(shape=[2, 2], dtype=float32, place=CUDAPlace(0), stop_gradient=False,\n#       [[-0.32770029,  0.38653070],\n#        [ 0.46030545,  0.08158520]])\n\nlinear.to(dtype='float64')\nlinear.weight\n#Tenor(shape=[2, 2], dtype=float64, place=CUDAPlace(0), stop_gradient=False,\n#       [[-0.32770029,  0.38653070],\n#        [ 0.46030545,  0.08158520]])\n\nlinear.to(device='cpu')\nlinear.weight\n#Tensor(shape=[2, 2], dtype=float64, place=CPUPlace, stop_gradient=False,\n#       [[-0.32770029,  0.38653070],\n#        [ 0.46030545, 0.08158520]])\nlinear.to(device=paddle.CUDAPinnedPlace(), blocking=False)\nlinear.weight\n#Tensor(shape=[2, 2], dtype=float64, place=CUDAPinnedPlace, stop_gradient=False,\n#       [[-0.04989364, -0.56889004],\n#        [ 0.33960250, 0.96878713]])",
            "masked_code": "import paddle\n\nlinear=paddle.nn.Linear(2, 2)\nlinear.weight\n#Parameter containing:\n#Tensor(shape=[2, 2], dtype=float32, place=CUDAPlace(0), stop_gradient=False,\n#       [[-0.32770029,  0.38653070],\n#        [ 0.46030545,  0.08158520]])\n\nlinear.to(dtype='float64')\nlinear.weight\n#Tenor(shape=[2, 2], dtype=float64, place=CUDAPlace(0), stop_gradient=False,\n#       [[-0.32770029,  0.38653070],\n#        [ 0.46030545,  0.08158520]])\n\nlinear.to(device='cpu')\nlinear.weight\n#Tensor(shape=[2, 2], dtype=float64, place=CPUPlace, stop_gradient=False,\n#       [[-0.32770029,  0.38653070],\n#        [ 0.46030545, 0.08158520]])\n<line_mask>\nlinear.weight\n#Tensor(shape=[2, 2], dtype=float64, place=CUDAPinnedPlace, stop_gradient=False,\n#       [[-0.04989364, -0.56889004],\n#        [ 0.33960250, 0.96878713]])",
            "masked_line": "linear.to(device=paddle.CUDAPinnedPlace(), blocking=False)",
            "answer": "to",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_415"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==2.2.0",
            "time": "2021-11-02",
            "description": "The code divides the process into multiple nodes and sets the placement of each process on the nodes.",
            "code": "import paddle\nimport paddle.distributed as dist\n\npaddle.enable_static()\n\nmesh = dist.ProcessMesh([[2, 4, 5], [0, 1, 3]])\nmesh.set_placement([0, 1, 2, 3, 4, 5])",
            "masked_code": "import paddle\nimport paddle.distributed as dist\n\npaddle.enable_static()\n\nmesh = dist.ProcessMesh([[2, 4, 5], [0, 1, 3]])\n<line_mask>",
            "masked_line": "mesh.set_placement([0, 1, 2, 3, 4, 5])",
            "answer": "set_placement",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_416"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==2.2.1",
            "time": "2021-11-30",
            "description": "This code segment sends and receives data between nodes in a graph structure using the \"sum\" pooling method.",
            "code": "import paddle\n\nx = paddle.to_tensor([[0, 2, 3], [1, 4, 5], [2, 6, 7]], dtype=\"float32\")\nindexes = paddle.to_tensor([[0, 1], [1, 2], [2, 1], [0, 0]], dtype=\"int32\")\nsrc_index = indexes[:, 0]\ndst_index = indexes[:, 1]\nout = paddle.incubate.graph_send_recv(x, src_index, dst_index, pool_type=\"sum\")",
            "masked_code": "import paddle\n\nx = paddle.to_tensor([[0, 2, 3], [1, 4, 5], [2, 6, 7]], dtype=\"float32\")\nindexes = paddle.to_tensor([[0, 1], [1, 2], [2, 1], [0, 0]], dtype=\"int32\")\nsrc_index = indexes[:, 0]\ndst_index = indexes[:, 1]\n<line_mask>",
            "masked_line": "out = paddle.incubate.graph_send_recv(x, src_index, dst_index, pool_type=\"sum\")",
            "answer": "graph_send_recv",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_417"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==2.2.1",
            "time": "2021-11-30",
            "description": "This code performs triangular solving of the system of linear equations where x is a upper triangular matrix and y is a vector, and returns the solution.",
            "code": "import paddle\nimport numpy as np\n\nx = paddle.to_tensor([[1, 1, 1], \n                      [0, 2, 1],\n                      [0, 0,-1]], dtype=\"float64\")\ny = paddle.to_tensor([[0], [-9], [5]], dtype=\"float64\")\nout = paddle.linalg.triangular_solve(x, y, upper=True)\n\nprint(out)",
            "masked_code": "import paddle\nimport numpy as np\n\nx = paddle.to_tensor([[1, 1, 1], \n                      [0, 2, 1],\n                      [0, 0,-1]], dtype=\"float64\")\ny = paddle.to_tensor([[0], [-9], [5]], dtype=\"float64\")\n<line_mask>\n\nprint(out)",
            "masked_line": "out = paddle.linalg.triangular_solve(x, y, upper=True)",
            "answer": "triangular_solve",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_418"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==2.3.0",
            "time": "2022-05-05",
            "description": "The code calculates the Jacobian matrix of the function \"func\" with respect to the input tensor x using the PaddlePaddle library. The Jacobian matrix represents all first-order partial derivatives of the function with respect to the input tensor x. The calculated Jacobian matrix is then printed out with specific rows or columns selected for display.",
            "code": "import paddle\n\n\ndef func(x, y):\n    return paddle.matmul(x, y)\n\n\nx = paddle.to_tensor([[1., 2.], [3., 4.]])\nJ = paddle.incubate.autograd.Jacobian(func, [x, x])\nprint(J[:, :])\n# Tensor(shape=[4, 8], dtype=float32, place=Place(gpu:0), stop_gradient=False,\n#        [[1., 3., 0., 0., 1., 0., 2., 0.],\n#         [2., 4., 0., 0., 0., 1., 0., 2.],\n#         [0., 0., 1., 3., 3., 0., 4., 0.],\n#         [0., 0., 2., 4., 0., 3., 0., 4.]])\n\nprint(J[0, :])\n# Tensor(shape=[8], dtype=float32, place=Place(gpu:0), stop_gradient=False,\n#        [1., 3., 0., 0., 1., 0., 2., 0.])\nprint(J[:, 0])\n# Tensor(shape=[4], dtype=float32, place=Place(gpu:0), stop_gradient=False,\n#        [1., 2., 0., 0.]",
            "masked_code": "import paddle\n\n\ndef func(x, y):\n    return paddle.matmul(x, y)\n\n\nx = paddle.to_tensor([[1., 2.], [3., 4.]])\n<line_mask>\nprint(J[:, :])\n# Tensor(shape=[4, 8], dtype=float32, place=Place(gpu:0), stop_gradient=False,\n#        [[1., 3., 0., 0., 1., 0., 2., 0.],\n#         [2., 4., 0., 0., 0., 1., 0., 2.],\n#         [0., 0., 1., 3., 3., 0., 4., 0.],\n#         [0., 0., 2., 4., 0., 3., 0., 4.]])\n\nprint(J[0, :])\n# Tensor(shape=[8], dtype=float32, place=Place(gpu:0), stop_gradient=False,\n#        [1., 3., 0., 0., 1., 0., 2., 0.])\nprint(J[:, 0])\n# Tensor(shape=[4], dtype=float32, place=Place(gpu:0), stop_gradient=False,\n#        [1., 2., 0., 0.]",
            "masked_line": "J = paddle.incubate.autograd.Jacobian(func, [x, x])",
            "answer": "Jacobian",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_419"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==2.3.0",
            "time": "2022-05-05",
            "description": "The code calculates the Hessian matrix for a given function, in this case, the function is defined as the sum of the square of the input vector elements. The Hessian matrix represents the second partial derivatives of the function with respect to its inputs.",
            "code": "import paddle\n\n\ndef reducer(x):\n    return paddle.sum(x * x)\n\n\nx = paddle.rand([2, 2])\nh = paddle.incubate.autograd.Hessian(reducer, x)\nprint(h[:])\n# Tensor(shape=[4, 4], dtype=float32, place=Place(gpu:0), stop_gradient=False,\n#        [[2., 0., 0., 0.],\n#         [0., 2., 0., 0.],\n#         [0., 0., 2., 0.],\n#         [0., 0., 0., 2.]])\n",
            "masked_code": "import paddle\n\n\ndef reducer(x):\n    return paddle.sum(x * x)\n\n\nx = paddle.rand([2, 2])\n<line_mask>\nprint(h[:])\n# Tensor(shape=[4, 4], dtype=float32, place=Place(gpu:0), stop_gradient=False,\n#        [[2., 0., 0., 0.],\n#         [0., 2., 0., 0.],\n#         [0., 0., 2., 0.],\n#         [0., 0., 0., 2.]])\n",
            "masked_line": "h = paddle.incubate.autograd.Hessian(reducer, x)",
            "answer": "Hessian",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_420"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==2.3.0",
            "time": "2022-05-05",
            "description": "The code defines a sparse feature embedding for input data with dimensions 1024x64. It sets up data input placeholders for 'show', 'click', and 'ins', and creates a distributed ShowClickEntry object. The code then creates a sparse embedding layer using the input data, the specified dimensions, and initialization parameters, without actually running the embedding layer for inference.",
            "code": "import paddle\npaddle.enable_static()\n\nsparse_feature_dim = 1024\nembedding_size = 64\n\nshows = paddle.static.data(name='show', shape=[1], dtype='int64')\nclicks = paddle.static.data(name='click', shape=[1], dtype='int64')\ninput = paddle.static.data(name='ins', shape=[1], dtype='int64')\n\nentry = paddle.distributed.ShowClickEntry(\"show\", \"click\")\n\nemb = paddle.static.nn.sparse_embedding(\n    input=input,\n    size=[sparse_feature_dim, embedding_size],\n    is_test=False,\n    entry=entry,\n    param_attr=paddle.ParamAttr(name=\"SparseFeatFactors\",\n                               initializer=paddle.nn.initializer.Uniform()))",
            "masked_code": "import paddle\npaddle.enable_static()\n\nsparse_feature_dim = 1024\nembedding_size = 64\n\nshows = paddle.static.data(name='show', shape=[1], dtype='int64')\nclicks = paddle.static.data(name='click', shape=[1], dtype='int64')\ninput = paddle.static.data(name='ins', shape=[1], dtype='int64')\n\n<line_mask>\n\nemb = paddle.static.nn.sparse_embedding(\n    input=input,\n    size=[sparse_feature_dim, embedding_size],\n    is_test=False,\n    entry=entry,\n    param_attr=paddle.ParamAttr(name=\"SparseFeatFactors\",\n                               initializer=paddle.nn.initializer.Uniform()))",
            "masked_line": "entry = paddle.distributed.ShowClickEntry(\"show\", \"click\")",
            "answer": "ShowClickEntry",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_421"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==2.3.0",
            "time": "2022-05-05",
            "description": "The code converts a set of tensors divided into two parts based on two different strategies provided in strategy_1 and strategy_2. The strategies define the shape, group, and mapping of the tensors to be processed. The conversion is performed by the Converter class using the tensors dictionary and the specified strategies to generate a result.",
            "code": "import numpy as np\ncomplete_tensors = np.arange(4).reshape([2, 2])\npartitial_tensors = np.split(complete_tensors, 2, axis=0)\nname = \"tmp_0\"\ntensors_dict = {name: partitial_tensors}\nstrategy_1 = {\n    name: {\n        \"process_shape\": [2],\n        \"process_group\": [0, 1],\n        \"dims_mapping\": [0, -1]\n    }\n}\nstrategy_2 = {\n    name: {\n        \"process_shape\": [2],\n        \"process_group\": [0, 1],\n        \"dims_mapping\": [-1, -1]\n    }\n}\nconverter = Converter(tensors_dict, strategy_1, strategy_2)\nresult = converter.convert()",
            "masked_code": "import numpy as np\ncomplete_tensors = np.arange(4).reshape([2, 2])\npartitial_tensors = np.split(complete_tensors, 2, axis=0)\nname = \"tmp_0\"\ntensors_dict = {name: partitial_tensors}\nstrategy_1 = {\n    name: {\n        \"process_shape\": [2],\n        \"process_group\": [0, 1],\n        \"dims_mapping\": [0, -1]\n    }\n}\nstrategy_2 = {\n    name: {\n        \"process_shape\": [2],\n        \"process_group\": [0, 1],\n        \"dims_mapping\": [-1, -1]\n    }\n}\nconverter = Converter(tensors_dict, strategy_1, strategy_2)\n<line_mask>",
            "masked_line": "result = converter.convert()",
            "answer": "convert",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_422"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==2.3.0",
            "time": "2022-05-05",
            "description": "This code splits the complete_tensor into three parts based on the specified indices [2, 4] along the third dimension.",
            "code": "import numpy as np\ncomplete_tensor = np.array([[[1.11, 1.12, 1.13, 1.14, 1.15, 1.16]]])\nrank = 2\ncomplete_shape = [1, 1, 6]\ndims_mapping = [-1, -1, 0]\nprocess_shape = [3]\nprocess_group = [0, 1, 2]\n\nsliced_tensor_list = split(complete_tensor, [[], [], [2, 4]], 3)",
            "masked_code": "import numpy as np\ncomplete_tensor = np.array([[[1.11, 1.12, 1.13, 1.14, 1.15, 1.16]]])\nrank = 2\ncomplete_shape = [1, 1, 6]\ndims_mapping = [-1, -1, 0]\nprocess_shape = [3]\nprocess_group = [0, 1, 2]\n\n<line_mask>",
            "masked_line": "sliced_tensor_list = split(complete_tensor, [[], [], [2, 4]], 3)",
            "answer": "split",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_423"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==2.3.0",
            "time": "2022-05-05",
            "description": "The code slices a tensor array `complete_tensor` using specific indices, and then retrieves the sliced index based on the rank, shape, dimensions mapping, process shape, and process group.",
            "code": "import numpy as np\ncomplete_tensor = np.array([[[1.11, 1.12, 1.13, 1.14, 1.15, 1.16]]])\nrank = 2\ncomplete_shape = [1, 1, 6]\ndims_mapping = [-1, -1, 0]\nprocess_shape = [3]\nprocess_group = [0, 1, 2]\n\nslice_tensor = _slice_tensor(complete_tensor, [[], [], [2, 4]], 3)\n\nindex = _get_sliced_index(rank, complete_shape, dims_mapping, process_shape, process_group)",
            "masked_code": "import numpy as np\ncomplete_tensor = np.array([[[1.11, 1.12, 1.13, 1.14, 1.15, 1.16]]])\nrank = 2\ncomplete_shape = [1, 1, 6]\ndims_mapping = [-1, -1, 0]\nprocess_shape = [3]\nprocess_group = [0, 1, 2]\n\nslice_tensor = _slice_tensor(complete_tensor, [[], [], [2, 4]], 3)\n\n<line_mask>",
            "masked_line": "index = _get_sliced_index(rank, complete_shape, dims_mapping, process_shape, process_group)",
            "answer": "_get_sliced_index",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_424"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==2.3.0",
            "time": "2022-05-05",
            "description": "The given Python code utilizes the PaddlePaddle framework to create and work with Beta distributions. The code demonstrates how to calculate the mean, variance, and entropy of the Beta distribution. It shows examples with both scalar and tensor inputs, showcasing how to handle broadcasting in tensor operations.",
            "code": "import paddle\n\n# scale input\nbeta = paddle.distribution.Beta(alpha=0.5, beta=0.5)\nprint(beta.mean)\n# Tensor(shape=[1], dtype=float32, place=CUDAPlace(0), stop_gradient=True,\n#        [0.50000000])\nprint(beta.variance)\n# Tensor(shape=[1], dtype=float32, place=CUDAPlace(0), stop_gradient=True,\n#        [0.12500000])\nprint(beta.entropy())\n# Tensor(shape=[1], dtype=float32, place=CUDAPlace(0), stop_gradient=True,\n#        [0.12500000])\n\n# tensor input with broadcast\nbeta = paddle.distribution.Beta(alpha=paddle.to_tensor([0.2, 0.4]), beta=0.6)\nprint(beta.mean)\n# Tensor(shape=[2], dtype=float32, place=CUDAPlace(0), stop_gradient=True,\n#        [0.25000000, 0.40000001])\nprint(beta.variance)\n# Tensor(shape=[2], dtype=float32, place=CUDAPlace(0), stop_gradient=True,\n#        [0.10416666, 0.12000000])\nprint(beta.entropy())\n# Tensor(shape=[2], dtype=float32, place=CUDAPlace(0), stop_gradient=True,\n#        [-1.91923141, -0.38095069])",
            "masked_code": "import paddle\n\n# scale input\n<line_mask>\nprint(beta.mean)\n# Tensor(shape=[1], dtype=float32, place=CUDAPlace(0), stop_gradient=True,\n#        [0.50000000])\nprint(beta.variance)\n# Tensor(shape=[1], dtype=float32, place=CUDAPlace(0), stop_gradient=True,\n#        [0.12500000])\nprint(beta.entropy())\n# Tensor(shape=[1], dtype=float32, place=CUDAPlace(0), stop_gradient=True,\n#        [0.12500000])\n\n# tensor input with broadcast\nbeta = paddle.distribution.Beta(alpha=paddle.to_tensor([0.2, 0.4]), beta=0.6)\nprint(beta.mean)\n# Tensor(shape=[2], dtype=float32, place=CUDAPlace(0), stop_gradient=True,\n#        [0.25000000, 0.40000001])\nprint(beta.variance)\n# Tensor(shape=[2], dtype=float32, place=CUDAPlace(0), stop_gradient=True,\n#        [0.10416666, 0.12000000])\nprint(beta.entropy())\n# Tensor(shape=[2], dtype=float32, place=CUDAPlace(0), stop_gradient=True,\n#        [-1.91923141, -0.38095069])",
            "masked_line": "beta = paddle.distribution.Beta(alpha=0.5, beta=0.5)",
            "answer": "Beta",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_425"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==2.3.0",
            "time": "2022-05-05",
            "description": "The code defines a Beta distribution with parameters [0.5, 0.5] and [0.5, 0.5]. It then calculates the log probability of a value 0.2 in the distribution. Next, it reinterprets the Beta distribution as an Independent distribution along axis 1 and calculates the log probability of values [0.2, 0.2].",
            "code": "import paddle\nfrom paddle.distribution import independent\n\nbeta = paddle.distribution.Beta(paddle.to_tensor([0.5, 0.5]), paddle.to_tensor([0.5, 0.5]))\nprint(beta.batch_shape, beta.event_shape)\n# (2,) ()\nprint(beta.log_prob(paddle.to_tensor(0.2)))\n# Tensor(shape=[2], dtype=float32, place=Place(gpu:0), stop_gradient=True,\n#        [-0.22843921, -0.22843921])\nreinterpreted_beta = independent.Independent(beta, 1)\nprint(reinterpreted_beta.batch_shape, reinterpreted_beta.event_shape)\n# () (2,)\nprint(reinterpreted_beta.log_prob(paddle.to_tensor([0.2,  0.2])))\n# Tensor(shape=[1], dtype=float32, place=Place(gpu:0), stop_gradient=True,\n#        [-0.45687842])",
            "masked_code": "import paddle\nfrom paddle.distribution import independent\n\nbeta = paddle.distribution.Beta(paddle.to_tensor([0.5, 0.5]), paddle.to_tensor([0.5, 0.5]))\nprint(beta.batch_shape, beta.event_shape)\n# (2,) ()\nprint(beta.log_prob(paddle.to_tensor(0.2)))\n# Tensor(shape=[2], dtype=float32, place=Place(gpu:0), stop_gradient=True,\n#        [-0.22843921, -0.22843921])\n<line_mask>\nprint(reinterpreted_beta.batch_shape, reinterpreted_beta.event_shape)\n# () (2,)\nprint(reinterpreted_beta.log_prob(paddle.to_tensor([0.2,  0.2])))\n# Tensor(shape=[1], dtype=float32, place=Place(gpu:0), stop_gradient=True,\n#        [-0.45687842])",
            "masked_line": "reinterpreted_beta = independent.Independent(beta, 1)",
            "answer": "Independent",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_426"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==2.3.0",
            "time": "2022-05-05",
            "description": "The code defines an affine transformation with scale factor 1 and shift factor 0, applies the forward transformation to the input tensor x, calculates the inverse transformation of the forward transformation applied to x, and computes the forward log determinant of the Jacobian matrix for the transformation at x.",
            "code": "import paddle\n\nx = paddle.to_tensor([1., 2.])\naffine = paddle.distribution.AffineTransform(paddle.to_tensor(0.), paddle.to_tensor(1.))\n\nprint(affine.forward(x))\nprint(affine.inverse(affine.forward(x)))\nprint(affine.forward_log_det_jacobian(x))",
            "masked_code": "import paddle\n\nx = paddle.to_tensor([1., 2.])\n<line_mask>\n\nprint(affine.forward(x))\nprint(affine.inverse(affine.forward(x)))\nprint(affine.forward_log_det_jacobian(x))",
            "masked_line": "affine = paddle.distribution.AffineTransform(paddle.to_tensor(0.), paddle.to_tensor(1.))",
            "answer": "AffineTransform",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_427"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==2.3.0",
            "time": "2022-05-05",
            "description": "The code defines a chain of transformations using the AffineTransform and ExpTransform distributions in the PaddlePaddle library. It applies the forward and inverse transformations on the input tensor x, calculates the log determinant Jacobian of both forward and inverse transformations, and prints the results.",
            "code": "import paddle\nx = paddle.to_tensor([0., 1., 2., 3.])\nchain = paddle.distribution.ChainTransform((\n    paddle.distribution.AffineTransform(\n        paddle.to_tensor(0.), paddle.to_tensor(1.)),\n    paddle.distribution.ExpTransform()\n))\nprint(chain.forward(x))\nprint(chain.inverse(chain.forward(x)))\nprint(chain.forward_log_det_jacobian(x))\nprint(chain.inverse_log_det_jacobian(chain.forward(x)))",
            "masked_code": "import paddle\nx = paddle.to_tensor([0., 1., 2., 3.])\n<line_mask>\n    paddle.distribution.AffineTransform(\n        paddle.to_tensor(0.), paddle.to_tensor(1.)),\n    paddle.distribution.ExpTransform()\n))\nprint(chain.forward(x))\nprint(chain.inverse(chain.forward(x)))\nprint(chain.forward_log_det_jacobian(x))\nprint(chain.inverse_log_det_jacobian(chain.forward(x)))",
            "masked_line": "chain = paddle.distribution.ChainTransform((",
            "answer": "ChainTransform",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_428"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==2.3.0",
            "time": "2022-05-05",
            "description": "This code defines a power transformation distribution with a power of 2, applies the forward transformation to the input tensor x, calculates the inverse transformation of the forward transformation, and calculates the forward log determinant of the Jacobian.",
            "code": "import paddle\n\nx = paddle.to_tensor([1., 2.])\npower = paddle.distribution.PowerTransform(paddle.to_tensor(2.))\n\nprint(power.forward(x))\nprint(power.inverse(power.forward(x)))\nprint(power.forward_log_det_jacobian(x))",
            "masked_code": "import paddle\n\nx = paddle.to_tensor([1., 2.])\n<line_mask>\n\nprint(power.forward(x))\nprint(power.inverse(power.forward(x)))\nprint(power.forward_log_det_jacobian(x))",
            "masked_line": "power = paddle.distribution.PowerTransform(paddle.to_tensor(2.))",
            "answer": "PowerTransform",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_429"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==2.3.0",
            "time": "2022-05-05",
            "description": "The code defines a ReshapeTransform object that reshapes the input tensor from a shape of (1, 2, 3) to a shape of (2, 3). It then applies the transformation to the input tensor x and prints the output shape, the transformed tensor, the inverse of the transformation, and the log determinant of the Jacobian of the transformation.",
            "code": "import paddle\n\nx = paddle.ones((1,2,3))\nreshape_transform = paddle.distribution.ReshapeTransform((2, 3), (3, 2))\nprint(reshape_transform.forward_shape((1,2,3)))\nprint(reshape_transform.forward(x))\nprint(reshape_transform.inverse(reshape_transform.forward(x)))\nprint(reshape_transform.forward_log_det_jacobian(x))",
            "masked_code": "import paddle\n\nx = paddle.ones((1,2,3))\n<line_mask>\nprint(reshape_transform.forward_shape((1,2,3)))\nprint(reshape_transform.forward(x))\nprint(reshape_transform.inverse(reshape_transform.forward(x)))\nprint(reshape_transform.forward_log_det_jacobian(x))",
            "masked_line": "reshape_transform = paddle.distribution.ReshapeTransform((2, 3), (3, 2))",
            "answer": "ReshapeTransform",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_430"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==2.3.0",
            "time": "2022-05-05",
            "description": "This code creates a tensor `x` filled with ones of shape (2,3), initializes a Sigmoid transform `t`, computes the forward transformation of `x` using the Sigmoid transform, computes the inverse transformation of the forward transformation result, and computes the forward log determinant of the Jacobian for `x` using the Sigmoid transform.",
            "code": "import paddle\n\nx = paddle.ones((2,3))\nt = paddle.distribution.SigmoidTransform()\nprint(t.forward(x))\nprint(t.inverse(t.forward(x)))\nprint(t.forward_log_det_jacobian(x))",
            "masked_code": "import paddle\n\nx = paddle.ones((2,3))\n<line_mask>\nprint(t.forward(x))\nprint(t.inverse(t.forward(x)))\nprint(t.forward_log_det_jacobian(x))",
            "masked_line": "t = paddle.distribution.SigmoidTransform()",
            "answer": "SigmoidTransform",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_431"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==2.3.0",
            "time": "2022-05-05",
            "description": "The code generates a tensor filled with ones of shape (2,3), then creates a SoftmaxTransform distribution. It uses the distribution to apply the forward and inverse transformations on the tensor x.",
            "code": "import paddle\n\nx = paddle.ones((2,3))\nt = paddle.distribution.SoftmaxTransform()\nprint(t.forward(x))\nprint(t.inverse(t.forward(x)))",
            "masked_code": "import paddle\n\nx = paddle.ones((2,3))\n<line_mask>\nprint(t.forward(x))\nprint(t.inverse(t.forward(x)))",
            "masked_line": "t = paddle.distribution.SoftmaxTransform()",
            "answer": "SoftmaxTransform",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_432"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==2.3.0",
            "time": "2022-05-05",
            "description": "The code defines a transformation function 't' composed of an exponential transform and a power transform with base 2. It then applies the forward transformation to the input 'x', calculates the inverse transformation of the forward-transformed 'x', and computes the forward log determinant Jacobian of 'x'.",
            "code": "import paddle\n\nx = paddle.stack(\n    (paddle.to_tensor([1., 2., 3.]), paddle.to_tensor([1, 2., 3.])), 1)\nt = paddle.distribution.StackTransform(\n    (paddle.distribution.ExpTransform(),\n    paddle.distribution.PowerTransform(paddle.to_tensor(2.))),\n    1\n)\nprint(t.forward(x))\nprint(t.inverse(t.forward(x)))\nprint(t.forward_log_det_jacobian(x))",
            "masked_code": "import paddle\n\nx = paddle.stack(\n    (paddle.to_tensor([1., 2., 3.]), paddle.to_tensor([1, 2., 3.])), 1)\n<line_mask>\n    (paddle.distribution.ExpTransform(),\n    paddle.distribution.PowerTransform(paddle.to_tensor(2.))),\n    1\n)\nprint(t.forward(x))\nprint(t.inverse(t.forward(x)))\nprint(t.forward_log_det_jacobian(x))",
            "masked_line": "t = paddle.distribution.StackTransform(",
            "answer": "StackTransform",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_433"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==2.3.0",
            "time": "2022-05-05",
            "description": "The code defines a StickBreakingTransform object and performs forward, inverse, and forward_log_det_jacobian operations on the input tensor x using the defined transformation.",
            "code": "import paddle\n\nx = paddle.to_tensor([1.,2.,3.])\nt = paddle.distribution.StickBreakingTransform()\nprint(t.forward(x))\nprint(t.inverse(t.forward(x)))\nprint(t.forward_log_det_jacobian(x))",
            "masked_code": "import paddle\n\nx = paddle.to_tensor([1.,2.,3.])\n<line_mask>\nprint(t.forward(x))\nprint(t.inverse(t.forward(x)))\nprint(t.forward_log_det_jacobian(x))",
            "masked_line": "t = paddle.distribution.StickBreakingTransform()",
            "answer": "StickBreakingTransform",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_434"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==2.3.0",
            "time": "2022-05-05",
            "description": "This code snippet implements the Tanh transform function using the PaddlePaddle library in Python to transform input tensors using the hyperbolic tangent function and compute the forward and inverse transformations as well as the log determinant Jacobian values.",
            "code": "import paddle\ntanh = paddle.distribution.TanhTransform()\nx = paddle.to_tensor([[1., 2., 3.], [4., 5., 6.]])\nprint(tanh.forward(x))\nprint(tanh.inverse(tanh.forward(x)))\nprint(tanh.forward_log_det_jacobian(x))\nprint(tanh.inverse_log_det_jacobian(tanh.forward(x)))",
            "masked_code": "import paddle\n<line_mask>\nx = paddle.to_tensor([[1., 2., 3.], [4., 5., 6.]])\nprint(tanh.forward(x))\nprint(tanh.inverse(tanh.forward(x)))\nprint(tanh.forward_log_det_jacobian(x))\nprint(tanh.inverse_log_det_jacobian(tanh.forward(x)))",
            "masked_line": "tanh = paddle.distribution.TanhTransform()",
            "answer": "TanhTransform",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_435"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==2.3.0",
            "time": "2022-05-05",
            "description": "The code defines a TransformedDistribution using a Normal distribution with mean 0 and standard deviation 1, along with an AffineTransform transformation with scale 1 and shift 2. It then samples 10 samples from this distribution and calculates the log probability of a value 0.5 under this distribution.",
            "code": "import paddle \nfrom paddle.distribution import transformed_distribution\n\nd = transformed_distribution.TransformedDistribution(\n    paddle.distribution.Normal(0., 1.), \n    [paddle.distribution.AffineTransform(paddle.to_tensor(1.), paddle.to_tensor(2.))]\n)\n\nprint(d.sample([10]))\n# Tensor(shape=[10], dtype=float32, place=Place(gpu:0), stop_gradient=True,\n#        [-0.10697651,  3.33609009, -0.86234951,  5.07457638,  0.75925219,\n#         -4.17087793,  2.22579336, -0.93845034,  0.66054249,  1.50957513])\nprint(d.log_prob(paddle.to_tensor(0.5)))\n# Tensor(shape=[1], dtype=float32, place=Place(gpu:0), stop_gradient=True,\n#        [-1.64333570])",
            "masked_code": "import paddle \nfrom paddle.distribution import transformed_distribution\n\n<line_mask>\n    paddle.distribution.Normal(0., 1.), \n    [paddle.distribution.AffineTransform(paddle.to_tensor(1.), paddle.to_tensor(2.))]\n)\n\nprint(d.sample([10]))\n# Tensor(shape=[10], dtype=float32, place=Place(gpu:0), stop_gradient=True,\n#        [-0.10697651,  3.33609009, -0.86234951,  5.07457638,  0.75925219,\n#         -4.17087793,  2.22579336, -0.93845034,  0.66054249,  1.50957513])\nprint(d.log_prob(paddle.to_tensor(0.5)))\n# Tensor(shape=[1], dtype=float32, place=Place(gpu:0), stop_gradient=True,\n#        [-1.64333570])",
            "masked_line": "d = transformed_distribution.TransformedDistribution(",
            "answer": "TransformedDistribution",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_436"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==2.3.0",
            "time": "2022-05-05",
            "description": "This code sets up an IpuStrategy for training a model with specified pipelining configuration, batching per step, and gradient accumulation settings.",
            "code": "import paddle\nimport paddle.static as static\n\npaddle.enable_static()\n\nipu_strategy = static.IpuStrategy()\nipu_strategy.set_pipelining_config(enable_pipelining=False,\n                                    batches_per_step=1,\n                                    enable_gradient_accumulation=False,\n                                    accumulation_factor=1)",
            "masked_code": "import paddle\nimport paddle.static as static\n\npaddle.enable_static()\n\nipu_strategy = static.IpuStrategy()\n<line_mask>\n                                    batches_per_step=1,\n                                    enable_gradient_accumulation=False,\n                                    accumulation_factor=1)",
            "masked_line": "ipu_strategy.set_pipelining_config(enable_pipelining=False,",
            "answer": "set_pipelining_config",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_438"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==2.3.0",
            "time": "2022-05-05",
            "description": "The code defines an IPU strategy for running operations in single precision floating point format.",
            "code": "import paddle\nimport paddle.static as static\n\npaddle.enable_static()\n\nipu_strategy = static.IpuStrategy()\nipu_strategy.set_precision_config(enable_fp16=False)",
            "masked_code": "import paddle\nimport paddle.static as static\n\npaddle.enable_static()\n\nipu_strategy = static.IpuStrategy()\n<line_mask>",
            "masked_line": "ipu_strategy.set_precision_config(enable_fp16=False)",
            "answer": "set_precision_config",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_439"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==2.3.0",
            "time": "2022-05-05",
            "description": "The code defines an IPU strategy that includes a custom operation mapping between a PaddlePaddle RELU function and a Popart RELU function.",
            "code": "import paddle\nimport paddle.static as static\n\npaddle.enable_static()\n\nipu_strategy = static.IpuStrategy()\nipu_strategy.add_custom_op('paddle_relu', 'popart_relu')",
            "masked_code": "import paddle\nimport paddle.static as static\n\npaddle.enable_static()\n\nipu_strategy = static.IpuStrategy()\n<line_mask>",
            "masked_line": "ipu_strategy.add_custom_op('paddle_relu', 'popart_relu')",
            "answer": "add_custom_op",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_440"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==2.3.0",
            "time": "2022-05-05",
            "description": "This code initializes an IpuStrategy object and sets the options for running on an IPU device, including specifying the number of IPUs to use and enabling mixed precision training with FP16.",
            "code": "import paddle\nimport paddle.static as static\n\npaddle.enable_static()\n\nipu_strategy = static.IpuStrategy()\noptions = {'num_ipus':1, 'enable_fp16': True}\nipu_strategy.set_options(options)",
            "masked_code": "import paddle\nimport paddle.static as static\n\npaddle.enable_static()\n\nipu_strategy = static.IpuStrategy()\noptions = {'num_ipus':1, 'enable_fp16': True}\n<line_mask>",
            "masked_line": "ipu_strategy.set_options(options)",
            "answer": "set_options",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_441"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==2.3.0",
            "time": "2022-05-05",
            "description": "The code defines an IPU (Intelligent Processing Unit) strategy using PaddlePaddle framework and retrieves the number of IPUs configured in the strategy.",
            "code": "import paddle\nimport paddle.static as static\n\npaddle.enable_static()\n\nipu_strategy = static.IpuStrategy()\nnum_ipus = ipu_strategy.get_option('num_ipus')",
            "masked_code": "import paddle\nimport paddle.static as static\n\npaddle.enable_static()\n\nipu_strategy = static.IpuStrategy()\n<line_mask>",
            "masked_line": "num_ipus = ipu_strategy.get_option('num_ipus')",
            "answer": "get_option",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_442"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==2.3.0",
            "time": "2022-05-05",
            "description": "The code enables the \"ViewSimplifyPattern\" optimization pattern for the IPU (Incremental Pointer Update) strategy in the PaddlePaddle framework.",
            "code": "import paddle\nimport paddle.static as static\n\npaddle.enable_static()\n\nipu_strategy = static.IpuStrategy()\nipu_strategy.enable_pattern(\"ViewSimplifyPattern\")",
            "masked_code": "import paddle\nimport paddle.static as static\n\npaddle.enable_static()\n\nipu_strategy = static.IpuStrategy()\n<line_mask>",
            "masked_line": "ipu_strategy.enable_pattern(\"ViewSimplifyPattern\")",
            "answer": "enable_pattern",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_443"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==2.5.0",
            "time": "2023-06-19",
            "description": "The code enables tensor checking for NaN and Inf values, converts two lists into tensors, raises the elements of the first tensor to the power of the corresponding elements in the second tensor, and performs backpropagation on the result tensor. Finally, the tensor checking is disabled.",
            "code": "import paddle\n\nchecker_config = paddle.amp.debugging.TensorCheckerConfig(enable=True, debug_mode=paddle.amp.debugging.DebugMode.CHECK_NAN_INF)\npaddle.amp.debugging.enable_tensor_checker(checker_config)\n\nx = paddle.to_tensor([1, 0, 3], place=paddle.CPUPlace(), dtype='float32', stop_gradient=False)\ny = paddle.to_tensor([0.2, 0, 0.5], place=paddle.CPUPlace(), dtype='float32')\nres = paddle.pow(x, y)\npaddle.autograd.backward(res, retain_graph=True)\npaddle.amp.debugging.disable_tensor_checker()",
            "masked_code": "import paddle\n\n<line_mask>\npaddle.amp.debugging.enable_tensor_checker(checker_config)\n\nx = paddle.to_tensor([1, 0, 3], place=paddle.CPUPlace(), dtype='float32', stop_gradient=False)\ny = paddle.to_tensor([0.2, 0, 0.5], place=paddle.CPUPlace(), dtype='float32')\nres = paddle.pow(x, y)\npaddle.autograd.backward(res, retain_graph=True)\npaddle.amp.debugging.disable_tensor_checker()",
            "masked_line": "checker_config = paddle.amp.debugging.TensorCheckerConfig(enable=True, debug_mode=paddle.amp.debugging.DebugMode.CHECK_NAN_INF)",
            "answer": "TensorCheckerConfig",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_444"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==2.5.0",
            "time": "2023-06-19",
            "description": "The code creates two stream objects, s1 and s2, along with an event object e. The event e is recorded on stream s1, and stream s2 waits for the event to complete before continuing execution.",
            "code": "import paddle\ns1 = paddle.device.Stream()\ns2 = paddle.device.Stream()\ne = paddle.device.Event()\ne.record(s1)\ns2.wait_event(e)",
            "masked_code": "import paddle\ns1 = paddle.device.Stream()\ns2 = paddle.device.Stream()\ne = paddle.device.Event()\ne.record(s1)\n<line_mask>",
            "masked_line": "s2.wait_event(e)",
            "answer": "wait_event",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_445"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==2.5.0",
            "time": "2023-06-19",
            "description": "The code creates two streams, s1 and s2, and then makes s1 wait for s2 to finish before continuing.",
            "code": "import paddle\npaddle.set_device('custom_cpu')\ns1 = paddle.device.Stream()\ns2 = paddle.device.Stream()\ns1.wait_stream(s2)",
            "masked_code": "import paddle\npaddle.set_device('custom_cpu')\ns1 = paddle.device.Stream()\ns2 = paddle.device.Stream()\n<line_mask>",
            "masked_line": "s1.wait_stream(s2)",
            "answer": "wait_stream",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_446"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==2.5.0",
            "time": "2023-06-19",
            "description": "The code sets up a custom CPU device using PaddlePaddle, creates a stream, records an event e1 in the stream, and creates and records another event e2 using a separate event object.",
            "code": "import paddle\npaddle.set_device('custom_cpu')\ns = paddle.device.Stream()\ne1 = s.record_event()\n\ne2 = paddle.device.Event()\ns.record_event(e2)",
            "masked_code": "import paddle\npaddle.set_device('custom_cpu')\ns = paddle.device.Stream()\ne1 = s.record_event()\n\ne2 = paddle.device.Event()\n<line_mask>",
            "masked_line": "s.record_event(e2)",
            "answer": "record_event",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_447"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==2.5.0",
            "time": "2023-06-19",
            "description": "The code creates two sets of data with shape [20] and adds them together to create a new set of data. It then waits for the default stream to finish before adding the original data1 set to the new data set.",
            "code": "import paddle\n\npaddle.set_device('custom_cpu')\ns = paddle.device.Stream()\ndata1 = paddle.ones(shape=[20])\ndata2 = paddle.ones(shape=[20])\ndata3 = data1 + data2\nwith paddle.device.stream_guard(s):\n    s.wait_stream(paddle.device.default_stream())\n    data4 = data1 + data3",
            "masked_code": "import paddle\n\npaddle.set_device('custom_cpu')\ns = paddle.device.Stream()\ndata1 = paddle.ones(shape=[20])\ndata2 = paddle.ones(shape=[20])\ndata3 = data1 + data2\n<line_mask>\n    s.wait_stream(paddle.device.default_stream())\n    data4 = data1 + data3",
            "masked_line": "with paddle.device.stream_guard(s):",
            "answer": "stream_guard",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_448"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==2.5.0",
            "time": "2023-06-19",
            "description": "The code initializes a parallel environment using PaddlePaddle and defines an orthogonal strategy for distributed training with data parallelism (DP), model parallelism (MP), and pipeline parallelism (PP) of 2 processes each, with a fused strategy dict for checking MP and PP processes.",
            "code": "import paddle\nimport paddle.distributed as dist\nfrom paddle.distributed.fleet.base.strategy_group import DPGroup, MPGroup, PPGroup\nfrom paddle.distributed.fleet.base.orthogonal_strategy import OrthogonalStrategy\n\ndist.init_parallel_env()\nstrategy = OrthogonalStrategy([(\"dp\", 2, DPGroup), (\"mp\", 2, MPGroup), (\"pp\", 2, PPGroup)], fused_strategy_dict={\"check\": [\"mp\", \"pp\"]})",
            "masked_code": "import paddle\nimport paddle.distributed as dist\nfrom paddle.distributed.fleet.base.strategy_group import DPGroup, MPGroup, PPGroup\nfrom paddle.distributed.fleet.base.orthogonal_strategy import OrthogonalStrategy\n\ndist.init_parallel_env()\n<line_mask>",
            "masked_line": "strategy = OrthogonalStrategy([(\"dp\", 2, DPGroup), (\"mp\", 2, MPGroup), (\"pp\", 2, PPGroup)], fused_strategy_dict={\"check\": [\"mp\", \"pp\"]})",
            "answer": "OrthogonalStrategy",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_449"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==2.5.0",
            "time": "2023-06-19",
            "description": "The code initializes a parallel environment using paddle.distributed, defines a strategy group consisting of two subgroups [0, 1] and [2, 3], and then prints the world size of the strategy group, which is 2.",
            "code": "import paddle.distributed as dist\nfrom paddle.distributed.fleet.base.strategy_group import StrategyGroupBase\n\ndist.init_parallel_env()\nstrategy_group = dist.fleet.base.strategy_group.StrategyGroupBase([[0, 1], [2, 3]])\nprint(strategy_group.world_size)  # 2",
            "masked_code": "import paddle.distributed as dist\nfrom paddle.distributed.fleet.base.strategy_group import StrategyGroupBase\n\ndist.init_parallel_env()\n<line_mask>\nprint(strategy_group.world_size)  # 2",
            "masked_line": "strategy_group = dist.fleet.base.strategy_group.StrategyGroupBase([[0, 1], [2, 3]])",
            "answer": "StrategyGroupBase",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_450"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==2.5.0",
            "time": "2023-06-19",
            "description": "The code generates random samples from Bernoulli distributions with different probabilities and shapes.",
            "code": "import paddle\nfrom paddle.distribution import Bernoulli\n\nrv = Bernoulli(paddle.full((), 0.3))\nprint(rv.sample([100]).shape)\n\nrv = Bernoulli(paddle.to_tensor(0.3))\nprint(rv.sample([100]).shape)\n\nrv = Bernoulli(paddle.to_tensor([0.3, 0.5]))\nprint(rv.sample([100]).shape)\n\nrv = Bernoulli(paddle.to_tensor([0.3, 0.5]))\nprint(rv.sample([100, 2]).shape)",
            "masked_code": "import paddle\nfrom paddle.distribution import Bernoulli\n\nrv = Bernoulli(paddle.full((), 0.3))\nprint(rv.sample([100]).shape)\n\nrv = Bernoulli(paddle.to_tensor(0.3))\nprint(rv.sample([100]).shape)\n\nrv = Bernoulli(paddle.to_tensor([0.3, 0.5]))\nprint(rv.sample([100]).shape)\n\nrv = Bernoulli(paddle.to_tensor([0.3, 0.5]))\n<line_mask>",
            "masked_line": "print(rv.sample([100, 2]).shape)",
            "answer": "sample",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_451"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==2.5.0",
            "time": "2023-06-19",
            "description": "The code initializes a Cauchy distribution with a specific location and scale parameter. It then computes the entropy of the distribution and prints the result.",
            "code": "import paddle\nfrom paddle.distribution import Cauchy\n\n# init Cauchy with float\nrv = Cauchy(loc=0.1, scale=1.2)\nprint(rv.entropy())\n# Tensor(shape=[], dtype=float32, place=Place(cpu), stop_gradient=True,\n#        2.71334577)\n\n# init Cauchy with N-Dim tensor\nrv = Cauchy(loc=paddle.to_tensor(0.1), scale=paddle.to_tensor([1.0, 2.0]))\nprint(rv.entropy())\n# Tensor(shape=[2], dtype=float32, place=Place(cpu), stop_gradient=True,\n#        [2.53102422, 3.22417140])",
            "masked_code": "import paddle\n<line_mask>\n\n# init Cauchy with float\nrv = Cauchy(loc=0.1, scale=1.2)\nprint(rv.entropy())\n# Tensor(shape=[], dtype=float32, place=Place(cpu), stop_gradient=True,\n#        2.71334577)\n\n# init Cauchy with N-Dim tensor\nrv = Cauchy(loc=paddle.to_tensor(0.1), scale=paddle.to_tensor([1.0, 2.0]))\nprint(rv.entropy())\n# Tensor(shape=[2], dtype=float32, place=Place(cpu), stop_gradient=True,\n#        [2.53102422, 3.22417140])",
            "masked_line": "from paddle.distribution import Cauchy",
            "answer": "Cauchy",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_452"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==2.5.0",
            "time": "2023-06-19",
            "description": "This code snippet initializes Cauchy distributions with specified parameters and calculates the cumulative distribution function (CDF) of the Cauchy distribution for given input values. It demonstrates the usage of Cauchy distributions in probability and statistics calculations with PaddlePaddle.",
            "code": "import paddle\nfrom paddle.distribution import Cauchy\n\n# init Cauchy with float\nrv = Cauchy(loc=0.1, scale=1.2)\nprint(rv.cdf(paddle.to_tensor(1.5)))\n\n# broadcast to value\nrv = Cauchy(loc=0.1, scale=1.2)\nprint(rv.cdf(paddle.to_tensor([1.5, 5.1])))\n\n# init Cauchy with N-Dim tensor\nrv = Cauchy(loc=paddle.to_tensor([0.1, 0.1]), scale=paddle.to_tensor([1.0, 2.0]))\nprint(rv.cdf(paddle.to_tensor([1.5, 5.1])))\n\n# init Cauchy with N-Dim tensor with broadcast\nrv = Cauchy(loc=paddle.to_tensor(0.1), scale=paddle.to_tensor([1.0, 2.0]))\nprint(rv.cdf(paddle.to_tensor([1.5, 5.1])))\n\n",
            "masked_code": "import paddle\nfrom paddle.distribution import Cauchy\n\n# init Cauchy with float\nrv = Cauchy(loc=0.1, scale=1.2)\nprint(rv.cdf(paddle.to_tensor(1.5)))\n\n# broadcast to value\nrv = Cauchy(loc=0.1, scale=1.2)\nprint(rv.cdf(paddle.to_tensor([1.5, 5.1])))\n\n# init Cauchy with N-Dim tensor\nrv = Cauchy(loc=paddle.to_tensor([0.1, 0.1]), scale=paddle.to_tensor([1.0, 2.0]))\n<line_mask>\n\n# init Cauchy with N-Dim tensor with broadcast\nrv = Cauchy(loc=paddle.to_tensor(0.1), scale=paddle.to_tensor([1.0, 2.0]))\nprint(rv.cdf(paddle.to_tensor([1.5, 5.1])))\n\n",
            "masked_line": "print(rv.cdf(paddle.to_tensor([1.5, 5.1])))",
            "answer": "cdf",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_453"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==2.5.0",
            "time": "2023-06-19",
            "description": "The code initializes Cauchy distributions with specified location and scale parameters, and then calculates the entropy of the distributions.",
            "code": "import paddle\nfrom paddle.distribution import Cauchy\n\n# init Cauchy with float\nrv = Cauchy(loc=0.1, scale=1.2)\nprint(rv.entropy())\n\n# init Cauchy with N-Dim tensor\nrv = Cauchy(loc=paddle.to_tensor(0.1), scale=paddle.to_tensor([1.0, 2.0]))\nprint(rv.entropy())",
            "masked_code": "import paddle\nfrom paddle.distribution import Cauchy\n\n# init Cauchy with float\nrv = Cauchy(loc=0.1, scale=1.2)\nprint(rv.entropy())\n\n# init Cauchy with N-Dim tensor\nrv = Cauchy(loc=paddle.to_tensor(0.1), scale=paddle.to_tensor([1.0, 2.0]))\n<line_mask>",
            "masked_line": "print(rv.entropy())",
            "answer": "entropy",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_454"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==2.5.0",
            "time": "2023-06-19",
            "description": "Calculate the Kullback-Leibler divergence between two Cauchy distributions with different parameters.",
            "code": "import paddle\nfrom paddle.distribution import Cauchy\n\nrv = Cauchy(loc=0.1, scale=1.2)\nrv_other = Cauchy(loc=paddle.to_tensor(1.2), scale=paddle.to_tensor([2.3, 3.4]))\nprint(rv.kl_divergence(rv_other))",
            "masked_code": "import paddle\nfrom paddle.distribution import Cauchy\n\nrv = Cauchy(loc=0.1, scale=1.2)\nrv_other = Cauchy(loc=paddle.to_tensor(1.2), scale=paddle.to_tensor([2.3, 3.4]))\n<line_mask>",
            "masked_line": "print(rv.kl_divergence(rv_other))",
            "answer": "kl_divergence",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_455"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==2.5.0",
            "time": "2023-06-19",
            "description": "This code performs a fused operation of dropout and element-wise addition on two input tensors x and y with a dropout probability of 0.5.",
            "code": "import paddle\nfrom paddle.incubate.nn.layer.fused_dropout_add import FusedDropoutAdd\n\nx = paddle.to_tensor([[1,2,3], [4,5,6]], dtype=\"float32\")\ny = paddle.to_tensor([[1,2,3], [4,5,6]], dtype=\"float32\")\n\nm = FusedDropoutAdd(p=0.5)\n\nout = m(x, y)",
            "masked_code": "import paddle\nfrom paddle.incubate.nn.layer.fused_dropout_add import FusedDropoutAdd\n\nx = paddle.to_tensor([[1,2,3], [4,5,6]], dtype=\"float32\")\ny = paddle.to_tensor([[1,2,3], [4,5,6]], dtype=\"float32\")\n\n<line_mask>\n\nout = m(x, y)",
            "masked_line": "m = FusedDropoutAdd(p=0.5)",
            "answer": "FusedDropoutAdd",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_456"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==2.5.0",
            "time": "2023-06-19",
            "description": "The code creates a FusedDropout layer with a dropout probability of 0.5 and applies it to the input tensor 'x' to generate an output tensor 'y_train'. It then switches the FusedDropout layer to test phase and applies it again to 'x' to generate another output tensor 'y_test'.",
            "code": "import paddle\n\nx = paddle.to_tensor([[1, 2, 3], [4, 5, 6]], dtype=\"float32\")\nm = paddle.incubate.nn.FusedDropout(p=0.5)\n\ny_train = m(x)\nprint(y_train)\n\nm.eval()  # switch the model to test phase\ny_test = m(x)\nprint(y_test)",
            "masked_code": "import paddle\n\nx = paddle.to_tensor([[1, 2, 3], [4, 5, 6]], dtype=\"float32\")\n<line_mask>\n\ny_train = m(x)\nprint(y_train)\n\nm.eval()  # switch the model to test phase\ny_test = m(x)\nprint(y_test)",
            "masked_line": "m = paddle.incubate.nn.FusedDropout(p=0.5)",
            "answer": "FusedDropout",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_457"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==2.5.0",
            "time": "2023-06-19",
            "description": "This code segment implements a fused expert-controlled mixture of experts neural network layer in Python using the PaddlePaddle framework. The FusedEcMoe layer takes input tensors x and gate with shapes [batch_size, sequence_length, d_model] and [batch_size, sequence_length, num_experts] respectively, and applies a mixture of experts operation with 8 experts and GELU activation function to produce an output tensor y with shape [batch_size, sequence_length, d_model].",
            "code": "import paddle\nfrom paddle.incubate.nn.layer.fused_ec_moe import FusedEcMoe\n\nx = paddle.randn([10, 128, 1024]) # [bsz, seq_len, d_model]\ngate = paddle.randn([10, 128, 8]) # [bsz, seq_len, num_experts]\nmoe = FusedEcMoe(1024, 4096, 8, act_type=\"gelu\")\ny = moe(x, gate)\nprint(y.shape) # [10, 128, 1024]",
            "masked_code": "import paddle\n<line_mask>\n\nx = paddle.randn([10, 128, 1024]) # [bsz, seq_len, d_model]\ngate = paddle.randn([10, 128, 8]) # [bsz, seq_len, num_experts]\nmoe = FusedEcMoe(1024, 4096, 8, act_type=\"gelu\")\ny = moe(x, gate)\nprint(y.shape) # [10, 128, 1024]",
            "masked_line": "from paddle.incubate.nn.layer.fused_ec_moe import FusedEcMoe",
            "answer": "FusedEcMoe",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_458"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==2.5.0",
            "time": "2023-06-19",
            "description": "This code unflattens a tensor of shape [4, 6, 8] into a tensor of shape [2, 3, 4, 6, 8] along the given axis 1.",
            "code": "import paddle\n\nx = paddle.randn(shape=[4, 6, 8])\nshape = [2, 3]\naxis = 1\nunflatten = paddle.nn.Unflatten(axis, shape)\nres = unflatten(x)\nprint(res.shape)",
            "masked_code": "import paddle\n\nx = paddle.randn(shape=[4, 6, 8])\nshape = [2, 3]\naxis = 1\n<line_mask>\nres = unflatten(x)\nprint(res.shape)",
            "masked_line": "unflatten = paddle.nn.Unflatten(axis, shape)",
            "answer": "Unflatten",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_459"
        },
        {
            "dependency": "pandas",
            "version": "==0.12.0",
            "time": "2013-07-24",
            "description": "The code retrieves option data for AAPL stock, including calls and puts for a specified month and year. It then calculates calls near the stock price with a specified range. Finally, it gets forward data for calls and puts with a specified month.",
            "code": "aapl = Options('aapl', 'yahoo')\ncalls = aapl.get_calls(9, 2012)\nputs = aapl.get_puts(9, 2012)\ncut_calls = aapl.get_near_stock_price(calls, above_below=3)\nforward_calls, forward_puts = aapl.get_forward_data(8, call=True, put=True)",
            "masked_code": "<line_mask>\ncalls = aapl.get_calls(9, 2012)\nputs = aapl.get_puts(9, 2012)\ncut_calls = aapl.get_near_stock_price(calls, above_below=3)\nforward_calls, forward_puts = aapl.get_forward_data(8, call=True, put=True)",
            "masked_line": "aapl = Options('aapl', 'yahoo')",
            "answer": "Options",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_460"
        },
        {
            "dependency": "pandas",
            "version": "==0.12.0",
            "time": "2013-07-24",
            "description": "This code sets and modifies the display font options for pandas, specifically changing the font color to red and size to 6pt.",
            "code": "import pandas.core.config as cf\nwith cf.config_prefix(\"display.font\"):\n    cf.register_option(\"color\", \"red\")\n    cf.register_option(\"size\", \" 5 pt\")\n    cf.set_option(size, \" 6 pt\")\n    cf.get_option(size)",
            "masked_code": "import pandas.core.config as cf\n<line_mask>\n    cf.register_option(\"color\", \"red\")\n    cf.register_option(\"size\", \" 5 pt\")\n    cf.set_option(size, \" 6 pt\")\n    cf.get_option(size)",
            "masked_line": "with cf.config_prefix(\"display.font\"):",
            "answer": "config_prefix",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_461"
        },
        {
            "dependency": "pandas",
            "version": "==0.12.0",
            "time": "2013-07-24",
            "description": "The code reads financial data for Goldman Sachs (GS), the VIX volatility index, and various Fama-French factors and portfolios.",
            "code": "gs = DataReader(\"GS\", \"yahoo\")\nvix = DataReader(\"VIXCLS\", \"fred\")\nff = DataReader(\"F-F_Research_Data_Factors\", \"famafrench\")\nff = DataReader(\"F-F_Research_Data_Factors_weekly\", \"famafrench\")\nff = DataReader(\"6_Portfolios_2x3\", \"famafrench\")\nff = DataReader(\"F-F_ST_Reversal_Factor\", \"famafrench\")",
            "masked_code": "gs = DataReader(\"GS\", \"yahoo\")\nvix = DataReader(\"VIXCLS\", \"fred\")\nff = DataReader(\"F-F_Research_Data_Factors\", \"famafrench\")\nff = DataReader(\"F-F_Research_Data_Factors_weekly\", \"famafrench\")\nff = DataReader(\"6_Portfolios_2x3\", \"famafrench\")\n<line_mask>",
            "masked_line": "ff = DataReader(\"F-F_ST_Reversal_Factor\", \"famafrench\")",
            "answer": "DataReader",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_462"
        },
        {
            "dependency": "pandas",
            "version": "==0.12.0",
            "time": "2013-07-24",
            "description": "This code reads a CSV file containing the Iris dataset, then creates a parallel coordinates plot using the 'Name' column and specifies color codes for different categories. Finally, it displays the plot using matplotlib.",
            "code": "from pandas import read_csv\nfrom pandas.tools.plotting import parallel_coordinates\nfrom matplotlib import pyplot as plt\ndf = read_csv('https://raw.github.com/pydata/pandas/master/pandas/tests/data/iris.csv')\nparallel_coordinates(df, 'Name', colors=('#556270', '#4ECDC4', '#C7F464'))\nplt.show()",
            "masked_code": "from pandas import read_csv\nfrom pandas.tools.plotting import parallel_coordinates\nfrom matplotlib import pyplot as plt\ndf = read_csv('https://raw.github.com/pydata/pandas/master/pandas/tests/data/iris.csv')\n<line_mask>\nplt.show()",
            "masked_line": "parallel_coordinates(df, 'Name', colors=('#556270', '#4ECDC4', '#C7F464'))",
            "answer": "parallel_coordinates",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_463"
        },
        {
            "dependency": "pandas",
            "version": "==0.12.0",
            "time": "2013-07-24",
            "description": "The code defines two test functions using a decorator that checks for internet connectivity before running the test. The first test function, test_something_with_yahoo, raises an IOError with a failure message. The second test function, test_something, prints \"I ran!\" and raises a ValueError to simulate a failure.",
            "code": "@with_connectivity_check(\"http://www.yahoo.com\")\ndef test_something_with_yahoo():\n    raise IOError(\"Failure Message\")\n\n@with_connectivity_check(\"failing://url.blaher\", check_before_test=True)\ndef test_something():\n    print(\"I ran!\")\n    raise ValueError(\"Failure\")",
            "masked_code": "<line_mask>\ndef test_something_with_yahoo():\n    raise IOError(\"Failure Message\")\n\n@with_connectivity_check(\"failing://url.blaher\", check_before_test=True)\ndef test_something():\n    print(\"I ran!\")\n    raise ValueError(\"Failure\")",
            "masked_line": "@with_connectivity_check(\"http://www.yahoo.com\")",
            "answer": "with_connectivity_check",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_464"
        },
        {
            "dependency": "pandas",
            "version": "==0.12.0",
            "time": "2013-07-24",
            "description": "The code asserts that specific exceptions are raised with particular error messages for different scenarios involving the use of the `int` function, regular expressions, and dictionary operations.",
            "code": "assertRaisesRegexp(ValueError, 'invalid literal for.*XYZ', int, 'XYZ')\nimport re\nassertRaisesRegexp(ValueError, re.compile('literal'), int, 'XYZ')\nassertRaisesRegexp(TypeError, 'literal', int, 'XYZ')\ndct = {}\nassertRaisesRegexp(KeyError, 'apple', dct.__getitem__, 'apple')\nassertRaisesRegexp(Exception, 'operand type.*int.*dict', lambda : 2 + {})",
            "masked_code": "<line_mask>\nimport re\nassertRaisesRegexp(ValueError, re.compile('literal'), int, 'XYZ')\nassertRaisesRegexp(TypeError, 'literal', int, 'XYZ')\ndct = {}\nassertRaisesRegexp(KeyError, 'apple', dct.__getitem__, 'apple')\nassertRaisesRegexp(Exception, 'operand type.*int.*dict', lambda : 2 + {})",
            "masked_line": "assertRaisesRegexp(ValueError, 'invalid literal for.*XYZ', int, 'XYZ')",
            "answer": "assertRaisesRegexp",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_465"
        },
        {
            "dependency": "pandas",
            "version": "==0.13.0",
            "time": "2013-12-30",
            "description": "The code generates a DataFrame with 10 rows and 2 columns filled with random numbers, then filters the DataFrame rows where the values in column 'a' are greater than the values in column 'b'.",
            "code": "from numpy.random import randn\nfrom pandas import DataFrame\ndf = DataFrame(randn(10, 2), columns=list('ab'))\ndf.query('a > b')\ndf[df.a > df.b]  # same result as the previous expression\n",
            "masked_code": "from numpy.random import randn\nfrom pandas import DataFrame\ndf = DataFrame(randn(10, 2), columns=list('ab'))\n<line_mask>\ndf[df.a > df.b]  # same result as the previous expression\n",
            "masked_line": "df.query('a > b')",
            "answer": "query",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_466"
        },
        {
            "dependency": "pandas",
            "version": "==0.13.0",
            "time": "2013-12-30",
            "description": "This code creates a MultiIndex series and then unstacks it along different levels to convert it into a DataFrame.",
            "code": "index = pd.MultiIndex.from_tuples([('one', 'a'), ('one', 'b'),\n                                   ('two', 'a'), ('two', 'b')])\ns = pd.Series(np.arange(1.0, 5.0), index=index)\ns.unstack(level=-1)\ns.unstack(level=0)\ndf = s.unstack(level=0)\ndf.unstack()\n",
            "masked_code": "index = pd.MultiIndex.from_tuples([('one', 'a'), ('one', 'b'),\n                                   ('two', 'a'), ('two', 'b')])\ns = pd.Series(np.arange(1.0, 5.0), index=index)\ns.unstack(level=-1)\ns.unstack(level=0)\n<line_mask>\ndf.unstack()\n",
            "masked_line": "df = s.unstack(level=0)",
            "answer": "unstack",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_467"
        },
        {
            "dependency": "pandas",
            "version": "==0.13.0",
            "time": "2013-12-30",
            "description": "The code checks if the values in a DataFrame match the specified values or are present in another DataFrame.",
            "code": "df = DataFrame({'A': [1, 2, 3], 'B': ['a', 'b', 'f']})\ndf.isin([1, 3, 12, 'a'])\n\ndf = DataFrame({'A': [1, 2, 3], 'B': [1, 4, 7]})\ndf.isin({'A': [1, 3], 'B': [4, 7, 12]})\n\ndf = DataFrame({'A': [1, 2, 3], 'B': ['a', 'b', 'f']})\nother = DataFrame({'A': [1, 3, 3, 2], 'B': ['e', 'f', 'f', 'e']})\ndf.isin(other)\n",
            "masked_code": "df = DataFrame({'A': [1, 2, 3], 'B': ['a', 'b', 'f']})\ndf.isin([1, 3, 12, 'a'])\n\ndf = DataFrame({'A': [1, 2, 3], 'B': [1, 4, 7]})\n<line_mask>\n\ndf = DataFrame({'A': [1, 2, 3], 'B': ['a', 'b', 'f']})\nother = DataFrame({'A': [1, 3, 3, 2], 'B': ['e', 'f', 'f', 'e']})\ndf.isin(other)\n",
            "masked_line": "df.isin({'A': [1, 3], 'B': [4, 7, 12]})",
            "answer": "isin",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_468"
        },
        {
            "dependency": "pandas",
            "version": "==0.13.0",
            "time": "2013-12-30",
            "description": "Calculate the product of all prime factors listed in the Counter dictionary and return the result.",
            "code": "c = Counter('ABCABC')\nsorted(c.elements())\n['A', 'A', 'B', 'B', 'C', 'C']\n\nprime_factors = Counter({2: 2, 3: 3, 17: 1})\nproduct = 1\nfor factor in prime_factors.elements():     \n    product *= factor                       \nproduct\n1836",
            "masked_code": "c = Counter('ABCABC')\n<line_mask>\n['A', 'A', 'B', 'B', 'C', 'C']\n\nprime_factors = Counter({2: 2, 3: 3, 17: 1})\nproduct = 1\nfor factor in prime_factors.elements():     \n    product *= factor                       \nproduct\n1836",
            "masked_line": "sorted(c.elements())",
            "answer": "elements",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_469"
        },
        {
            "dependency": "pandas",
            "version": "==0.13.0",
            "time": "2013-12-30",
            "description": "This code creates two Counter objects 'c' and 'd' which count the occurrences of each character in the strings 'which' and 'watch', updates the counter objects with the characters from the string 'witch' and the Counter object 'd', and finally returns the count of the character 'h' in Counter object 'c', which is 4.",
            "code": "c = Counter('which')\nc.update('witch')\nd = Counter('watch')\nc.update(d)\nc['h']\n4",
            "masked_code": "c = Counter('which')\n<line_mask>\nd = Counter('watch')\nc.update(d)\nc['h']\n4",
            "masked_line": "c.update('witch')",
            "answer": "update",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_470"
        },
        {
            "dependency": "pandas",
            "version": "==0.13.0",
            "time": "2013-12-30",
            "description": "The code subtracts the occurrences of characters in the string 'witch' and the Counter object {'w': 1, 'a': 1, 't': 1, 'c': 1, 'h': 1} from the Counter object created from the string 'which'. It then retrieves the counts of the characters 'h' and 'w' from the Counter object.",
            "code": "c = Counter('which')\nc.subtract('witch')\nc.subtract(Counter('watch'))\nc['h']\nc['w']",
            "masked_code": "c = Counter('which')\nc.subtract('witch')\n<line_mask>\nc['h']\nc['w']",
            "masked_line": "c.subtract(Counter('watch'))",
            "answer": "subtract",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_471"
        },
        {
            "dependency": "pandas",
            "version": "==0.15.2",
            "time": "2014-12-11",
            "description": "The code creates a tuple containing an empty list and assigns it to the variable 'a'. It then checks if 'a' is hashable, which returns True. However, a custom function 'is_hashable' is called on 'a' which returns False.",
            "code": "a = ([],)\nisinstance(a, collections.Hashable)\nTrue\nis_hashable(a)\nFalse",
            "masked_code": "a = ([],)\nisinstance(a, collections.Hashable)\nTrue\n<line_mask>\nFalse",
            "masked_line": "is_hashable(a)",
            "answer": "is_hashable",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_472"
        },
        {
            "dependency": "pandas",
            "version": "==0.16.0",
            "time": "2015-03-22",
            "description": "The code converts a pandas Series object with some NaN values into a sparse pandas Series, then further converts it into a COO (Coordinate Format) representation with specified row and column levels and sorted labels.",
            "code": "from numpy import nan\ns = Series([3.0, nan, 1.0, 3.0, nan, nan])\ns.index = MultiIndex.from_tuples([(1, 2, 'a', 0),\n                                  (1, 2, 'a', 1),\n                                  (1, 1, 'b', 0),\n                                  (1, 1, 'b', 1),\n                                  (2, 1, 'b', 0),\n                                  (2, 1, 'b', 1)],\n                                  names=['A', 'B', 'C', 'D'])\nss = s.to_sparse()\nA, rows, columns = ss.to_coo(row_levels=['A', 'B'],\n                             column_levels=['C', 'D'],\n                             sort_labels=True)",
            "masked_code": "from numpy import nan\ns = Series([3.0, nan, 1.0, 3.0, nan, nan])\ns.index = MultiIndex.from_tuples([(1, 2, 'a', 0),\n                                  (1, 2, 'a', 1),\n                                  (1, 1, 'b', 0),\n                                  (1, 1, 'b', 1),\n                                  (2, 1, 'b', 0),\n                                  (2, 1, 'b', 1)],\n                                  names=['A', 'B', 'C', 'D'])\nss = s.to_sparse()\n<line_mask>\n                             column_levels=['C', 'D'],\n                             sort_labels=True)",
            "masked_line": "A, rows, columns = ss.to_coo(row_levels=['A', 'B'],",
            "answer": "to_coo",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_473"
        },
        {
            "dependency": "pandas",
            "version": "==0.18.0",
            "time": "2016-03-11",
            "description": "The first block of code creates a DataFrame with columns 'A', 'B', and 'C', then converts it to an xarray.\n\nThe second block of code creates a DataFrame with columns 'A', 'B', and 'C', sets the index to be a MultiIndex using columns 'B' and 'A', and then converts it to an xarray.\n\nThe third block of code creates a Panel with item axis 'A', 'B', 'C', and 'D', major axis as a date range from '20130101' with 3 periods, and minor axis 'first' and 'second', then converts it to an xarray.",
            "code": "df = pd.DataFrame({'A' : [1, 1, 2],\n                   'B' : ['foo', 'bar', 'foo'],\n                   'C' : np.arange(4.,7)})\ndf.to_xarray()\n\ndf = pd.DataFrame({'A' : [1, 1, 2],\n                   'B' : ['foo', 'bar', 'foo'],\n                   'C' : np.arange(4.,7)}\n                 ).set_index(['B','A'])\ndf.to_xarray()\n\np = pd.Panel(np.arange(24).reshape(4,3,2),\n             items=list('ABCD'),\n             major_axis=pd.date_range('20130101', periods=3),\n             minor_axis=['first', 'second'])\np.to_xarray()",
            "masked_code": "df = pd.DataFrame({'A' : [1, 1, 2],\n                   'B' : ['foo', 'bar', 'foo'],\n                   'C' : np.arange(4.,7)})\ndf.to_xarray()\n\ndf = pd.DataFrame({'A' : [1, 1, 2],\n                   'B' : ['foo', 'bar', 'foo'],\n                   'C' : np.arange(4.,7)}\n                 ).set_index(['B','A'])\n<line_mask>\n\np = pd.Panel(np.arange(24).reshape(4,3,2),\n             items=list('ABCD'),\n             major_axis=pd.date_range('20130101', periods=3),\n             minor_axis=['first', 'second'])\np.to_xarray()",
            "masked_line": "df.to_xarray()",
            "answer": "to_xarray",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_474"
        },
        {
            "dependency": "pandas",
            "version": "==0.18.1",
            "time": "2016-05-03",
            "description": "The code fetches options data for the stock AAPL from Yahoo Finance, including call and put data for the next expiry, call data within 3 strikes below and above the stock price, call and put data with expiry from now to 8 months out, and all call and put data available.",
            "code": "# Instantiate object with ticker\naapl = Options('aapl', 'yahoo')\n\n# Fetch next expiry call data\ncalls = aapl.get_call_data()\n\n# Fetch next expiry put data\nputs = aapl.get_put_data()\n\n# cut down the call data to be 3 below and 3 above the stock price.\ncut_calls = aapl.get_near_stock_price(call=True, above_below=3)\n\n# Fetch call and put data with expiry from now to 8 months out\nforward_data = aapl.get_forward_data(8, call=True, put=True)\n\n# Fetch all call and put data\nall_data = aapl.get_all_data()\n",
            "masked_code": "# Instantiate object with ticker\n<line_mask>\n\n# Fetch next expiry call data\ncalls = aapl.get_call_data()\n\n# Fetch next expiry put data\nputs = aapl.get_put_data()\n\n# cut down the call data to be 3 below and 3 above the stock price.\ncut_calls = aapl.get_near_stock_price(call=True, above_below=3)\n\n# Fetch call and put data with expiry from now to 8 months out\nforward_data = aapl.get_forward_data(8, call=True, put=True)\n\n# Fetch all call and put data\nall_data = aapl.get_all_data()\n",
            "masked_line": "aapl = Options('aapl', 'yahoo')",
            "answer": "Options",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_475"
        },
        {
            "dependency": "pandas",
            "version": "==0.20.0",
            "time": "2017-05-05",
            "description": "The function is_object_dtype determines whether the input data type is of type object. It returns True if the input data type is object, and False otherwise.",
            "code": "is_object_dtype(object)\nTrue\nis_object_dtype(int)\nFalse\nis_object_dtype(np.array([], dtype=object))\nTrue\nis_object_dtype(np.array([], dtype=int))\nFalse\nis_object_dtype([1, 2, 3])\nFalse",
            "masked_code": "is_object_dtype(object)\nTrue\nis_object_dtype(int)\nFalse\nis_object_dtype(np.array([], dtype=object))\nTrue\nis_object_dtype(np.array([], dtype=int))\nFalse\n<line_mask>\nFalse",
            "masked_line": "is_object_dtype([1, 2, 3])",
            "answer": "is_object_dtype",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_476"
        },
        {
            "dependency": "pandas",
            "version": "==0.20.0",
            "time": "2017-05-05",
            "description": "The code checks if the input object is of a categorical data type.",
            "code": "is_categorical_dtype(object)\nis_categorical_dtype(CategoricalDtype())\nis_categorical_dtype([1, 2, 3])\nis_categorical_dtype(pd.Categorical([1, 2, 3]))\nis_categorical_dtype(pd.CategoricalIndex([1, 2, 3]) )",
            "masked_code": "<line_mask>\nis_categorical_dtype(CategoricalDtype())\nis_categorical_dtype([1, 2, 3])\nis_categorical_dtype(pd.Categorical([1, 2, 3]))\nis_categorical_dtype(pd.CategoricalIndex([1, 2, 3]) )",
            "masked_line": "is_categorical_dtype(object)",
            "answer": "is_categorical_dtype",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_477"
        },
        {
            "dependency": "pandas",
            "version": "==0.20.0",
            "time": "2017-05-05",
            "description": "The function is_string_dtype checks if the input data type is a string type (str) and returns True if it is, False if it is not.",
            "code": "is_string_dtype(str)\nTrue\nis_string_dtype(object)\nTrue\nis_string_dtype(int)\nFalse\nis_string_dtype(np.array(['a', 'b']))\nTrue\nis_string_dtype(pd.Series([1, 2]))\nFalse",
            "masked_code": "is_string_dtype(str)\nTrue\nis_string_dtype(object)\nTrue\nis_string_dtype(int)\nFalse\nis_string_dtype(np.array(['a', 'b']))\nTrue\n<line_mask>\nFalse",
            "masked_line": "is_string_dtype(pd.Series([1, 2]))",
            "answer": "is_string_dtype",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_478"
        },
        {
            "dependency": "pandas",
            "version": "==0.20.0",
            "time": "2017-05-05",
            "description": "The code checks whether the input data type is a signed integer.",
            "code": "is_signed_integer_dtype(int)\nis_signed_integer_dtype(float)\nis_signed_integer_dtype(np.uint64)  # unsigned\nis_signed_integer_dtype(np.datetime64)\nis_signed_integer_dtype(np.timedelta64)\nis_signed_integer_dtype(np.array(['a', 'b']))\nis_signed_integer_dtype(pd.Series([1, 2]))\nis_signed_integer_dtype(np.array([], dtype=np.timedelta64))\nis_signed_integer_dtype(pd.Index([1, 2.]))  # float\nis_signed_integer_dtype(np.array([1, 2], dtype=np.uint32))  # unsigned",
            "masked_code": "is_signed_integer_dtype(int)\nis_signed_integer_dtype(float)\nis_signed_integer_dtype(np.uint64)  # unsigned\nis_signed_integer_dtype(np.datetime64)\n<line_mask>\nis_signed_integer_dtype(np.array(['a', 'b']))\nis_signed_integer_dtype(pd.Series([1, 2]))\nis_signed_integer_dtype(np.array([], dtype=np.timedelta64))\nis_signed_integer_dtype(pd.Index([1, 2.]))  # float\nis_signed_integer_dtype(np.array([1, 2], dtype=np.uint32))  # unsigned",
            "masked_line": "is_signed_integer_dtype(np.timedelta64)",
            "answer": "is_signed_integer_dtype",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_479"
        },
        {
            "dependency": "pandas",
            "version": "==0.20.0",
            "time": "2017-05-05",
            "description": "The code checks if the input is a boolean type, whether it is a boolean value, a NumPy boolean type, or a NumPy array containing boolean values.",
            "code": "is_bool_dtype(bool)\nTrue\nis_bool_dtype(np.bool)\nTrue\nis_bool_dtype(np.array([True, False]))\nTrue",
            "masked_code": "is_bool_dtype(bool)\nTrue\nis_bool_dtype(np.bool)\nTrue\n<line_mask>\nTrue",
            "masked_line": "is_bool_dtype(np.array([True, False]))",
            "answer": "is_bool_dtype",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_480"
        },
        {
            "dependency": "pandas",
            "version": "==0.20.0",
            "time": "2017-05-05",
            "description": "Checks if the input is a nested list-like object.",
            "code": "is_nested_list_like([[1, 2, 3]])\nis_nested_list_like([{1, 2, 3}, {1, 2, 3}])\nis_nested_list_like([\"foo\"])\nis_nested_list_like([])\nis_nested_list_like([[1, 2, 3], 1])",
            "masked_code": "is_nested_list_like([[1, 2, 3]])\nis_nested_list_like([{1, 2, 3}, {1, 2, 3}])\nis_nested_list_like([\"foo\"])\nis_nested_list_like([])\n<line_mask>",
            "masked_line": "is_nested_list_like([[1, 2, 3], 1])",
            "answer": "is_nested_list_like",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_481"
        },
        {
            "dependency": "pandas",
            "version": "==0.20.0",
            "time": "2017-05-05",
            "description": "The code creates a named tuple called \"Point\" with fields \"x\" and \"y\", then checks if the given input is a named tuple instance and returns True if it is, otherwise returns False.",
            "code": "Point = namedtuple(\"Point\", [\"x\", \"y\"])\np = Point(1, 2)\nis_named_tuple(p)\nTrue\nis_named_tuple((1, 2))\nFalse",
            "masked_code": "Point = namedtuple(\"Point\", [\"x\", \"y\"])\np = Point(1, 2)\n<line_mask>\nTrue\nis_named_tuple((1, 2))\nFalse",
            "masked_line": "is_named_tuple(p)",
            "answer": "is_named_tuple",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_482"
        },
        {
            "dependency": "pandas",
            "version": "==0.20.0",
            "time": "2017-05-05",
            "description": "This Python code defines two functions that test printing output to stdout. The first function tests printing \"foo\" to stdout and asserts that the output is equal to \"foo\". The second function tests printing \"foo\" to stdout and asserts that the output is not equal to \"bar\".",
            "code": "@capture_stdout\ndef test_print_pass():\n    print(\"foo\")\n    out = sys.stdout.getvalue()\n    assert out == \"foo\"\n\n@capture_stdout\ndef test_print_fail():\n    print(\"foo\")\n    out = sys.stdout.getvalue()\n    assert out == \"bar\"",
            "masked_code": "<line_mask>\ndef test_print_pass():\n    print(\"foo\")\n    out = sys.stdout.getvalue()\n    assert out == \"foo\"\n\n@capture_stdout\ndef test_print_fail():\n    print(\"foo\")\n    out = sys.stdout.getvalue()\n    assert out == \"bar\"",
            "masked_line": "@capture_stdout",
            "answer": "capture_stdout",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_483"
        },
        {
            "dependency": "pandas",
            "version": "==0.20.0",
            "time": "2017-05-05",
            "description": "The functions test_stderr_pass and test_stderr_fail capture the standard error output, write \"foo\" to the standard error, get the value of the standard error, and then assert if the output is equal to \"foo\" or \"bar\" respectively.",
            "code": "@capture_stderr\ndef test_stderr_pass():\n    sys.stderr.write(\"foo\")\n    out = sys.stderr.getvalue()\n    assert out == \"foo\"\n\n@capture_stderr\ndef test_stderr_fail():\n    sys.stderr.write(\"foo\")\n    out = sys.stderr.getvalue()\n    assert out == \"bar\"",
            "masked_code": "<line_mask>\ndef test_stderr_pass():\n    sys.stderr.write(\"foo\")\n    out = sys.stderr.getvalue()\n    assert out == \"foo\"\n\n@capture_stderr\ndef test_stderr_fail():\n    sys.stderr.write(\"foo\")\n    out = sys.stderr.getvalue()\n    assert out == \"bar\"",
            "masked_line": "@capture_stderr",
            "answer": "capture_stderr",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_484"
        },
        {
            "dependency": "pandas",
            "version": "==0.21.0",
            "time": "2017-10-27",
            "description": "The function `_recode_for_categories` recodes the input array of codes based on old and new categories. It assigns the new codes for categories in the input array based on the mapping provided by the old and new categories.",
            "code": "old_cat = pd.Index(['b', 'a', 'c'])\nnew_cat = pd.Index(['a', 'b'])\ncodes = np.array([0, 1, 1, 2])\n_recode_for_categories(codes, old_cat, new_cat)\narray([ 1,  0,  0, -1])",
            "masked_code": "old_cat = pd.Index(['b', 'a', 'c'])\nnew_cat = pd.Index(['a', 'b'])\ncodes = np.array([0, 1, 1, 2])\n<line_mask>\narray([ 1,  0,  0, -1])",
            "masked_line": "_recode_for_categories(codes, old_cat, new_cat)",
            "answer": "_recode_for_categories",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_485"
        },
        {
            "dependency": "pandas",
            "version": "==0.21.0",
            "time": "2017-10-27",
            "description": "The code creates an index with the provided data in a specified format.",
            "code": "_ensure_index(['a', 'b'])\nIndex(['a', 'b'], dtype='object')\n\n_ensure_index([('a', 'a'),  ('b', 'c')])\nIndex([('a', 'a'), ('b', 'c')], dtype='object')\n\n_ensure_index([['a', 'a'], ['b', 'c']])\nMultiIndex(levels=[['a'], ['b', 'c']],\n           labels=[[0, 0], [0, 1]])",
            "masked_code": "<line_mask>\nIndex(['a', 'b'], dtype='object')\n\n_ensure_index([('a', 'a'),  ('b', 'c')])\nIndex([('a', 'a'), ('b', 'c')], dtype='object')\n\n_ensure_index([['a', 'a'], ['b', 'c']])\nMultiIndex(levels=[['a'], ['b', 'c']],\n           labels=[[0, 0], [0, 1]])",
            "masked_line": "_ensure_index(['a', 'b'])",
            "answer": "_ensure_index",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_486"
        },
        {
            "dependency": "pandas",
            "version": "==0.21.0",
            "time": "2017-10-27",
            "description": "The code renames the columns and/or index labels of a DataFrame.",
            "code": "df = pd.DataFrame({\"A\": [1, 2, 3], \"B\": [4, 5, 6]})\ndf.rename(index=str, columns={\"A\": \"a\", \"B\": \"c\"})\ndf.rename(index=str, columns={\"A\": \"a\", \"C\": \"c\"})\ndf.rename(str.lower, axis='columns')\ndf.rename({1: 2, 2: 4}, axis='index')\n",
            "masked_code": "df = pd.DataFrame({\"A\": [1, 2, 3], \"B\": [4, 5, 6]})\n<line_mask>\ndf.rename(index=str, columns={\"A\": \"a\", \"C\": \"c\"})\ndf.rename(str.lower, axis='columns')\ndf.rename({1: 2, 2: 4}, axis='index')\n",
            "masked_line": "df.rename(index=str, columns={\"A\": \"a\", \"B\": \"c\"})",
            "answer": "rename",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_487"
        },
        {
            "dependency": "pandas",
            "version": "==0.23.0",
            "time": "2018-05-15",
            "description": "The code creates a pandas DataFrame with a single column containing relatively long strings of data. It then uses StataWriter117 to write the data into a .dta file, which is a Stata data file format.",
            "code": "import pandas as pd\nfrom pandas.io.stata import StataWriter117\ndata = pd.DataFrame([[1.0, 1, 'a']], columns=['a', 'b', 'c'])\nwriter = StataWriter117('./data_file.dta', data)\nwriter.write_file()\n\ndata = pd.DataFrame([['A relatively long string'], [''], ['']],\n                    columns=['strls'])\nwriter = StataWriter117('./data_file_with_long_strings.dta', data,\n                        convert_strl=['strls'])\nwriter.write_file()\n",
            "masked_code": "import pandas as pd\nfrom pandas.io.stata import StataWriter117\ndata = pd.DataFrame([[1.0, 1, 'a']], columns=['a', 'b', 'c'])\nwriter = StataWriter117('./data_file.dta', data)\nwriter.write_file()\n\ndata = pd.DataFrame([['A relatively long string'], [''], ['']],\n                    columns=['strls'])\n<line_mask>\n                        convert_strl=['strls'])\nwriter.write_file()\n",
            "masked_line": "writer = StataWriter117('./data_file_with_long_strings.dta', data,",
            "answer": "StataWriter117",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_488"
        },
        {
            "dependency": "pandas",
            "version": "==0.23.0",
            "time": "2018-05-15",
            "description": "The code generates unique values from different types of Series data including integers, timestamps, and categorical data.",
            "code": "pd.Series([2, 1, 3, 3], name='A').unique()\npd.Series([pd.Timestamp('2016-01-01') for _ in range(3)]).unique()\npd.Series([pd.Timestamp('2016-01-01', tz='US/Eastern') for _ in range(3)]).unique()\npd.Series(pd.Categorical(list('baabc'))).unique()\npd.Series(pd.Categorical(list('baabc'), categories=list('abc'), ordered=True)).unique()",
            "masked_code": "pd.Series([2, 1, 3, 3], name='A').unique()\npd.Series([pd.Timestamp('2016-01-01') for _ in range(3)]).unique()\n<line_mask>\npd.Series(pd.Categorical(list('baabc'))).unique()\npd.Series(pd.Categorical(list('baabc'), categories=list('abc'), ordered=True)).unique()",
            "masked_line": "pd.Series([pd.Timestamp('2016-01-01', tz='US/Eastern') for _ in range(3)]).unique()",
            "answer": "unique",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_489"
        },
        {
            "dependency": "pandas",
            "version": "==0.23.0",
            "time": "2018-05-15",
            "description": "The code checks for duplicated values within the pandas Series 'animals' and returns a boolean Series indicating whether each element is a duplicate. The 'keep' parameter allows for customization on how to treat duplicate values.",
            "code": "animals = pd.Series(['lama', 'cow', 'lama', 'beetle', 'lama'])\nanimals.duplicated()\nanimals.duplicated(keep='first')\nanimals.duplicated(keep='last')\nanimals.duplicated(keep=False)",
            "masked_code": "animals = pd.Series(['lama', 'cow', 'lama', 'beetle', 'lama'])\nanimals.duplicated()\nanimals.duplicated(keep='first')\n<line_mask>\nanimals.duplicated(keep=False)",
            "masked_line": "animals.duplicated(keep='last')",
            "answer": "duplicated",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_490"
        },
        {
            "dependency": "pandas",
            "version": "==0.23.0",
            "time": "2018-05-15",
            "description": "The code determines and returns the duplicated values in the given index.",
            "code": "pd.Index([1, 2, 2, 3, 3, 3, 4]).get_duplicates()\npd.Index([1., 2., 2., 3., 3., 3., 4.]).get_duplicates()\npd.Index(['a', 'b', 'b', 'c', 'c', 'c', 'd']).get_duplicates()\ndates = pd.to_datetime(['2018-01-01', '2018-01-02', '2018-01-03',\n                        '2018-01-03', '2018-01-04', '2018-01-04'],\n                       format='%Y-%m-%d')\npd.Index(dates).get_duplicates()\npd.Index([1, 2, 3, 2, 3, 4, 3]).get_duplicates()\npd.Index([1, 2, 3, 4]).get_duplicates()\ndates = pd.to_datetime(['2018-01-01', '2018-01-02', '2018-01-03'],\n                       format='%Y-%m-%d')\npd.Index(dates).get_duplicates()",
            "masked_code": "pd.Index([1, 2, 2, 3, 3, 3, 4]).get_duplicates()\n<line_mask>\npd.Index(['a', 'b', 'b', 'c', 'c', 'c', 'd']).get_duplicates()\ndates = pd.to_datetime(['2018-01-01', '2018-01-02', '2018-01-03',\n                        '2018-01-03', '2018-01-04', '2018-01-04'],\n                       format='%Y-%m-%d')\npd.Index(dates).get_duplicates()\npd.Index([1, 2, 3, 2, 3, 4, 3]).get_duplicates()\npd.Index([1, 2, 3, 4]).get_duplicates()\ndates = pd.to_datetime(['2018-01-01', '2018-01-02', '2018-01-03'],\n                       format='%Y-%m-%d')\npd.Index(dates).get_duplicates()",
            "masked_line": "pd.Index([1., 2., 2., 3., 3., 3., 4.]).get_duplicates()",
            "answer": "get_duplicates",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_491"
        },
        {
            "dependency": "pandas",
            "version": "==0.22.0",
            "time": "2017-12-30",
            "description": "The code converts frequency codes (e.g. 'D', 'W', 'M', 'H', 'S') into timestamps based on a specified base.",
            "code": "get_to_timestamp_base(get_freq_code('D')[0])\nget_to_timestamp_base(get_freq_code('W')[0])\nget_to_timestamp_base(get_freq_code('M')[0])\nget_to_timestamp_base(get_freq_code('H')[0])\nget_to_timestamp_base(get_freq_code('S')[0] )",
            "masked_code": "get_to_timestamp_base(get_freq_code('D')[0])\nget_to_timestamp_base(get_freq_code('W')[0])\nget_to_timestamp_base(get_freq_code('M')[0])\nget_to_timestamp_base(get_freq_code('H')[0])\n<line_mask>",
            "masked_line": "get_to_timestamp_base(get_freq_code('S')[0] )",
            "answer": "get_to_timestamp_base",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_492"
        },
        {
            "dependency": "pandas",
            "version": "==0.24.0",
            "time": "2019-01-25",
            "description": "The code generates a DatetimeIndex object containing dates from January 2018 to March 2018, and then converts the month names of the dates in the index to a new Index object.",
            "code": "idx = pd.date_range(start='2018-01', freq='M', periods=3)\nidx\nDatetimeIndex(['2018-01-31', '2018-02-28', '2018-03-31'],\n              dtype='datetime64[ns]', freq='M')\nidx.month_name()\nIndex(['January', 'February', 'March'], dtype='object')",
            "masked_code": "idx = pd.date_range(start='2018-01', freq='M', periods=3)\nidx\nDatetimeIndex(['2018-01-31', '2018-02-28', '2018-03-31'],\n              dtype='datetime64[ns]', freq='M')\n<line_mask>\nIndex(['January', 'February', 'March'], dtype='object')",
            "masked_line": "idx.month_name()",
            "answer": "month_name",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_493"
        },
        {
            "dependency": "pandas",
            "version": "==0.24.0",
            "time": "2019-01-25",
            "description": "This code generates a DatetimeIndex consisting of three consecutive dates starting from '2018-01-01' with a daily frequency. Then, it retrieves the day names corresponding to each date in the DatetimeIndex.",
            "code": "idx = pd.date_range(start='2018-01-01', freq='D', periods=3)\nidx\nDatetimeIndex(['2018-01-01', '2018-01-02', '2018-01-03'],\n              dtype='datetime64[ns]', freq='D')\nidx.day_name()\nIndex(['Monday', 'Tuesday', 'Wednesday'], dtype='object')",
            "masked_code": "idx = pd.date_range(start='2018-01-01', freq='D', periods=3)\nidx\nDatetimeIndex(['2018-01-01', '2018-01-02', '2018-01-03'],\n              dtype='datetime64[ns]', freq='D')\n<line_mask>\nIndex(['Monday', 'Tuesday', 'Wednesday'], dtype='object')",
            "masked_line": "idx.day_name()",
            "answer": "day_name",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_494"
        },
        {
            "dependency": "pandas",
            "version": "==0.25.0",
            "time": "2019-07-18",
            "description": "The code creates plots using the data stored in a pandas Series and DataFrame. It generates line plots for the Series and DataFrame, with options to plot on separate subplots, customize the x and y axes, and display the type of the plot object.",
            "code": "s = pd.Series([1, 3, 2])\ns.plot.line()\n\ndf = pd.DataFrame({\n   'pig': [20, 18, 489, 675, 1776],\n   'horse': [4, 25, 281, 600, 1900]\n   }, index=[1990, 1997, 2003, 2009, 2014])\nlines = df.plot.line()\n\naxes = df.plot.line(subplots=True)\ntype(axes)\n\nlines = df.plot.line(x='pig', y='horse')\n",
            "masked_code": "s = pd.Series([1, 3, 2])\ns.plot.line()\n\ndf = pd.DataFrame({\n   'pig': [20, 18, 489, 675, 1776],\n   'horse': [4, 25, 281, 600, 1900]\n   }, index=[1990, 1997, 2003, 2009, 2014])\nlines = df.plot.line()\n\naxes = df.plot.line(subplots=True)\ntype(axes)\n\n<line_mask>\n",
            "masked_line": "lines = df.plot.line(x='pig', y='horse')",
            "answer": "line",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_495"
        },
        {
            "dependency": "pandas",
            "version": "==0.5.0",
            "time": "2011-10-25",
            "description": "The code multiplies all the elements in the Counter 'prime_factors' and returns the product, which is 1836.",
            "code": "c = Counter('ABCABC')\nsorted(c.elements())\n['A', 'A', 'B', 'B', 'C', 'C']\n\nprime_factors = Counter({2: 2, 3: 3, 17: 1})\nproduct = 1\nfor factor in prime_factors.elements():\n    product *= factor\nproduct\n1836",
            "masked_code": "c = Counter('ABCABC')\nsorted(c.elements())\n['A', 'A', 'B', 'B', 'C', 'C']\n\nprime_factors = Counter({2: 2, 3: 3, 17: 1})\nproduct = 1\n<line_mask>\n    product *= factor\nproduct\n1836",
            "masked_line": "for factor in prime_factors.elements():",
            "answer": "elements",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_496"
        },
        {
            "dependency": "pandas",
            "version": "==0.5.0",
            "time": "2011-10-25",
            "description": "The code is creating a Counter object to count the occurrences of each character in the string 'which'. Then it subtracts the counts of characters in the string 'witch' and the counts of characters in the Counter object created from the string 'watch'. Finally, it checks the count of the character 'h', which is 0, and the count of the character 'w', which is -1.",
            "code": "c = Counter('which')\nc.subtract('witch')             \nc.subtract(Counter('watch'))    \nc['h']                          \n0\nc['w']                          \n-1",
            "masked_code": "c = Counter('which')\n<line_mask>\nc.subtract(Counter('watch'))    \nc['h']                          \n0\nc['w']                          \n-1",
            "masked_line": "c.subtract('witch')",
            "answer": "subtract",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_497"
        },
        {
            "dependency": "pandas",
            "version": "==0.7.0",
            "time": "2012-02-09",
            "description": "The code generates multiple subplots with different types of plots and shares the y-axis for the first two subplots.",
            "code": "x = np.linspace(0, 2*np.pi, 400)\ny = np.sin(x**2)\n\nf, ax = plt.subplots()\nax.plot(x, y)\nax.set_title('Simple plot')\n\nf, (ax1, ax2) = plt.subplots(1, 2, sharey=True)\nax1.plot(x, y)\nax1.set_title('Sharing Y axis')\nax2.scatter(x, y)\n\nplt.subplots(2, 2, subplot_kw=dict(polar=True) )",
            "masked_code": "x = np.linspace(0, 2*np.pi, 400)\ny = np.sin(x**2)\n\n<line_mask>\nax.plot(x, y)\nax.set_title('Simple plot')\n\nf, (ax1, ax2) = plt.subplots(1, 2, sharey=True)\nax1.plot(x, y)\nax1.set_title('Sharing Y axis')\nax2.scatter(x, y)\n\nplt.subplots(2, 2, subplot_kw=dict(polar=True) )",
            "masked_line": "f, ax = plt.subplots()",
            "answer": "subplots",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_498"
        },
        {
            "dependency": "pandas",
            "version": "==0.9.0",
            "time": "2012-10-08",
            "description": "The code creates a class \"Duck\" with attributes \"attr1\" and \"attr2\" initialized to \"fizz\" and \"buzz\" respectively. It then creates an instance \"b\" of class \"SimpleMock\" with attribute \"attr1\" set to \"bar\". Checking the values of attributes in instance \"b\" and class \"Duck\" shows that the values match the expected values.",
            "code": "a = type(\"Duck\",(),{})\na.attr1,a.attr2 =\"fizz\",\"buzz\"\nb = SimpleMock(a,\"attr1\",\"bar\")\nb.attr1 == \"bar\" and b.attr2 == \"buzz\"\nTrue\na.attr1 == \"fizz\" and a.attr2 == \"buzz\"\nTrue",
            "masked_code": "a = type(\"Duck\",(),{})\na.attr1,a.attr2 =\"fizz\",\"buzz\"\n<line_mask>\nb.attr1 == \"bar\" and b.attr2 == \"buzz\"\nTrue\na.attr1 == \"fizz\" and a.attr2 == \"buzz\"\nTrue",
            "masked_line": "b = SimpleMock(a,\"attr1\",\"bar\")",
            "answer": "SimpleMock",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_499"
        },
        {
            "dependency": "pandas",
            "version": "==1.0.0",
            "time": "2020-01-29",
            "description": "The code converts boolean values within a Pandas array to a NumPy array and specifies the data type as boolean. It also demonstrates converting a Pandas array of integers to a NumPy array with a specified data type.",
            "code": "a = pd.array([True, False, pd.NA], dtype=\"boolean\")\na.to_numpy()\narray([True, False, NA], dtype=object)\n\npd.array([True, False], dtype=\"boolean\").to_numpy(dtype=\"bool\")\narray([ True, False])\npd.array([1, 2], dtype=\"Int64\").to_numpy(\"int64\")\narray([1, 2])\n",
            "masked_code": "a = pd.array([True, False, pd.NA], dtype=\"boolean\")\na.to_numpy()\narray([True, False, NA], dtype=object)\n\n<line_mask>\narray([ True, False])\npd.array([1, 2], dtype=\"Int64\").to_numpy(\"int64\")\narray([1, 2])\n",
            "masked_line": "pd.array([True, False], dtype=\"boolean\").to_numpy(dtype=\"bool\")",
            "answer": "to_numpy",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_500"
        },
        {
            "dependency": "pandas",
            "version": "==1.2.0",
            "time": "2020-12-26",
            "description": "The code creates a DataFrame with two columns \"a\" and \"b\", then formats the DataFrame as a long table with a caption, label, and column format, and finally prints the table.",
            "code": "from pandas import DataFrame\nfrom pandas.io.formats import format as fmt\ndf = DataFrame({\"a\": [1, 2], \"b\": [\"b1\", \"b2\"]})\nformatter = fmt.DataFrameFormatter(df)\nbuilder = LongTableBuilder(formatter, caption='a long table', label='tab:long', column_format='lrl')\ntable = builder.get_result()\nprint(table)",
            "masked_code": "from pandas import DataFrame\nfrom pandas.io.formats import format as fmt\ndf = DataFrame({\"a\": [1, 2], \"b\": [\"b1\", \"b2\"]})\nformatter = fmt.DataFrameFormatter(df)\n<line_mask>\ntable = builder.get_result()\nprint(table)",
            "masked_line": "builder = LongTableBuilder(formatter, caption='a long table', label='tab:long', column_format='lrl')",
            "answer": "LongTableBuilder",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_501"
        },
        {
            "dependency": "pandas",
            "version": "==1.2.0",
            "time": "2020-12-26",
            "description": "The code creates a DataFrame with columns \"a\" and \"b\", formats the DataFrame into a table with a specified caption, label, and column format, and then prints the formatted table.",
            "code": "from pandas import DataFrame\nfrom pandas.io.formats import format as fmt\ndf = DataFrame({\"a\": [1, 2], \"b\": [\"b1\", \"b2\"]})\nformatter = fmt.DataFrameFormatter(df)\nbuilder = RegularTableBuilder(formatter, caption='caption', label='lab', column_format='lrc')\ntable = builder.get_result()\nprint(table)",
            "masked_code": "from pandas import DataFrame\nfrom pandas.io.formats import format as fmt\ndf = DataFrame({\"a\": [1, 2], \"b\": [\"b1\", \"b2\"]})\nformatter = fmt.DataFrameFormatter(df)\n<line_mask>\ntable = builder.get_result()\nprint(table)",
            "masked_line": "builder = RegularTableBuilder(formatter, caption='caption', label='lab', column_format='lrc')",
            "answer": "RegularTableBuilder",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_502"
        },
        {
            "dependency": "pandas",
            "version": "==1.2.0",
            "time": "2020-12-26",
            "description": "The code creates a dataframe with columns 'a' and 'b', then formats the dataframe using TabularBuilder with column format 'lrc', and finally prints the formatted table.",
            "code": "from pandas import DataFrame\nfrom pandas.io.formats import format as fmt\ndf = DataFrame({\"a\": [1, 2], \"b\": [\"b1\", \"b2\"]})\nformatter = fmt.DataFrameFormatter(df)\nbuilder = TabularBuilder(formatter, column_format='lrc')\ntable = builder.get_result()\nprint(table)",
            "masked_code": "from pandas import DataFrame\nfrom pandas.io.formats import format as fmt\ndf = DataFrame({\"a\": [1, 2], \"b\": [\"b1\", \"b2\"]})\nformatter = fmt.DataFrameFormatter(df)\n<line_mask>\ntable = builder.get_result()\nprint(table)",
            "masked_line": "builder = TabularBuilder(formatter, column_format='lrc')",
            "answer": "TabularBuilder",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_503"
        },
        {
            "dependency": "pandas",
            "version": "==1.4.0",
            "time": "2022-01-22",
            "description": "The code segment performs groupby operation on the 'gender' column of the DataFrame 'df' and computes the count of unique values in the grouped data.",
            "code": "df = pd.DataFrame({\n    'gender': ['male', 'male', 'female', 'male', 'female', 'male'],\n    'education': ['low', 'medium', 'high', 'low', 'high', 'low'],\n    'country': ['US', 'FR', 'US', 'FR', 'FR', 'FR']\n})\n\ndf.groupby('gender').value_counts()\ndf.groupby('gender').value_counts(ascending=True)\ndf.groupby('gender').value_counts(normalize=True)\ndf.groupby('gender', as_index=False).value_counts()\ndf.groupby('gender', as_index=False).value_counts(normalize=True)",
            "masked_code": "df = pd.DataFrame({\n    'gender': ['male', 'male', 'female', 'male', 'female', 'male'],\n    'education': ['low', 'medium', 'high', 'low', 'high', 'low'],\n    'country': ['US', 'FR', 'US', 'FR', 'FR', 'FR']\n})\n\ndf.groupby('gender').value_counts()\ndf.groupby('gender').value_counts(ascending=True)\n<line_mask>\ndf.groupby('gender', as_index=False).value_counts()\ndf.groupby('gender', as_index=False).value_counts(normalize=True)",
            "masked_line": "df.groupby('gender').value_counts(normalize=True)",
            "answer": "value_counts",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_504"
        },
        {
            "dependency": "pandas",
            "version": "==2.0.0",
            "time": "2023-04-03",
            "description": "The code is checking if the input data type is a real numeric data type.",
            "code": "from pandas.api.types import is_any_real_numeric_dtype\nis_any_real_numeric_dtype(int)\nis_any_real_numeric_dtype(float)\nis_any_real_numeric_dtype(object)\nis_any_real_numeric_dtype(str)\nis_any_real_numeric_dtype(complex(1, 2))\nis_any_real_numeric_dtype(bool)",
            "masked_code": "from pandas.api.types import is_any_real_numeric_dtype\nis_any_real_numeric_dtype(int)\nis_any_real_numeric_dtype(float)\nis_any_real_numeric_dtype(object)\n<line_mask>\nis_any_real_numeric_dtype(complex(1, 2))\nis_any_real_numeric_dtype(bool)",
            "masked_line": "is_any_real_numeric_dtype(str)",
            "answer": "is_any_real_numeric_dtype",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_505"
        },
        {
            "dependency": "pandas",
            "version": "==2.1.0",
            "time": "2023-08-30",
            "description": "The code snippet calculates the length of the string representation of each element in a DataFrame, creates a copy of the DataFrame, sets the value at the first row and first column to a pd.NA value in the copy, then calculates the length of the string representation of each element in the copy DataFrame while ignoring the NA values. Finally, it squares each element in the original DataFrame.",
            "code": "df.map(lambda x: len(str(x)))\ndf_copy = df.copy()\ndf_copy.iloc[0, 0] = pd.NA\ndf_copy.map(lambda x: len(str(x)), na_action='ignore')\ndf.map(lambda x: x**2)",
            "masked_code": "df.map(lambda x: len(str(x)))\ndf_copy = df.copy()\ndf_copy.iloc[0, 0] = pd.NA\ndf_copy.map(lambda x: len(str(x)), na_action='ignore')\n<line_mask>",
            "masked_line": "df.map(lambda x: x**2)",
            "answer": "map",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_506"
        },
        {
            "dependency": "pandas",
            "version": "==2.1.0",
            "time": "2023-08-30",
            "description": "The code finds the minimum value of the elements in the index object.",
            "code": "idx = pd.Index([3, 2, 1])\nidx.min()\n\nidx = pd.Index(['c', 'b', 'a'])\nidx.min()\n\nidx = pd.MultiIndex.from_product([('a', 'b'), (2, 1)])\nidx.min()",
            "masked_code": "idx = pd.Index([3, 2, 1])\nidx.min()\n\nidx = pd.Index(['c', 'b', 'a'])\n<line_mask>\n\nidx = pd.MultiIndex.from_product([('a', 'b'), (2, 1)])\nidx.min()",
            "masked_line": "idx.min()",
            "answer": "min",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_507"
        },
        {
            "dependency": "prompt-toolkit",
            "version": "==0.59",
            "time": "2016-02-27",
            "description": "The code creates a callback object that can store event handler functions. It allows adding event handler functions to the callback object and firing the event by calling the `fire()` method.",
            "code": "c = Callback(function)\nc.fire()\n\nc = Callback()\nc += handler_function  # Add event handler.\nc.fire()  # Fire event.\n",
            "masked_code": "c = Callback(function)\nc.fire()\n\n<line_mask>\nc += handler_function  # Add event handler.\nc.fire()  # Fire event.\n",
            "masked_line": "c = Callback()",
            "answer": "Callback",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_508"
        },
        {
            "dependency": "prompt-toolkit",
            "version": "==3.0.0",
            "time": "2019-11-24",
            "description": "The code defines an asynchronous function named interact that prompts the user with a yes/no dialog, allows the user to type something, and then prints out the user's input. The interact function is passed as an argument to PromptToolkitSSHServer which is used to create a SSH server with the specified host keys. The server is then run on the specified port indefinitely.",
            "code": "async def interact() -> None:\n    await yes_no_dialog(\"my title\", \"my text\").run_async()\n\n    prompt_session = PromptSession()\n    text = await prompt_session.prompt_async(\"Type something: \")\n    print_formatted_text('You said: ', text)\n\nserver = PromptToolkitSSHServer(interact=interact)\nloop = get_event_loop()\nloop.run_until_complete(\n    asyncssh.create_server(\n        lambda: MySSHServer(interact),\n        \"\",\n        port,\n        server_host_keys=[\"/etc/ssh/...\"],\n    )\n)\nloop.run_forever()",
            "masked_code": "async def interact() -> None:\n    await yes_no_dialog(\"my title\", \"my text\").run_async()\n\n    prompt_session = PromptSession()\n    text = await prompt_session.prompt_async(\"Type something: \")\n    print_formatted_text('You said: ', text)\n\n<line_mask>\nloop = get_event_loop()\nloop.run_until_complete(\n    asyncssh.create_server(\n        lambda: MySSHServer(interact),\n        \"\",\n        port,\n        server_host_keys=[\"/etc/ssh/...\"],\n    )\n)\nloop.run_forever()",
            "masked_line": "server = PromptToolkitSSHServer(interact=interact)",
            "answer": "PromptToolkitSSHServer",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_509"
        },
        {
            "dependency": "psutil",
            "version": "==0.1.3",
            "time": "2010-03-02",
            "description": "The code creates a new process that launches the Notepad application in a minimized window on a Windows system.",
            "code": "import win32con\nimport wmi\nc = wmi.WMI ()\nstartup = c.Win32_ProcessStartup.new (ShowWindow=win32con.SW_SHOWMINIMIZED)\npid, retval = c.Win32_Process.Create (\n  CommandLine=\"notepad.exe\",\n  ProcessStartupInformation=startup\n)",
            "masked_code": "import win32con\nimport wmi\nc = wmi.WMI ()\n<line_mask>\npid, retval = c.Win32_Process.Create (\n  CommandLine=\"notepad.exe\",\n  ProcessStartupInformation=startup\n)",
            "masked_line": "startup = c.Win32_ProcessStartup.new (ShowWindow=win32con.SW_SHOWMINIMIZED)",
            "answer": "new",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_510"
        },
        {
            "dependency": "psutil",
            "version": "==0.1.3",
            "time": "2010-03-02",
            "description": "The code creates a new minimized instance of the Notepad application using the Windows Management Instrumentation (WMI).",
            "code": "import win32con\nimport wmi\nc = wmi.WMI ()\nstartup = c.Win32_ProcessStartup.new (ShowWindow=win32con.SW_SHOWMINIMIZED)\npid, retval = c.Win32_Process.Create (\n  CommandLine=\"notepad.exe\",\n  ProcessStartupInformation=startup\n)",
            "masked_code": "import win32con\nimport wmi\nc = wmi.WMI ()\n<line_mask>\npid, retval = c.Win32_Process.Create (\n  CommandLine=\"notepad.exe\",\n  ProcessStartupInformation=startup\n)",
            "masked_line": "startup = c.Win32_ProcessStartup.new (ShowWindow=win32con.SW_SHOWMINIMIZED)",
            "answer": "new",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_511"
        },
        {
            "dependency": "psutil",
            "version": "==0.5.0",
            "time": "2012-06-27",
            "description": "This code uses the psutil module to create a subprocess running a Python command that prints 'hi'. It retrieves information such as the process name, user IDs, and username. It also communicates with the subprocess, terminates it, and waits for it to finish within a specified timeout period.",
            "code": "import psutil\nfrom subprocess import PIPE\np = psutil.Popen([\"/usr/bin/python\", \"-c\", \"print 'hi'\"], stdout=PIPE)\np.name\np.uids\np.username\np.communicate()\np.terminate()\np.wait(timeout=2)",
            "masked_code": "import psutil\nfrom subprocess import PIPE\n<line_mask>\np.name\np.uids\np.username\np.communicate()\np.terminate()\np.wait(timeout=2)",
            "masked_line": "p = psutil.Popen([\"/usr/bin/python\", \"-c\", \"print 'hi'\"], stdout=PIPE)",
            "answer": "Popen",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_512"
        },
        {
            "dependency": "psutil",
            "version": "==1.2.0",
            "time": "2013-11-20",
            "description": "The code terminates multiple processes, waits for them to finish within a time limit, prints a message when each process is terminated, and kills any processes that are still alive after the time limit.",
            "code": "def on_terminate(proc):\n    print(\"process {} terminated\".format(proc))\n\nfor p in procs:\n    p.terminate()\n\ngone, still_alive = wait_procs(procs, 3, callback=on_terminate)\nfor p in still_alive:\n    p.kill()",
            "masked_code": "def on_terminate(proc):\n    print(\"process {} terminated\".format(proc))\n\nfor p in procs:\n    p.terminate()\n\n<line_mask>\nfor p in still_alive:\n    p.kill()",
            "masked_line": "gone, still_alive = wait_procs(procs, 3, callback=on_terminate)",
            "answer": "wait_procs",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_513"
        },
        {
            "dependency": "pyarrow",
            "version": "==0.8.0",
            "time": "2017-12-12",
            "description": "The code converts a tuple of mixed data types into a tuple of strings.",
            "code": "name = 'foo'\n_column_name_to_strings(name)\n'foo'\nname = ('foo', 'bar')\n_column_name_to_strings(name)\n('foo', 'bar')\nimport pandas as pd\nname = (1, pd.Timestamp('2017-02-01 00:00:00'))\n_column_name_to_strings(name)\n('1', '2017-02-01 00:00:00')",
            "masked_code": "name = 'foo'\n_column_name_to_strings(name)\n'foo'\nname = ('foo', 'bar')\n_column_name_to_strings(name)\n('foo', 'bar')\nimport pandas as pd\nname = (1, pd.Timestamp('2017-02-01 00:00:00'))\n<line_mask>\n('1', '2017-02-01 00:00:00')",
            "masked_line": "_column_name_to_strings(name)",
            "answer": "_column_name_to_strings",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_514"
        },
        {
            "dependency": "pyarrow",
            "version": "==1.0.0",
            "time": "2020-07-20",
            "description": "The code creates an Arrow array with values [\"a\", \"b\", \"c\", None, \"e\"] and a corresponding mask array with values [True, False, None, False, True]. It then filters the array based on the mask, first with the default behavior of filtering out null values, and then explicitly emits null values.",
            "code": "import pyarrow as pa\narr = pa.array([\"a\", \"b\", \"c\", None, \"e\"])\nmask = pa.array([True, False, None, False, True])\narr.filter(mask)\narr.filter(mask, null_selection_behavior='emit_null')\n",
            "masked_code": "import pyarrow as pa\narr = pa.array([\"a\", \"b\", \"c\", None, \"e\"])\nmask = pa.array([True, False, None, False, True])\narr.filter(mask)\n<line_mask>\n",
            "masked_line": "arr.filter(mask, null_selection_behavior='emit_null')",
            "answer": "filter",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_515"
        },
        {
            "dependency": "pyarrow",
            "version": "==15.0.0",
            "time": "2024-01-16",
            "description": "The code creates a PyArrow table with columns 'year', 'n_legs', and 'animal'. It then writes the table to a Parquet dataset with a root path of 'dataset_v2_schema' and partitions it by the 'year' column. Finally, it reads the schema of the Parquet dataset named 'dataset_v2_schema/'.",
            "code": "import pyarrow as pa\ntable = pa.table({'year': [2020, 2022, 2021, 2022, 2019, 2021],\n                  'n_legs': [2, 2, 4, 4, 5, 100],\n                  'animal': [\"Flamingo\", \"Parrot\", \"Dog\", \"Horse\",\n                             \"Brittle stars\", \"Centipede\"]})\nimport pyarrow.parquet as pq\npq.write_to_dataset(table, root_path='dataset_v2_schema',\n                    partition_cols=['year'])\ndataset = pq.ParquetDataset('dataset_v2_schema/')\ndataset.schema",
            "masked_code": "import pyarrow as pa\ntable = pa.table({'year': [2020, 2022, 2021, 2022, 2019, 2021],\n                  'n_legs': [2, 2, 4, 4, 5, 100],\n                  'animal': [\"Flamingo\", \"Parrot\", \"Dog\", \"Horse\",\n                             \"Brittle stars\", \"Centipede\"]})\nimport pyarrow.parquet as pq\npq.write_to_dataset(table, root_path='dataset_v2_schema',\n                    partition_cols=['year'])\ndataset = pq.ParquetDataset('dataset_v2_schema/')\n<line_mask>",
            "masked_line": "dataset.schema",
            "answer": "schema",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_516"
        },
        {
            "dependency": "pyarrow",
            "version": "==14.0.2",
            "time": "2023-12-12",
            "description": "The code creates a Parquet table with columns for year, number of legs, and animal. It then writes the table to a dataset with the year as a partition column. Finally, it reads the dataset and retrieves the schema.",
            "code": "import pyarrow as pa\ntable = pa.table({'year': [2020, 2022, 2021, 2022, 2019, 2021],\n                  'n_legs': [2, 2, 4, 4, 5, 100],\n                  'animal': [\"Flamingo\", \"Parrot\", \"Dog\", \"Horse\",\n                             \"Brittle stars\", \"Centipede\"]})\nimport pyarrow.parquet as pq\npq.write_to_dataset(table, root_path='dataset_v2_schema',\n                    partition_cols=['year'],\n                    use_legacy_dataset=False)\ndataset = pq.ParquetDataset('dataset_v2_schema/',\n                            use_legacy_dataset=False)\ndataset.schema",
            "masked_code": "import pyarrow as pa\ntable = pa.table({'year': [2020, 2022, 2021, 2022, 2019, 2021],\n                  'n_legs': [2, 2, 4, 4, 5, 100],\n                  'animal': [\"Flamingo\", \"Parrot\", \"Dog\", \"Horse\",\n                             \"Brittle stars\", \"Centipede\"]})\nimport pyarrow.parquet as pq\npq.write_to_dataset(table, root_path='dataset_v2_schema',\n                    partition_cols=['year'],\n                    use_legacy_dataset=False)\ndataset = pq.ParquetDataset('dataset_v2_schema/',\n                            use_legacy_dataset=False)\n<line_mask>",
            "masked_line": "dataset.schema",
            "answer": "schema",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_517"
        },
        {
            "dependency": "pyarrow",
            "version": "==14.0.2",
            "time": "2023-12-12",
            "description": "The code creates a pandas DataFrame with columns for year, number of legs, and animal names. It then converts the DataFrame into a PyArrow Table and writes it to a Parquet file 'table_V2.parquet'. Later, it reads the Parquet file into a PyArrow Dataset, retrieves the 'n_legs' column, and accesses the metadata of the dataset.",
            "code": "import pyarrow as pa\nimport pandas as pd\ndf = pd.DataFrame({'year': [2020, 2022, 2021, 2022, 2019, 2021],\n                   'n_legs': [2, 2, 4, 4, 5, 100],\n                   'animal': [\"Flamingo\", \"Parrot\", \"Dog\", \"Horse\",\n                              \"Brittle stars\", \"Centipede\"]})\ntable = pa.Table.from_pandas(df)\nimport pyarrow.parquet as pq\npq.write_table(table, 'table_V2.parquet')\ndataset = pq.ParquetDataset('table_V2.parquet',\n                            use_legacy_dataset=False)\ndataset.read_pandas(columns=[\"n_legs\"])\ndataset.read_pandas(columns=[\"n_legs\"]).schema.pandas_metadata",
            "masked_code": "import pyarrow as pa\nimport pandas as pd\ndf = pd.DataFrame({'year': [2020, 2022, 2021, 2022, 2019, 2021],\n                   'n_legs': [2, 2, 4, 4, 5, 100],\n                   'animal': [\"Flamingo\", \"Parrot\", \"Dog\", \"Horse\",\n                              \"Brittle stars\", \"Centipede\"]})\ntable = pa.Table.from_pandas(df)\nimport pyarrow.parquet as pq\npq.write_table(table, 'table_V2.parquet')\ndataset = pq.ParquetDataset('table_V2.parquet',\n                            use_legacy_dataset=False)\n<line_mask>\ndataset.read_pandas(columns=[\"n_legs\"]).schema.pandas_metadata",
            "masked_line": "dataset.read_pandas(columns=[\"n_legs\"])",
            "answer": "read_pandas",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_518"
        },
        {
            "dependency": "pyarrow",
            "version": "==14.0.2",
            "time": "2023-12-12",
            "description": "The code creates a PyArrow table with columns 'year', 'n_legs', and 'animal', stores it as a Parquet file in a dataset with partitions based on the 'year' column, and then reads the dataset fragments.",
            "code": "import pyarrow as pa\ntable = pa.table({'year': [2020, 2022, 2021, 2022, 2019, 2021],\n                  'n_legs': [2, 2, 4, 4, 5, 100],\n                  'animal': [\"Flamingo\", \"Parrot\", \"Dog\", \"Horse\",\n                             \"Brittle stars\", \"Centipede\"]})\nimport pyarrow.parquet as pq\npq.write_to_dataset(table, root_path='dataset_v2_fragments',\n                    partition_cols=['year'],\n                    use_legacy_dataset=False)\ndataset = pq.ParquetDataset('dataset_v2_fragments/',\n                            use_legacy_dataset=False)\ndataset.fragments\n",
            "masked_code": "import pyarrow as pa\ntable = pa.table({'year': [2020, 2022, 2021, 2022, 2019, 2021],\n                  'n_legs': [2, 2, 4, 4, 5, 100],\n                  'animal': [\"Flamingo\", \"Parrot\", \"Dog\", \"Horse\",\n                             \"Brittle stars\", \"Centipede\"]})\nimport pyarrow.parquet as pq\npq.write_to_dataset(table, root_path='dataset_v2_fragments',\n                    partition_cols=['year'],\n                    use_legacy_dataset=False)\ndataset = pq.ParquetDataset('dataset_v2_fragments/',\n                            use_legacy_dataset=False)\n<line_mask>\n",
            "masked_line": "dataset.fragments",
            "answer": "fragments",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_519"
        },
        {
            "dependency": "pyarrow",
            "version": "==14.0.2",
            "time": "2023-12-12",
            "description": "The code creates a PyArrow table with columns 'year', 'n_legs', and 'animal'. It then writes the table to a Parquet dataset at 'dataset_v2_files' location, partitioning it by the 'year' column. Finally, it reads the dataset back and returns the list of Parquet files within the dataset.",
            "code": "import pyarrow as pa\ntable = pa.table({'year': [2020, 2022, 2021, 2022, 2019, 2021],\n                  'n_legs': [2, 2, 4, 4, 5, 100],\n                  'animal': [\"Flamingo\", \"Parrot\", \"Dog\", \"Horse\",\n                             \"Brittle stars\", \"Centipede\"]})\nimport pyarrow.parquet as pq\npq.write_to_dataset(table, root_path='dataset_v2_files',\n                    partition_cols=['year'],\n                    use_legacy_dataset=False)\ndataset = pq.ParquetDataset('dataset_v2_files/',\n                            use_legacy_dataset=False)\ndataset.files",
            "masked_code": "import pyarrow as pa\ntable = pa.table({'year': [2020, 2022, 2021, 2022, 2019, 2021],\n                  'n_legs': [2, 2, 4, 4, 5, 100],\n                  'animal': [\"Flamingo\", \"Parrot\", \"Dog\", \"Horse\",\n                             \"Brittle stars\", \"Centipede\"]})\nimport pyarrow.parquet as pq\npq.write_to_dataset(table, root_path='dataset_v2_files',\n                    partition_cols=['year'],\n                    use_legacy_dataset=False)\ndataset = pq.ParquetDataset('dataset_v2_files/',\n                            use_legacy_dataset=False)\n<line_mask>",
            "masked_line": "dataset.files",
            "answer": "files",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_520"
        },
        {
            "dependency": "pyarrow",
            "version": "==6.0.2",
            "time": "2022-07-14",
            "description": "This code calculates the mode(s) of the provided array with a given tolerance level of 2.",
            "code": "import pyarrow as pa\nimport pyarrow.compute as pc\narr = pa.array([1, 1, 2, 2, 3, 2, 2, 2])\nmodes = pc.mode(arr, 2)\nmodes[0]\nmodes[1]",
            "masked_code": "import pyarrow as pa\nimport pyarrow.compute as pc\narr = pa.array([1, 1, 2, 2, 3, 2, 2, 2])\n<line_mask>\nmodes[0]\nmodes[1]",
            "masked_line": "modes = pc.mode(arr, 2)",
            "answer": "mode",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_521"
        },
        {
            "dependency": "pyarrow",
            "version": "==8.0.0",
            "time": "2022-05-03",
            "description": "The code reads in a table with information about different animals and their number of legs, writes this table to a parquet file named 'example.parquet', and then reads the parquet file to get the number of row groups in the file.",
            "code": "import pyarrow as pa\ntable = pa.table({'n_legs': [2, 2, 4, 4, 5, 100],\n                  'animal': [\"Flamingo\", \"Parrot\", \"Dog\", \"Horse\",\n                             \"Brittle stars\", \"Centipede\"]})\nimport pyarrow.parquet as pq\npq.write_table(table, 'example.parquet')\nparquet_file = pq.ParquetFile('example.parquet')\n\nparquet_file.num_row_groups",
            "masked_code": "import pyarrow as pa\ntable = pa.table({'n_legs': [2, 2, 4, 4, 5, 100],\n                  'animal': [\"Flamingo\", \"Parrot\", \"Dog\", \"Horse\",\n                             \"Brittle stars\", \"Centipede\"]})\nimport pyarrow.parquet as pq\npq.write_table(table, 'example.parquet')\nparquet_file = pq.ParquetFile('example.parquet')\n\n<line_mask>",
            "masked_line": "parquet_file.num_row_groups",
            "answer": "num_row_groups",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_522"
        },
        {
            "dependency": "pyarrow",
            "version": "==8.0.0",
            "time": "2022-05-03",
            "description": "The code creates a table containing data about animals, including the year, number of legs, and animal names. It then writes this table to a Parquet dataset with a specified root path, partitions it by the 'year' column, and specifies to not use the legacy dataset. Finally, it reads the schema of the Parquet dataset.",
            "code": "import pyarrow as pa\ntable = pa.table({'year': [2020, 2022, 2021, 2022, 2019, 2021],\n                  'n_legs': [2, 2, 4, 4, 5, 100],\n                  'animal': [\"Flamingo\", \"Parrot\", \"Dog\", \"Horse\",\n                             \"Brittle stars\", \"Centipede\"]})\nimport pyarrow.parquet as pq\npq.write_to_dataset(table, root_path='dataset_v2_schema',\n                    partition_cols=['year'],\n                    use_legacy_dataset=False)\ndataset = pq._ParquetDatasetV2('dataset_v2_schema/')\n\ndataset.schema",
            "masked_code": "import pyarrow as pa\ntable = pa.table({'year': [2020, 2022, 2021, 2022, 2019, 2021],\n                  'n_legs': [2, 2, 4, 4, 5, 100],\n                  'animal': [\"Flamingo\", \"Parrot\", \"Dog\", \"Horse\",\n                             \"Brittle stars\", \"Centipede\"]})\nimport pyarrow.parquet as pq\npq.write_to_dataset(table, root_path='dataset_v2_schema',\n                    partition_cols=['year'],\n                    use_legacy_dataset=False)\ndataset = pq._ParquetDatasetV2('dataset_v2_schema/')\n\n<line_mask>",
            "masked_line": "dataset.schema",
            "answer": "schema",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_523"
        },
        {
            "dependency": "pyarrow",
            "version": "==8.0.0",
            "time": "2022-05-03",
            "description": "The code creates a PyArrow table with columns 'year', 'n_legs', and 'animal'. It then writes the table to a Parquet dataset with partitioning by the 'year' column in the 'dataset_v2_fragments' directory. Finally, it creates a Parquet dataset from the fragments in the 'dataset_v2_fragments' directory.",
            "code": "import pyarrow as pa\ntable = pa.table({'year': [2020, 2022, 2021, 2022, 2019, 2021],\n                  'n_legs': [2, 2, 4, 4, 5, 100],\n                  'animal': [\"Flamingo\", \"Parrot\", \"Dog\", \"Horse\",\n                             \"Brittle stars\", \"Centipede\"]})\nimport pyarrow.parquet as pq\npq.write_to_dataset(table, root_path='dataset_v2_fragments',\n                    partition_cols=['year'],\n                    use_legacy_dataset=False)\ndataset = pq._ParquetDatasetV2('dataset_v2_fragments/')\ndataset.fragments\n",
            "masked_code": "import pyarrow as pa\ntable = pa.table({'year': [2020, 2022, 2021, 2022, 2019, 2021],\n                  'n_legs': [2, 2, 4, 4, 5, 100],\n                  'animal': [\"Flamingo\", \"Parrot\", \"Dog\", \"Horse\",\n                             \"Brittle stars\", \"Centipede\"]})\nimport pyarrow.parquet as pq\npq.write_to_dataset(table, root_path='dataset_v2_fragments',\n                    partition_cols=['year'],\n                    use_legacy_dataset=False)\ndataset = pq._ParquetDatasetV2('dataset_v2_fragments/')\n<line_mask>\n",
            "masked_line": "dataset.fragments",
            "answer": "fragments",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_524"
        },
        {
            "dependency": "pyarrow",
            "version": "==8.0.0",
            "time": "2022-05-03",
            "description": "The code creates a Parquet table with columns 'year', 'n_legs', and 'animal' containing data on different animals. It then writes this table to a Parquet dataset with partitioning by the 'year' column in the 'dataset_v2_files' directory. Finally, it retrieves the files in the created Parquet dataset.",
            "code": "import pyarrow as pa\ntable = pa.table({'year': [2020, 2022, 2021, 2022, 2019, 2021],\n                  'n_legs': [2, 2, 4, 4, 5, 100],\n                  'animal': [\"Flamingo\", \"Parrot\", \"Dog\", \"Horse\",\n                             \"Brittle stars\", \"Centipede\"]})\nimport pyarrow.parquet as pq\npq.write_to_dataset(table, root_path='dataset_v2_files',\n                    partition_cols=['year'],\n                    use_legacy_dataset=False)\ndataset = pq._ParquetDatasetV2('dataset_v2_files/')\ndataset.files",
            "masked_code": "import pyarrow as pa\ntable = pa.table({'year': [2020, 2022, 2021, 2022, 2019, 2021],\n                  'n_legs': [2, 2, 4, 4, 5, 100],\n                  'animal': [\"Flamingo\", \"Parrot\", \"Dog\", \"Horse\",\n                             \"Brittle stars\", \"Centipede\"]})\nimport pyarrow.parquet as pq\npq.write_to_dataset(table, root_path='dataset_v2_files',\n                    partition_cols=['year'],\n                    use_legacy_dataset=False)\ndataset = pq._ParquetDatasetV2('dataset_v2_files/')\n<line_mask>",
            "masked_line": "dataset.files",
            "answer": "files",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_525"
        },
        {
            "dependency": "pyarrow",
            "version": "==0.2.0",
            "time": "2017-02-15",
            "description": "This function converts elements in a tuple to strings.",
            "code": "name = 'foo'\n_column_name_to_strings(name)\n'foo'\nname = ('foo', 'bar')\n_column_name_to_strings(name)\n('foo', 'bar')\nimport pandas as pd\nname = (1, pd.Timestamp('2017-02-01 00:00:00'))\n_column_name_to_strings(name)\n('1', '2017-02-01 00:00:00')",
            "masked_code": "name = 'foo'\n_column_name_to_strings(name)\n'foo'\nname = ('foo', 'bar')\n<line_mask>\n('foo', 'bar')\nimport pandas as pd\nname = (1, pd.Timestamp('2017-02-01 00:00:00'))\n_column_name_to_strings(name)\n('1', '2017-02-01 00:00:00')",
            "masked_line": "_column_name_to_strings(name)",
            "answer": "_column_name_to_strings",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_526"
        },
        {
            "dependency": "pyarrow",
            "version": "==0.4.0",
            "time": "2017-05-19",
            "description": "The function _column_name_to_strings converts input tuples into tuples of strings.",
            "code": "name = 'foo'\n_column_name_to_strings(name)\n'foo'\nname = ('foo', 'bar')\n_column_name_to_strings(name)\n('foo', 'bar')\nimport pandas as pd\nname = (1, pd.Timestamp('2017-02-01 00:00:00'))\n_column_name_to_strings(name)\n('1', '2017-02-01 00:00:00')",
            "masked_code": "name = 'foo'\n<line_mask>\n'foo'\nname = ('foo', 'bar')\n_column_name_to_strings(name)\n('foo', 'bar')\nimport pandas as pd\nname = (1, pd.Timestamp('2017-02-01 00:00:00'))\n_column_name_to_strings(name)\n('1', '2017-02-01 00:00:00')",
            "masked_line": "_column_name_to_strings(name)",
            "answer": "_column_name_to_strings",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_527"
        },
        {
            "dependency": "pyarrow",
            "version": "==0.4.1",
            "time": "2017-06-07",
            "description": "The function `_column_name_to_strings` converts the input into a tuple of strings, where each element in the tuple is converted to a string.",
            "code": "name = 'foo'\n_column_name_to_strings(name)\n'foo'\nname = ('foo', 'bar')\n_column_name_to_strings(name)\n('foo', 'bar')\nimport pandas as pd\nname = (1, pd.Timestamp('2017-02-01 00:00:00'))\n_column_name_to_strings(name)\n('1', '2017-02-01 00:00:00')",
            "masked_code": "name = 'foo'\n<line_mask>\n'foo'\nname = ('foo', 'bar')\n_column_name_to_strings(name)\n('foo', 'bar')\nimport pandas as pd\nname = (1, pd.Timestamp('2017-02-01 00:00:00'))\n_column_name_to_strings(name)\n('1', '2017-02-01 00:00:00')",
            "masked_line": "_column_name_to_strings(name)",
            "answer": "_column_name_to_strings",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_528"
        },
        {
            "dependency": "pyrsistent",
            "version": "==0.10.0",
            "time": "2015-04-28",
            "description": "The code creates a list s2 with elements [1, 1, 2], then removes the element 1 from s2 to create a new list s3. It then removes the element 2 from s3 to create a new list s4. Finally, the code returns a list with elements [1, 1].",
            "code": "s2 = pbag([1, 1, 2])\ns3 = s2.remove(1)\ns4 = s3.remove(2)\ns4\npbag([1, 1])",
            "masked_code": "s2 = pbag([1, 1, 2])\n<line_mask>\ns4 = s3.remove(2)\ns4\npbag([1, 1])",
            "masked_line": "s3 = s2.remove(1)",
            "answer": "remove",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_529"
        },
        {
            "dependency": "pyrsistent",
            "version": "==0.10.0",
            "time": "2015-04-28",
            "description": "This code snippet demonstrates the functionality of popping elements from a custom implementation of a deque data structure. It showcases different scenarios such as popping from an empty deque, popping with different indices, and the resulting deque after each operation.",
            "code": "pdeque([1, 2]).pop()\npdeque([1])\npdeque([1, 2]).pop(2)\npdeque([])\npdeque([1, 2]).pop(-1)\npdeque([2])",
            "masked_code": "<line_mask>\npdeque([1])\npdeque([1, 2]).pop(2)\npdeque([])\npdeque([1, 2]).pop(-1)\npdeque([2])",
            "masked_line": "pdeque([1, 2]).pop()",
            "answer": "pop",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_530"
        },
        {
            "dependency": "pyrsistent",
            "version": "==0.9.4",
            "time": "2015-04-20",
            "description": "The code performs various pop operations on a deque object, removing and returning elements based on the specified index.",
            "code": "pdeque([1, 2]).pop()\npdeque([1])\npdeque([1, 2]).pop(2)\npdeque([])\npdeque([1, 2]).pop(-1)\npdeque([2])",
            "masked_code": "<line_mask>\npdeque([1])\npdeque([1, 2]).pop(2)\npdeque([])\npdeque([1, 2]).pop(-1)\npdeque([2])",
            "masked_line": "pdeque([1, 2]).pop()",
            "answer": "pop",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_531"
        },
        {
            "dependency": "pyrsistent",
            "version": "==0.12.0",
            "time": "2017-01-06",
            "description": "The code retrieves specific values from the frozen dictionary 'transaction'. It attempts to get the value at specific keys like 'purchase', 'name', 'items', 'total' and 'apple'. It also tries to retrieve values at non-existent keys like 'y' and out of range index like 10. Some of the attempts include specifying a default value or setting a flag for non-existent keys.",
            "code": "from pyrsistent import freeze\ntransaction = freeze({'name': 'Alice',\n                      'purchase': {'items': ['Apple', 'Orange'],\n                                   'costs': [0.50, 1.25]},\n                      'credit card': '5555-1234-1234-1234'})\nget_in(['purchase', 'items', 0], transaction)\nget_in(['name'], transaction)\nget_in(['purchase', 'total'], transaction)\nget_in(['purchase', 'items', 'apple'], transaction)\nget_in(['purchase', 'items', 10], transaction)\nget_in(['purchase', 'total'], transaction, 0)\nget_in(['y'], {}, no_default=True)",
            "masked_code": "from pyrsistent import freeze\ntransaction = freeze({'name': 'Alice',\n                      'purchase': {'items': ['Apple', 'Orange'],\n                                   'costs': [0.50, 1.25]},\n                      'credit card': '5555-1234-1234-1234'})\nget_in(['purchase', 'items', 0], transaction)\nget_in(['name'], transaction)\n<line_mask>\nget_in(['purchase', 'items', 'apple'], transaction)\nget_in(['purchase', 'items', 10], transaction)\nget_in(['purchase', 'total'], transaction, 0)\nget_in(['y'], {}, no_default=True)",
            "masked_line": "get_in(['purchase', 'total'], transaction)",
            "answer": "get_in",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_532"
        },
        {
            "dependency": "pyrsistent",
            "version": "==0.4.0",
            "time": "2014-09-20",
            "description": "This code defines a class called PositivePoint that represents a point with positive x and y coordinates. It utilizes immutable to create an immutable class with x and y attributes. The class also contains a __new__ method that checks if the x and y coordinates are positive and raises an exception if they are not.",
            "code": "class PositivePoint(immutable('x, y')):\n    __slots__ = tuple()\n    def __new__(cls, x, y):\n        if x > 0 and y > 0:\n            return super(PositivePoint, cls).__new__(cls, x, y)\n        raise Exception('Coordinates must be positive!')",
            "masked_code": "<line_mask>\n    __slots__ = tuple()\n    def __new__(cls, x, y):\n        if x > 0 and y > 0:\n            return super(PositivePoint, cls).__new__(cls, x, y)\n        raise Exception('Coordinates must be positive!')",
            "masked_line": "class PositivePoint(immutable('x, y')):",
            "answer": "immutable",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_533"
        },
        {
            "dependency": "pyrsistent",
            "version": "==0.5.0",
            "time": "2014-09-24",
            "description": "This code defines a list s2 with elements [1, 1, 2], removes the first occurrence of value 1 from s2, then removes the value 2 from the resulting list, and finally returns a list with elements [1, 1].",
            "code": "s2 = pbag([1, 1, 2])\ns3 = s2.remove(1)\ns4 = s3.remove(2)\ns4\npbag([1, 1])",
            "masked_code": "s2 = pbag([1, 1, 2])\n<line_mask>\ns4 = s3.remove(2)\ns4\npbag([1, 1])",
            "masked_line": "s3 = s2.remove(1)",
            "answer": "remove",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_534"
        },
        {
            "dependency": "pyrsistent",
            "version": "==0.5.0",
            "time": "2014-09-24",
            "description": "The code merges two dictionaries together by combining their values for matching keys, using the specified function for combining the values.",
            "code": "from operator import add\nm1 = m(a=1, b=2)\nm1.merge_with(add, m(a=2))\npmap({'a': 3, 'b': 2})\nm1 = m(a=1)\nm1.merge_with(lambda l, r: l, m(a=2), {'a':3})\npmap({'a': 1})",
            "masked_code": "from operator import add\nm1 = m(a=1, b=2)\nm1.merge_with(add, m(a=2))\npmap({'a': 3, 'b': 2})\nm1 = m(a=1)\n<line_mask>\npmap({'a': 1})",
            "masked_line": "m1.merge_with(lambda l, r: l, m(a=2), {'a':3})",
            "answer": "merge_with",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_535"
        },
        {
            "dependency": "pyrsistent",
            "version": "==0.6.1",
            "time": "2014-10-31",
            "description": "This code defines a class called PositivePoint which represents a point with positive coordinates. It specifies that the x and y coordinates of the point must be greater than 0, otherwise it raises an Exception stating that the coordinates must be positive.",
            "code": "class PositivePoint(pclass('x, y')):\n    __slots__ = tuple()\n    def __new__(cls, x, y):\n        if x > 0 and y > 0:\n            return super(PositivePoint, cls).__new__(cls, x, y)\n        raise Exception('Coordinates must be positive!')",
            "masked_code": "<line_mask>\n    __slots__ = tuple()\n    def __new__(cls, x, y):\n        if x > 0 and y > 0:\n            return super(PositivePoint, cls).__new__(cls, x, y)\n        raise Exception('Coordinates must be positive!')",
            "masked_line": "class PositivePoint(pclass('x, y')):",
            "answer": "pclass",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_536"
        },
        {
            "dependency": "pyrsistent",
            "version": "==0.6.0",
            "time": "2014-10-26",
            "description": "This Python code defines a class called PositivePoint which represents a point in a two-dimensional space with positive coordinates. It restricts the creation of instances to only those with positive x and y coordinates, raising an exception if either x or y is not positive.",
            "code": "class PositivePoint(immutable('x, y')):\n    __slots__ = tuple()\n    def __new__(cls, x, y):\n        if x > 0 and y > 0:\n            return super(PositivePoint, cls).__new__(cls, x, y)\n        raise Exception('Coordinates must be positive!')",
            "masked_code": "<line_mask>\n    __slots__ = tuple()\n    def __new__(cls, x, y):\n        if x > 0 and y > 0:\n            return super(PositivePoint, cls).__new__(cls, x, y)\n        raise Exception('Coordinates must be positive!')",
            "masked_line": "class PositivePoint(immutable('x, y')):",
            "answer": "immutable",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_537"
        },
        {
            "dependency": "pyrsistent",
            "version": "==0.8.0",
            "time": "2015-01-21",
            "description": "The code allows for transforming the content of articles in a newspaper object to either a shorter or very short version by truncating the content.",
            "code": "news_paper = freeze({'articles': [{'author': 'Sara', 'content': 'A short article'},\n                                  {'author': 'Steve', 'content': 'A slightly longer article'}],\n                     'weather': {'temperature': '11C', 'wind': '5m/s'}})\nshort_news = news_paper.transform(['articles', ny, 'content'], lambda c: c[:25] + '...' if len(c) > 25 else c)\nvery_short_news = news_paper.transform(['articles', ny, 'content'], lambda c: c[:15] + '...' if len(c) > 15 else c)\nvery_short_news.articles[0].content\nvery_short_news.articles[1].content",
            "masked_code": "news_paper = freeze({'articles': [{'author': 'Sara', 'content': 'A short article'},\n                                  {'author': 'Steve', 'content': 'A slightly longer article'}],\n                     'weather': {'temperature': '11C', 'wind': '5m/s'}})\nshort_news = news_paper.transform(['articles', ny, 'content'], lambda c: c[:25] + '...' if len(c) > 25 else c)\n<line_mask>\nvery_short_news.articles[0].content\nvery_short_news.articles[1].content",
            "masked_line": "very_short_news = news_paper.transform(['articles', ny, 'content'], lambda c: c[:15] + '...' if len(c) > 15 else c)",
            "answer": "transform",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_538"
        },
        {
            "dependency": "pyrsistent",
            "version": "==0.9.2",
            "time": "2015-04-03",
            "description": "This code defines a mapping class called IntToFloatMap that ensures the keys are integers and the values are floats. It also includes an invariant check to validate the mapping between keys and values.",
            "code": "class IntToFloatMap(CheckedPMap):\n    __key_type__ = int\n    __value_type__ = float\n    __invariant__ = lambda k, v: (int(v) == k, 'Invalid mapping')\n\nIntToFloatMap({1: 1.5, 2: 2.25})",
            "masked_code": "<line_mask>\n    __key_type__ = int\n    __value_type__ = float\n    __invariant__ = lambda k, v: (int(v) == k, 'Invalid mapping')\n\nIntToFloatMap({1: 1.5, 2: 2.25})",
            "masked_line": "class IntToFloatMap(CheckedPMap):",
            "answer": "CheckedPMap",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_539"
        },
        {
            "dependency": "pyrsistent",
            "version": "==0.9.2",
            "time": "2015-04-03",
            "description": "This Python code defines a class called PositivePoint that represents a point with positive coordinates. The class only allows the creation of instances with positive x and y coordinates. If the coordinates are not positive, it raises an exception with the message 'Coordinates must be positive!'.",
            "code": "class PositivePoint(pclass('x, y')):\n    __slots__ = tuple()\n    def __new__(cls, x, y):\n        if x > 0 and y > 0:\n            return super(PositivePoint, cls).__new__(cls, x, y)\n        raise Exception('Coordinates must be positive!')",
            "masked_code": "<line_mask>\n    __slots__ = tuple()\n    def __new__(cls, x, y):\n        if x > 0 and y > 0:\n            return super(PositivePoint, cls).__new__(cls, x, y)\n        raise Exception('Coordinates must be positive!')",
            "masked_line": "class PositivePoint(pclass('x, y')):",
            "answer": "pclass",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_540"
        },
        {
            "dependency": "pytest",
            "version": "==3.0.0",
            "time": "2016-08-18",
            "description": "The code is checking whether two values are approximately equal within certain specified relative and absolute tolerances.",
            "code": "\n0.1 + 0.2 == approx(0.3)\n(0.1 + 0.2, 0.2 + 0.4) == approx((0.3, 0.6))\n1.0001 == approx(1, rel=1e-3)\n1.0001 == approx(1, abs=1e-3)\n1 + 1e-8 == approx(1)\n1 + 1e-8 == approx(1, abs=1e-12)\n1 + 1e-8 == approx(1, rel=1e-6, abs=1e-12)\n",
            "masked_code": "\n0.1 + 0.2 == approx(0.3)\n(0.1 + 0.2, 0.2 + 0.4) == approx((0.3, 0.6))\n1.0001 == approx(1, rel=1e-3)\n<line_mask>\n1 + 1e-8 == approx(1)\n1 + 1e-8 == approx(1, abs=1e-12)\n1 + 1e-8 == approx(1, rel=1e-6, abs=1e-12)\n",
            "masked_line": "1.0001 == approx(1, abs=1e-3)",
            "answer": "approx",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_541"
        },
        {
            "dependency": "pytest",
            "version": "==6.2.0",
            "time": "2020-12-12",
            "description": "The code creates a context manager to catch exceptions that occur within a thread. It stores the exception type, value, and traceback in the `args` attribute of the context manager. This information can be accessed after the thread is spawned to handle any exceptions that may have occurred. Once the context manager is exited, the `args` attribute is no longer accessible.",
            "code": "class catch_threading_exception:\n    def __enter__(self):\n        self.args = None\n        return self\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        if exc_type is not None:\n            self.args = (exc_type, exc_value, traceback)\n\nwith catch_threading_exception() as cm:\n    # code spawning a thread which raises an exception\n    ...\n    # check the thread exception: use cm.args\n    ...\n# cm.args attribute no longer exists at this point\n# (to break a reference cycle)\n",
            "masked_code": "<line_mask>\n    def __enter__(self):\n        self.args = None\n        return self\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        if exc_type is not None:\n            self.args = (exc_type, exc_value, traceback)\n\nwith catch_threading_exception() as cm:\n    # code spawning a thread which raises an exception\n    ...\n    # check the thread exception: use cm.args\n    ...\n# cm.args attribute no longer exists at this point\n# (to break a reference cycle)\n",
            "masked_line": "class catch_threading_exception:",
            "answer": "catch_threading_exception",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_542"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==0.10.0",
            "time": "2020-10-07",
            "description": "This function creates a data loader for training MNIST dataset with specified batch size and shuffling the data before each epoch.",
            "code": "def train_dataloader(self):\n    transform = transforms.Compose([transforms.ToTensor(),\n                                    transforms.Normalize((0.5,), (1.0,))])\n    dataset = MNIST(root='/path/to/mnist/', train=True, transform=transform,\n                    download=True)\n    loader = torch.utils.data.DataLoader(\n        dataset=dataset,\n        batch_size=self.batch_size,\n        shuffle=True\n    )\n    return loader",
            "masked_code": "<line_mask>\n    transform = transforms.Compose([transforms.ToTensor(),\n                                    transforms.Normalize((0.5,), (1.0,))])\n    dataset = MNIST(root='/path/to/mnist/', train=True, transform=transform,\n                    download=True)\n    loader = torch.utils.data.DataLoader(\n        dataset=dataset,\n        batch_size=self.batch_size,\n        shuffle=True\n    )\n    return loader",
            "masked_line": "def train_dataloader(self):",
            "answer": "train_dataloader",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_543"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==0.10.0",
            "time": "2020-10-07",
            "description": "The function creates a data loader for the MNIST dataset without shuffling the data. It transforms the data to tensor format and normalizes it before returning the data loader. It can also return multiple data loaders for different subsets of the MNIST dataset.",
            "code": "def test_dataloader(self):\n    transform = transforms.Compose([transforms.ToTensor(),\n                                    transforms.Normalize((0.5,), (1.0,))])\n    dataset = MNIST(root='/path/to/mnist/', train=False, transform=transform,\n                    download=True)\n    loader = torch.utils.data.DataLoader(\n        dataset=dataset,\n        batch_size=self.batch_size,\n        shuffle=False\n    )\n\n    return loader\n\n# can also return multiple dataloaders\ndef test_dataloader(self):\n    return [loader_a, loader_b, ..., loader_n]\n",
            "masked_code": "def test_dataloader(self):\n    transform = transforms.Compose([transforms.ToTensor(),\n                                    transforms.Normalize((0.5,), (1.0,))])\n    dataset = MNIST(root='/path/to/mnist/', train=False, transform=transform,\n                    download=True)\n    loader = torch.utils.data.DataLoader(\n        dataset=dataset,\n        batch_size=self.batch_size,\n        shuffle=False\n    )\n\n    return loader\n\n# can also return multiple dataloaders\n<line_mask>\n    return [loader_a, loader_b, ..., loader_n]\n",
            "masked_line": "def test_dataloader(self):",
            "answer": "test_dataloader",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_544"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==0.10.0",
            "time": "2020-10-07",
            "description": "This code defines a method to create a data loader for validation data. It normalizes and converts the data to tensors using predefined transformations on the MNIST dataset. It then creates a DataLoader object with specified batch size and shuffle settings. It can also return multiple data loaders for different datasets.",
            "code": "def val_dataloader(self):\n    transform = transforms.Compose([transforms.ToTensor(),\n                                    transforms.Normalize((0.5,), (1.0,))])\n    dataset = MNIST(root='/path/to/mnist/', train=False,\n                    transform=transform, download=True)\n    loader = torch.utils.data.DataLoader(\n        dataset=dataset,\n        batch_size=self.batch_size,\n        shuffle=False\n    )\n\n    return loader\n\n# can also return multiple dataloaders\ndef val_dataloader(self):\n    return [loader_a, loader_b, ..., loader_n]\n",
            "masked_code": "<line_mask>\n    transform = transforms.Compose([transforms.ToTensor(),\n                                    transforms.Normalize((0.5,), (1.0,))])\n    dataset = MNIST(root='/path/to/mnist/', train=False,\n                    transform=transform, download=True)\n    loader = torch.utils.data.DataLoader(\n        dataset=dataset,\n        batch_size=self.batch_size,\n        shuffle=False\n    )\n\n    return loader\n\n# can also return multiple dataloaders\ndef val_dataloader(self):\n    return [loader_a, loader_b, ..., loader_n]\n",
            "masked_line": "def val_dataloader(self):",
            "answer": "val_dataloader",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_545"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==0.10.0",
            "time": "2020-10-07",
            "description": "This function transfers a batch of data to a specified device, moving all tensors in a custom data structure to the device if the batch is an instance of CustomBatch, otherwise it transfers the batch using the superclass's transfer method.",
            "code": "def transfer_batch_to_device(self, batch, device):\n    if isinstance(batch, CustomBatch):\n        # move all tensors in your custom data structure to the device\n        batch.samples = batch.samples.to(device)\n        batch.targets = batch.targets.to(device)\n    else:\n        batch = super().transfer_batch_to_device(data, device)\n    return batch",
            "masked_code": "<line_mask>\n    if isinstance(batch, CustomBatch):\n        # move all tensors in your custom data structure to the device\n        batch.samples = batch.samples.to(device)\n        batch.targets = batch.targets.to(device)\n    else:\n        batch = super().transfer_batch_to_device(data, device)\n    return batch",
            "masked_line": "def transfer_batch_to_device(self, batch, device):",
            "answer": "transfer_batch_to_device",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_546"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==0.10.0",
            "time": "2020-10-07",
            "description": "The code sets up a model and trainer, runs a learning rate finder, inspects the results, determines the suggested learning rate, overwrites the learning rate, creates a new model with the suggested learning rate, and then trains the model with the new learning rate.",
            "code": "# Setup model and trainer\nmodel = MyModelClass(hparams)\ntrainer = pl.Trainer()\n\n# Run lr finder\nlr_finder = trainer.lr_find(model, ...)\n\n# Inspect results\nfig = lr_finder.plot(); fig.show()\nsuggested_lr = lr_finder.suggestion()\n\n# Overwrite lr and create new model\nhparams.lr = suggested_lr\nmodel = MyModelClass(hparams)\n\n# Ready to train with new learning rate\ntrainer.fit(model)\n",
            "masked_code": "# Setup model and trainer\nmodel = MyModelClass(hparams)\ntrainer = pl.Trainer()\n\n# Run lr finder\n<line_mask>\n\n# Inspect results\nfig = lr_finder.plot(); fig.show()\nsuggested_lr = lr_finder.suggestion()\n\n# Overwrite lr and create new model\nhparams.lr = suggested_lr\nmodel = MyModelClass(hparams)\n\n# Ready to train with new learning rate\ntrainer.fit(model)\n",
            "masked_line": "lr_finder = trainer.lr_find(model, ...)",
            "answer": "lr_find",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_547"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==0.10.0",
            "time": "2020-10-07",
            "description": "The code defines command line arguments for a PyTorch Lightning Trainer model training process, allowing for customization of a custom argument '--my_custom_arg' with a default value of 'something'. It then parses the arguments and initializes a Trainer object with the provided configuration.",
            "code": "from pytorch_lightning import Trainer\nparser = ArgumentParser(add_help=False)\nparser = Trainer.add_argparse_args(parser)\nparser.add_argument('--my_custom_arg', default='something')  # doctest: +SKIP\nargs = Trainer.parse_argparser(parser.parse_args(\"\"))\ntrainer = Trainer.from_argparse_args(args, logger=False)",
            "masked_code": "from pytorch_lightning import Trainer\nparser = ArgumentParser(add_help=False)\nparser = Trainer.add_argparse_args(parser)\nparser.add_argument('--my_custom_arg', default='something')  # doctest: +SKIP\nargs = Trainer.parse_argparser(parser.parse_args(\"\"))\n<line_mask>",
            "masked_line": "trainer = Trainer.from_argparse_args(args, logger=False)",
            "answer": "from_argparse_args",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_548"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==0.10.0",
            "time": "2020-10-07",
            "description": "The code defines a simple neural network model with one linear layer. It then converts the model to TorchScript and saves it to a file named \"model.pt\". Finally, it checks if the file \"model.pt\" exists.",
            "code": "class SimpleModel(LightningModule):\n    def __init__(self):\n        super().__init__()\n        self.l1 = torch.nn.Linear(in_features=64, out_features=4)\n\n    def forward(self, x):\n        return torch.relu(self.l1(x.view(x.size(0), -1)))\n\nmodel = SimpleModel()\ntorch.jit.save(model.to_torchscript(), \"model.pt\")\nos.path.isfile(\"model.pt\")\n",
            "masked_code": "class SimpleModel(LightningModule):\n    def __init__(self):\n        super().__init__()\n        self.l1 = torch.nn.Linear(in_features=64, out_features=4)\n\n    def forward(self, x):\n        return torch.relu(self.l1(x.view(x.size(0), -1)))\n\nmodel = SimpleModel()\n<line_mask>\nos.path.isfile(\"model.pt\")\n",
            "masked_line": "torch.jit.save(model.to_torchscript(), \"model.pt\")",
            "answer": "to_torchscript",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_549"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==0.9.0",
            "time": "2020-08-20",
            "description": "This code calculates the confusion matrix for the predicted values `pred` and the target values `target`. The confusion matrix is a 2D tensor where the rows represent the actual classes and the columns represent the predicted classes, showing the count of true positives in each cell.",
            "code": "pred = torch.tensor([0, 1, 2, 2])\ntarget = torch.tensor([0, 1, 2, 2])\nmetric = ConfusionMatrix()\nmetric(pred, target)\ntensor([[1., 0., 0.],\n        [0., 1., 0.],\n        [0., 0., 2.]])",
            "masked_code": "pred = torch.tensor([0, 1, 2, 2])\ntarget = torch.tensor([0, 1, 2, 2])\n<line_mask>\nmetric(pred, target)\ntensor([[1., 0., 0.],\n        [0., 1., 0.],\n        [0., 0., 2.]])",
            "masked_line": "metric = ConfusionMatrix()",
            "answer": "ConfusionMatrix",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_550"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==0.9.0",
            "time": "2020-08-20",
            "description": "This code calculates precision, recall, and thresholds based on predicted values and target values.",
            "code": "pred = torch.tensor([0, 1, 2, 3])\ntarget = torch.tensor([0, 1, 2, 2])\nmetric = PrecisionRecall()\nprec, recall, thr = metric(pred, target)\nprec\ntensor([0.3333, 0.0000, 0.0000, 1.0000])\nrecall\ntensor([1., 0., 0., 0.])\nthr\ntensor([1., 2., 3.])",
            "masked_code": "pred = torch.tensor([0, 1, 2, 3])\ntarget = torch.tensor([0, 1, 2, 2])\n<line_mask>\nprec, recall, thr = metric(pred, target)\nprec\ntensor([0.3333, 0.0000, 0.0000, 1.0000])\nrecall\ntensor([1., 0., 0., 0.])\nthr\ntensor([1., 2., 3.])",
            "masked_line": "metric = PrecisionRecall()",
            "answer": "PrecisionRecall",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_551"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==0.9.0",
            "time": "2020-08-20",
            "description": "Calculate the precision metric for a classification task with 4 classes using the predicted values \"pred\" and the target values \"target\".",
            "code": "pred = torch.tensor([0, 1, 2, 3])\ntarget = torch.tensor([0, 1, 2, 2])\nmetric = Precision(num_classes=4)\nmetric(pred, target)\ntensor(0.7500)",
            "masked_code": "pred = torch.tensor([0, 1, 2, 3])\ntarget = torch.tensor([0, 1, 2, 2])\n<line_mask>\nmetric(pred, target)\ntensor(0.7500)",
            "masked_line": "metric = Precision(num_classes=4)",
            "answer": "Precision",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_552"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==0.9.0",
            "time": "2020-08-20",
            "description": "The code calculates the recall metric for the predictions \"pred\" compared to the target values \"target\". The recall value is 0.6250.",
            "code": "pred = torch.tensor([0, 1, 2, 3])\ntarget = torch.tensor([0, 1, 2, 2])\nmetric = Recall()\nmetric(pred, target)\ntensor(0.6250)",
            "masked_code": "pred = torch.tensor([0, 1, 2, 3])\ntarget = torch.tensor([0, 1, 2, 2])\n<line_mask>\nmetric(pred, target)\ntensor(0.6250)",
            "masked_line": "metric = Recall()",
            "answer": "Recall",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_553"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==0.9.0",
            "time": "2020-08-20",
            "description": "This code calculates the average precision of the predicted values compared to the target values.",
            "code": "pred = torch.tensor([0, 1, 2, 3])\ntarget = torch.tensor([0, 1, 2, 2])\nmetric = AveragePrecision()\nmetric(pred, target)\ntensor(0.3333)",
            "masked_code": "pred = torch.tensor([0, 1, 2, 3])\ntarget = torch.tensor([0, 1, 2, 2])\n<line_mask>\nmetric(pred, target)\ntensor(0.3333)",
            "masked_line": "metric = AveragePrecision()",
            "answer": "AveragePrecision",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_554"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==0.9.0",
            "time": "2020-08-20",
            "description": "Calculate the Area Under the Receiver Operating Characteristic Curve (AUROC) for the predicted values compared to the target values.",
            "code": "pred = torch.tensor([0, 1, 2, 3])\ntarget = torch.tensor([0, 1, 2, 2])\nmetric = AUROC()\nmetric(pred, target)\ntensor(0.3333)",
            "masked_code": "pred = torch.tensor([0, 1, 2, 3])\ntarget = torch.tensor([0, 1, 2, 2])\n<line_mask>\nmetric(pred, target)\ntensor(0.3333)",
            "masked_line": "metric = AUROC()",
            "answer": "AUROC",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_555"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==0.9.0",
            "time": "2020-08-20",
            "description": "Calculate the F-beta score with beta=0.25 between the predicted tensor and the target tensor.",
            "code": "pred = torch.tensor([0, 1, 2, 3])\ntarget = torch.tensor([0, 1, 2, 2])\nmetric = FBeta(0.25)\nmetric(pred, target)\ntensor(0.7361)",
            "masked_code": "pred = torch.tensor([0, 1, 2, 3])\ntarget = torch.tensor([0, 1, 2, 2])\n<line_mask>\nmetric(pred, target)\ntensor(0.7361)",
            "masked_line": "metric = FBeta(0.25)",
            "answer": "FBeta",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_556"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==0.9.0",
            "time": "2020-08-20",
            "description": "The code calculates the F1 score between the predicted tensor and the target tensor.",
            "code": "pred = torch.tensor([0, 1, 2, 3])\ntarget = torch.tensor([0, 1, 2, 2])\nmetric = F1()\nmetric(pred, target)\ntensor(0.6667)",
            "masked_code": "pred = torch.tensor([0, 1, 2, 3])\ntarget = torch.tensor([0, 1, 2, 2])\n<line_mask>\nmetric(pred, target)\ntensor(0.6667)",
            "masked_line": "metric = F1()",
            "answer": "F1",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_557"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==0.9.0",
            "time": "2020-08-20",
            "description": "The code calculates the false positive rate (fps), true positive rate (tps), and thresholds for receiver operating characteristic (ROC) analysis using the predicted values (pred) and target values (target) tensors.",
            "code": "pred = torch.tensor([0, 1, 2, 3])\ntarget = torch.tensor([0, 1, 2, 2])\nmetric = ROC()\nfps, tps, thresholds = metric(pred, target)\nfps\ntensor([0.0000, 0.3333, 0.6667, 0.6667, 1.0000])\ntps\ntensor([0., 0., 0., 1., 1.])\nthresholds\ntensor([4., 3., 2., 1., 0.])",
            "masked_code": "pred = torch.tensor([0, 1, 2, 3])\ntarget = torch.tensor([0, 1, 2, 2])\n<line_mask>\nfps, tps, thresholds = metric(pred, target)\nfps\ntensor([0.0000, 0.3333, 0.6667, 0.6667, 1.0000])\ntps\ntensor([0., 0., 0., 1., 1.])\nthresholds\ntensor([4., 3., 2., 1., 0.])",
            "masked_line": "metric = ROC()",
            "answer": "ROC",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_558"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==0.9.0",
            "time": "2020-08-20",
            "description": "The code calculates the Multiclass ROC (Receiver Operating Characteristic) curve for the predictions `pred` and corresponding true labels `target` using the MulticlassROC class. It returns the true positive rate, false positive rate, and thresholds for each class.",
            "code": "pred = torch.tensor([[0.85, 0.05, 0.05, 0.05],\n...                     [0.05, 0.85, 0.05, 0.05],\n...                     [0.05, 0.05, 0.85, 0.05],\n...                     [0.05, 0.05, 0.05, 0.85]])\ntarget = torch.tensor([0, 1, 3, 2])\nmetric = MulticlassROC()\nclasses_roc = metric(pred, target)\nmetric(pred, target)   # doctest: +NORMALIZE_WHITESPACE\n((tensor([0., 0., 1.]), tensor([0., 1., 1.]), tensor([1.8500, 0.8500, 0.0500])),\n (tensor([0., 0., 1.]), tensor([0., 1., 1.]), tensor([1.8500, 0.8500, 0.0500])),\n (tensor([0.0000, 0.3333, 1.0000]), tensor([0., 0., 1.]), tensor([1.8500, 0.8500, 0.0500])),\n (tensor([0.0000, 0.3333, 1.0000]), tensor([0., 0., 1.]), tensor([1.8500, 0.8500, 0.0500])))",
            "masked_code": "pred = torch.tensor([[0.85, 0.05, 0.05, 0.05],\n...                     [0.05, 0.85, 0.05, 0.05],\n...                     [0.05, 0.05, 0.85, 0.05],\n...                     [0.05, 0.05, 0.05, 0.85]])\ntarget = torch.tensor([0, 1, 3, 2])\n<line_mask>\nclasses_roc = metric(pred, target)\nmetric(pred, target)   # doctest: +NORMALIZE_WHITESPACE\n((tensor([0., 0., 1.]), tensor([0., 1., 1.]), tensor([1.8500, 0.8500, 0.0500])),\n (tensor([0., 0., 1.]), tensor([0., 1., 1.]), tensor([1.8500, 0.8500, 0.0500])),\n (tensor([0.0000, 0.3333, 1.0000]), tensor([0., 0., 1.]), tensor([1.8500, 0.8500, 0.0500])),\n (tensor([0.0000, 0.3333, 1.0000]), tensor([0., 0., 1.]), tensor([1.8500, 0.8500, 0.0500])))",
            "masked_line": "metric = MulticlassROC()",
            "answer": "MulticlassROC",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_559"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==0.9.0",
            "time": "2020-08-20",
            "description": "This code calculates the Dice coefficient metric between the predicted tensor and the target tensor.",
            "code": "pred = torch.tensor([[0.85, 0.05, 0.05, 0.05],\n...                      [0.05, 0.85, 0.05, 0.05],\n...                      [0.05, 0.05, 0.85, 0.05],\n...                      [0.05, 0.05, 0.05, 0.85]])\ntarget = torch.tensor([0, 1, 3, 2])\nmetric = DiceCoefficient()\nmetric(pred, target)\ntensor(0.3333)",
            "masked_code": "pred = torch.tensor([[0.85, 0.05, 0.05, 0.05],\n...                      [0.05, 0.85, 0.05, 0.05],\n...                      [0.05, 0.05, 0.85, 0.05],\n...                      [0.05, 0.05, 0.05, 0.85]])\ntarget = torch.tensor([0, 1, 3, 2])\n<line_mask>\nmetric(pred, target)\ntensor(0.3333)",
            "masked_line": "metric = DiceCoefficient()",
            "answer": "DiceCoefficient",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_560"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==0.9.0",
            "time": "2020-08-20",
            "description": "The code calculates the BLEU score (bilingual evaluation understudy) between the translation corpus and the reference corpus, which measures the similarity between the translation and reference texts.",
            "code": "translate_corpus = ['the cat is on the mat'.split()]\nreference_corpus = [['there is a cat on the mat'.split(), 'a cat is on the mat'.split()]]\nmetric = BLEUScore()\nmetric(translate_corpus, reference_corpus)\ntensor(0.7598)",
            "masked_code": "translate_corpus = ['the cat is on the mat'.split()]\nreference_corpus = [['there is a cat on the mat'.split(), 'a cat is on the mat'.split()]]\n<line_mask>\nmetric(translate_corpus, reference_corpus)\ntensor(0.7598)",
            "masked_line": "metric = BLEUScore()",
            "answer": "BLEUScore",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_561"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==0.9.0",
            "time": "2020-08-20",
            "description": "The code calculates the Root Mean Square Error (RMSE) between the predicted values (pred) and the target values (target).",
            "code": "pred = torch.tensor([0., 1, 2, 3])\ntarget = torch.tensor([0., 1, 2, 2])\nmetric = RMSE()\nmetric(pred, target)\ntensor(0.5000)",
            "masked_code": "pred = torch.tensor([0., 1, 2, 3])\ntarget = torch.tensor([0., 1, 2, 2])\n<line_mask>\nmetric(pred, target)\ntensor(0.5000)",
            "masked_line": "metric = RMSE()",
            "answer": "RMSE",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_562"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==0.9.0",
            "time": "2020-08-20",
            "description": "This code calculates the Mean Absolute Error (MAE) between the predicted values (pred) and the target values (target).",
            "code": "pred = torch.tensor([0., 1, 2, 3])\ntarget = torch.tensor([0., 1, 2, 2])\nmetric = MAE()\nmetric(pred, target)\ntensor(0.2500)",
            "masked_code": "pred = torch.tensor([0., 1, 2, 3])\ntarget = torch.tensor([0., 1, 2, 2])\n<line_mask>\nmetric(pred, target)\ntensor(0.2500)",
            "masked_line": "metric = MAE()",
            "answer": "MAE",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_563"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==0.9.0",
            "time": "2020-08-20",
            "description": "Calculate the Root Mean Squared Logarithmic Error (RMSLE) between the predicted values and the target values.",
            "code": "pred = torch.tensor([0., 1, 2, 3])\ntarget = torch.tensor([0., 1, 2, 2])\nmetric = RMSLE()\nmetric(pred, target)\ntensor(0.0207)",
            "masked_code": "pred = torch.tensor([0., 1, 2, 3])\ntarget = torch.tensor([0., 1, 2, 2])\n<line_mask>\nmetric(pred, target)\ntensor(0.0207)",
            "masked_line": "metric = RMSLE()",
            "answer": "RMSLE",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_564"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==0.9.0",
            "time": "2020-08-20",
            "description": "This code calculates the Peak Signal-to-Noise Ratio (PSNR) between two sets of tensors, 'pred' and 'target'.",
            "code": "pred = torch.tensor([[0.0, 1.0], [2.0, 3.0]])\ntarget = torch.tensor([[3.0, 2.0], [1.0, 0.0]])\nmetric = PSNR()\nmetric(pred, target)\ntensor(2.5527)",
            "masked_code": "pred = torch.tensor([[0.0, 1.0], [2.0, 3.0]])\ntarget = torch.tensor([[3.0, 2.0], [1.0, 0.0]])\n<line_mask>\nmetric(pred, target)\ntensor(2.5527)",
            "masked_line": "metric = PSNR()",
            "answer": "PSNR",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_565"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==0.9.0",
            "time": "2020-08-20",
            "description": "This code calculates the structural similarity index between the predicted and target images, where the predicted image is generated using random values and the target image is created by multiplying the predicted image by 0.75. The SSIM metric is used to measure the similarity between the two images, and the resulting similarity index value is 0.9219.",
            "code": "pred = torch.rand([16, 1, 16, 16])\ntarget = pred * 0.75\nmetric = SSIM()\nmetric(pred, target)\ntensor(0.9219)",
            "masked_code": "pred = torch.rand([16, 1, 16, 16])\ntarget = pred * 0.75\n<line_mask>\nmetric(pred, target)\ntensor(0.9219)",
            "masked_line": "metric = SSIM()",
            "answer": "SSIM",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_566"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==0.9.0",
            "time": "2020-08-20",
            "description": "Calculate the balanced accuracy of the predicted values y_pred compared to the true values y_true.",
            "code": "y_pred = torch.tensor([0, 0, 0, 1])\ny_true = torch.tensor([0, 0, 1, 1])\nmetric = BalancedAccuracy()\nmetric(y_pred, y_true)\ntensor([0.7500])",
            "masked_code": "y_pred = torch.tensor([0, 0, 0, 1])\ny_true = torch.tensor([0, 0, 1, 1])\n<line_mask>\nmetric(y_pred, y_true)\ntensor([0.7500])",
            "masked_line": "metric = BalancedAccuracy()",
            "answer": "BalancedAccuracy",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_568"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==0.9.0",
            "time": "2020-08-20",
            "description": "The code calculates the Cohen's Kappa score between the predicted values (y_pred) and the true values (y_true).",
            "code": "y_pred = torch.tensor([1, 2, 0, 2])\ny_true = torch.tensor([2, 2, 2, 1])\nmetric = CohenKappaScore()\nmetric(y_pred, y_true)\ntensor([-0.3333])",
            "masked_code": "y_pred = torch.tensor([1, 2, 0, 2])\ny_true = torch.tensor([2, 2, 2, 1])\n<line_mask>\nmetric(y_pred, y_true)\ntensor([-0.3333])",
            "masked_line": "metric = CohenKappaScore()",
            "answer": "CohenKappaScore",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_569"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==0.9.0",
            "time": "2020-08-20",
            "description": "The code calculates the Discounted Cumulative Gain (DCG) metric for the predicted scores `y_score` and the true labels `y_true`.",
            "code": "y_score = torch.tensor([[.1, .2, .3, 4, 70]])\ny_true = torch.tensor([[10, 0, 0, 1, 5]])\nmetric = DCG()\nmetric(y_score, y_true)\ntensor([9.4995])",
            "masked_code": "y_score = torch.tensor([[.1, .2, .3, 4, 70]])\ny_true = torch.tensor([[10, 0, 0, 1, 5]])\n<line_mask>\nmetric(y_score, y_true)\ntensor([9.4995])",
            "masked_line": "metric = DCG()",
            "answer": "DCG",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_570"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==0.9.0",
            "time": "2020-08-20",
            "description": "The code calculates the Hamming loss metric between the predicted tensor y_pred and the true tensor y_true, resulting in a tensor value of 0.2500.",
            "code": "y_pred = torch.tensor([0, 1, 2, 3])\ny_true = torch.tensor([1, 1, 2, 3])\nmetric = Hamming()\nmetric(y_pred, y_true)\ntensor([0.2500])",
            "masked_code": "y_pred = torch.tensor([0, 1, 2, 3])\ny_true = torch.tensor([1, 1, 2, 3])\n<line_mask>\nmetric(y_pred, y_true)\ntensor([0.2500])",
            "masked_line": "metric = Hamming()",
            "answer": "Hamming",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_573"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==0.9.0",
            "time": "2020-08-20",
            "description": "Calculate the Hinge loss between the predicted decisions and the true labels.",
            "code": "pred_decision = torch.tensor([-2.17, -0.97, -0.19, -0.43])\ny_true = torch.tensor([1, 1, 0, 0])\nmetric = Hinge()\nmetric(pred_decision, y_true)\ntensor([1.6300])",
            "masked_code": "pred_decision = torch.tensor([-2.17, -0.97, -0.19, -0.43])\ny_true = torch.tensor([1, 1, 0, 0])\n<line_mask>\nmetric(pred_decision, y_true)\ntensor([1.6300])",
            "masked_line": "metric = Hinge()",
            "answer": "Hinge",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_574"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==0.9.0",
            "time": "2020-08-20",
            "description": "Calculate the Jaccard similarity coefficient between the predicted tensor and true tensor.",
            "code": "y_pred = torch.tensor([1, 1, 1])\ny_true = torch.tensor([0, 1, 1])\nmetric = Jaccard()\nmetric(y_pred, y_true)\ntensor([0.3333])",
            "masked_code": "y_pred = torch.tensor([1, 1, 1])\ny_true = torch.tensor([0, 1, 1])\n<line_mask>\nmetric(y_pred, y_true)\ntensor([0.3333])",
            "masked_line": "metric = Jaccard()",
            "answer": "Jaccard",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_575"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==0.9.0",
            "time": "2020-08-20",
            "description": "The code calculates the explained variance between the predicted tensor and the true tensor values.",
            "code": "y_pred = torch.tensor([2.5, 0.0, 2, 8])\ny_true = torch.tensor([3, -0.5, 2, 7])\nmetric = ExplainedVariance()\nmetric(y_pred, y_true)\ntensor([0.9572])",
            "masked_code": "y_pred = torch.tensor([2.5, 0.0, 2, 8])\ny_true = torch.tensor([3, -0.5, 2, 7])\n<line_mask>\nmetric(y_pred, y_true)\ntensor([0.9572])",
            "masked_line": "metric = ExplainedVariance()",
            "answer": "ExplainedVariance",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_579"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==0.9.0",
            "time": "2020-08-20",
            "description": "The code calculates the R-squared score (coefficient of determination) of the predicted values (y_pred) compared to the true values (y_true).",
            "code": "y_pred = torch.tensor([2.5, 0.0, 2, 8])\ny_true = torch.tensor([3, -0.5, 2, 7])\nmetric = R2Score()\nmetric(y_pred, y_true)\ntensor([0.9486])",
            "masked_code": "y_pred = torch.tensor([2.5, 0.0, 2, 8])\ny_true = torch.tensor([3, -0.5, 2, 7])\n<line_mask>\nmetric(y_pred, y_true)\ntensor([0.9486])",
            "masked_line": "metric = R2Score()",
            "answer": "R2Score",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_580"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==0.9.0",
            "time": "2020-08-20",
            "description": "The code calculates the mean Poisson deviance between the predicted values (y_pred) and the true values (y_true) using the MeanPoissonDeviance metric.",
            "code": "y_pred = torch.tensor([2, 0.5, 1, 4])\ny_true = torch.tensor([0.5, 0.5, 2., 2.])\nmetric = MeanPoissonDeviance()\nmetric(y_pred, y_true)\ntensor([0.9034])",
            "masked_code": "y_pred = torch.tensor([2, 0.5, 1, 4])\ny_true = torch.tensor([0.5, 0.5, 2., 2.])\n<line_mask>\nmetric(y_pred, y_true)\ntensor([0.9034])",
            "masked_line": "metric = MeanPoissonDeviance()",
            "answer": "MeanPoissonDeviance",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_581"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==0.9.0",
            "time": "2020-08-20",
            "description": "The code calculates the Mean Gamma Deviance metric between the predicted values (y_pred) and true values (y_true) using torch tensors.",
            "code": "y_pred = torch.tensor([0.5, 0.5, 2., 2.])\ny_true = torch.tensor([2, 0.5, 1, 4])\nmetric = MeanGammaDeviance()\nmetric(y_pred, y_true)\ntensor([1.0569])",
            "masked_code": "y_pred = torch.tensor([0.5, 0.5, 2., 2.])\ny_true = torch.tensor([2, 0.5, 1, 4])\n<line_mask>\nmetric(y_pred, y_true)\ntensor([1.0569])",
            "masked_line": "metric = MeanGammaDeviance()",
            "answer": "MeanGammaDeviance",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_582"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==0.9.0",
            "time": "2020-08-20",
            "description": "Calculate the mean Tweedie deviance between the predicted values y_pred and the true values y_true.",
            "code": "y_pred = torch.tensor([2, 0.5, 1, 4])\ny_true = torch.tensor([0.5, 0.5, 2., 2.])\nmetric = MeanTweedieDeviance()\nmetric(y_pred, y_true)\ntensor([1.8125])",
            "masked_code": "y_pred = torch.tensor([2, 0.5, 1, 4])\ny_true = torch.tensor([0.5, 0.5, 2., 2.])\n<line_mask>\nmetric(y_pred, y_true)\ntensor([1.8125])",
            "masked_line": "metric = MeanTweedieDeviance()",
            "answer": "MeanTweedieDeviance",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_583"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==0.9.0",
            "time": "2020-08-20",
            "description": "This code prepares and sets up data for a task by downloading, cleaning, and caching ImageNet dataset.",
            "code": "dm.prepare_data()\ndm.setup()\n\ndef prepare_data(self):\n    download_imagenet()\n    clean_imagenet()\n    cache_imagenet()\n",
            "masked_code": "<line_mask>\ndm.setup()\n\ndef prepare_data(self):\n    download_imagenet()\n    clean_imagenet()\n    cache_imagenet()\n",
            "masked_line": "dm.prepare_data()",
            "answer": "prepare_data",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_584"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==0.9.0",
            "time": "2020-08-20",
            "description": "This function transfers a batch of data to the specified device. If the batch is an instance of CustomBatch, it moves all tensors in the custom data structure to the device. Otherwise, it calls the superclass method to transfer the batch to the device.",
            "code": "def transfer_batch_to_device(self, batch, device):\n    if isinstance(batch, CustomBatch):\n        # move all tensors in your custom data structure to the device\n        batch.samples = batch.samples.to(device)\n        batch.targets = batch.targets.to(device)\n    else:\n        batch = super().transfer_batch_to_device(data, device)\n    return batch",
            "masked_code": "def transfer_batch_to_device(self, batch, device):\n    if isinstance(batch, CustomBatch):\n        # move all tensors in your custom data structure to the device\n        batch.samples = batch.samples.to(device)\n        batch.targets = batch.targets.to(device)\n    else:\n        <line_mask>\n    return batch",
            "masked_line": "batch = super().transfer_batch_to_device(data, device)",
            "answer": "transfer_batch_to_device",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_585"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==0.9.0",
            "time": "2020-08-20",
            "description": "This function transfers a batch of data to a specified device, either moving all tensors in a custom data structure to the device or calling the superclass function to transfer the batch if it is not a custom batch.",
            "code": "def transfer_batch_to_device(self, batch, device):\n    if isinstance(batch, CustomBatch):\n        # move all tensors in your custom data structure to the device\n        batch.samples = batch.samples.to(device)\n        batch.targets = batch.targets.to(device)\n    else:\n        batch = super().transfer_batch_to_device(data, device)\n    return batch\n",
            "masked_code": "def transfer_batch_to_device(self, batch, device):\n    if isinstance(batch, CustomBatch):\n        # move all tensors in your custom data structure to the device\n        batch.samples = batch.samples.to(device)\n        batch.targets = batch.targets.to(device)\n    else:\n        <line_mask>\n    return batch\n",
            "masked_line": "batch = super().transfer_batch_to_device(data, device)",
            "answer": "transfer_batch_to_device",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_586"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==0.9.0",
            "time": "2020-08-20",
            "description": "This function creates a data loader for training data for the MNIST dataset in PyTorch with specified transformation and batch size.",
            "code": "def train_dataloader(self):\n    transform = transforms.Compose([transforms.ToTensor(),\n                                    transforms.Normalize((0.5,), (1.0,))])\n    dataset = MNIST(root='/path/to/mnist/', train=True, transform=transform,\n                    download=True)\n    loader = torch.utils.data.DataLoader(\n        dataset=dataset,\n        batch_size=self.batch_size,\n        shuffle=True\n    )\n    return loader",
            "masked_code": "<line_mask>\n    transform = transforms.Compose([transforms.ToTensor(),\n                                    transforms.Normalize((0.5,), (1.0,))])\n    dataset = MNIST(root='/path/to/mnist/', train=True, transform=transform,\n                    download=True)\n    loader = torch.utils.data.DataLoader(\n        dataset=dataset,\n        batch_size=self.batch_size,\n        shuffle=True\n    )\n    return loader",
            "masked_line": "def train_dataloader(self):",
            "answer": "train_dataloader",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_587"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==0.9.0",
            "time": "2020-08-20",
            "description": "The function `test_dataloader` creates a data loader for the MNIST dataset with specified transformations and parameters, and returns it. It can also potentially return multiple data loaders.",
            "code": "def test_dataloader(self):\n    transform = transforms.Compose([transforms.ToTensor(),\n                                    transforms.Normalize((0.5,), (1.0,))])\n    dataset = MNIST(root='/path/to/mnist/', train=False, transform=transform,\n                    download=True)\n    loader = torch.utils.data.DataLoader(\n        dataset=dataset,\n        batch_size=self.batch_size,\n        shuffle=False\n    )\n\n    return loader\n\n# can also return multiple dataloaders\ndef test_dataloader(self):\n    return [loader_a, loader_b, ..., loader_n]\n",
            "masked_code": "def test_dataloader(self):\n    transform = transforms.Compose([transforms.ToTensor(),\n                                    transforms.Normalize((0.5,), (1.0,))])\n    dataset = MNIST(root='/path/to/mnist/', train=False, transform=transform,\n                    download=True)\n    loader = torch.utils.data.DataLoader(\n        dataset=dataset,\n        batch_size=self.batch_size,\n        shuffle=False\n    )\n\n    return loader\n\n# can also return multiple dataloaders\n<line_mask>\n    return [loader_a, loader_b, ..., loader_n]\n",
            "masked_line": "def test_dataloader(self):",
            "answer": "test_dataloader",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_588"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==0.9.0",
            "time": "2020-08-20",
            "description": "This code defines a function that creates a data loader for validation data. The function sets up data transformation, loads the MNIST dataset, and creates a DataLoader object with specified batch size and shuffle settings. It returns the DataLoader object for the validation data. Additionally, it can also return multiple data loaders if needed.",
            "code": "def val_dataloader(self):\n    transform = transforms.Compose([transforms.ToTensor(),\n                                    transforms.Normalize((0.5,), (1.0,))])\n    dataset = MNIST(root='/path/to/mnist/', train=False,\n                    transform=transform, download=True)\n    loader = torch.utils.data.DataLoader(\n        dataset=dataset,\n        batch_size=self.batch_size,\n        shuffle=False\n    )\n\n    return loader\n\n# can also return multiple dataloaders\ndef val_dataloader(self):\n    return [loader_a, loader_b, ..., loader_n]\n",
            "masked_code": "<line_mask>\n    transform = transforms.Compose([transforms.ToTensor(),\n                                    transforms.Normalize((0.5,), (1.0,))])\n    dataset = MNIST(root='/path/to/mnist/', train=False,\n                    transform=transform, download=True)\n    loader = torch.utils.data.DataLoader(\n        dataset=dataset,\n        batch_size=self.batch_size,\n        shuffle=False\n    )\n\n    return loader\n\n# can also return multiple dataloaders\ndef val_dataloader(self):\n    return [loader_a, loader_b, ..., loader_n]\n",
            "masked_line": "def val_dataloader(self):",
            "answer": "val_dataloader",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_589"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==0.9.0",
            "time": "2020-08-20",
            "description": "The code defines a parser to handle arguments without adding help, adds custom argument \"--my_custom_arg\" with a default value of 'something', then parses the arguments and creates a Trainer object using the parsed arguments with logger disabled.",
            "code": "parser = ArgumentParser(add_help=False)\nparser = Trainer.add_argparse_args(parser)\nparser.add_argument('--my_custom_arg', default='something')  # doctest: +SKIP\nargs = Trainer.parse_argparser(parser.parse_args(\"\"))\ntrainer = Trainer.from_argparse_args(args, logger=False)",
            "masked_code": "parser = ArgumentParser(add_help=False)\nparser = Trainer.add_argparse_args(parser)\nparser.add_argument('--my_custom_arg', default='something')  # doctest: +SKIP\nargs = Trainer.parse_argparser(parser.parse_args(\"\"))\n<line_mask>",
            "masked_line": "trainer = Trainer.from_argparse_args(args, logger=False)",
            "answer": "from_argparse_args",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_590"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==0.7.6",
            "time": "2020-05-15",
            "description": "The code updates the values of 'a' and 'c' in the hparams dictionary and then retrieves and prints the updated values of 'b' and 'c'.",
            "code": "hparams = {'c': 4}\nupdate_hparams(hparams, {'a': {'b': 2}, 'c': 1})\nhparams['a']['b'], hparams['c']\nupdate_hparams(hparams, {'a': {'b': 4}, 'c': 7})\nhparams['a']['b'], hparams['c']",
            "masked_code": "hparams = {'c': 4}\nupdate_hparams(hparams, {'a': {'b': 2}, 'c': 1})\nhparams['a']['b'], hparams['c']\n<line_mask>\nhparams['a']['b'], hparams['c']",
            "masked_line": "update_hparams(hparams, {'a': {'b': 4}, 'c': 7})",
            "answer": "update_hparams",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_591"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==0.7.6",
            "time": "2020-05-15",
            "description": "The code defines a set of hyperparameters, saves them to a CSV file, loads the hyperparameters from the CSV file, compares the original hyperparameters with the loaded hyperparameters, and finally deletes the CSV file.",
            "code": "hparams = Namespace(batch_size=32, learning_rate=0.001, data_root='./any/path/here')\npath_csv = './testing-hparams.csv'\nsave_hparams_to_tags_csv(path_csv, hparams)\nhparams_new = load_hparams_from_tags_csv(path_csv)\nvars(hparams) == hparams_new\nos.remove(path_csv)",
            "masked_code": "hparams = Namespace(batch_size=32, learning_rate=0.001, data_root='./any/path/here')\npath_csv = './testing-hparams.csv'\nsave_hparams_to_tags_csv(path_csv, hparams)\n<line_mask>\nvars(hparams) == hparams_new\nos.remove(path_csv)",
            "masked_line": "hparams_new = load_hparams_from_tags_csv(path_csv)",
            "answer": "load_hparams_from_tags_csv",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_592"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==0.7.6",
            "time": "2020-05-15",
            "description": "This code creates a namespace object with specified parameters, saves the parameters to a YAML file, loads the parameters from the YAML file into a new namespace object, compares the parameters of the original and loaded namespace objects, and then removes the YAML file.",
            "code": "hparams = Namespace(batch_size=32, learning_rate=0.001, data_root='./any/path/here')\npath_yaml = './testing-hparams.yaml'\nsave_hparams_to_yaml(path_yaml, hparams)\nhparams_new = load_hparams_from_yaml(path_yaml)\nvars(hparams) == hparams_new\nos.remove(path_yaml)",
            "masked_code": "hparams = Namespace(batch_size=32, learning_rate=0.001, data_root='./any/path/here')\npath_yaml = './testing-hparams.yaml'\nsave_hparams_to_yaml(path_yaml, hparams)\n<line_mask>\nvars(hparams) == hparams_new\nos.remove(path_yaml)",
            "masked_line": "hparams_new = load_hparams_from_yaml(path_yaml)",
            "answer": "load_hparams_from_yaml",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_593"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==0.8.0",
            "time": "2020-06-18",
            "description": "Calculate the accuracy of the predictions compared to the target values.",
            "code": "pred = torch.tensor([0, 1, 2, 3])\ntarget = torch.tensor([0, 1, 2, 2])\nmetric = Accuracy()\nmetric(pred, target)\ntensor(0.7500)",
            "masked_code": "pred = torch.tensor([0, 1, 2, 3])\ntarget = torch.tensor([0, 1, 2, 2])\n<line_mask>\nmetric(pred, target)\ntensor(0.7500)",
            "masked_line": "metric = Accuracy()",
            "answer": "Accuracy",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_594"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==0.8.0",
            "time": "2020-06-18",
            "description": "This code calculates the confusion matrix between the predicted values (pred) and the target values (target).",
            "code": "pred = torch.tensor([0, 1, 2, 2])\ntarget = torch.tensor([0, 1, 2, 2])\nmetric = ConfusionMatrix()\nmetric(pred, target)\ntensor([[1., 0., 0.],\n        [0., 1., 0.],\n        [0., 0., 2.]])",
            "masked_code": "pred = torch.tensor([0, 1, 2, 2])\ntarget = torch.tensor([0, 1, 2, 2])\n<line_mask>\nmetric(pred, target)\ntensor([[1., 0., 0.],\n        [0., 1., 0.],\n        [0., 0., 2.]])",
            "masked_line": "metric = ConfusionMatrix()",
            "answer": "ConfusionMatrix",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_595"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==0.8.0",
            "time": "2020-06-18",
            "description": "The code calculates precision, recall, and thresholds based on the predicted and target values.",
            "code": "pred = torch.tensor([0, 1, 2, 3])\ntarget = torch.tensor([0, 1, 2, 2])\nmetric = PrecisionRecall()\nprec, recall, thr = metric(pred, target)\nprec\ntensor([0.3333, 0.0000, 0.0000, 1.0000])\nrecall\ntensor([1., 0., 0., 0.])\nthr\ntensor([1., 2., 3.])",
            "masked_code": "pred = torch.tensor([0, 1, 2, 3])\ntarget = torch.tensor([0, 1, 2, 2])\n<line_mask>\nprec, recall, thr = metric(pred, target)\nprec\ntensor([0.3333, 0.0000, 0.0000, 1.0000])\nrecall\ntensor([1., 0., 0., 0.])\nthr\ntensor([1., 2., 3.])",
            "masked_line": "metric = PrecisionRecall()",
            "answer": "PrecisionRecall",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_596"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==0.8.0",
            "time": "2020-06-18",
            "description": "The code calculates the recall metric for a prediction tensor and a target tensor.",
            "code": "pred = torch.tensor([0, 1, 2, 3])\ntarget = torch.tensor([0, 1, 2, 2])\nmetric = Recall()\nmetric(pred, target)\ntensor(0.6250)",
            "masked_code": "pred = torch.tensor([0, 1, 2, 3])\ntarget = torch.tensor([0, 1, 2, 2])\n<line_mask>\nmetric(pred, target)\ntensor(0.6250)",
            "masked_line": "metric = Recall()",
            "answer": "Recall",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_597"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==0.8.0",
            "time": "2020-06-18",
            "description": "Calculate the average precision score between the predicted tensor values and the target tensor values.",
            "code": "pred = torch.tensor([0, 1, 2, 3])\ntarget = torch.tensor([0, 1, 2, 2])\nmetric = AveragePrecision()\nmetric(pred, target)\ntensor(0.3333)",
            "masked_code": "pred = torch.tensor([0, 1, 2, 3])\ntarget = torch.tensor([0, 1, 2, 2])\n<line_mask>\nmetric(pred, target)\ntensor(0.3333)",
            "masked_line": "metric = AveragePrecision()",
            "answer": "AveragePrecision",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_598"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==0.8.0",
            "time": "2020-06-18",
            "description": "The code calculates the Area Under the Receiver Operating Characteristic (AUROC) metric using the predicted values (pred) and target values (target). The AUROC value obtained is 0.3333.",
            "code": "pred = torch.tensor([0, 1, 2, 3])\ntarget = torch.tensor([0, 1, 2, 2])\nmetric = AUROC()\nmetric(pred, target)\ntensor(0.3333)",
            "masked_code": "pred = torch.tensor([0, 1, 2, 3])\ntarget = torch.tensor([0, 1, 2, 2])\n<line_mask>\nmetric(pred, target)\ntensor(0.3333)",
            "masked_line": "metric = AUROC()",
            "answer": "AUROC",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_599"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==0.8.0",
            "time": "2020-06-18",
            "description": "The code calculates the F-beta score with beta=0.25 between the predicted tensor and target tensor.",
            "code": "pred = torch.tensor([0, 1, 2, 3])\ntarget = torch.tensor([0, 1, 2, 2])\nmetric = FBeta(0.25)\nmetric(pred, target)\ntensor(0.7361)",
            "masked_code": "pred = torch.tensor([0, 1, 2, 3])\ntarget = torch.tensor([0, 1, 2, 2])\n<line_mask>\nmetric(pred, target)\ntensor(0.7361)",
            "masked_line": "metric = FBeta(0.25)",
            "answer": "FBeta",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_600"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==0.8.0",
            "time": "2020-06-18",
            "description": "Calculate the F1 score metric for the predicted values compared to the target values.",
            "code": "pred = torch.tensor([0, 1, 2, 3])\ntarget = torch.tensor([0, 1, 2, 2])\nmetric = F1()\nmetric(pred, target)\ntensor(0.6667)",
            "masked_code": "pred = torch.tensor([0, 1, 2, 3])\ntarget = torch.tensor([0, 1, 2, 2])\n<line_mask>\nmetric(pred, target)\ntensor(0.6667)",
            "masked_line": "metric = F1()",
            "answer": "F1",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_601"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==0.8.0",
            "time": "2020-06-18",
            "description": "The code calculates the False Positive Rate (fps), True Positive Rate (tps), and thresholds using the Receiver Operating Characteristic (ROC) metric for the predicted values (pred) compared to the target values (target).",
            "code": "pred = torch.tensor([0, 1, 2, 3])\ntarget = torch.tensor([0, 1, 2, 2])\nmetric = ROC()\nfps, tps, thresholds = metric(pred, target)\nfps\ntensor([0.0000, 0.3333, 0.6667, 0.6667, 1.0000])\ntps\ntensor([0., 0., 0., 1., 1.])\nthresholds\ntensor([4., 3., 2., 1., 0.])",
            "masked_code": "pred = torch.tensor([0, 1, 2, 3])\ntarget = torch.tensor([0, 1, 2, 2])\n<line_mask>\nfps, tps, thresholds = metric(pred, target)\nfps\ntensor([0.0000, 0.3333, 0.6667, 0.6667, 1.0000])\ntps\ntensor([0., 0., 0., 1., 1.])\nthresholds\ntensor([4., 3., 2., 1., 0.])",
            "masked_line": "metric = ROC()",
            "answer": "ROC",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_602"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==0.8.0",
            "time": "2020-06-18",
            "description": "This code calculates the Dice coefficient metric between the predicted tensor \"pred\" and the target tensor \"target\" for a multi-class classification problem.",
            "code": "pred = torch.tensor([[0.85, 0.05, 0.05, 0.05],\n...                      [0.05, 0.85, 0.05, 0.05],\n...                      [0.05, 0.05, 0.85, 0.05],\n...                      [0.05, 0.05, 0.05, 0.85]])\ntarget = torch.tensor([0, 1, 3, 2])\nmetric = DiceCoefficient()\nmetric(pred, target)\ntensor(0.3333)",
            "masked_code": "pred = torch.tensor([[0.85, 0.05, 0.05, 0.05],\n...                      [0.05, 0.85, 0.05, 0.05],\n...                      [0.05, 0.05, 0.85, 0.05],\n...                      [0.05, 0.05, 0.05, 0.85]])\ntarget = torch.tensor([0, 1, 3, 2])\n<line_mask>\nmetric(pred, target)\ntensor(0.3333)",
            "masked_line": "metric = DiceCoefficient()",
            "answer": "DiceCoefficient",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_603"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==0.8.0",
            "time": "2020-06-18",
            "description": "The code calculates the Intersection over Union (IoU) metric between two sets of binary masks represented as tensors.",
            "code": "pred = torch.tensor([[0, 0, 0, 0, 0, 0, 0, 0],\n...                      [0, 0, 1, 1, 1, 0, 0, 0],\n...                      [0, 0, 0, 0, 0, 0, 0, 0]])\ntarget = torch.tensor([[0, 0, 0, 0, 0, 0, 0, 0],\n...                        [0, 0, 0, 1, 1, 1, 0, 0],\n...                        [0, 0, 0, 0, 0, 0, 0, 0]])\nmetric = IoU()\nmetric(pred, target)\ntensor(0.7045)",
            "masked_code": "pred = torch.tensor([[0, 0, 0, 0, 0, 0, 0, 0],\n...                      [0, 0, 1, 1, 1, 0, 0, 0],\n...                      [0, 0, 0, 0, 0, 0, 0, 0]])\ntarget = torch.tensor([[0, 0, 0, 0, 0, 0, 0, 0],\n...                        [0, 0, 0, 1, 1, 1, 0, 0],\n...                        [0, 0, 0, 0, 0, 0, 0, 0]])\n<line_mask>\nmetric(pred, target)\ntensor(0.7045)",
            "masked_line": "metric = IoU()",
            "answer": "IoU",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_604"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==0.8.0",
            "time": "2020-06-18",
            "description": "The code creates an AttributeDict object with initial key-value pairs 'key1': 1 and 'key2': 'abc'. It then updates the AttributeDict with a new key-value pair 'my-key': 3.14 and another pair 'mew_key': 42. Finally, it updates the value of key 'key1' to 2 and prints out the AttributeDict object.",
            "code": "ad = AttributeDict({'key1': 1, 'key2': 'abc'})\nad.update({'my-key': 3.14})\nad.update(mew_key=42)\nad.key1 = 2\nad",
            "masked_code": "<line_mask>\nad.update({'my-key': 3.14})\nad.update(mew_key=42)\nad.key1 = 2\nad",
            "masked_line": "ad = AttributeDict({'key1': 1, 'key2': 'abc'})",
            "answer": "AttributeDict",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_612"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==0.8.0",
            "time": "2020-06-18",
            "description": "This function calculates the confusion matrix between the predicted values and the target values. If normalize is set to True, it normalizes the confusion matrix.",
            "code": "def confusion_matrix(pred, target, normalize=False):\n    num_classes = max(max(pred), max(target)) + 1\n    C = torch.zeros(num_classes, num_classes)\n    for p, t in zip(pred, target):\n        C[p, t] += 1\n    if normalize:\n        C = C / C.sum(1, keepdim=True)\n    return C\n",
            "masked_code": "<line_mask>\n    num_classes = max(max(pred), max(target)) + 1\n    C = torch.zeros(num_classes, num_classes)\n    for p, t in zip(pred, target):\n        C[p, t] += 1\n    if normalize:\n        C = C / C.sum(1, keepdim=True)\n    return C\n",
            "masked_line": "def confusion_matrix(pred, target, normalize=False):",
            "answer": "confusion_matrix",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_613"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==0.8.0",
            "time": "2020-06-18",
            "description": "The function calculates the precision and recall values for a classification task with multiple classes.",
            "code": "def precision_recall(pred, target, num_classes, reduction='elementwise_mean'):\n    # compute precision and recall\n    # code here\n\n    return precision, recall\n\nx = torch.tensor([0, 1, 2, 3])\ny = torch.tensor([0, 1, 2, 2])\nprecision_recall(x, y)\n",
            "masked_code": "<line_mask>\n    # compute precision and recall\n    # code here\n\n    return precision, recall\n\nx = torch.tensor([0, 1, 2, 3])\ny = torch.tensor([0, 1, 2, 2])\nprecision_recall(x, y)\n",
            "masked_line": "def precision_recall(pred, target, num_classes, reduction='elementwise_mean'):",
            "answer": "precision_recall",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_614"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==0.8.0",
            "time": "2020-06-18",
            "description": "The given Python code calculates the receiver operating characteristic (ROC) curve by comparing the values in tensors x and y, and returns the false positive rates (fpr), true positive rates (tpr), and thresholds.",
            "code": "x = torch.tensor([0, 1, 2, 3])\ny = torch.tensor([0, 1, 2, 2])\nfpr, tpr, thresholds = roc(x, y)\nfpr\ntpr\nthresholds",
            "masked_code": "x = torch.tensor([0, 1, 2, 3])\ny = torch.tensor([0, 1, 2, 2])\n<line_mask>\nfpr\ntpr\nthresholds",
            "masked_line": "fpr, tpr, thresholds = roc(x, y)",
            "answer": "roc",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_615"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==0.8.0",
            "time": "2020-06-18",
            "description": "The code calculates the precision, recall, and thresholds for a given set of predictions and targets.",
            "code": "precision, recall, thresholds = precision_recall_curve(pred, target) \nprecision \ntensor([0.3333, 0.0000, 0.0000, 1.0000]) \nrecall \ntensor([1., 0., 0., 0.]) \nthresholds \ntensor([1, 2, 3])",
            "masked_code": "<line_mask>\nprecision \ntensor([0.3333, 0.0000, 0.0000, 1.0000]) \nrecall \ntensor([1., 0., 0., 0.]) \nthresholds \ntensor([1, 2, 3])",
            "masked_line": "precision, recall, thresholds = precision_recall_curve(pred, target)",
            "answer": "precision_recall_curve",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_616"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==0.8.0",
            "time": "2020-06-18",
            "description": "This function transfers a batch of data to a specified device. If the batch is an instance of a custom data structure called CustomBatch, it moves all tensors within the batch to the specified device. Otherwise, it uses the superclass method to transfer the batch to the device.",
            "code": "def transfer_batch_to_device(self, batch, device):\n    if isinstance(batch, CustomBatch):\n        # move all tensors in your custom data structure to the device\n        batch.samples = batch.samples.to(device)\n        batch.targets = batch.targets.to(device)\n    else:\n        batch = super().transfer_batch_to_device(data, device)\n    return batch\n",
            "masked_code": "def transfer_batch_to_device(self, batch, device):\n    if isinstance(batch, CustomBatch):\n        # move all tensors in your custom data structure to the device\n        batch.samples = batch.samples.to(device)\n        batch.targets = batch.targets.to(device)\n    else:\n        <line_mask>\n    return batch\n",
            "masked_line": "batch = super().transfer_batch_to_device(data, device)",
            "answer": "transfer_batch_to_device",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_617"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==0.8.1",
            "time": "2020-06-19",
            "description": "This code defines a LightningModule called LitModel and a Trainer object. It uses the TrainsLogger to log training progress and metrics during the training process. The Trainer object is initialized with the TrainsLogger for logging purposes.",
            "code": "from pytorch_lightning import Trainer\nfrom pytorch_lightning.loggers import TrainsLogger\ntrains_logger = TrainsLogger(\n    project_name='pytorch lightning',\n    task_name='default',\n    output_uri='.',\n)\ntrainer = Trainer(logger=trains_logger)\n\nfrom pytorch_lightning import LightningModule\nclass LitModel(LightningModule):\n    def training_step(self, batch, batch_idx):\n        # example\n        self.logger.experiment.whatever_trains_supports(...)\n\n    def any_lightning_module_function_or_hook(self):\n        self.logger.experiment.whatever_trains_supports(...)",
            "masked_code": "from pytorch_lightning import Trainer\nfrom pytorch_lightning.loggers import TrainsLogger\n<line_mask>\n    project_name='pytorch lightning',\n    task_name='default',\n    output_uri='.',\n)\ntrainer = Trainer(logger=trains_logger)\n\nfrom pytorch_lightning import LightningModule\nclass LitModel(LightningModule):\n    def training_step(self, batch, batch_idx):\n        # example\n        self.logger.experiment.whatever_trains_supports(...)\n\n    def any_lightning_module_function_or_hook(self):\n        self.logger.experiment.whatever_trains_supports(...)",
            "masked_line": "trains_logger = TrainsLogger(",
            "answer": "TrainsLogger",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_618"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==0.8.5",
            "time": "2020-07-10",
            "description": "This code calculates the Peak Signal-to-Noise Ratio (PSNR) metric between two tensors, 'pred' and 'target'.",
            "code": "pred = torch.tensor([[0.0, 1.0], [2.0, 3.0]])\ntarget = torch.tensor([[3.0, 2.0], [1.0, 0.0]])\nmetric = PSNR()\nmetric(pred, target)\ntensor(2.5527)",
            "masked_code": "pred = torch.tensor([[0.0, 1.0], [2.0, 3.0]])\ntarget = torch.tensor([[3.0, 2.0], [1.0, 0.0]])\n<line_mask>\nmetric(pred, target)\ntensor(2.5527)",
            "masked_line": "metric = PSNR()",
            "answer": "PSNR",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_619"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==0.8.5",
            "time": "2020-07-10",
            "description": "This function calculates the mean squared error between the predicted values (pred) and the target values (target).",
            "code": "def mse(pred, target, reduction='elementwise_mean'):\n    return torch.mean((pred - target) ** 2)\n    \nx = torch.tensor([0., 1, 2, 3])\ny = torch.tensor([0., 1, 2, 2])\nmse(x, y)\n",
            "masked_code": "def mse(pred, target, reduction='elementwise_mean'):\n    return torch.mean((pred - target) ** 2)\n    \nx = torch.tensor([0., 1, 2, 3])\ny = torch.tensor([0., 1, 2, 2])\n<line_mask>\n",
            "masked_line": "mse(x, y)",
            "answer": "mse",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_620"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==0.8.5",
            "time": "2020-07-10",
            "description": "This code calculates the Root Mean Squared Logarithmic Error (RMSLE) between two sets of values.",
            "code": "def rmsle(pred, target, reduction='elementwise_mean'):\n    return torch.sqrt(torch.mean((torch.log1p(pred) - torch.log1p(target))**2))\n    \nx = torch.tensor([0., 1, 2, 3])\ny = torch.tensor([0., 1, 2, 2])\nrmsle(x, y)\n",
            "masked_code": "def rmsle(pred, target, reduction='elementwise_mean'):\n    return torch.sqrt(torch.mean((torch.log1p(pred) - torch.log1p(target))**2))\n    \nx = torch.tensor([0., 1, 2, 3])\ny = torch.tensor([0., 1, 2, 2])\n<line_mask>\n",
            "masked_line": "rmsle(x, y)",
            "answer": "rmsle",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_621"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==0.9.0",
            "time": "2020-08-20",
            "description": "The code calculates the balanced accuracy score for the predicted values 'y_pred' and true values 'y_true'.",
            "code": "y_pred = torch.tensor([0, 0, 0, 1])\ny_true = torch.tensor([0, 0, 1, 1])\nmetric = BalancedAccuracy()\nmetric(y_pred, y_true)\ntensor([0.7500])",
            "masked_code": "y_pred = torch.tensor([0, 0, 0, 1])\ny_true = torch.tensor([0, 0, 1, 1])\n<line_mask>\nmetric(y_pred, y_true)\ntensor([0.7500])",
            "masked_line": "metric = BalancedAccuracy()",
            "answer": "BalancedAccuracy",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_622"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==0.9.0",
            "time": "2020-08-20",
            "description": "The code calculates the Cohen's Kappa score as a performance metric by comparing the predicted values (y_pred) with the true values (y_true).",
            "code": "y_pred = torch.tensor([1, 2, 0, 2])\ny_true = torch.tensor([2, 2, 2, 1])\nmetric = CohenKappaScore()\nmetric(y_pred, y_true)\ntensor([-0.3333])",
            "masked_code": "y_pred = torch.tensor([1, 2, 0, 2])\ny_true = torch.tensor([2, 2, 2, 1])\n<line_mask>\nmetric(y_pred, y_true)\ntensor([-0.3333])",
            "masked_line": "metric = CohenKappaScore()",
            "answer": "CohenKappaScore",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_623"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==0.9.0",
            "time": "2020-08-20",
            "description": "Calculate the Hamming loss between the predicted tensor y_pred and the true tensor y_true.",
            "code": "y_pred = torch.tensor([0, 1, 2, 3])\ny_true = torch.tensor([1, 1, 2, 3])\nmetric = Hamming()\nmetric(y_pred, y_true)\ntensor([0.2500])",
            "masked_code": "y_pred = torch.tensor([0, 1, 2, 3])\ny_true = torch.tensor([1, 1, 2, 3])\n<line_mask>\nmetric(y_pred, y_true)\ntensor([0.2500])",
            "masked_line": "metric = Hamming()",
            "answer": "Hamming",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_624"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==0.9.0",
            "time": "2020-08-20",
            "description": "The code calculates the hinge loss between the predicted decisions and the true labels.",
            "code": "pred_decision = torch.tensor([-2.17, -0.97, -0.19, -0.43])\ny_true = torch.tensor([1, 1, 0, 0])\nmetric = Hinge()\nmetric(pred_decision, y_true)\ntensor([1.6300])",
            "masked_code": "pred_decision = torch.tensor([-2.17, -0.97, -0.19, -0.43])\ny_true = torch.tensor([1, 1, 0, 0])\n<line_mask>\nmetric(pred_decision, y_true)\ntensor([1.6300])",
            "masked_line": "metric = Hinge()",
            "answer": "Hinge",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_625"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==0.9.0",
            "time": "2020-08-20",
            "description": "Calculate the Jaccard similarity between the predicted tensor y_pred and the true tensor y_true.",
            "code": "y_pred = torch.tensor([1, 1, 1])\ny_true = torch.tensor([0, 1, 1])\nmetric = Jaccard()\nmetric(y_pred, y_true)\ntensor([0.3333])",
            "masked_code": "y_pred = torch.tensor([1, 1, 1])\ny_true = torch.tensor([0, 1, 1])\n<line_mask>\nmetric(y_pred, y_true)\ntensor([0.3333])",
            "masked_line": "metric = Jaccard()",
            "answer": "Jaccard",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_626"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==0.9.0",
            "time": "2020-08-20",
            "description": "The code calculates the explained variance between the predicted values (y_pred) and the true values (y_true) using the ExplainedVariance metric, and returns the result as a tensor.",
            "code": "y_pred = torch.tensor([2.5, 0.0, 2, 8])\ny_true = torch.tensor([3, -0.5, 2, 7])\nmetric = ExplainedVariance()\nmetric(y_pred, y_true)\ntensor([0.9572])",
            "masked_code": "y_pred = torch.tensor([2.5, 0.0, 2, 8])\ny_true = torch.tensor([3, -0.5, 2, 7])\n<line_mask>\nmetric(y_pred, y_true)\ntensor([0.9572])",
            "masked_line": "metric = ExplainedVariance()",
            "answer": "ExplainedVariance",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_627"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==0.9.0",
            "time": "2020-08-20",
            "description": "The code calculates the mean squared log error between the predicted values (y_pred) and the true values (y_true) using the MeanSquaredLogError metric.",
            "code": "y_pred = torch.tensor([2.5, 5, 4, 8])\ny_true = torch.tensor([3, 5, 2.5, 7])\nmetric = MeanSquaredLogError()\nmetric(y_pred, y_true)\ntensor([0.0397])",
            "masked_code": "y_pred = torch.tensor([2.5, 5, 4, 8])\ny_true = torch.tensor([3, 5, 2.5, 7])\n<line_mask>\nmetric(y_pred, y_true)\ntensor([0.0397])",
            "masked_line": "metric = MeanSquaredLogError()",
            "answer": "MeanSquaredLogError",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_628"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==0.9.0",
            "time": "2020-08-20",
            "description": "The code calculates the median absolute error between two sets of predicted and true values.",
            "code": "y_pred = torch.tensor([2.5, 0.0, 2, 8])\ny_true = torch.tensor([3, -0.5, 2, 7])\nmetric = MedianAbsoluteError()\nmetric(y_pred, y_true)\ntensor([0.5000])",
            "masked_code": "y_pred = torch.tensor([2.5, 0.0, 2, 8])\ny_true = torch.tensor([3, -0.5, 2, 7])\n<line_mask>\nmetric(y_pred, y_true)\ntensor([0.5000])",
            "masked_line": "metric = MedianAbsoluteError()",
            "answer": "MedianAbsoluteError",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_629"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==0.9.0",
            "time": "2020-08-20",
            "description": "The code calculates the mean Poisson deviance between the predicted tensor values (y_pred) and the true tensor values (y_true).",
            "code": "y_pred = torch.tensor([2, 0.5, 1, 4])\ny_true = torch.tensor([0.5, 0.5, 2., 2.])\nmetric = MeanPoissonDeviance()\nmetric(y_pred, y_true)\ntensor([0.9034])",
            "masked_code": "y_pred = torch.tensor([2, 0.5, 1, 4])\ny_true = torch.tensor([0.5, 0.5, 2., 2.])\n<line_mask>\nmetric(y_pred, y_true)\ntensor([0.9034])",
            "masked_line": "metric = MeanPoissonDeviance()",
            "answer": "MeanPoissonDeviance",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_630"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==0.9.0",
            "time": "2020-08-20",
            "description": "The code calculates the mean gamma deviance between the predicted tensor values and the true tensor values.",
            "code": "y_pred = torch.tensor([0.5, 0.5, 2., 2.])\ny_true = torch.tensor([2, 0.5, 1, 4])\nmetric = MeanGammaDeviance()\nmetric(y_pred, y_true)\ntensor([1.0569])",
            "masked_code": "y_pred = torch.tensor([0.5, 0.5, 2., 2.])\ny_true = torch.tensor([2, 0.5, 1, 4])\n<line_mask>\nmetric(y_pred, y_true)\ntensor([1.0569])",
            "masked_line": "metric = MeanGammaDeviance()",
            "answer": "MeanGammaDeviance",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_631"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==0.9.0",
            "time": "2020-08-20",
            "description": "This code calculates the Mean Tweedie Deviance metric for the predicted values (y_pred) compared to the true values (y_true).",
            "code": "y_pred = torch.tensor([2, 0.5, 1, 4])\ny_true = torch.tensor([0.5, 0.5, 2., 2.])\nmetric = MeanTweedieDeviance()\nmetric(y_pred, y_true)\ntensor([1.8125])",
            "masked_code": "y_pred = torch.tensor([2, 0.5, 1, 4])\ny_true = torch.tensor([0.5, 0.5, 2., 2.])\n<line_mask>\nmetric(y_pred, y_true)\ntensor([1.8125])",
            "masked_line": "metric = MeanTweedieDeviance()",
            "answer": "MeanTweedieDeviance",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_632"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==1.0.0",
            "time": "2020-10-13",
            "description": "The code sets environment variables for the PyTorch Lightning Trainer class and parses them to create a Namespace object with specified attributes.",
            "code": "from pytorch_lightning import Trainer\nparse_env_variables(Trainer)\nNamespace()\nimport os\nos.environ[\"PL_TRAINER_GPUS\"] = '42'\nos.environ[\"PL_TRAINER_BLABLABLA\"] = '1.23'\nparse_env_variables(Trainer)\nNamespace(gpus=42)\ndel os.environ[\"PL_TRAINER_GPUS\"]",
            "masked_code": "from pytorch_lightning import Trainer\nparse_env_variables(Trainer)\nNamespace()\nimport os\nos.environ[\"PL_TRAINER_GPUS\"] = '42'\nos.environ[\"PL_TRAINER_BLABLABLA\"] = '1.23'\n<line_mask>\nNamespace(gpus=42)\ndel os.environ[\"PL_TRAINER_GPUS\"]",
            "masked_line": "parse_env_variables(Trainer)",
            "answer": "parse_env_variables",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_633"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==1.0.4",
            "time": "2020-10-27",
            "description": "Calculate the Structural Similarity Index (SSIM) between the predicted values (preds) and the target values (target) in the specified dimensions.",
            "code": "from pytorch_lightning.metrics import SSIM\npreds = torch.rand([16, 1, 16, 16])\ntarget = preds * 0.75\nssim = SSIM()\nssim(preds, target)",
            "masked_code": "from pytorch_lightning.metrics import SSIM\npreds = torch.rand([16, 1, 16, 16])\ntarget = preds * 0.75\n<line_mask>\nssim(preds, target)",
            "masked_line": "ssim = SSIM()",
            "answer": "SSIM",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_634"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==1.0.4",
            "time": "2020-10-27",
            "description": "The code calculates the explained variance between the target and predicted tensors.",
            "code": "from pytorch_lightning.metrics.functional import explained_variance\ntarget = torch.tensor([3, -0.5, 2, 7])\npreds = torch.tensor([2.5, 0.0, 2, 8])\nexplained_variance(preds, target)\n\ntarget = torch.tensor([[0.5, 1], [-1, 1], [7, -6]])\npreds = torch.tensor([[0, 2], [-1, 2], [8, -5]])\nexplained_variance(preds, target, multioutput='raw_values')",
            "masked_code": "from pytorch_lightning.metrics.functional import explained_variance\ntarget = torch.tensor([3, -0.5, 2, 7])\npreds = torch.tensor([2.5, 0.0, 2, 8])\n<line_mask>\n\ntarget = torch.tensor([[0.5, 1], [-1, 1], [7, -6]])\npreds = torch.tensor([[0, 2], [-1, 2], [8, -5]])\nexplained_variance(preds, target, multioutput='raw_values')",
            "masked_line": "explained_variance(preds, target)",
            "answer": "explained_variance",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_635"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==1.0.7",
            "time": "2020-11-17",
            "description": "The code defines a class called Model with an __init__ method that accepts parameters hparams, my_args, anykw, and my_kwargs. The function parse_class_init_keys is called with the Model class as an argument and returns a tuple containing the strings 'self', 'my_args', 'my_kwargs'.",
            "code": "class Model():\n    def __init__(self, hparams, *my_args, anykw=42, **my_kwargs):\n        pass\n\nparse_class_init_keys(Model)\n('self', 'my_args', 'my_kwargs')",
            "masked_code": "class Model():\n    def __init__(self, hparams, *my_args, anykw=42, **my_kwargs):\n        pass\n\n<line_mask>\n('self', 'my_args', 'my_kwargs')",
            "masked_line": "parse_class_init_keys(Model)",
            "answer": "parse_class_init_keys",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_636"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==1.1.0",
            "time": "2020-12-10",
            "description": "The code defines a custom plugin \"MyPlugin\" that requires the presence of a specific AMP plugin \"MyCustomAMPPlugin\". When attempting to create a trainer object with plugins that include both \"MyPlugin\" and \"NativeAMPPlugin\", it will crash due to the enforcement of using \"MyCustomAMPPlugin\" by \"MyPlugin\".",
            "code": "class MyPlugin(DDPPlugin):\n    def required_plugins(self):\n        return [MyCustomAMPPlugin()]\n\n# Will automatically add the necessary AMP plugin\ntrainer = Trainer(plugins=[MyPlugin()])\n\n# Crash as MyPlugin enforces custom AMP plugin\ntrainer = Trainer(plugins=[MyPlugin(), NativeAMPPlugin()])",
            "masked_code": "class MyPlugin(DDPPlugin):\n    <line_mask>\n        return [MyCustomAMPPlugin()]\n\n# Will automatically add the necessary AMP plugin\ntrainer = Trainer(plugins=[MyPlugin()])\n\n# Crash as MyPlugin enforces custom AMP plugin\ntrainer = Trainer(plugins=[MyPlugin(), NativeAMPPlugin()])",
            "masked_line": "def required_plugins(self):",
            "answer": "required_plugins",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_637"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==1.1.0",
            "time": "2020-12-10",
            "description": "This code selects the top k elements along a specified dimension of a given tensor and creates a binary tensor where the top k elements are represented as 1.",
            "code": "def select_topk(prob_tensor, topk, dim):\n    values, indices = torch.topk(prob_tensor, topk, dim=dim)\n    binary_tensor = torch.zeros_like(prob_tensor, dtype=torch.int32)\n    binary_tensor.scatter_(dim, indices, 1)\n    return binary_tensor\n\nx = torch.tensor([[1.1, 2.0, 3.0], [2.0, 1.0, 0.5]])\nresult = select_topk(x, topk=2)\nprint(result)\n",
            "masked_code": "<line_mask>\n    values, indices = torch.topk(prob_tensor, topk, dim=dim)\n    binary_tensor = torch.zeros_like(prob_tensor, dtype=torch.int32)\n    binary_tensor.scatter_(dim, indices, 1)\n    return binary_tensor\n\nx = torch.tensor([[1.1, 2.0, 3.0], [2.0, 1.0, 0.5]])\nresult = select_topk(x, topk=2)\nprint(result)\n",
            "masked_line": "def select_topk(prob_tensor, topk, dim):",
            "answer": "select_topk",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_638"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==1.1.0",
            "time": "2020-12-10",
            "description": "This code calculates the Receiver Operating Characteristic (ROC) curve by comparing two sets of data (x and y) and returns the false positive rates (fpr), true positive rates (tpr), and thresholds.",
            "code": "x = torch.tensor([0, 1, 2, 3])\ny = torch.tensor([0, 1, 1, 1])\nfpr, tpr, thresholds = __roc(x, y)\nfpr\ntensor([0., 0., 0., 0., 1.])\ntpr\ntensor([0.0000, 0.3333, 0.6667, 1.0000, 1.0000])\nthresholds\ntensor([4, 3, 2, 1, 0])\n",
            "masked_code": "x = torch.tensor([0, 1, 2, 3])\ny = torch.tensor([0, 1, 1, 1])\n<line_mask>\nfpr\ntensor([0., 0., 0., 0., 1.])\ntpr\ntensor([0.0000, 0.3333, 0.6667, 1.0000, 1.0000])\nthresholds\ntensor([4, 3, 2, 1, 0])\n",
            "masked_line": "fpr, tpr, thresholds = __roc(x, y)",
            "answer": "__roc",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_639"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==1.1.1",
            "time": "2020-12-15",
            "description": "This code calculates the Receiver Operating Characteristic (ROC) curve using the input tensors x and y, and returns the false positive rate (fpr), true positive rate (tpr), and thresholds.",
            "code": "x = torch.tensor([0, 1, 2, 3])\ny = torch.tensor([0, 1, 1, 1])\nfpr, tpr, thresholds = _roc(x, y)\nfpr\ntensor([0., 0., 0., 0., 1.])\ntpr\ntensor([0.0000, 0.3333, 0.6667, 1.0000, 1.0000])\nthresholds\ntensor([4, 3, 2, 1, 0])",
            "masked_code": "x = torch.tensor([0, 1, 2, 3])\ny = torch.tensor([0, 1, 1, 1])\n<line_mask>\nfpr\ntensor([0., 0., 0., 0., 1.])\ntpr\ntensor([0.0000, 0.3333, 0.6667, 1.0000, 1.0000])\nthresholds\ntensor([4, 3, 2, 1, 0])",
            "masked_line": "fpr, tpr, thresholds = _roc(x, y)",
            "answer": "_roc",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_640"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==1.1.0",
            "time": "2020-12-10",
            "description": "The code calculates the Receiver Operating Characteristic (ROC) curve using tensors x and y. It returns the false positive rate (fpr), true positive rate (tpr), and corresponding thresholds.",
            "code": "x = torch.tensor([0, 1, 2, 3])\ny = torch.tensor([0, 1, 1, 1])\nfpr, tpr, thresholds = __roc(x, y)\nfpr\ntensor([0., 0., 0., 0., 1.])\ntpr\ntensor([0.0000, 0.3333, 0.6667, 1.0000, 1.0000])\nthresholds\ntensor([4, 3, 2, 1, 0])",
            "masked_code": "x = torch.tensor([0, 1, 2, 3])\ny = torch.tensor([0, 1, 1, 1])\n<line_mask>\nfpr\ntensor([0., 0., 0., 0., 1.])\ntpr\ntensor([0.0000, 0.3333, 0.6667, 1.0000, 1.0000])\nthresholds\ntensor([4, 3, 2, 1, 0])",
            "masked_line": "fpr, tpr, thresholds = __roc(x, y)",
            "answer": "__roc",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_641"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==1.2.0",
            "time": "2021-02-18",
            "description": "The code calculates various metrics such as accuracy, precision, and recall for a multi-class classification task using PyTorch Lightning.",
            "code": "from pytorch_lightning.metrics import MetricCollection, Accuracy, Precision, Recall\ntarget = torch.tensor([0, 2, 0, 2, 0, 1, 0, 2])\npreds = torch.tensor([2, 1, 2, 0, 1, 2, 2, 2])\nmetrics = MetricCollection([Accuracy(),\n                            Precision(num_classes=3, average='macro'),\n                            Recall(num_classes=3, average='macro')])\nmetrics(preds, target)\n\nmetrics = MetricCollection({'micro_recall': Recall(num_classes=3, average='micro'),\n                            'macro_recall': Recall(num_classes=3, average='macro')})\nmetrics(preds, target)",
            "masked_code": "from pytorch_lightning.metrics import MetricCollection, Accuracy, Precision, Recall\ntarget = torch.tensor([0, 2, 0, 2, 0, 1, 0, 2])\npreds = torch.tensor([2, 1, 2, 0, 1, 2, 2, 2])\n<line_mask>\n                            Precision(num_classes=3, average='macro'),\n                            Recall(num_classes=3, average='macro')])\nmetrics(preds, target)\n\nmetrics = MetricCollection({'micro_recall': Recall(num_classes=3, average='micro'),\n                            'macro_recall': Recall(num_classes=3, average='macro')})\nmetrics(preds, target)",
            "masked_line": "metrics = MetricCollection([Accuracy(),",
            "answer": "MetricCollection",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_642"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==1.2.0",
            "time": "2021-02-18",
            "description": "The code creates two data loaders with different batch sizes and then combines them using a custom CombinedLoader class. The CombinedLoader class has two modes of operation: 'max_size_cycle' mode cycles through batches until all loaders are exhausted, while 'min_size' mode combines batches by the minimum batch size of all loaders. The code then iterates through the combined loader and prints each item.",
            "code": "loaders = {'a': torch.utils.data.DataLoader(range(6), batch_size=4),\n            'b': torch.utils.data.DataLoader(range(15), batch_size=5)}\ncombined_loader = CombinedLoader(loaders, 'max_size_cycle')\nfor item in combined_loader:\n    print(item)\ncombined_loader = CombinedLoader(loaders, 'min_size')\nfor item in combined_loader:\n    print(item)",
            "masked_code": "loaders = {'a': torch.utils.data.DataLoader(range(6), batch_size=4),\n            'b': torch.utils.data.DataLoader(range(15), batch_size=5)}\ncombined_loader = CombinedLoader(loaders, 'max_size_cycle')\nfor item in combined_loader:\n    print(item)\n<line_mask>\nfor item in combined_loader:\n    print(item)",
            "masked_line": "combined_loader = CombinedLoader(loaders, 'min_size')",
            "answer": "CombinedLoader",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_643"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==1.2.0",
            "time": "2021-02-18",
            "description": "The code calculates the R-squared score (coefficient of determination) between the target and predicted values using the PyTorch Lightning library.",
            "code": "from pytorch_lightning.metrics.functional import r2score\ntarget = torch.tensor([3, -0.5, 2, 7])\npreds = torch.tensor([2.5, 0.0, 2, 8])\nr2score(preds, target)\n\ntarget = torch.tensor([[0.5, 1], [-1, 1], [7, -6]])\npreds = torch.tensor([[0, 2], [-1, 2], [8, -5]])\nr2score(preds, target, multioutput='raw_values')",
            "masked_code": "<line_mask>\ntarget = torch.tensor([3, -0.5, 2, 7])\npreds = torch.tensor([2.5, 0.0, 2, 8])\nr2score(preds, target)\n\ntarget = torch.tensor([[0.5, 1], [-1, 1], [7, -6]])\npreds = torch.tensor([[0, 2], [-1, 2], [8, -5]])\nr2score(preds, target, multioutput='raw_values')",
            "masked_line": "from pytorch_lightning.metrics.functional import r2score",
            "answer": "r2score",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_644"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==1.3.0",
            "time": "2021-05-06",
            "description": "This code defines a custom prediction writer class that extends the BasePredictionWriter class in the PyTorch Lightning library. The CustomWriter class has methods to write predictions to specified output directories at the end of training batches and epochs. The write_on_batch_end method saves individual batch predictions to separate files, while the write_on_epoch_end method saves all epoch predictions to a single file.",
            "code": "import torch\nfrom pytorch_lightning.callbacks import BasePredictionWriter\n\nclass CustomWriter(BasePredictionWriter):\n\n    def __init__(self, output_dir: str, write_interval: str):\n        super().__init__(write_interval)\n        self.output_dir\n\n    def write_on_batch_end(\n        self, trainer, pl_module: 'LightningModule', prediction: Any, batch_indices: List[int], batch: Any,\n        batch_idx: int, dataloader_idx: int\n    ):\n        torch.save(prediction, os.path.join(self.output_dir, dataloader_idx, f\"{batch_idx}.pt\"))\n\n    def write_on_epoch_end(\n        self, trainer, pl_module: 'LightningModule', predictions: List[Any], batch_indices: List[Any]\n    ):\n        torch.save(predictions, os.path.join(self.output_dir, \"predictions.pt\"))",
            "masked_code": "import torch\n<line_mask>\n\nclass CustomWriter(BasePredictionWriter):\n\n    def __init__(self, output_dir: str, write_interval: str):\n        super().__init__(write_interval)\n        self.output_dir\n\n    def write_on_batch_end(\n        self, trainer, pl_module: 'LightningModule', prediction: Any, batch_indices: List[int], batch: Any,\n        batch_idx: int, dataloader_idx: int\n    ):\n        torch.save(prediction, os.path.join(self.output_dir, dataloader_idx, f\"{batch_idx}.pt\"))\n\n    def write_on_epoch_end(\n        self, trainer, pl_module: 'LightningModule', predictions: List[Any], batch_indices: List[Any]\n    ):\n        torch.save(predictions, os.path.join(self.output_dir, \"predictions.pt\"))",
            "masked_line": "from pytorch_lightning.callbacks import BasePredictionWriter",
            "answer": "BasePredictionWriter",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_645"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==1.3.0",
            "time": "2021-05-06",
            "description": "The code sets up a timer to stop training after a specific duration of time, which can be specified in different ways, such as using a string in the format \"days:hours:minutes:seconds\", a datetime.timedelta object, or a dictionary with weeks and days. The Trainer class from pytorch_lightning is used along with the Timer callback to force training to stop after the given time limit. The Timer object can also be used to query the training/validation/test time in seconds by specifying the type of time to be queried.",
            "code": "from pytorch_lightning import Trainer\nfrom pytorch_lightning.callbacks import Timer\n\n# stop training after 12 hours\ntimer = Timer(duration=\"00:12:00:00\")\n\n# or provide a datetime.timedelta\nfrom datetime import timedelta\ntimer = Timer(duration=timedelta(weeks=1))\n\n# or provide a dictionary\ntimer = Timer(duration=dict(weeks=4, days=2))\n\n# force training to stop after given time limit\ntrainer = Trainer(callbacks=[timer])\n\n# query training/validation/test time (in seconds)\ntimer.time_elapsed(\"train\")\ntimer.start_time(\"validate\")\ntimer.end_time(\"test\")",
            "masked_code": "from pytorch_lightning import Trainer\nfrom pytorch_lightning.callbacks import Timer\n\n# stop training after 12 hours\ntimer = Timer(duration=\"00:12:00:00\")\n\n# or provide a datetime.timedelta\nfrom datetime import timedelta\ntimer = Timer(duration=timedelta(weeks=1))\n\n# or provide a dictionary\n<line_mask>\n\n# force training to stop after given time limit\ntrainer = Trainer(callbacks=[timer])\n\n# query training/validation/test time (in seconds)\ntimer.time_elapsed(\"train\")\ntimer.start_time(\"validate\")\ntimer.end_time(\"test\")",
            "masked_line": "timer = Timer(duration=dict(weeks=4, days=2))",
            "answer": "Timer",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_646"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==1.5.0",
            "time": "2021-11-02",
            "description": "The code initializes a Trainer object from the pytorch_lightning library with the callback function RichModelSummary(), which provides a detailed summary of the model during training. \n\nThe code initializes a Trainer object from the pytorch_lightning library with the callback function RichProgressBar(), which displays a progress bar during model training.",
            "code": "from pytorch_lightning import Trainer\nfrom pytorch_lightning.callbacks import RichModelSummary\n\ntrainer = Trainer(callbacks=RichModelSummary())\n\n\nfrom pytorch_lightning import Trainer\nfrom pytorch_lightning.callbacks import RichProgressBar\n\ntrainer = Trainer(callbacks=RichProgressBar())\n",
            "masked_code": "from pytorch_lightning import Trainer\n<line_mask>\n\ntrainer = Trainer(callbacks=RichModelSummary())\n\n\nfrom pytorch_lightning import Trainer\nfrom pytorch_lightning.callbacks import RichProgressBar\n\ntrainer = Trainer(callbacks=RichProgressBar())\n",
            "masked_line": "from pytorch_lightning.callbacks import RichModelSummary",
            "answer": "RichModelSummary",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_647"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==1.5.0",
            "time": "2021-11-02",
            "description": "This code defines a class `SimpleDataFetcher` that inherits from `AbstractDataFetcher`. It contains a method `fetching_function` that fetches data from a `dataloader_iter` object using a `while True` loop. The function returns the next data element from `dataloader_iter` along with a boolean value indicating whether there are more elements to fetch. If `StopIteration` is raised, it returns `None` along with a boolean value indicating that there are no more elements to fetch.",
            "code": "class SimpleDataFetcher(AbstractDataFetcher):\n    def fetching_function(self):\n        while True:\n            try:\n                return next(self.dataloader_iter), False\n            except StopIteration:\n                return None, True",
            "masked_code": "<line_mask>\n    def fetching_function(self):\n        while True:\n            try:\n                return next(self.dataloader_iter), False\n            except StopIteration:\n                return None, True",
            "masked_line": "class SimpleDataFetcher(AbstractDataFetcher):",
            "answer": "AbstractDataFetcher",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_648"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==1.7.0",
            "time": "2022-08-02",
            "description": "This code defines a class called Flow that inherits from LightningFlow. It initializes an empty list called names. It has a method called configure_commands that returns a dictionary mapping a command name 'my_command_name' to a method my_remote_method. The my_remote_method takes a name as input and appends it to the names list.",
            "code": "class Flow(LightningFlow):\n    def __init__(self):\n        super().__init__()\n        self.names = []\n\n    def configure_commands(self):\n        return {\"my_command_name\": self.my_remote_method}\n\n    def my_remote_method(self, name):\n        self.names.append(name)\n",
            "masked_code": "class Flow(LightningFlow):\n    def __init__(self):\n        super().__init__()\n        self.names = []\n\n    <line_mask>\n        return {\"my_command_name\": self.my_remote_method}\n\n    def my_remote_method(self, name):\n        self.names.append(name)\n",
            "masked_line": "def configure_commands(self):",
            "answer": "configure_commands",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_649"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==1.7.0",
            "time": "2022-08-02",
            "description": "The code defines a dataclass called MyOwnBuildConfig that inherits from BuildConfig. It has a method build_commands that returns a list containing the command \"apt-get install libsparsehash-dev\".",
            "code": "from dataclasses import dataclass\nfrom lightning_app import BuildConfig\n\n@dataclass\nclass MyOwnBuildConfig(BuildConfig):\n\n    def build_commands(self):\n        return [\"apt-get install libsparsehash-dev\"]",
            "masked_code": "from dataclasses import dataclass\nfrom lightning_app import BuildConfig\n\n@dataclass\nclass MyOwnBuildConfig(BuildConfig):\n\n    <line_mask>\n        return [\"apt-get install libsparsehash-dev\"]",
            "masked_line": "def build_commands(self):",
            "answer": "build_commands",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_650"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==1.7.0",
            "time": "2022-08-02",
            "description": "The code reads a Python file from a specified path, removes any trailing whitespace from each line, and then prunes any imports and callables from the lines of code.",
            "code": "import os\n\npy_file = os.path.join(_PROJECT_ROOT, \"src\", \"pytorch_lightning\", \"utilities\", \"cli.py\")\nimport_path = \".\".join([\"pytorch_lightning\", \"utilities\", \"cli\"])\n\nwith open(py_file, encoding=\"utf-8\") as fp:\n    lines = [ln.rstrip() for ln in fp.readlines()]\n\nlines = prune_imports_callables(lines)",
            "masked_code": "import os\n\npy_file = os.path.join(_PROJECT_ROOT, \"src\", \"pytorch_lightning\", \"utilities\", \"cli.py\")\nimport_path = \".\".join([\"pytorch_lightning\", \"utilities\", \"cli\"])\n\nwith open(py_file, encoding=\"utf-8\") as fp:\n    lines = [ln.rstrip() for ln in fp.readlines()]\n\n<line_mask>",
            "masked_line": "lines = prune_imports_callables(lines)",
            "answer": "prune_imports_callables",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_651"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==1.7.0",
            "time": "2022-08-02",
            "description": "The code reads and cleans up the contents of a specific Python file, storing each line in a list, and then removes certain function calls from the lines.",
            "code": "import os\n\npy_file = os.path.join(_PROJECT_ROOT, \"src\", \"pytorch_lightning\", \"loggers\", \"__init__.py\")\nimport_path = \".\".join([\"pytorch_lightning\", \"loggers\"])\n\nwith open(py_file, encoding=\"utf-8\") as fp:\n    lines = [ln.rstrip() for ln in fp.readlines()]\n\nlines = prune_func_calls(lines)",
            "masked_code": "import os\n\npy_file = os.path.join(_PROJECT_ROOT, \"src\", \"pytorch_lightning\", \"loggers\", \"__init__.py\")\nimport_path = \".\".join([\"pytorch_lightning\", \"loggers\"])\n\nwith open(py_file, encoding=\"utf-8\") as fp:\n    lines = [ln.rstrip() for ln in fp.readlines()]\n\n<line_mask>",
            "masked_line": "lines = prune_func_calls(lines)",
            "answer": "prune_func_calls",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_652"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==1.7.0",
            "time": "2022-08-02",
            "description": "The code reads a Python file containing functions and imports, removes unnecessary imports, and removes empty statements from the file.",
            "code": "import os\n\npy_file = os.path.join(_PROJECT_ROOT, \"src\", \"pytorch_lightning\", \"utilities\", \"cli.py\")\nimport_path = \".\".join([\"pytorch_lightning\", \"utilities\", \"cli\"])\n\nwith open(py_file, encoding=\"utf-8\") as fp:\n    lines = [ln.rstrip() for ln in fp.readlines()]\n\nlines = prune_imports_callables(lines)\nlines = prune_empty_statements(lines)",
            "masked_code": "import os\n\npy_file = os.path.join(_PROJECT_ROOT, \"src\", \"pytorch_lightning\", \"utilities\", \"cli.py\")\nimport_path = \".\".join([\"pytorch_lightning\", \"utilities\", \"cli\"])\n\nwith open(py_file, encoding=\"utf-8\") as fp:\n    lines = [ln.rstrip() for ln in fp.readlines()]\n\nlines = prune_imports_callables(lines)\n<line_mask>",
            "masked_line": "lines = prune_empty_statements(lines)",
            "answer": "prune_empty_statements",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_653"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==1.8.0",
            "time": "2022-11-01",
            "description": "The code updates the counter value in the state of the app and prints a message displaying the updated counter value.",
            "code": "import param\napp = AppStateWatcher()\napp.state.counter = 1\n\n@param.depends(app.param.state, watch=True)\ndef update(state):\n    print(f\"The counter was updated to {state.counter}\")\n\napp.state.counter += 1",
            "masked_code": "import param\n<line_mask>\napp.state.counter = 1\n\n@param.depends(app.param.state, watch=True)\ndef update(state):\n    print(f\"The counter was updated to {state.counter}\")\n\napp.state.counter += 1",
            "masked_line": "app = AppStateWatcher()",
            "answer": "AppStateWatcher",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_654"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==1.8.0",
            "time": "2022-11-01",
            "description": "This code defines a function `print_log_msg` that prints out a message. It then creates a logs socket using a provided `client` object with specific parameters, and runs the socket indefinitely to listen for log messages. Finally, it starts a separate thread to run the socket and then closes the socket when finished.",
            "code": "def print_log_msg(ws_app, msg):\n    print(msg)\n\nlogs_socket = client.create_cluster_logs_socket(\"cluster_id\", 1661100000, 1661101000, print_log_msg)\nlogs_socket.run_forever()\n\n\ndef print_log_msg(ws_app, msg):\n    print(msg)\n\nlogs_socket = client.create_cluster_logs_socket(\"cluster_id\", 1661100000, 1661101000, print_log_msg)\n\nlogs_thread = Thread(target=cluster_logs_socket.run_forever)\n\nlogs_thread.start()\n# .......\n\nlogs_socket.close()\n",
            "masked_code": "def print_log_msg(ws_app, msg):\n    print(msg)\n\n<line_mask>\nlogs_socket.run_forever()\n\n\ndef print_log_msg(ws_app, msg):\n    print(msg)\n\nlogs_socket = client.create_cluster_logs_socket(\"cluster_id\", 1661100000, 1661101000, print_log_msg)\n\nlogs_thread = Thread(target=cluster_logs_socket.run_forever)\n\nlogs_thread.start()\n# .......\n\nlogs_socket.close()\n",
            "masked_line": "logs_socket = client.create_cluster_logs_socket(\"cluster_id\", 1661100000, 1661101000, print_log_msg)",
            "answer": "create_cluster_logs_socket",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_655"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==1.8.4",
            "time": "2022-12-08",
            "description": "The first code snippet creates a StaticWebFrontend object that serves files from a specified folder path when configuring the layout in the Work class.\n\nThe second code snippet configures a layout by defining tabs with specific content for each tab in the Work class.",
            "code": "from lightning_app.frontend import StaticWebFrontend\n\nclass Work(LightningWork):\n    def configure_layout(self):\n        return StaticWebFrontend(\"path/to/folder/to/serve\")\n\nclass Work(LightningWork):\n    def configure_layout(self):\n        return [\n            dict(name=\"First Tab\", content=self.child0),\n            dict(name=\"Second Tab\", content=self.child1),\n            dict(name=\"Lightning\", content=\"https://lightning.ai\"),\n        ]\n",
            "masked_code": "from lightning_app.frontend import StaticWebFrontend\n\nclass Work(LightningWork):\n    def configure_layout(self):\n        return StaticWebFrontend(\"path/to/folder/to/serve\")\n\nclass Work(LightningWork):\n    <line_mask>\n        return [\n            dict(name=\"First Tab\", content=self.child0),\n            dict(name=\"Second Tab\", content=self.child1),\n            dict(name=\"Lightning\", content=\"https://lightning.ai\"),\n        ]\n",
            "masked_line": "def configure_layout(self):",
            "answer": "configure_layout",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_656"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==1.9.0",
            "time": "2023-01-17",
            "description": "The function adjusts the version constraints for the package \"arrow\" based on the specified conditions and comments, and applies the specified adjustment (none, all, or major) accordingly.",
            "code": "_RequirementWithComment(\"arrow<=1.2.2,>=1.2.0\", comment=\"# anything\").adjust(\"none\")\n_RequirementWithComment(\"arrow<=1.2.2,>=1.2.0\", comment=\"# strict\").adjust(\"none\")\n_RequirementWithComment(\"arrow<=1.2.2,>=1.2.0\", comment=\"# my name\").adjust(\"all\")\n_RequirementWithComment(\"arrow>=1.2.0, <=1.2.2\", comment=\"# strict\").adjust(\"all\")\n_RequirementWithComment(\"arrow\").adjust(\"all\")\n_RequirementWithComment(\"arrow>=1.2.0, <=1.2.2\", comment=\"# cool\").adjust(\"major\")\n_RequirementWithComment(\"arrow>=1.2.0, <=1.2.2\", comment=\"# strict\").adjust(\"major\")\n_RequirementWithComment(\"arrow>=1.2.0\").adjust(\"major\")\n_RequirementWithComment(\"arrow\").adjust(\"major\")",
            "masked_code": "_RequirementWithComment(\"arrow<=1.2.2,>=1.2.0\", comment=\"# anything\").adjust(\"none\")\n_RequirementWithComment(\"arrow<=1.2.2,>=1.2.0\", comment=\"# strict\").adjust(\"none\")\n_RequirementWithComment(\"arrow<=1.2.2,>=1.2.0\", comment=\"# my name\").adjust(\"all\")\n<line_mask>\n_RequirementWithComment(\"arrow\").adjust(\"all\")\n_RequirementWithComment(\"arrow>=1.2.0, <=1.2.2\", comment=\"# cool\").adjust(\"major\")\n_RequirementWithComment(\"arrow>=1.2.0, <=1.2.2\", comment=\"# strict\").adjust(\"major\")\n_RequirementWithComment(\"arrow>=1.2.0\").adjust(\"major\")\n_RequirementWithComment(\"arrow\").adjust(\"major\")",
            "masked_line": "_RequirementWithComment(\"arrow>=1.2.0, <=1.2.2\", comment=\"# strict\").adjust(\"all\")",
            "answer": "adjust",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_657"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==1.8.6",
            "time": "2022-12-21",
            "description": "The code is augmenting requirements for the \"arrow\" package with different unfreeze options.",
            "code": "_augment_requirement(\"arrow<=1.2.2,>=1.2.0  # anything\", unfreeze=\"\")\n_augment_requirement(\"arrow<=1.2.2,>=1.2.0  # strict\", unfreeze=\"\")\n_augment_requirement(\"arrow<=1.2.2,>=1.2.0  # my name\", unfreeze=\"all\")\n_augment_requirement(\"arrow>=1.2.0, <=1.2.2  # strict\", unfreeze=\"all\")\n_augment_requirement(\"arrow\", unfreeze=\"all\")\n_augment_requirement(\"arrow>=1.2.0, <=1.2.2  # cool\", unfreeze=\"major\")\n_augment_requirement(\"arrow>=1.2.0, <=1.2.2  # strict\", unfreeze=\"major\")\n_augment_requirement(\"arrow>=1.2.0\", unfreeze=\"major\")\n_augment_requirement(\"arrow\", unfreeze=\"major\")",
            "masked_code": "_augment_requirement(\"arrow<=1.2.2,>=1.2.0  # anything\", unfreeze=\"\")\n_augment_requirement(\"arrow<=1.2.2,>=1.2.0  # strict\", unfreeze=\"\")\n_augment_requirement(\"arrow<=1.2.2,>=1.2.0  # my name\", unfreeze=\"all\")\n_augment_requirement(\"arrow>=1.2.0, <=1.2.2  # strict\", unfreeze=\"all\")\n_augment_requirement(\"arrow\", unfreeze=\"all\")\n_augment_requirement(\"arrow>=1.2.0, <=1.2.2  # cool\", unfreeze=\"major\")\n_augment_requirement(\"arrow>=1.2.0, <=1.2.2  # strict\", unfreeze=\"major\")\n<line_mask>\n_augment_requirement(\"arrow\", unfreeze=\"major\")",
            "masked_line": "_augment_requirement(\"arrow>=1.2.0\", unfreeze=\"major\")",
            "answer": "_augment_requirement",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_658"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==2.2.0",
            "time": "2024-02-07",
            "description": "The code calculates the throughput of a process by measuring the time taken to process a certain number of samples and then computing the throughput every 10 samples.",
            "code": "throughput = Throughput()\nt0 = time()\nfor i in range(1000):\n    do_work()\n    if torch.cuda.is_available(): torch.cuda.synchronize()  # required or else time() won't be correct\n    throughput.update(time=time() - t0, samples=i)\n    if i % 10 == 0:\n        print(throughput.compute())",
            "masked_code": "<line_mask>\nt0 = time()\nfor i in range(1000):\n    do_work()\n    if torch.cuda.is_available(): torch.cuda.synchronize()  # required or else time() won't be correct\n    throughput.update(time=time() - t0, samples=i)\n    if i % 10 == 0:\n        print(throughput.compute())",
            "masked_line": "throughput = Throughput()",
            "answer": "Throughput",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_659"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==0.6.0",
            "time": "2020-01-21",
            "description": "The code increases the value of the counter in the app state by 1 and prints a message indicating the updated value of the counter.",
            "code": "import param\napp = AppStateWatcher()\napp.state.counter = 1\n\n@param.depends(app.param.state, watch=True)\ndef update(state):\n    print(f\"The counter was updated to {state.counter}\")\n\napp.state.counter += 1",
            "masked_code": "import param\n<line_mask>\napp.state.counter = 1\n\n@param.depends(app.param.state, watch=True)\ndef update(state):\n    print(f\"The counter was updated to {state.counter}\")\n\napp.state.counter += 1",
            "masked_line": "app = AppStateWatcher()",
            "answer": "AppStateWatcher",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_660"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==0.6.0",
            "time": "2020-01-21",
            "description": "The code defines a function called 'print_log_msg' that prints a message. It then creates a logs socket using a client function 'create_cluster_logs_socket' with specific parameters. The socket runs continuously in a loop to receive log messages. Finally, it closes the logs socket when finished.",
            "code": "def print_log_msg(ws_app, msg):\n    print(msg)\n\nlogs_socket = client.create_cluster_logs_socket(\"cluster_id\", 1661100000, 1661101000, print_log_msg)\nlogs_socket.run_forever()\n\n\ndef print_log_msg(ws_app, msg):\n    print(msg)\n\nlogs_socket = client.create_cluster_logs_socket(\"cluster_id\", 1661100000, 1661101000, print_log_msg)\n\nlogs_thread = Thread(target=cluster_logs_socket.run_forever)\n\nlogs_thread.start()\n# .......\n\nlogs_socket.close()\n",
            "masked_code": "def print_log_msg(ws_app, msg):\n    print(msg)\n\nlogs_socket = client.create_cluster_logs_socket(\"cluster_id\", 1661100000, 1661101000, print_log_msg)\nlogs_socket.run_forever()\n\n\ndef print_log_msg(ws_app, msg):\n    print(msg)\n\n<line_mask>\n\nlogs_thread = Thread(target=cluster_logs_socket.run_forever)\n\nlogs_thread.start()\n# .......\n\nlogs_socket.close()\n",
            "masked_line": "logs_socket = client.create_cluster_logs_socket(\"cluster_id\", 1661100000, 1661101000, print_log_msg)",
            "answer": "create_cluster_logs_socket",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_661"
        },
        {
            "dependency": "ray",
            "version": "==0.4.0",
            "time": "2018-03-27",
            "description": "The code is implementing a bracketing algorithm to optimize a certain function with specified parameters. The algorithm updates the brackets based on the results of trials and determines a cutoff value for stopping the optimization process.",
            "code": "b = _Bracket(1, 10, 2, 3)\nb.on_result(trial1, 1, 2)  # CONTINUE\nb.on_result(trial2, 1, 4)  # CONTINUE\nb.cutoff(b._rungs[-1][1]) == 3.0  # rungs are reversed\nb.on_result(trial3, 1, 1)  # STOP\nb.cutoff(b._rungs[0][1]) == 2.0",
            "masked_code": "<line_mask>\nb.on_result(trial1, 1, 2)  # CONTINUE\nb.on_result(trial2, 1, 4)  # CONTINUE\nb.cutoff(b._rungs[-1][1]) == 3.0  # rungs are reversed\nb.on_result(trial3, 1, 1)  # STOP\nb.cutoff(b._rungs[0][1]) == 2.0",
            "masked_line": "b = _Bracket(1, 10, 2, 3)",
            "answer": "_Bracket",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_662"
        },
        {
            "dependency": "ray",
            "version": "==0.7.3",
            "time": "2019-08-02",
            "description": "The code initializes a model class with input, hidden, output, and value layers using TensorFlow's Keras layers, and registers the variables of the base model.",
            "code": "def __init__(self, *args, **kwargs):\n    super(MyModelClass, self).__init__(*args, **kwargs)\n    input_layer = tf.keras.layers.Input(...)\n    hidden_layer = tf.keras.layers.Dense(...)(input_layer)\n    output_layer = tf.keras.layers.Dense(...)(hidden_layer)\n    value_layer = tf.keras.layers.Dense(...)(hidden_layer)\n    self.base_model = tf.keras.Model(\n        input_layer, [output_layer, value_layer])\n    self.register_variables(self.base_model.variables)",
            "masked_code": "<line_mask>\n    super(MyModelClass, self).__init__(*args, **kwargs)\n    input_layer = tf.keras.layers.Input(...)\n    hidden_layer = tf.keras.layers.Dense(...)(input_layer)\n    output_layer = tf.keras.layers.Dense(...)(hidden_layer)\n    value_layer = tf.keras.layers.Dense(...)(hidden_layer)\n    self.base_model = tf.keras.Model(\n        input_layer, [output_layer, value_layer])\n    self.register_variables(self.base_model.variables)",
            "masked_line": "def __init__(self, *args, **kwargs):",
            "answer": "__init__",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_663"
        },
        {
            "dependency": "ray",
            "version": "==0.7.4",
            "time": "2019-09-05",
            "description": "The code defines a configuration space with hyperparameters for 'width', 'height', and 'activation' with specified ranges and choices. It then sets up a Bayesian optimization hyperparameter tuning algorithm (TuneBOHB) with a maximum of 4 concurrent training runs, aiming to minimize 'mean_loss'. Additionally, it sets up a hyperband algorithm (HyperBandForBOHB) with a maximum of 100 training iterations based on 'mean_loss'. Finally, it runs the training process using the specified trainable class, with the hyperparameter tuning algorithm TuneBOHB and the hyperband algorithm HyperBandForBOHB.",
            "code": "import ConfigSpace as CS\nconfig_space = CS.ConfigurationSpace()\nconfig_space.add_hyperparameter(\n        CS.UniformFloatHyperparameter('width', lower=0, upper=20))\nconfig_space.add_hyperparameter(\n        CS.UniformFloatHyperparameter('height', lower=-100, upper=100))\nconfig_space.add_hyperparameter(\n        CS.CategoricalHyperparameter(\n            name='activation', choices=['relu', 'tanh']))\nalgo = TuneBOHB(\n        config_space, max_concurrent=4, metric='mean_loss', mode='min')\nbohb = HyperBandForBOHB(\n        time_attr='training_iteration',\n        metric='mean_loss',\n        mode='min',\n        max_t=100)\nrun(MyTrainableClass, scheduler=bohb, search_alg=algo)",
            "masked_code": "import ConfigSpace as CS\nconfig_space = CS.ConfigurationSpace()\nconfig_space.add_hyperparameter(\n        CS.UniformFloatHyperparameter('width', lower=0, upper=20))\nconfig_space.add_hyperparameter(\n        CS.UniformFloatHyperparameter('height', lower=-100, upper=100))\nconfig_space.add_hyperparameter(\n        CS.CategoricalHyperparameter(\n            name='activation', choices=['relu', 'tanh']))\n<line_mask>\n        config_space, max_concurrent=4, metric='mean_loss', mode='min')\nbohb = HyperBandForBOHB(\n        time_attr='training_iteration',\n        metric='mean_loss',\n        mode='min',\n        max_t=100)\nrun(MyTrainableClass, scheduler=bohb, search_alg=algo)",
            "masked_line": "algo = TuneBOHB(",
            "answer": "TuneBOHB",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_664"
        },
        {
            "dependency": "ray",
            "version": "==0.7.5",
            "time": "2019-09-17",
            "description": "This code creates two Namespaced Key-Value Stores, `store_ns1` and `store_ns2`, and allows them to store and retrieve key-value pairs within their respective namespaces. It demonstrates putting and getting values for the same key in different namespaces.",
            "code": "store_ns1 = NamespacedKVStore(namespace=\"ns1\")\nstore_ns2 = NamespacedKVStore(namespace=\"ns2\")\nstore_ns1.put(\"same-key\", 1)\nstore_ns1.get(\"same-key\")\nstore_ns2.put(\"same-key\", 2)\nstore_ns2.get(\"same-key\", 2)",
            "masked_code": "store_ns1 = NamespacedKVStore(namespace=\"ns1\")\n<line_mask>\nstore_ns1.put(\"same-key\", 1)\nstore_ns1.get(\"same-key\")\nstore_ns2.put(\"same-key\", 2)\nstore_ns2.get(\"same-key\", 2)",
            "masked_line": "store_ns2 = NamespacedKVStore(namespace=\"ns2\")",
            "answer": "NamespacedKVStore",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_665"
        },
        {
            "dependency": "ray",
            "version": "==0.8.1",
            "time": "2020-01-26",
            "description": "The code creates an ActorPool object, submits a lambda function to double a value for processing by the actor pool, checks if there is a next result available, retrieves the next result from the pool, and then checks again if there is a next result available.",
            "code": "pool = ActorPool(...)\npool.submit(lambda a, v: a.double.remote(v), 1)\nprint(pool.has_next())\nprint(pool.get_next())\nprint(pool.has_next())",
            "masked_code": "pool = ActorPool(...)\npool.submit(lambda a, v: a.double.remote(v), 1)\n<line_mask>\nprint(pool.get_next())\nprint(pool.has_next())",
            "masked_line": "print(pool.has_next())",
            "answer": "has_next",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_666"
        },
        {
            "dependency": "ray",
            "version": "==0.8.1",
            "time": "2020-01-26",
            "description": "The code defines two functions that accept batches of inputs, ensuring that the inputs are lists before proceeding with the rest of the code.",
            "code": "@serve.accept_batch\ndef serving_func(flask_request):\n    assert isinstance(flask_request, list)\n    ...\n\n@serve.accept_batch\ndef __call__(self, *, python_arg=None):\n    assert isinstance(python_arg, list)",
            "masked_code": "<line_mask>\ndef serving_func(flask_request):\n    assert isinstance(flask_request, list)\n    ...\n\n@serve.accept_batch\ndef __call__(self, *, python_arg=None):\n    assert isinstance(python_arg, list)",
            "masked_line": "@serve.accept_batch",
            "answer": "accept_batch",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_667"
        },
        {
            "dependency": "ray",
            "version": "==0.8.2",
            "time": "2020-02-24",
            "description": "The code generates an iterator that iterates over a range of numbers from 10 to 1, shuffles the data locally with a buffer size of 2, and then gathers the shuffled data synchronously. It then iterates over the data four times using the `next()` function.",
            "code": "it = from_range(10, 1).local_shuffle(shuffle_buffer_size=2)\nit = it.gather_sync()\nnext(it)\nnext(it)\nnext(it)\nnext(it)\n",
            "masked_code": "<line_mask>\nit = it.gather_sync()\nnext(it)\nnext(it)\nnext(it)\nnext(it)\n",
            "masked_line": "it = from_range(10, 1).local_shuffle(shuffle_buffer_size=2)",
            "answer": "local_shuffle",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_668"
        },
        {
            "dependency": "ray",
            "version": "==0.8.3",
            "time": "2020-03-24",
            "description": "This code performs a hyperparameter optimization using the Dragonfly library by defining a domain with variables \"LiNO3_vol\", \"Li2SO4_vol\", and \"NaClO4_vol\" with specified ranges. It then sets up an optimization algorithm using EuclideanGPBandit and EuclideanFunctionCaller from Dragonfly. Finally, it runs the optimization using the DragonflySearch algorithm with the specified objective function my_func and maximum concurrency of 4.",
            "code": "from ray import tune\nfrom dragonfly.opt.gp_bandit import EuclideanGPBandit\nfrom dragonfly.exd.experiment_caller import EuclideanFunctionCaller\nfrom dragonfly import load_config\n\ndomain_vars = [{\n    \"name\": \"LiNO3_vol\",\n    \"type\": \"float\",\n    \"min\": 0,\n    \"max\": 7\n}, {\n    \"name\": \"Li2SO4_vol\",\n    \"type\": \"float\",\n    \"min\": 0,\n    \"max\": 7\n}, {\n    \"name\": \"NaClO4_vol\",\n    \"type\": \"float\",\n    \"min\": 0,\n    \"max\": 7\n}]\n\ndomain_config = load_config({\"domain\": domain_vars})\nfunc_caller = EuclideanFunctionCaller(None,\n    domain_config.domain.list_of_domains[0])\noptimizer = EuclideanGPBandit(func_caller, ask_tell_mode=True)\n\nalgo = DragonflySearch(optimizer, max_concurrent=4,\n    metric=\"objective\", mode=\"max\")\n\ntune.run(my_func, algo=algo)\n",
            "masked_code": "from ray import tune\nfrom dragonfly.opt.gp_bandit import EuclideanGPBandit\nfrom dragonfly.exd.experiment_caller import EuclideanFunctionCaller\nfrom dragonfly import load_config\n\ndomain_vars = [{\n    \"name\": \"LiNO3_vol\",\n    \"type\": \"float\",\n    \"min\": 0,\n    \"max\": 7\n}, {\n    \"name\": \"Li2SO4_vol\",\n    \"type\": \"float\",\n    \"min\": 0,\n    \"max\": 7\n}, {\n    \"name\": \"NaClO4_vol\",\n    \"type\": \"float\",\n    \"min\": 0,\n    \"max\": 7\n}]\n\ndomain_config = load_config({\"domain\": domain_vars})\nfunc_caller = EuclideanFunctionCaller(None,\n    domain_config.domain.list_of_domains[0])\noptimizer = EuclideanGPBandit(func_caller, ask_tell_mode=True)\n\n<line_mask>\n    metric=\"objective\", mode=\"max\")\n\ntune.run(my_func, algo=algo)\n",
            "masked_line": "algo = DragonflySearch(optimizer, max_concurrent=4,",
            "answer": "DragonflySearch",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_669"
        },
        {
            "dependency": "ray",
            "version": "==0.8.3",
            "time": "2020-03-24",
            "description": "The code creates 4 ReplayActor instances and sets up ParallelRollouts object. It then stores the SampleBatch data generated from rollouts into the ReplayActors using StoreToReplayActors function.",
            "code": "actors = [ReplayActor.remote() for _ in range(4)]\nrollouts = ParallelRollouts(...)\nstore_op = rollouts.for_each(StoreToReplayActors(actors))\nnext(store_op)\nSampleBatch(...)",
            "masked_code": "actors = [ReplayActor.remote() for _ in range(4)]\nrollouts = ParallelRollouts(...)\n<line_mask>\nnext(store_op)\nSampleBatch(...)",
            "masked_line": "store_op = rollouts.for_each(StoreToReplayActors(actors))",
            "answer": "StoreToReplayActors",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_670"
        },
        {
            "dependency": "ray",
            "version": "==0.8.3",
            "time": "2020-03-24",
            "description": "The code creates a queue with a maximum size of 100, then enqueues data in parallel and dequeues data concurrently in an asynchronous mode.",
            "code": "queue = queue.Queue(100)\nwrite_op = ParallelRollouts(...).for_each(Enqueue(queue))\nread_op = Dequeue(queue)\ncombined_op = Concurrently([write_op, read_op], mode=\"async\")\nnext(combined_op)",
            "masked_code": "queue = queue.Queue(100)\n<line_mask>\nread_op = Dequeue(queue)\ncombined_op = Concurrently([write_op, read_op], mode=\"async\")\nnext(combined_op)",
            "masked_line": "write_op = ParallelRollouts(...).for_each(Enqueue(queue))",
            "answer": "Enqueue",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_671"
        },
        {
            "dependency": "ray",
            "version": "==0.8.2",
            "time": "2020-02-24",
            "description": "The code defines functions for creating a neural network model, optimizer, and dataset. It then creates a PyTorchTrainer object using the defined functions and trains the model using Mean Squared Error loss and stochastic gradient descent optimization with a specified learning rate.",
            "code": "def model_creator(config):\n    return nn.Linear(1, 1)\n\n\ndef optimizer_creator(model, config):\n    return torch.optim.SGD(\n        model.parameters(), lr=config.get(\"lr\", 1e-4))\n\n\ndef data_creator(config):\n    return LinearDataset(2, 5), LinearDataset(2, 5, size=400)\n\ntrainer = PyTorchTrainer(\n    model_creator,\n    data_creator,\n    optimizer_creator,\n    loss_creator=nn.MSELoss,\n    use_gpu=True\n)\ntrainer.train()\n",
            "masked_code": "def model_creator(config):\n    return nn.Linear(1, 1)\n\n\ndef optimizer_creator(model, config):\n    return torch.optim.SGD(\n        model.parameters(), lr=config.get(\"lr\", 1e-4))\n\n\ndef data_creator(config):\n    return LinearDataset(2, 5), LinearDataset(2, 5, size=400)\n\n<line_mask>\n    model_creator,\n    data_creator,\n    optimizer_creator,\n    loss_creator=nn.MSELoss,\n    use_gpu=True\n)\ntrainer.train()\n",
            "masked_line": "trainer = PyTorchTrainer(",
            "answer": "PyTorchTrainer",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_672"
        },
        {
            "dependency": "ray",
            "version": "==1.0.1",
            "time": "2020-11-06",
            "description": "The code defines a custom Callback class called MyCallback that prints the value of a metric from the result of each trial. It then defines a train function that loops 10 times and reports a metric value. Finally, it runs the train function using Ray Tune with the MyCallback as a callback.",
            "code": "from ray import tune\nfrom ray.tune import Callback\n\n\nclass MyCallback(Callback):\n    def on_trial_result(self, iteration, trials, trial, result,\n                        **info):\n        print(f\"Got result: {result['metric']}\")\n\n\ndef train(config):\n    for i in range(10):\n        tune.report(metric=i)\n\n\ntune.run(\n    train,\n    callbacks=[MyCallback()])\n",
            "masked_code": "from ray import tune\n<line_mask>\n\n\nclass MyCallback(Callback):\n    def on_trial_result(self, iteration, trials, trial, result,\n                        **info):\n        print(f\"Got result: {result['metric']}\")\n\n\ndef train(config):\n    for i in range(10):\n        tune.report(metric=i)\n\n\ntune.run(\n    train,\n    callbacks=[MyCallback()])\n",
            "masked_line": "from ray.tune import Callback",
            "answer": "Callback",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_673"
        },
        {
            "dependency": "ray",
            "version": "==1.0.1",
            "time": "2020-11-06",
            "description": "The code initializes a Ray instance, creates a placement group with 2 CPUs, and checks if the current placement group is None.",
            "code": "@ray.remote\ndef f():\n    pg = get_current_placement_group()\n    pg = placement_group([{\"CPU\": 2}])\n    f.options(placement_group=pg).remote()\n\nray.init()\nassert get_current_placement_group() is None",
            "masked_code": "@ray.remote\ndef f():\n    <line_mask>\n    pg = placement_group([{\"CPU\": 2}])\n    f.options(placement_group=pg).remote()\n\nray.init()\nassert get_current_placement_group() is None",
            "masked_line": "pg = get_current_placement_group()",
            "answer": "get_current_placement_group",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_674"
        },
        {
            "dependency": "ray",
            "version": "==1.1.0",
            "time": "2020-12-24",
            "description": "The code aims to create a Torch DataLoader object from a given shard of data, which can be used for training a model using TorchTrainer.",
            "code": "# create dummy data\nspark.range(...).write.parquet(...)\n# create MLDataset\ndata = ray.util.data.read_parquet(...)\n# convert to TorchMLDataset\nds = data.to_torch(feature_columns=..., label_column=...)\n# get the given shard data\nshard = ds.get_shard(0)\n# create the DataLoader from the shard data and this can be used for\n# the TorchTrainer data creator as well\ndata = DataLoader(shard, batch_size=32)\n",
            "masked_code": "# create dummy data\nspark.range(...).write.parquet(...)\n# create MLDataset\n<line_mask>\n# convert to TorchMLDataset\nds = data.to_torch(feature_columns=..., label_column=...)\n# get the given shard data\nshard = ds.get_shard(0)\n# create the DataLoader from the shard data and this can be used for\n# the TorchTrainer data creator as well\ndata = DataLoader(shard, batch_size=32)\n",
            "masked_line": "data = ray.util.data.read_parquet(...)",
            "answer": "read_parquet",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_675"
        },
        {
            "dependency": "ray",
            "version": "==1.10.0",
            "time": "2022-01-24",
            "description": "The code reads items from a generator and adds them to an output buffer. If the buffer reaches a certain size, it yields the buffered items and then continues adding more items. Finally, it yields any remaining items in the buffer.",
            "code": "output = BlockOutputBuffer(udf, 500 * 1024 * 1024)\nfor item in generator():\n    output.add(item)\n    if output.has_next():\n        yield output.next()\noutput.finalize()\nif output.has_next():\n    yield output.next()",
            "masked_code": "<line_mask>\nfor item in generator():\n    output.add(item)\n    if output.has_next():\n        yield output.next()\noutput.finalize()\nif output.has_next():\n    yield output.next()",
            "masked_line": "output = BlockOutputBuffer(udf, 500 * 1024 * 1024)",
            "answer": "BlockOutputBuffer",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_676"
        },
        {
            "dependency": "ray",
            "version": "==1.10.0",
            "time": "2022-01-24",
            "description": "The code creates a GcsErrorSubscriber object, subscribes to it, polls for error data while a flag \"running\" is true, and then closes the subscriber.",
            "code": "subscriber = GcsErrorSubscriber()\nsubscriber.subscribe()\nwhile running:\n    error_id, error_data = subscriber.poll()\nsubscriber.close()",
            "masked_code": "<line_mask>\nsubscriber.subscribe()\nwhile running:\n    error_id, error_data = subscriber.poll()\nsubscriber.close()",
            "masked_line": "subscriber = GcsErrorSubscriber()",
            "answer": "GcsErrorSubscriber",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_677"
        },
        {
            "dependency": "ray",
            "version": "==1.10.0",
            "time": "2022-01-24",
            "description": "The code creates a GcsLogSubscriber object, subscribes to logs, and then continuously polls for logs until the program stops running. Finally, it closes the subscriber.",
            "code": "subscriber = GcsLogSubscriber()\nsubscriber.subscribe()\nwhile running:\n    log = subscriber.poll()\nsubscriber.close()",
            "masked_code": "<line_mask>\nsubscriber.subscribe()\nwhile running:\n    log = subscriber.poll()\nsubscriber.close()",
            "masked_line": "subscriber = GcsLogSubscriber()",
            "answer": "GcsLogSubscriber",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_678"
        },
        {
            "dependency": "ray",
            "version": "==1.10.0",
            "time": "2022-01-24",
            "description": "The code creates a GcsFunctionKeySubscriber object, subscribes to it, continuously polls for keys while a specified condition 'running' is true, and then closes the subscriber after the loop is finished.",
            "code": "subscriber = GcsFunctionKeySubscriber()\nsubscriber.subscribe()\nwhile running:\n    key = subscriber.poll()\nsubscriber.close()",
            "masked_code": "<line_mask>\nsubscriber.subscribe()\nwhile running:\n    key = subscriber.poll()\nsubscriber.close()",
            "masked_line": "subscriber = GcsFunctionKeySubscriber()",
            "answer": "GcsFunctionKeySubscriber",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_679"
        },
        {
            "dependency": "ray",
            "version": "==1.13.0",
            "time": "2022-06-01",
            "description": "The code loads the CIFAR-10 dataset using TensorFlow Datasets and creates a data pipeline for processing the dataset. It reads the dataset using Ray data, and then extracts the features and labels for the first example in the dataset. Finally, it prints the shape of the features and the corresponding label.",
            "code": "import ray.data\nfrom ray.data.datasource import SimpleTensorFlowDatasource\nimport tensorflow_datasets as tfds\n\ndef dataset_factory():\n    return tfds.load(\"cifar10\", split=[\"train\"], as_supervised=True)[0]\n\ndataset = ray.data.read_datasource(\n    SimpleTensorFlowDatasource(),\n    parallelism=1,\n    dataset_factory=dataset_factory\n)\n\nfeatures, label = dataset.take(1)[0]\nfeatures.shape\nlabel",
            "masked_code": "import ray.data\n<line_mask>\nimport tensorflow_datasets as tfds\n\ndef dataset_factory():\n    return tfds.load(\"cifar10\", split=[\"train\"], as_supervised=True)[0]\n\ndataset = ray.data.read_datasource(\n    SimpleTensorFlowDatasource(),\n    parallelism=1,\n    dataset_factory=dataset_factory\n)\n\nfeatures, label = dataset.take(1)[0]\nfeatures.shape\nlabel",
            "masked_line": "from ray.data.datasource import SimpleTensorFlowDatasource",
            "answer": "SimpleTensorFlowDatasource",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_680"
        },
        {
            "dependency": "ray",
            "version": "==1.13.0",
            "time": "2022-06-01",
            "description": "The code reads MNIST dataset using Ray's SimpleTorchDatasource with parallelism of 1 and returns the first element from the dataset.",
            "code": "import ray\nfrom ray.data.datasource import SimpleTorchDatasource\n\ndataset_factory = lambda: torchvision.datasets.MNIST(\"data\", download=True)\ndataset = ray.data.read_datasource(\n    SimpleTorchDatasource(), parallelism=1, dataset_factory=dataset_factory\n)\ndataset.take(1)",
            "masked_code": "import ray\nfrom ray.data.datasource import SimpleTorchDatasource\n\ndataset_factory = lambda: torchvision.datasets.MNIST(\"data\", download=True)\ndataset = ray.data.read_datasource(\n    <line_mask>\n)\ndataset.take(1)",
            "masked_line": "SimpleTorchDatasource(), parallelism=1, dataset_factory=dataset_factory",
            "answer": "SimpleTorchDatasource",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_681"
        },
        {
            "dependency": "ray",
            "version": "==1.13.0",
            "time": "2022-06-01",
            "description": "The code trains a Random Forest Regressor model on a dataset with features labeled as 'x' and target variable labeled as 'y'.",
            "code": "import ray\n\nfrom ray.ml.train.integrations.sklearn import SklearnTrainer\nfrom sklearn.ensemble import RandomForestRegressor\n\ntrain_dataset = ray.data.from_items(\n    [{\"x\": x, \"y\": x + 1} for x in range(32)])\ntrainer = SklearnTrainer(\n    sklearn_estimator=RandomForestRegressor,\n    label_column=\"y\",\n    scaling_config={\n        \"trainer_resources\": {\"CPU\": 4}\n    },\n    datasets={\"train\": train_dataset}\n)\nresult = trainer.fit()\n",
            "masked_code": "import ray\n\nfrom ray.ml.train.integrations.sklearn import SklearnTrainer\nfrom sklearn.ensemble import RandomForestRegressor\n\ntrain_dataset = ray.data.from_items(\n    [{\"x\": x, \"y\": x + 1} for x in range(32)])\n<line_mask>\n    sklearn_estimator=RandomForestRegressor,\n    label_column=\"y\",\n    scaling_config={\n        \"trainer_resources\": {\"CPU\": 4}\n    },\n    datasets={\"train\": train_dataset}\n)\nresult = trainer.fit()\n",
            "masked_line": "trainer = SklearnTrainer(",
            "answer": "SklearnTrainer",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_682"
        },
        {
            "dependency": "ray",
            "version": "==1.2.0",
            "time": "2021-02-12",
            "description": "The code utilizes the HorovodRayAccelerator to distribute the training of a MNIST classifier model across 2 nodes with 4 workers per node, each utilizing 1 CPU and 1 GPU. The Trainer object is then created with 1 GPU specified, and the model is trained using this configuration.",
            "code": "import pytorch_lightning as ptl\nfrom ray.util.lightning_accelerators import HorovodRayAccelerator\n\nptl_model = MNISTClassifier(...)\n# 2 nodes, 4 workers per node, each using 1 CPU and 1 GPU.\naccelerator = HorovodRayAccelerator(num_hosts=2, num_slots=4,\n    use_gpu=True)\n\n# If using GPUs, set the ``gpus`` arg to a value > 0.\n# The actual number of GPUs is determined by ``num_slots``.\ntrainer = pl.Trainer(..., gpus=1, accelerator=accelerator)\ntrainer.fit(ptl_model)",
            "masked_code": "import pytorch_lightning as ptl\nfrom ray.util.lightning_accelerators import HorovodRayAccelerator\n\nptl_model = MNISTClassifier(...)\n# 2 nodes, 4 workers per node, each using 1 CPU and 1 GPU.\n<line_mask>\n    use_gpu=True)\n\n# If using GPUs, set the ``gpus`` arg to a value > 0.\n# The actual number of GPUs is determined by ``num_slots``.\ntrainer = pl.Trainer(..., gpus=1, accelerator=accelerator)\ntrainer.fit(ptl_model)",
            "masked_line": "accelerator = HorovodRayAccelerator(num_hosts=2, num_slots=4,",
            "answer": "HorovodRayAccelerator",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_683"
        },
        {
            "dependency": "ray",
            "version": "==1.3.0",
            "time": "2021-04-22",
            "description": "The code defines a configuration dictionary with two parameters: width and height, each with a uniform distribution. It then initializes an HEBOSearch object with a specific metric and optimization mode. Finally, it runs a function (my_func) with the specified configuration and search algorithm.",
            "code": "config = {\n    \"width\": tune.uniform(0, 20),\n    \"height\": tune.uniform(-100, 100)\n}\n\nhebo = HEBOSearch(metric=\"mean_loss\", mode=\"min\")\ntune.run(my_func, config=config, search_alg=hebo)\n\n\nfrom ray import tune\nfrom ray.tune.suggest.hebo import HEBOSearch\nfrom hebo.design_space.design_space import DesignSpace\n\nspace_config = [\n    {'name' : 'width', 'type' : 'num', 'lb' : 0, 'ub' : 20},\n    {'name' : 'height', 'type' : 'num', 'lb' : -100, 'ub' : 100},\n]\nspace = DesignSpace().parse(space_config)\n\nhebo = HEBOSearch(space, metric=\"mean_loss\", mode=\"min\")\ntune.run(my_func, search_alg=hebo)\n",
            "masked_code": "config = {\n    \"width\": tune.uniform(0, 20),\n    \"height\": tune.uniform(-100, 100)\n}\n\nhebo = HEBOSearch(metric=\"mean_loss\", mode=\"min\")\ntune.run(my_func, config=config, search_alg=hebo)\n\n\nfrom ray import tune\n<line_mask>\nfrom hebo.design_space.design_space import DesignSpace\n\nspace_config = [\n    {'name' : 'width', 'type' : 'num', 'lb' : 0, 'ub' : 20},\n    {'name' : 'height', 'type' : 'num', 'lb' : -100, 'ub' : 100},\n]\nspace = DesignSpace().parse(space_config)\n\nhebo = HEBOSearch(space, metric=\"mean_loss\", mode=\"min\")\ntune.run(my_func, search_alg=hebo)\n",
            "masked_line": "from ray.tune.suggest.hebo import HEBOSearch",
            "answer": "HEBOSearch",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_684"
        },
        {
            "dependency": "ray",
            "version": "==1.3.0",
            "time": "2021-04-22",
            "description": "The code loads a package, prints the runtime environment configuration, and defines and interacts with a remote actor and remote function using Ray.",
            "code": "my_pkg = load_package(\"~/path/to/my_pkg.yaml\")\nmy_pkg = ray.util.load_package(\n  \"https://raw.githubusercontent.com/user/repo/refspec\"\n  \"/path/to/package/my_pkg.yaml\")\nprint(my_pkg._runtime_env)\nmy_pkg.my_func.remote(1, 2)\nactor = my_pkg.MyActor.remote(3, 4)\n@ray.remote(runtime_env=my_pkg._runtime_env)\ndef f(): ...\n",
            "masked_code": "my_pkg = load_package(\"~/path/to/my_pkg.yaml\")\n<line_mask>\n  \"https://raw.githubusercontent.com/user/repo/refspec\"\n  \"/path/to/package/my_pkg.yaml\")\nprint(my_pkg._runtime_env)\nmy_pkg.my_func.remote(1, 2)\nactor = my_pkg.MyActor.remote(3, 4)\n@ray.remote(runtime_env=my_pkg._runtime_env)\ndef f(): ...\n",
            "masked_line": "my_pkg = ray.util.load_package(",
            "answer": "load_package",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_685"
        },
        {
            "dependency": "ray",
            "version": "==1.6.0",
            "time": "2021-08-21",
            "description": "This code creates an inference pipeline using a dataset from a directory. The pipeline is defined with different stages and parallelism levels, allowing for efficient inference computation. Lastly, the pipeline output is iteratively read and printed.",
            "code": "# Create an inference pipeline.\nds = ray.data.read_binary_files(dir)\npipe = ds.pipeline(parallelism=10).map(infer)\nDatasetPipeline(num_stages=2, length=40)\n\n# The higher the stage parallelism, the shorter the pipeline.\npipe = ds.pipeline(parallelism=20).map(infer)\nDatasetPipeline(num_stages=2, length=20)\n\n# Outputs can be incrementally read from the pipeline.\nfor item in pipe.iter_rows():\n    print(item)\n",
            "masked_code": "# Create an inference pipeline.\nds = ray.data.read_binary_files(dir)\n<line_mask>\nDatasetPipeline(num_stages=2, length=40)\n\n# The higher the stage parallelism, the shorter the pipeline.\npipe = ds.pipeline(parallelism=20).map(infer)\nDatasetPipeline(num_stages=2, length=20)\n\n# Outputs can be incrementally read from the pipeline.\nfor item in pipe.iter_rows():\n    print(item)\n",
            "masked_line": "pipe = ds.pipeline(parallelism=10).map(infer)",
            "answer": "pipeline",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_686"
        },
        {
            "dependency": "ray",
            "version": "==1.7.0",
            "time": "2021-10-01",
            "description": "This code defines a class method that constructs an instance of the calling class from a string input that matches a specific pattern. If the string matches the pattern, it creates an instance of the class with named arguments extracted from the string, otherwise it raises a TypeError.",
            "code": "@classmethod\ndef construct_from_string(cls, string):\n    pattern = re.compile(r\"^my_type\\[(?P<arg_name>.+)\\]$\")\n    match = pattern.match(string)\n    if match:\n        return cls(**match.groupdict())\n    else:\n        raise TypeError(\n            f\"Cannot construct a '{cls.__name__}' from '{string}'\"\n        )",
            "masked_code": "@classmethod\n<line_mask>\n    pattern = re.compile(r\"^my_type\\[(?P<arg_name>.+)\\]$\")\n    match = pattern.match(string)\n    if match:\n        return cls(**match.groupdict())\n    else:\n        raise TypeError(\n            f\"Cannot construct a '{cls.__name__}' from '{string}'\"\n        )",
            "masked_line": "def construct_from_string(cls, string):",
            "answer": "construct_from_string",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_687"
        },
        {
            "dependency": "ray",
            "version": "==1.7.0",
            "time": "2021-10-01",
            "description": "This function takes a list of indices and returns the corresponding values from the input data, with an option to fill missing values if specified.",
            "code": "def take(self, indices, allow_fill=False, fill_value=None):\n    from pandas.core.algorithms import take\n\n    data = self.astype(object)\n\n    if allow_fill and fill_value is None:\n        fill_value = self.dtype.na_value\n\n    result = take(data, indices, fill_value=fill_value,\n                  allow_fill=allow_fill)\n    return self._from_sequence(result, dtype=self.dtype)\n",
            "masked_code": "<line_mask>\n    from pandas.core.algorithms import take\n\n    data = self.astype(object)\n\n    if allow_fill and fill_value is None:\n        fill_value = self.dtype.na_value\n\n    result = take(data, indices, fill_value=fill_value,\n                  allow_fill=allow_fill)\n    return self._from_sequence(result, dtype=self.dtype)\n",
            "masked_line": "def take(self, indices, allow_fill=False, fill_value=None):",
            "answer": "take",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_688"
        },
        {
            "dependency": "ray",
            "version": "==1.7.0",
            "time": "2021-10-01",
            "description": "The code trains a model using the Torch backend with GPU support if available, setting the GPU device and then running the training function provided.",
            "code": "import time\nfrom ray.util import sgd\n\ndef train_func():\n    if torch.cuda.is_available():\n        torch.cuda.set_device(sgd.local_rank())\n    ...\n\ntrainer = Trainer(backend=\"torch\", use_gpu=True)\ntrainer.start()\ntrainer.run(train_func)\ntrainer.shutdown()",
            "masked_code": "import time\nfrom ray.util import sgd\n\ndef train_func():\n    if torch.cuda.is_available():\n        <line_mask>\n    ...\n\ntrainer = Trainer(backend=\"torch\", use_gpu=True)\ntrainer.start()\ntrainer.run(train_func)\ntrainer.shutdown()",
            "masked_line": "torch.cuda.set_device(sgd.local_rank())",
            "answer": "local_rank",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_689"
        },
        {
            "dependency": "ray",
            "version": "==1.7.0",
            "time": "2021-10-01",
            "description": "This code trains a machine learning model using stochastic gradient descent (SGD) with the Torch backend. It loads a checkpoint, runs the training function, prints the iterations from the checkpoint epoch to 4, and then shuts down the Trainer.",
            "code": "from ray.util import sgd\n\ndef train_func():\n    checkpoint = sgd.load_checkpoint()\n    for iter in range(checkpoint[\"epoch\"], 5):\n        print(iter)\n\ntrainer = Trainer(backend=\"torch\")\ntrainer.start()\ntrainer.run(train_func, checkpoint={\"epoch\": 3})\n# 3\n# 4\ntrainer.shutdown()\n",
            "masked_code": "from ray.util import sgd\n\ndef train_func():\n    <line_mask>\n    for iter in range(checkpoint[\"epoch\"], 5):\n        print(iter)\n\ntrainer = Trainer(backend=\"torch\")\ntrainer.start()\ntrainer.run(train_func, checkpoint={\"epoch\": 3})\n# 3\n# 4\ntrainer.shutdown()\n",
            "masked_line": "checkpoint = sgd.load_checkpoint()",
            "answer": "load_checkpoint",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_690"
        },
        {
            "dependency": "ray",
            "version": "==1.7.0",
            "time": "2021-10-01",
            "description": "This function pads the sequences in the input data dictionary with zeros to match a specified maximum length, excluding certain states if specified.",
            "code": "def right_zero_pad(self, max_len, exclude_states=False):\n    self.zero_padded = True\n    self.max_seq_len = max_len\n\n    if self[SampleBatch.SEQ_LENS] is None:\n        raise ValueError\n\n    for key in self.keys():\n        if key != SampleBatch.SEQ_LENS and (not exclude_states or \"state_in\" not in key):\n            self[key] += [0] * (max_len - len(self[key]))\n\n    return self\n",
            "masked_code": "<line_mask>\n    self.zero_padded = True\n    self.max_seq_len = max_len\n\n    if self[SampleBatch.SEQ_LENS] is None:\n        raise ValueError\n\n    for key in self.keys():\n        if key != SampleBatch.SEQ_LENS and (not exclude_states or \"state_in\" not in key):\n            self[key] += [0] * (max_len - len(self[key]))\n\n    return self\n",
            "masked_line": "def right_zero_pad(self, max_len, exclude_states=False):",
            "answer": "right_zero_pad",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_691"
        },
        {
            "dependency": "ray",
            "version": "==1.6.0",
            "time": "2021-08-21",
            "description": "The code utilizes the HorovodRayAccelerator to distribute the training of a MNIST classifier across 2 nodes with 4 workers per node, each worker using 1 CPU and 1 GPU. It sets up the Trainer with 1 GPU and the specified accelerator to train the ptl_model on the MNIST dataset.",
            "code": "import pytorch_lightning as ptl\nfrom ray.util.lightning_accelerators import HorovodRayAccelerator\n\nptl_model = MNISTClassifier(...)\n# 2 nodes, 4 workers per node, each using 1 CPU and 1 GPU.\naccelerator = HorovodRayAccelerator(num_hosts=2, num_slots=4,\n    use_gpu=True)\n\n# If using GPUs, set the ``gpus`` arg to a value > 0.\n# The actual number of GPUs is determined by ``num_slots``.\ntrainer = pl.Trainer(..., gpus=1, accelerator=accelerator)\ntrainer.fit(ptl_model)",
            "masked_code": "import pytorch_lightning as ptl\nfrom ray.util.lightning_accelerators import HorovodRayAccelerator\n\nptl_model = MNISTClassifier(...)\n# 2 nodes, 4 workers per node, each using 1 CPU and 1 GPU.\n<line_mask>\n    use_gpu=True)\n\n# If using GPUs, set the ``gpus`` arg to a value > 0.\n# The actual number of GPUs is determined by ``num_slots``.\ntrainer = pl.Trainer(..., gpus=1, accelerator=accelerator)\ntrainer.fit(ptl_model)",
            "masked_line": "accelerator = HorovodRayAccelerator(num_hosts=2, num_slots=4,",
            "answer": "HorovodRayAccelerator",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_692"
        },
        {
            "dependency": "ray",
            "version": "==2.3.0",
            "time": "2023-02-16",
            "description": "The code creates a resource manager, requests resources (4 CPUs), waits until resources are ready, acquires the resources, binds to a remote task or actor, runs a remote function using the acquired resources, and frees the resources after use.",
            "code": "# Create resource manager\nresource_manager = ResourceManager()\n\n# Create resource request\nresource_request = ResourceRequest([{\"CPU\": 4}])\n\n# Pass to resource manager\nresource_manager.request_resources(resource_request)\n\n# Wait until ready\nwhile not resource_manager.has_resources_ready(resource_request):\n    time.sleep(1)\n\n# Once ready, acquire resources\nacquired_resource = resource_manager.acquire_resources(resource_request)\n\n# Bind to remote task or actor\nannotated_remote_fn = acquired_resource.annotate_remote_entities(\n    [remote_fn])\n\n# Run remote function. This will use the acquired resources\nray.get(annotated_remote_fn.remote())\n\n# After using the resources, free\nresource_manager.free_resources(annotated_resources)\n",
            "masked_code": "# Create resource manager\n<line_mask>\n\n# Create resource request\nresource_request = ResourceRequest([{\"CPU\": 4}])\n\n# Pass to resource manager\nresource_manager.request_resources(resource_request)\n\n# Wait until ready\nwhile not resource_manager.has_resources_ready(resource_request):\n    time.sleep(1)\n\n# Once ready, acquire resources\nacquired_resource = resource_manager.acquire_resources(resource_request)\n\n# Bind to remote task or actor\nannotated_remote_fn = acquired_resource.annotate_remote_entities(\n    [remote_fn])\n\n# Run remote function. This will use the acquired resources\nray.get(annotated_remote_fn.remote())\n\n# After using the resources, free\nresource_manager.free_resources(annotated_resources)\n",
            "masked_line": "resource_manager = ResourceManager()",
            "answer": "ResourceManager",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_693"
        },
        {
            "dependency": "ray",
            "version": "==2.3.0",
            "time": "2023-02-16",
            "description": "The code trains a model using the MultiWorkerMirroredStrategy from TensorFlow, fitting the model on a dataset shard with a custom callback called ReportCheckpointCallback.",
            "code": "from ray.air.integrations.keras import ReportCheckpointCallback\ndef train_loop_per_worker():\n    strategy = tf.distribute.MultiWorkerMirroredStrategy()\n    with strategy.scope():\n        model = build_model()\n\n    model.fit(dataset_shard, callbacks=[ReportCheckpointCallback()])",
            "masked_code": "from ray.air.integrations.keras import ReportCheckpointCallback\ndef train_loop_per_worker():\n    strategy = tf.distribute.MultiWorkerMirroredStrategy()\n    with strategy.scope():\n        model = build_model()\n\n    <line_mask>",
            "masked_line": "model.fit(dataset_shard, callbacks=[ReportCheckpointCallback()])",
            "answer": "ReportCheckpointCallback",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_694"
        },
        {
            "dependency": "ray",
            "version": "==2.3.0",
            "time": "2023-02-16",
            "description": "This code snippet defines a function 'to_tensor' that converts a numpy array batch to a torch tensor. The function then performs permutation of dimensions, normalization of pixel values, and returns the processed tensor. This tensor transformation function is used as part of a data preprocessing pipeline that includes resizing images to (224, 224) dimensions and converting them to TorchVision preprocessed format.",
            "code": "def to_tensor(batch: np.ndarray) -> torch.Tensor:\n    tensor = torch.as_tensor(batch, dtype=torch.float)\n    # (B, H, W, C) -> (B, C, H, W)\n    tensor = tensor.permute(0, 3, 1, 2).contiguous()\n    # [0., 255.] -> [0., 1.]\n    tensor = tensor.div(255)\n    return tensor\ntransform = transforms.Compose([\n    transforms.Lambda(to_tensor),\n    transforms.Resize((224, 224))\n])\npreprocessor = TorchVisionPreprocessor(\n    [\"image\"], transform=transform, batched=True\n)\npreprocessor.transform(dataset)  # doctest: +ellipsis\nDataset(num_blocks=..., num_rows=..., schema={image: ArrowTensorType(shape=(3, 224, 224), dtype=float)})\n",
            "masked_code": "def to_tensor(batch: np.ndarray) -> torch.Tensor:\n    tensor = torch.as_tensor(batch, dtype=torch.float)\n    # (B, H, W, C) -> (B, C, H, W)\n    tensor = tensor.permute(0, 3, 1, 2).contiguous()\n    # [0., 255.] -> [0., 1.]\n    tensor = tensor.div(255)\n    return tensor\ntransform = transforms.Compose([\n    transforms.Lambda(to_tensor),\n    transforms.Resize((224, 224))\n])\n<line_mask>\n    [\"image\"], transform=transform, batched=True\n)\npreprocessor.transform(dataset)  # doctest: +ellipsis\nDataset(num_blocks=..., num_rows=..., schema={image: ArrowTensorType(shape=(3, 224, 224), dtype=float)})\n",
            "masked_line": "preprocessor = TorchVisionPreprocessor(",
            "answer": "TorchVisionPreprocessor",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_695"
        },
        {
            "dependency": "ray",
            "version": "==2.5.0",
            "time": "2023-06-06",
            "description": "The code creates a dataset using Ray, performs groupby operations on the dataset, and then operates on the groups by calculating the sum of values in columns \"B\" and \"C\" relative to each group in a pandas DataFrame.",
            "code": "import ray\nimport pandas as pd\nimport numpy as np\n\nds = ray.data.from_items([\n    {\"group\": 1, \"value\": 1},\n    {\"group\": 1, \"value\": 2},\n    {\"group\": 2, \"value\": 3},\n    {\"group\": 2, \"value\": 4}]\n)\n\nds.groupby(\"group\").map_groups(\n    lambda g: {\"result\": np.array([g[\"value\"][0]])}\n)\n\ndf = pd.DataFrame(\n    {\"A\": [\"a\", \"a\", \"b\"], \"B\": [1, 1, 3], \"C\": [4, 6, 5]}\n)\n\nds = ray.data.from_pandas(df)\n\ngrouped = ds.groupby(\"A\")\n\ngrouped.map_groups(\n    lambda g: g.apply(\n        lambda c: c / g[c.name].sum() if c.name in [\"B\", \"C\"] else c\n    )\n)",
            "masked_code": "import ray\nimport pandas as pd\nimport numpy as np\n\nds = ray.data.from_items([\n    {\"group\": 1, \"value\": 1},\n    {\"group\": 1, \"value\": 2},\n    {\"group\": 2, \"value\": 3},\n    {\"group\": 2, \"value\": 4}]\n)\n\n<line_mask>\n    lambda g: {\"result\": np.array([g[\"value\"][0]])}\n)\n\ndf = pd.DataFrame(\n    {\"A\": [\"a\", \"a\", \"b\"], \"B\": [1, 1, 3], \"C\": [4, 6, 5]}\n)\n\nds = ray.data.from_pandas(df)\n\ngrouped = ds.groupby(\"A\")\n\ngrouped.map_groups(\n    lambda g: g.apply(\n        lambda c: c / g[c.name].sum() if c.name in [\"B\", \"C\"] else c\n    )\n)",
            "masked_line": "ds.groupby(\"group\").map_groups(",
            "answer": "map_groups",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_696"
        },
        {
            "dependency": "ray",
            "version": "==2.5.0",
            "time": "2023-06-06",
            "description": "The code creates a dataset with 5 blocks and 5 rows, where each row has an integer ID. It then creates an iterator for the dataset.",
            "code": "import ray\nds = ray.data.range(5)\nds\nDataset(num_blocks=5, num_rows=5, schema={id: int64})\nds.iterator()\nDataIterator(Dataset(num_blocks=5, num_rows=5, schema={id: int64}))",
            "masked_code": "import ray\nds = ray.data.range(5)\nds\nDataset(num_blocks=5, num_rows=5, schema={id: int64})\nds.iterator()\n<line_mask>",
            "masked_line": "DataIterator(Dataset(num_blocks=5, num_rows=5, schema={id: int64}))",
            "answer": "DataIterator",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_697"
        },
        {
            "dependency": "ray",
            "version": "==2.7.0",
            "time": "2023-09-14",
            "description": "The code defines a function named \"f\" that takes an integer input and returns twice the input value. It then deploys the function as a Ray Serve application under the name \"my_app\". Finally, it retrieves the handle to the deployed application and asserts that when the function is remotely called with the input value of 3, it returns the expected result of 6.",
            "code": "import ray\nfrom ray import serve\n\n@serve.deployment\ndef f(val: int) -> int:\n    return val * 2\n\nserve.run(f.bind(), name=\"my_app\")\nhandle = serve.get_app_handle(\"my_app\")\nassert handle.remote(3).result() == 6\n",
            "masked_code": "import ray\nfrom ray import serve\n\n@serve.deployment\ndef f(val: int) -> int:\n    return val * 2\n\nserve.run(f.bind(), name=\"my_app\")\n<line_mask>\nassert handle.remote(3).result() == 6\n",
            "masked_line": "handle = serve.get_app_handle(\"my_app\")",
            "answer": "get_app_handle",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_698"
        },
        {
            "dependency": "ray",
            "version": "==2.7.0",
            "time": "2023-09-14",
            "description": "The code writes images stored in a column named \"image\" to the local path \"/tmp/images\" in different file formats such as jpeg, png, jpg, and bmp.",
            "code": "ds.write_images(\"local:///tmp/images\", column=\"image\")\nds.write_images(\"local:///tmp/images\", column=\"image\", file_format=\"jpeg\")\nds.write_images(\"local:///tmp/images\", column=\"image\", file_format=\"png\")\nds.write_images(\"local:///tmp/images\", column=\"image\", file_format=\"jpg\")\nds.write_images(\"local:///tmp/images\", column=\"image\", file_format=\"bmp\")",
            "masked_code": "<line_mask>\nds.write_images(\"local:///tmp/images\", column=\"image\", file_format=\"jpeg\")\nds.write_images(\"local:///tmp/images\", column=\"image\", file_format=\"png\")\nds.write_images(\"local:///tmp/images\", column=\"image\", file_format=\"jpg\")\nds.write_images(\"local:///tmp/images\", column=\"image\", file_format=\"bmp\")",
            "masked_line": "ds.write_images(\"local:///tmp/images\", column=\"image\")",
            "answer": "write_images",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_699"
        },
        {
            "dependency": "ray",
            "version": "==2.7.0",
            "time": "2023-09-14",
            "description": "This code creates a SQLite database \"example.db\" and a table \"movie\" with columns title, year, and score. It then inserts two movie records into the table using the data provided in the code. Finally, it reads all records from the \"movie\" table and prints the result, ordered by the \"year\" column.",
            "code": "import sqlite3\nimport ray\n\nconnection = sqlite3.connect(\"example.db\")\nconnection.cursor().execute(\"CREATE TABLE movie(title, year, score)\")\ndataset = ray.data.from_items([\n    {\"title\": \"Monty Python and the Holy Grail\", \"year\": 1975, \"score\": 8.2},\n    {\"title\": \"And Now for Something Completely Different\", \"year\": 1971, \"score\": 7.5}\n])\n\ndataset.write_sql(\n    \"INSERT INTO movie VALUES(?, ?, ?)\", lambda: sqlite3.connect(\"example.db\")\n)\n\nresult = connection.cursor().execute(\"SELECT * FROM movie ORDER BY year\")\nprint(result.fetchall())",
            "masked_code": "import sqlite3\nimport ray\n\nconnection = sqlite3.connect(\"example.db\")\nconnection.cursor().execute(\"CREATE TABLE movie(title, year, score)\")\ndataset = ray.data.from_items([\n    {\"title\": \"Monty Python and the Holy Grail\", \"year\": 1975, \"score\": 8.2},\n    {\"title\": \"And Now for Something Completely Different\", \"year\": 1971, \"score\": 7.5}\n])\n\n<line_mask>\n    \"INSERT INTO movie VALUES(?, ?, ?)\", lambda: sqlite3.connect(\"example.db\")\n)\n\nresult = connection.cursor().execute(\"SELECT * FROM movie ORDER BY year\")\nprint(result.fetchall())",
            "masked_line": "dataset.write_sql(",
            "answer": "write_sql",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_700"
        },
        {
            "dependency": "ray",
            "version": "==2.9.0",
            "time": "2023-12-18",
            "description": "The code initializes an ImageFilenameProvider class that generates filenames for rows in a dataset based on specific parameters. It then utilizes the ImageFilenameProvider class to read image data from a parquet file and write the images to a specified directory with the specified file format (png) and naming convention.",
            "code": "import ray\nfrom ray.data.datasource import FilenameProvider\n\nclass ImageFilenameProvider(FilenameProvider):\n\n    def __init__(self, file_format: str):\n        self.file_format = file_format\n\n    def get_filename_for_row(self, row, task_index, block_index, row_index):\n        return (\n            f\"{row['label']}_{task_index:06}_{block_index:06}\"\n            f\"_{row_index:06}.{self.file_format}\"\n        )\n\nds = ray.data.read_parquet(\"s3://anonymous@ray-example-data/images.parquet\")\nds.write_images(\n    \"/tmp/results\",\n    column=\"image\",\n    filename_provider=ImageFilenameProvider(\"png\")\n)",
            "masked_code": "import ray\nfrom ray.data.datasource import FilenameProvider\n\n<line_mask>\n\n    def __init__(self, file_format: str):\n        self.file_format = file_format\n\n    def get_filename_for_row(self, row, task_index, block_index, row_index):\n        return (\n            f\"{row['label']}_{task_index:06}_{block_index:06}\"\n            f\"_{row_index:06}.{self.file_format}\"\n        )\n\nds = ray.data.read_parquet(\"s3://anonymous@ray-example-data/images.parquet\")\nds.write_images(\n    \"/tmp/results\",\n    column=\"image\",\n    filename_provider=ImageFilenameProvider(\"png\")\n)",
            "masked_line": "class ImageFilenameProvider(FilenameProvider):",
            "answer": "FilenameProvider",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_701"
        },
        {
            "dependency": "ray",
            "version": "==2.9.0",
            "time": "2023-12-18",
            "description": "This Python code defines a class called CSVDatasink that inherits from BlockBasedFileDatasink. It has an __init__ method that initializes the object with a given path and file_format set to \"csv\". Additionally, it includes a method called write_block_to_file that takes a BlockAccessor object and a pyarrow.NativeFile object, converts the block to an Arrow table, and writes it to the file in CSV format using the pyarrow csv module.",
            "code": "class CSVDatasink(BlockBasedFileDatasink):\n    def __init__(self, path: str):\n        super().__init__(path, file_format=\"csv\")\n\n    def write_block_to_file(self, block: BlockAccessor, file: \"pyarrow.NativeFile\"):\n        from pyarrow import csv\n        csv.write_csv(block.to_arrow(), file)",
            "masked_code": "<line_mask>\n    def __init__(self, path: str):\n        super().__init__(path, file_format=\"csv\")\n\n    def write_block_to_file(self, block: BlockAccessor, file: \"pyarrow.NativeFile\"):\n        from pyarrow import csv\n        csv.write_csv(block.to_arrow(), file)",
            "masked_line": "class CSVDatasink(BlockBasedFileDatasink):",
            "answer": "BlockBasedFileDatasink",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_702"
        },
        {
            "dependency": "requests",
            "version": "==0.10.2",
            "time": "2012-02-15",
            "description": "The code creates a MultiDict object, sets a list of values for the key 'foo', retrieves the first value associated with key 'foo', and then retrieves the list of all values associated with key 'foo'.",
            "code": "d = MultiDict()\nd.setlist('foo', ['1', '2'])\nd['foo']\n'1'\nd.getlist('foo')\n['1', '2']",
            "masked_code": "d = MultiDict()\n<line_mask>\nd['foo']\n'1'\nd.getlist('foo')\n['1', '2']",
            "masked_line": "d.setlist('foo', ['1', '2'])",
            "answer": "setlist",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_703"
        },
        {
            "dependency": "requests",
            "version": "==0.12.1",
            "time": "2012-05-08",
            "description": "The code defines a MultiDict object, sets a list of values for the key 'foo' in the MultiDict object, retrieves the first value for the key 'foo', and retrieves the full list of values for the key 'foo'.",
            "code": "d = MultiDict()\nd.setlist('foo', ['1', '2'])\nd['foo']\n'1'\nd.getlist('foo')\n['1', '2']",
            "masked_code": "d = MultiDict()\n<line_mask>\nd['foo']\n'1'\nd.getlist('foo')\n['1', '2']",
            "masked_line": "d.setlist('foo', ['1', '2'])",
            "answer": "setlist",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_704"
        },
        {
            "dependency": "requests",
            "version": "==0.14.1",
            "time": "2012-10-01",
            "description": "The code defines a function called from_key_val_list that takes an object as input. If the input object is a dictionary, the function returns an ordered dictionary with the same key-value pairs. Otherwise, it raises a ValueError stating that more than one value is needed to unpack. The code also includes examples of calling the function with a list of tuples and a dictionary.",
            "code": "from collections import OrderedDict\n\ndef from_key_val_list(obj):\n    if isinstance(obj, dict):\n        return OrderedDict(obj)\n    else:\n        raise ValueError('need more than 1 value to unpack')\n\n# \nfrom_key_val_list([('key', 'val')])\nfrom_key_val_list({'key': 'val'})",
            "masked_code": "from collections import OrderedDict\n\ndef from_key_val_list(obj):\n    if isinstance(obj, dict):\n        return OrderedDict(obj)\n    else:\n        raise ValueError('need more than 1 value to unpack')\n\n# \n<line_mask>\nfrom_key_val_list({'key': 'val'})",
            "masked_line": "from_key_val_list([('key', 'val')])",
            "answer": "from_key_val_list",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_705"
        },
        {
            "dependency": "requests",
            "version": "==2.15.1",
            "time": "2017-05-27",
            "description": "The code creates a PoolManager object with 2 pools, then sends GET requests to 'http://google.com/', 'http://google.com/mail', and 'http://yahoo.com/'. Finally, it returns the number of pools in the PoolManager object.",
            "code": "manager = PoolManager(num_pools=2)\nr = manager.request('GET', 'http://google.com/')\nr = manager.request('GET', 'http://google.com/mail')\nr = manager.request('GET', 'http://yahoo.com/')\nlen(manager.pools)\n",
            "masked_code": "<line_mask>\nr = manager.request('GET', 'http://google.com/')\nr = manager.request('GET', 'http://google.com/mail')\nr = manager.request('GET', 'http://yahoo.com/')\nlen(manager.pools)\n",
            "masked_line": "manager = PoolManager(num_pools=2)",
            "answer": "PoolManager",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_706"
        },
        {
            "dependency": "requests",
            "version": "==2.15.1",
            "time": "2017-05-27",
            "description": "The code creates a proxy manager using urllib3 for making HTTP requests through a proxy server. It sends GET requests to 'http://google.com/', 'http://httpbin.org/', 'https://httpbin.org/', and 'https://twitter.com/'. It also checks the number of connection pools used by the proxy manager.",
            "code": "proxy = urllib3.ProxyManager('http://localhost:3128/')\nr1 = proxy.request('GET', 'http://google.com/')\nr2 = proxy.request('GET', 'http://httpbin.org/')\nlen(proxy.pools)\nr3 = proxy.request('GET', 'https://httpbin.org/')\nr4 = proxy.request('GET', 'https://twitter.com/')\nlen(proxy.pools)\n",
            "masked_code": "<line_mask>\nr1 = proxy.request('GET', 'http://google.com/')\nr2 = proxy.request('GET', 'http://httpbin.org/')\nlen(proxy.pools)\nr3 = proxy.request('GET', 'https://httpbin.org/')\nr4 = proxy.request('GET', 'https://twitter.com/')\nlen(proxy.pools)\n",
            "masked_line": "proxy = urllib3.ProxyManager('http://localhost:3128/')",
            "answer": "ProxyManager",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_707"
        },
        {
            "dependency": "requests",
            "version": "==2.15.1",
            "time": "2017-05-27",
            "description": "The code sets up a PoolManager for making HTTP requests with different retry configurations, including setting up retries for connection, reading, and redirecting. The code then makes three HTTP GET requests to 'http://example.com/' with different retry configurations set.",
            "code": "retries = Retry(connect=5, read=2, redirect=5)\nhttp = PoolManager(retries=retries)\nresponse = http.request('GET', 'http://example.com/')\n\nresponse = http.request('GET', 'http://example.com/', retries=Retry(10))\n\nresponse = http.request('GET', 'http://example.com/', retries=False)\n",
            "masked_code": "<line_mask>\nhttp = PoolManager(retries=retries)\nresponse = http.request('GET', 'http://example.com/')\n\nresponse = http.request('GET', 'http://example.com/', retries=Retry(10))\n\nresponse = http.request('GET', 'http://example.com/', retries=False)\n",
            "masked_line": "retries = Retry(connect=5, read=2, redirect=5)",
            "answer": "Retry",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_708"
        },
        {
            "dependency": "requests",
            "version": "==2.16.3",
            "time": "2017-05-27",
            "description": "The code is using the PoolManager from the requests library to make HTTP GET requests to 'http://example.com/' with different retry settings.",
            "code": "retries = Retry(connect=5, read=2, redirect=5)\nhttp = PoolManager(retries=retries)\nresponse = http.request('GET', 'http://example.com/')\n\nresponse = http.request('GET', 'http://example.com/', retries=Retry(10))\n\nresponse = http.request('GET', 'http://example.com/', retries=False)\n",
            "masked_code": "retries = Retry(connect=5, read=2, redirect=5)\nhttp = PoolManager(retries=retries)\nresponse = http.request('GET', 'http://example.com/')\n\n<line_mask>\n\nresponse = http.request('GET', 'http://example.com/', retries=False)\n",
            "masked_line": "response = http.request('GET', 'http://example.com/', retries=Retry(10))",
            "answer": "Retry",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_709"
        },
        {
            "dependency": "requests",
            "version": "==2.16.3",
            "time": "2017-05-27",
            "description": "This code creates a PoolManager with 2 pools, sends GET requests to 'http://google.com/', 'http://google.com/mail', and 'http://yahoo.com/', and returns the number of pools in the manager.",
            "code": "manager = PoolManager(num_pools=2)\nr = manager.request('GET', 'http://google.com/')\nr = manager.request('GET', 'http://google.com/mail')\nr = manager.request('GET', 'http://yahoo.com/')\nlen(manager.pools)\n",
            "masked_code": "<line_mask>\nr = manager.request('GET', 'http://google.com/')\nr = manager.request('GET', 'http://google.com/mail')\nr = manager.request('GET', 'http://yahoo.com/')\nlen(manager.pools)\n",
            "masked_line": "manager = PoolManager(num_pools=2)",
            "answer": "PoolManager",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_710"
        },
        {
            "dependency": "requests",
            "version": "==2.16.3",
            "time": "2017-05-27",
            "description": "The code creates a proxy manager object with the proxy server located at 'http://localhost:3128/'. It then sends multiple GET requests using the proxy manager to different websites like 'http://google.com/', 'http://httpbin.org/', 'https://httpbin.org/', and 'https://twitter.com/'. The code also checks the number of proxy pools after each request.",
            "code": "proxy = urllib3.ProxyManager('http://localhost:3128/')\nr1 = proxy.request('GET', 'http://google.com/')\nr2 = proxy.request('GET', 'http://httpbin.org/')\nlen(proxy.pools)\nr3 = proxy.request('GET', 'https://httpbin.org/')\nr4 = proxy.request('GET', 'https://twitter.com/')\nlen(proxy.pools)\n",
            "masked_code": "<line_mask>\nr1 = proxy.request('GET', 'http://google.com/')\nr2 = proxy.request('GET', 'http://httpbin.org/')\nlen(proxy.pools)\nr3 = proxy.request('GET', 'https://httpbin.org/')\nr4 = proxy.request('GET', 'https://twitter.com/')\nlen(proxy.pools)\n",
            "masked_line": "proxy = urllib3.ProxyManager('http://localhost:3128/')",
            "answer": "ProxyManager",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_711"
        },
        {
            "dependency": "requests",
            "version": "==2.16.3",
            "time": "2017-05-27",
            "description": "The code creates a PoolManager object for making HTTP requests with specified retry settings, where the number of connect, read, and redirect retries can be configured. It then uses this PoolManager object to make multiple GET requests to 'http://example.com/' with different retry settings or disabling retries entirely.",
            "code": "retries = Retry(connect=5, read=2, redirect=5)\nhttp = PoolManager(retries=retries)\nresponse = http.request('GET', 'http://example.com/')\nresponse = http.request('GET', 'http://example.com/', retries=Retry(10))\nresponse = http.request('GET', 'http://example.com/', retries=False)\n",
            "masked_code": "<line_mask>\nhttp = PoolManager(retries=retries)\nresponse = http.request('GET', 'http://example.com/')\nresponse = http.request('GET', 'http://example.com/', retries=Retry(10))\nresponse = http.request('GET', 'http://example.com/', retries=False)\n",
            "masked_line": "retries = Retry(connect=5, read=2, redirect=5)",
            "answer": "Retry",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_712"
        },
        {
            "dependency": "requests",
            "version": "==2.4.0",
            "time": "2014-08-29",
            "description": "The code creates a PoolManager object to manage HTTP requests with specified retry settings, and then sends three GET requests to 'http://example.com/' with different retry configurations.",
            "code": "retries = Retry(connect=5, read=2, redirect=5)\nhttp = PoolManager(retries=retries)\nresponse = http.request('GET', 'http://example.com/')\n\nresponse = http.request('GET', 'http://example.com/', retries=Retry(10))\n\nresponse = http.request('GET', 'http://example.com/', retries=False)\n",
            "masked_code": "<line_mask>\nhttp = PoolManager(retries=retries)\nresponse = http.request('GET', 'http://example.com/')\n\nresponse = http.request('GET', 'http://example.com/', retries=Retry(10))\n\nresponse = http.request('GET', 'http://example.com/', retries=False)\n",
            "masked_line": "retries = Retry(connect=5, read=2, redirect=5)",
            "answer": "Retry",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_713"
        },
        {
            "dependency": "scikit-learn",
            "version": "==0.11",
            "time": "2012-05-07",
            "description": "The code performs semi-supervised label propagation on the Iris dataset.",
            "code": "from sklearn import datasets\nfrom sklearn.semi_supervised import LabelPropagation\nlabel_prop_model = LabelPropagation()\niris = datasets.load_iris()\nrandom_unlabeled_points = np.where(np.random.random_integers(0, 1,\n   size=len(iris.target)))\nlabels = np.copy(iris.target)\nlabels[random_unlabeled_points] = -1\nlabel_prop_model.fit(iris.data, labels)\n",
            "masked_code": "from sklearn import datasets\n<line_mask>\nlabel_prop_model = LabelPropagation()\niris = datasets.load_iris()\nrandom_unlabeled_points = np.where(np.random.random_integers(0, 1,\n   size=len(iris.target)))\nlabels = np.copy(iris.target)\nlabels[random_unlabeled_points] = -1\nlabel_prop_model.fit(iris.data, labels)\n",
            "masked_line": "from sklearn.semi_supervised import LabelPropagation",
            "answer": "LabelPropagation",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_714"
        },
        {
            "dependency": "scikit-learn",
            "version": "==0.12",
            "time": "2012-09-04",
            "description": "The code calculates the pseudo-inverse of a matrix 'a' and verifies if the pseudo-inverse fulfills the properties of a Moore-Penrose pseudo-inverse.",
            "code": "from numpy import *\na = random.randn(9, 6)\na = np.dot(a, a.T)\nB = pinvh(a)\nallclose(a, dot(a, dot(B, a)))\nallclose(B, dot(B, dot(a, B)))\n",
            "masked_code": "from numpy import *\na = random.randn(9, 6)\na = np.dot(a, a.T)\n<line_mask>\nallclose(a, dot(a, dot(B, a)))\nallclose(B, dot(B, dot(a, B)))\n",
            "masked_line": "B = pinvh(a)",
            "answer": "pinvh",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_715"
        },
        {
            "dependency": "scikit-learn",
            "version": "==0.13",
            "time": "2013-01-21",
            "description": "This code performs one-hot encoding on a given dataset and transforms a new set of features using the fitted encoder.",
            "code": "from sklearn.preprocessing import OneHotEncoder\nenc = OneHotEncoder()\nenc.fit([[0, 0, 3], [1, 1, 0], [0, 2, 1], [1, 0, 2]])\nenc.n_values_\nenc.feature_indices_\nenc.transform([[0, 1, 1]]).toarray()",
            "masked_code": "from sklearn.preprocessing import OneHotEncoder\n<line_mask>\nenc.fit([[0, 0, 3], [1, 1, 0], [0, 2, 1], [1, 0, 2]])\nenc.n_values_\nenc.feature_indices_\nenc.transform([[0, 1, 1]]).toarray()",
            "masked_line": "enc = OneHotEncoder()",
            "answer": "OneHotEncoder",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_716"
        },
        {
            "dependency": "scikit-learn",
            "version": "==0.13",
            "time": "2013-01-21",
            "description": "This code computes the partial dependence of the first feature on the output of a Gradient Boosting classifier, using the specified samples and labels.",
            "code": "from sklearn.ensemble import GradientBoostingClassifier\ngb = GradientBoostingClassifier().fit(samples, labels)\nkwargs = dict(X=samples, percentiles=(0, 1), grid_resolution=2)\npartial_dependence(gb, [0], **kwargs)\n(array([[-10.72892297,  10.72892297]]), [array([ 0.,  1.])])",
            "masked_code": "from sklearn.ensemble import GradientBoostingClassifier\ngb = GradientBoostingClassifier().fit(samples, labels)\nkwargs = dict(X=samples, percentiles=(0, 1), grid_resolution=2)\n<line_mask>\n(array([[-10.72892297,  10.72892297]]), [array([ 0.,  1.])])",
            "masked_line": "partial_dependence(gb, [0], **kwargs)",
            "answer": "partial_dependence",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_717"
        },
        {
            "dependency": "scikit-learn",
            "version": "==0.13",
            "time": "2013-01-21",
            "description": "The code calculates the zero-one loss between the predicted values (y_pred) and the true values (y_true), where the zero-one loss is the fraction of misclassifications. The function can optionally return the unnormalized zero-one loss value.",
            "code": "from sklearn.metrics import zero_one_loss\ny_pred = [1, 2, 3, 4]\ny_true = [2, 2, 3, 4]\nzero_one_loss(y_true, y_pred)\nzero_one_loss(y_true, y_pred, normalize=False)\n",
            "masked_code": "from sklearn.metrics import zero_one_loss\ny_pred = [1, 2, 3, 4]\ny_true = [2, 2, 3, 4]\nzero_one_loss(y_true, y_pred)\n<line_mask>\n",
            "masked_line": "zero_one_loss(y_true, y_pred, normalize=False)",
            "answer": "zero_one_loss",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_718"
        },
        {
            "dependency": "scikit-learn",
            "version": "==0.13",
            "time": "2013-01-21",
            "description": "This code calculates the accuracy of the predicted values compared to the true values.",
            "code": "from sklearn.metrics import accuracy_score\ny_pred = [0, 2, 1, 3]\ny_true = [0, 1, 2, 3]\naccuracy_score(y_true, y_pred)\n0.5",
            "masked_code": "<line_mask>\ny_pred = [0, 2, 1, 3]\ny_true = [0, 1, 2, 3]\naccuracy_score(y_true, y_pred)\n0.5",
            "masked_line": "from sklearn.metrics import accuracy_score",
            "answer": "accuracy_score",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_719"
        },
        {
            "dependency": "scikit-learn",
            "version": "==0.13",
            "time": "2013-01-21",
            "description": "Calculate the mean absolute error between true and predicted values for two sets of data, one-dimensional and multi-dimensional.",
            "code": "from sklearn.metrics import mean_absolute_error\ny_true = [3, -0.5, 2, 7]\ny_pred = [2.5, 0.0, 2, 8]\nmean_absolute_error(y_true, y_pred)\ny_true = [[0.5, 1], [-1, 1], [7, -6]]\ny_pred = [[0, 2], [-1, 2], [8, -5]]\nmean_absolute_error(y_true, y_pred)\n",
            "masked_code": "from sklearn.metrics import mean_absolute_error\ny_true = [3, -0.5, 2, 7]\ny_pred = [2.5, 0.0, 2, 8]\n<line_mask>\ny_true = [[0.5, 1], [-1, 1], [7, -6]]\ny_pred = [[0, 2], [-1, 2], [8, -5]]\nmean_absolute_error(y_true, y_pred)\n",
            "masked_line": "mean_absolute_error(y_true, y_pred)",
            "answer": "mean_absolute_error",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_720"
        },
        {
            "dependency": "scikit-learn",
            "version": "==0.14",
            "time": "2013-08-07",
            "description": "The code generates all possible combinations of parameters specified in a grid for parameter tuning in machine learning models.",
            "code": "from sklearn.grid_search import ParameterGrid\nparam_grid = {'a': [1, 2], 'b': [True, False]}\nlist(ParameterGrid(param_grid)) == (\n   [{'a': 1, 'b': True}, {'a': 1, 'b': False},\n    {'a': 2, 'b': True}, {'a': 2, 'b': False}])\n\ngrid = [{'kernel': ['linear']}, {'kernel': ['rbf'], 'gamma': [1, 10]}]\nlist(ParameterGrid(grid)) == [{'kernel': 'linear'},\n                              {'kernel': 'rbf', 'gamma': 1},\n                              {'kernel': 'rbf', 'gamma': 10}]",
            "masked_code": "from sklearn.grid_search import ParameterGrid\nparam_grid = {'a': [1, 2], 'b': [True, False]}\nlist(ParameterGrid(param_grid)) == (\n   [{'a': 1, 'b': True}, {'a': 1, 'b': False},\n    {'a': 2, 'b': True}, {'a': 2, 'b': False}])\n\ngrid = [{'kernel': ['linear']}, {'kernel': ['rbf'], 'gamma': [1, 10]}]\n<line_mask>\n                              {'kernel': 'rbf', 'gamma': 1},\n                              {'kernel': 'rbf', 'gamma': 10}]",
            "masked_line": "list(ParameterGrid(grid)) == [{'kernel': 'linear'},",
            "answer": "ParameterGrid",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_721"
        },
        {
            "dependency": "scikit-learn",
            "version": "==0.14",
            "time": "2013-08-07",
            "description": "The code generates a list of dictionaries with randomized parameters from a given parameter grid, rounding the values to 6 decimal places. It then checks if the rounded list matches a predefined list of dictionaries with specific values for 'a' and 'b'.",
            "code": "from sklearn.grid_search import ParameterSampler\nfrom scipy.stats.distributions import expon\nimport numpy as np\nnp.random.seed(0)\nparam_grid = {'a':[1, 2], 'b': expon()}\nparam_list = list(ParameterSampler(param_grid, n_iter=4))\nrounded_list = [dict((k, round(v, 6)) for (k, v) in d.items())\n                for d in param_list]\nrounded_list == [{'b': 0.89856, 'a': 1},\n                 {'b': 0.923223, 'a': 1},\n                 {'b': 1.878964, 'a': 2},\n                 {'b': 1.038159, 'a': 2}]",
            "masked_code": "from sklearn.grid_search import ParameterSampler\nfrom scipy.stats.distributions import expon\nimport numpy as np\nnp.random.seed(0)\nparam_grid = {'a':[1, 2], 'b': expon()}\n<line_mask>\nrounded_list = [dict((k, round(v, 6)) for (k, v) in d.items())\n                for d in param_list]\nrounded_list == [{'b': 0.89856, 'a': 1},\n                 {'b': 0.923223, 'a': 1},\n                 {'b': 1.878964, 'a': 2},\n                 {'b': 1.038159, 'a': 2}]",
            "masked_line": "param_list = list(ParameterSampler(param_grid, n_iter=4))",
            "answer": "ParameterSampler",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_722"
        },
        {
            "dependency": "scikit-learn",
            "version": "==0.14",
            "time": "2013-08-07",
            "description": "The code fits a multi-task Lasso regression model to the input data and target values, then prints the coefficients and intercept of the model.",
            "code": "from sklearn import linear_model\nclf = linear_model.MultiTaskLasso(alpha=0.1)\nclf.fit([[0,0], [1, 1], [2, 2]], [[0, 0], [1, 1], [2, 2]])\nprint(clf.coef_)\nprint(clf.intercept_)\n",
            "masked_code": "from sklearn import linear_model\n<line_mask>\nclf.fit([[0,0], [1, 1], [2, 2]], [[0, 0], [1, 1], [2, 2]])\nprint(clf.coef_)\nprint(clf.intercept_)\n",
            "masked_line": "clf = linear_model.MultiTaskLasso(alpha=0.1)",
            "answer": "MultiTaskLasso",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_723"
        },
        {
            "dependency": "scikit-learn",
            "version": "==0.14",
            "time": "2013-08-07",
            "description": "The code performs training a Bernoulli Restricted Boltzmann Machine model on a 3-dimensional binary input matrix X.",
            "code": "import numpy as np\nfrom sklearn.neural_network import BernoulliRBM\nX = np.array([[0, 0, 0], [0, 1, 1], [1, 0, 1], [1, 1, 1]])\nmodel = BernoulliRBM(n_components=2)\nmodel.fit(X)\n",
            "masked_code": "import numpy as np\nfrom sklearn.neural_network import BernoulliRBM\nX = np.array([[0, 0, 0], [0, 1, 1], [1, 0, 1], [1, 1, 1]])\n<line_mask>\nmodel.fit(X)\n",
            "masked_line": "model = BernoulliRBM(n_components=2)",
            "answer": "BernoulliRBM",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_724"
        },
        {
            "dependency": "scikit-learn",
            "version": "==0.14",
            "time": "2013-08-07",
            "description": "Calculate the receiver operating characteristic area under the curve (ROC AUC) score of the predicted probabilities (y_scores) compared to the true binary labels (y_true).",
            "code": "import numpy as np\nfrom sklearn.metrics import roc_auc_score\ny_true = np.array([0, 0, 1, 1])\ny_scores = np.array([0.1, 0.4, 0.35, 0.8])\nroc_auc_score(y_true, y_scores)\n0.75",
            "masked_code": "import numpy as np\nfrom sklearn.metrics import roc_auc_score\ny_true = np.array([0, 0, 1, 1])\ny_scores = np.array([0.1, 0.4, 0.35, 0.8])\n<line_mask>\n0.75",
            "masked_line": "roc_auc_score(y_true, y_scores)",
            "answer": "roc_auc_score",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_725"
        },
        {
            "dependency": "scikit-learn",
            "version": "==0.14",
            "time": "2013-08-07",
            "description": "This code calculates the Hamming loss between two sets of labels.",
            "code": "from sklearn.metrics import hamming_loss\ny_pred = [1, 2, 3, 4]\ny_true = [2, 2, 3, 4]\nhamming_loss(y_true, y_pred)\n\nhamming_loss(np.array([[0.0, 1.0], [1.0, 1.0]]), np.zeros((2, 2)))\n\nhamming_loss([(1, 2), (3, )], [(1, 2), tuple()])\n",
            "masked_code": "from sklearn.metrics import hamming_loss\ny_pred = [1, 2, 3, 4]\ny_true = [2, 2, 3, 4]\nhamming_loss(y_true, y_pred)\n\nhamming_loss(np.array([[0.0, 1.0], [1.0, 1.0]]), np.zeros((2, 2)))\n\n<line_mask>\n",
            "masked_line": "hamming_loss([(1, 2), (3, )], [(1, 2), tuple()])",
            "answer": "hamming_loss",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_726"
        },
        {
            "dependency": "scikit-learn",
            "version": "==0.14",
            "time": "2013-08-07",
            "description": "The code performs grid search cross-validation to find the best hyperparameters for a Linear Support Vector Machine (LinearSVC) model using an fbeta_score with beta=2 as the scoring metric.",
            "code": "from sklearn.metrics import fbeta_score, make_scorer\nftwo_scorer = make_scorer(fbeta_score, beta=2)\nfrom sklearn.grid_search import GridSearchCV\nfrom sklearn.svm import LinearSVC\ngrid = GridSearchCV(LinearSVC(), param_grid={'C': [1, 10]},\n                    scoring=ftwo_scorer)",
            "masked_code": "from sklearn.metrics import fbeta_score, make_scorer\n<line_mask>\nfrom sklearn.grid_search import GridSearchCV\nfrom sklearn.svm import LinearSVC\ngrid = GridSearchCV(LinearSVC(), param_grid={'C': [1, 10]},\n                    scoring=ftwo_scorer)",
            "masked_line": "ftwo_scorer = make_scorer(fbeta_score, beta=2)",
            "answer": "make_scorer",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_727"
        },
        {
            "dependency": "scikit-learn",
            "version": "==0.14",
            "time": "2013-08-07",
            "description": "The code checks if the input is a label indicator matrix.",
            "code": "import numpy as np\nfrom sklearn.utils.multiclass import is_label_indicator_matrix\nis_label_indicator_matrix([0, 1, 0, 1])\nis_label_indicator_matrix([[1], [0, 2], []])\nis_label_indicator_matrix(np.array([[1, 0], [0, 0]]))\nis_label_indicator_matrix(np.array([[1], [0], [0]]))\nis_label_indicator_matrix(np.array([[1, 0, 0]]))",
            "masked_code": "import numpy as np\nfrom sklearn.utils.multiclass import is_label_indicator_matrix\nis_label_indicator_matrix([0, 1, 0, 1])\n<line_mask>\nis_label_indicator_matrix(np.array([[1, 0], [0, 0]]))\nis_label_indicator_matrix(np.array([[1], [0], [0]]))\nis_label_indicator_matrix(np.array([[1, 0, 0]]))",
            "masked_line": "is_label_indicator_matrix([[1], [0, 2], []])",
            "answer": "is_label_indicator_matrix",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_728"
        },
        {
            "dependency": "scikit-learn",
            "version": "==0.14",
            "time": "2013-08-07",
            "description": "The code checks if the input is a sequence of sequences.",
            "code": "import numpy as np\nfrom sklearn.utils.multiclass import is_multilabel\nis_sequence_of_sequences([0, 1, 0, 1])\nis_sequence_of_sequences([[1], [0, 2], []])\nis_sequence_of_sequences(np.array([[1], [0, 2], []], dtype=object))\nis_sequence_of_sequences([(1,), (0, 2), ()])\nis_sequence_of_sequences(np.array([[1, 0], [0, 0]]))\nis_sequence_of_sequences(np.array([[1], [0], [0]]))\nis_sequence_of_sequences(np.array([[1, 0, 0]]))",
            "masked_code": "import numpy as np\nfrom sklearn.utils.multiclass import is_multilabel\nis_sequence_of_sequences([0, 1, 0, 1])\nis_sequence_of_sequences([[1], [0, 2], []])\nis_sequence_of_sequences(np.array([[1], [0, 2], []], dtype=object))\nis_sequence_of_sequences([(1,), (0, 2), ()])\n<line_mask>\nis_sequence_of_sequences(np.array([[1], [0], [0]]))\nis_sequence_of_sequences(np.array([[1, 0, 0]]))",
            "masked_line": "is_sequence_of_sequences(np.array([[1, 0], [0, 0]]))",
            "answer": "is_sequence_of_sequences",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_729"
        },
        {
            "dependency": "scikit-learn",
            "version": "==0.14",
            "time": "2013-08-07",
            "description": "The code checks if the input arrays represent a multilabel setting.",
            "code": "import numpy as np\nfrom sklearn.utils.multiclass import is_multilabel\nis_multilabel([0, 1, 0, 1])\nis_multilabel([[1], [0, 2], []])\nis_multilabel(np.array([[1, 0], [0, 0]]))\nis_multilabel(np.array([[1], [0], [0]]))\nis_multilabel(np.array([[1, 0, 0]]))\n",
            "masked_code": "import numpy as np\nfrom sklearn.utils.multiclass import is_multilabel\n<line_mask>\nis_multilabel([[1], [0, 2], []])\nis_multilabel(np.array([[1, 0], [0, 0]]))\nis_multilabel(np.array([[1], [0], [0]]))\nis_multilabel(np.array([[1, 0, 0]]))\n",
            "masked_line": "is_multilabel([0, 1, 0, 1])",
            "answer": "is_multilabel",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_730"
        },
        {
            "dependency": "scikit-learn",
            "version": "==0.13.1",
            "time": "2013-02-23",
            "description": "The code generates a sparse matrix using numpy and scipy, then uses cs_graph_components function to find the connected components in the graph represented by the matrix.",
            "code": "from scipy.sparse import cs_graph_components\nimport numpy as np\nD = np.eye(4)\nD[0,1] = D[1,0] = 1\ncs_graph_components(D)\nfrom scipy.sparse import dok_matrix\ncs_graph_components(dok_matrix(D))",
            "masked_code": "from scipy.sparse import cs_graph_components\nimport numpy as np\nD = np.eye(4)\nD[0,1] = D[1,0] = 1\ncs_graph_components(D)\nfrom scipy.sparse import dok_matrix\n<line_mask>",
            "masked_line": "cs_graph_components(dok_matrix(D))",
            "answer": "cs_graph_components",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_731"
        },
        {
            "dependency": "scikit-learn",
            "version": "==0.13.1",
            "time": "2013-02-23",
            "description": "The code calculates the connected components of a graph represented by the input matrix D.",
            "code": "from scipy.sparse import cs_graph_components\nimport numpy as np\nD = np.eye(4)\nD[0,1] = D[1,0] = 1\ncs_graph_components(D)\n\nfrom scipy.sparse import dok_matrix\ncs_graph_components(dok_matrix(D))",
            "masked_code": "<line_mask>\nimport numpy as np\nD = np.eye(4)\nD[0,1] = D[1,0] = 1\ncs_graph_components(D)\n\nfrom scipy.sparse import dok_matrix\ncs_graph_components(dok_matrix(D))",
            "masked_line": "from scipy.sparse import cs_graph_components",
            "answer": "cs_graph_components",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_732"
        },
        {
            "dependency": "scikit-learn",
            "version": "==0.15.0",
            "time": "2014-07-15",
            "description": "The code creates polynomial features of degree 2 for the input data X and then creates polynomial features with only interaction terms for the same input data X.",
            "code": "from sklearn.preprocessing import PolynomialFeatures\nimport numpy as np\n\nX = np.arange(6).reshape(3, 2)\npoly = PolynomialFeatures(2)\npoly.fit_transform(X)\n\npoly = PolynomialFeatures(interaction_only=True)\npoly.fit_transform(X)\n",
            "masked_code": "from sklearn.preprocessing import PolynomialFeatures\nimport numpy as np\n\nX = np.arange(6).reshape(3, 2)\n<line_mask>\npoly.fit_transform(X)\n\npoly = PolynomialFeatures(interaction_only=True)\npoly.fit_transform(X)\n",
            "masked_line": "poly = PolynomialFeatures(2)",
            "answer": "PolynomialFeatures",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_733"
        },
        {
            "dependency": "scikit-learn",
            "version": "==0.15.0",
            "time": "2014-07-15",
            "description": "The code is performing multi-label binarization on a list of sets. The MultiLabelBinarizer is being used to transform the input data into a binary matrix where each element represents the presence or absence of a particular label. The \"fit_transform\" method is fitting the MultiLabelBinarizer to the input data and transforming it into a binary matrix. The \"classes_\" attribute of the MultiLabelBinarizer returns the unique classes present in the input data.",
            "code": "mlb = MultiLabelBinarizer()\nmlb.fit_transform([(1, 2), (3,)])\narray([[1, 1, 0],\n       [0, 0, 1]])\nmlb.classes_\narray([1, 2, 3])\n\nmlb.fit_transform([set(['sci-fi', 'thriller']), set(['comedy'])])\narray([[0, 1, 1],\n       [1, 0, 0]])\nlist(mlb.classes_)\n['comedy', 'sci-fi', 'thriller']",
            "masked_code": "<line_mask>\nmlb.fit_transform([(1, 2), (3,)])\narray([[1, 1, 0],\n       [0, 0, 1]])\nmlb.classes_\narray([1, 2, 3])\n\nmlb.fit_transform([set(['sci-fi', 'thriller']), set(['comedy'])])\narray([[0, 1, 1],\n       [1, 0, 0]])\nlist(mlb.classes_)\n['comedy', 'sci-fi', 'thriller']",
            "masked_line": "mlb = MultiLabelBinarizer()",
            "answer": "MultiLabelBinarizer",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_734"
        },
        {
            "dependency": "scikit-learn",
            "version": "==0.14.1",
            "time": "2013-08-08",
            "description": "The code calculates the zero-one loss between the predicted and true values, both with and without normalization.",
            "code": "from sklearn.metrics import zero_one\ny_pred = [1, 2, 3, 4]\ny_true = [2, 2, 3, 4]\nzero_one(y_true, y_pred)\nzero_one(y_true, y_pred, normalize=True)\n",
            "masked_code": "from sklearn.metrics import zero_one\ny_pred = [1, 2, 3, 4]\ny_true = [2, 2, 3, 4]\n<line_mask>\nzero_one(y_true, y_pred, normalize=True)\n",
            "masked_line": "zero_one(y_true, y_pred)",
            "answer": "zero_one",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_735"
        },
        {
            "dependency": "scikit-learn",
            "version": "==0.16.0",
            "time": "2015-03-26",
            "description": "This code fits a Kernel Ridge regression model to the randomly generated data X and y with an alpha regularization parameter of 1.0.",
            "code": "from sklearn.kernel_ridge import KernelRidge\nimport numpy as np\nn_samples, n_features = 10, 5\nrng = np.random.RandomState(0)\ny = rng.randn(n_samples)\nX = rng.randn(n_samples, n_features)\nclf = KernelRidge(alpha=1.0)\nclf.fit(X, y)\n",
            "masked_code": "from sklearn.kernel_ridge import KernelRidge\nimport numpy as np\nn_samples, n_features = 10, 5\nrng = np.random.RandomState(0)\ny = rng.randn(n_samples)\nX = rng.randn(n_samples, n_features)\n<line_mask>\nclf.fit(X, y)\n",
            "masked_line": "clf = KernelRidge(alpha=1.0)",
            "answer": "KernelRidge",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_736"
        },
        {
            "dependency": "scikit-learn",
            "version": "==0.16.0",
            "time": "2015-03-26",
            "description": "The code performs incremental PCA (Principal Component Analysis) on the given dataset X, with a batch size of 3 and 2 components. It fits the incremental PCA model to the data and transforms the data into the new feature space.",
            "code": "import numpy as np\nfrom sklearn.decomposition import IncrementalPCA\nX = np.array([[-1, -1], [-2, -1], [-3, -2], [1, 1], [2, 1], [3, 2]])\nipca = IncrementalPCA(n_components=2, batch_size=3)\nipca.fit(X)\nipca.transform(X) # doctest: +SKIP",
            "masked_code": "import numpy as np\nfrom sklearn.decomposition import IncrementalPCA\nX = np.array([[-1, -1], [-2, -1], [-3, -2], [1, 1], [2, 1], [3, 2]])\nipca = IncrementalPCA(n_components=2, batch_size=3)\nipca.fit(X)\n<line_mask>",
            "masked_line": "ipca.transform(X) # doctest: +SKIP",
            "answer": "transform",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_737"
        },
        {
            "dependency": "scikit-learn",
            "version": "==0.16.0",
            "time": "2015-03-26",
            "description": "This code segment uses the LSHForest algorithm from the sklearn library to fit a model on the training data X_train, and then calculates the distances and indices of the nearest neighbors for the test data X_test.",
            "code": "from sklearn.neighbors import LSHForest\n\nX_train = [[5, 5, 2], [21, 5, 5], [1, 1, 1], [8, 9, 1], [6, 10, 2]]\nX_test = [[9, 1, 6], [3, 1, 10], [7, 10, 3]]\nlshf = LSHForest()\nlshf.fit(X_train)\ndistances, indices = lshf.kneighbors(X_test, n_neighbors=2)\ndistances\nindices\n",
            "masked_code": "<line_mask>\n\nX_train = [[5, 5, 2], [21, 5, 5], [1, 1, 1], [8, 9, 1], [6, 10, 2]]\nX_test = [[9, 1, 6], [3, 1, 10], [7, 10, 3]]\nlshf = LSHForest()\nlshf.fit(X_train)\ndistances, indices = lshf.kneighbors(X_test, n_neighbors=2)\ndistances\nindices\n",
            "masked_line": "from sklearn.neighbors import LSHForest",
            "answer": "LSHForest",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_738"
        },
        {
            "dependency": "scikit-learn",
            "version": "==0.16.0",
            "time": "2015-03-26",
            "description": "This code calculates the label ranking average precision score between the true labels (y_true) and the predicted labels (y_score).",
            "code": "import numpy as np\nfrom sklearn.metrics import label_ranking_average_precision_score\ny_true = np.array([[1, 0, 0], [0, 0, 1]])\ny_score = np.array([[0.75, 0.5, 1], [1, 0.2, 0.1]])\nlabel_ranking_average_precision_score(y_true, y_score)         # doctest: +ELLIPSIS",
            "masked_code": "import numpy as np\nfrom sklearn.metrics import label_ranking_average_precision_score\ny_true = np.array([[1, 0, 0], [0, 0, 1]])\ny_score = np.array([[0.75, 0.5, 1], [1, 0.2, 0.1]])\n<line_mask>",
            "masked_line": "label_ranking_average_precision_score(y_true, y_score)         # doctest: +ELLIPSIS",
            "answer": "label_ranking_average_precision_score",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_739"
        },
        {
            "dependency": "scikit-learn",
            "version": "==0.16.0",
            "time": "2015-03-26",
            "description": "This code defines a class called MetaEst with a constructor that initializes a sub_est attribute. It also has a method predict that calls the predict method of the sub_est attribute.",
            "code": "class MetaEst(object):\n    def __init__(self, sub_est):\n        self.sub_est = sub_est\n\n    @if_delegate_has_method(delegate='sub_est')\n    def predict(self, X):\n        return self.sub_est.predict(X)\n\nclass HasPredict(object):\n    def predict(self, X):\n        return X.sum(axis=1)\n\nclass HasNoPredict(object):\n    pass\n",
            "masked_code": "class MetaEst(object):\n    def __init__(self, sub_est):\n        self.sub_est = sub_est\n\n    <line_mask>\n    def predict(self, X):\n        return self.sub_est.predict(X)\n\nclass HasPredict(object):\n    def predict(self, X):\n        return X.sum(axis=1)\n\nclass HasNoPredict(object):\n    pass\n",
            "masked_line": "@if_delegate_has_method(delegate='sub_est')",
            "answer": "if_delegate_has_method",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_740"
        },
        {
            "dependency": "scikit-learn",
            "version": "==0.16.0",
            "time": "2015-03-26",
            "description": "The code determines the number of CPU cores available for parallel processing tasks and adjusts the number of jobs accordingly. It ensures that at least one job is always available for processing.",
            "code": "from sklearn.utils import _get_n_jobs\n_get_n_jobs(4)\njobs = _get_n_jobs(-2)\nassert jobs == max(cpu_count() - 1, 1)\n_get_n_jobs(0)\n",
            "masked_code": "from sklearn.utils import _get_n_jobs\n_get_n_jobs(4)\njobs = _get_n_jobs(-2)\nassert jobs == max(cpu_count() - 1, 1)\n<line_mask>\n",
            "masked_line": "_get_n_jobs(0)",
            "answer": "_get_n_jobs",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_741"
        },
        {
            "dependency": "scikit-learn",
            "version": "==0.15.2",
            "time": "2014-09-04",
            "description": "This code calculates the Area Under the Curve (AUC) score for a binary classification model using the true labels and predicted scores.",
            "code": "import numpy as np\nfrom sklearn.metrics import auc_score\ny_true = np.array([0, 0, 1, 1])\ny_scores = np.array([0.1, 0.4, 0.35, 0.8])\nauc_score(y_true, y_scores)\n0.75",
            "masked_code": "import numpy as np\n<line_mask>\ny_true = np.array([0, 0, 1, 1])\ny_scores = np.array([0.1, 0.4, 0.35, 0.8])\nauc_score(y_true, y_scores)\n0.75",
            "masked_line": "from sklearn.metrics import auc_score",
            "answer": "auc_score",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_742"
        },
        {
            "dependency": "scikit-learn",
            "version": "==0.16.1",
            "time": "2015-04-14",
            "description": "The code checks whether the input is a label indicator matrix or not.",
            "code": "import numpy as np\nfrom sklearn.utils.multiclass import is_label_indicator_matrix\nis_label_indicator_matrix([0, 1, 0, 1])\nis_label_indicator_matrix([[1], [0, 2], []])\nis_label_indicator_matrix(np.array([[1, 0], [0, 0]]))\nis_label_indicator_matrix(np.array([[1], [0], [0]]))\nis_label_indicator_matrix(np.array([[1, 0, 0]]))",
            "masked_code": "import numpy as np\nfrom sklearn.utils.multiclass import is_label_indicator_matrix\n<line_mask>\nis_label_indicator_matrix([[1], [0, 2], []])\nis_label_indicator_matrix(np.array([[1, 0], [0, 0]]))\nis_label_indicator_matrix(np.array([[1], [0], [0]]))\nis_label_indicator_matrix(np.array([[1, 0, 0]]))",
            "masked_line": "is_label_indicator_matrix([0, 1, 0, 1])",
            "answer": "is_label_indicator_matrix",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_743"
        },
        {
            "dependency": "scikit-learn",
            "version": "==0.19.0",
            "time": "2017-08-11",
            "description": "This code checks if a given input contains only finite numbers or not by using the assert_all_finite function from the sklearn package.",
            "code": "import sklearn\nfrom sklearn.utils.validation import assert_all_finite\nwith sklearn.config_context(assume_finite=True):\n    assert_all_finite([float('nan')])\nwith sklearn.config_context(assume_finite=True):\n    with sklearn.config_context(assume_finite=False):\n        assert_all_finite([float('nan')])\n",
            "masked_code": "import sklearn\nfrom sklearn.utils.validation import assert_all_finite\nwith sklearn.config_context(assume_finite=True):\n    assert_all_finite([float('nan')])\nwith sklearn.config_context(assume_finite=True):\n    <line_mask>\n        assert_all_finite([float('nan')])\n",
            "masked_line": "with sklearn.config_context(assume_finite=False):",
            "answer": "config_context",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_744"
        },
        {
            "dependency": "scikit-learn",
            "version": "==0.19.0",
            "time": "2017-08-11",
            "description": "The code calculates the Normalized Discounted Cumulative Gain (NDCG) score between the true ranking of items (y_true) and the predicted ranking of items (y_score) at a given cut-off point (k) value.",
            "code": "y_true = [1, 0, 2]\ny_score = [[0.15, 0.55, 0.2], [0.7, 0.2, 0.1], [0.06, 0.04, 0.9]]\nndcg_score(y_true, y_score, k=2)\n1.0\ny_score = [[0.9, 0.5, 0.8], [0.7, 0.2, 0.1], [0.06, 0.04, 0.9]]\nndcg_score(y_true, y_score, k=2)\n0.66666666666666663",
            "masked_code": "y_true = [1, 0, 2]\ny_score = [[0.15, 0.55, 0.2], [0.7, 0.2, 0.1], [0.06, 0.04, 0.9]]\n<line_mask>\n1.0\ny_score = [[0.9, 0.5, 0.8], [0.7, 0.2, 0.1], [0.06, 0.04, 0.9]]\nndcg_score(y_true, y_score, k=2)\n0.66666666666666663",
            "masked_line": "ndcg_score(y_true, y_score, k=2)",
            "answer": "ndcg_score",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_745"
        },
        {
            "dependency": "scikit-learn",
            "version": "==0.18.2",
            "time": "2017-06-19",
            "description": "The code calculates the pseudo-inverse of a matrix \"a\" and then checks if the product of \"a\" with the product of its pseudo-inverse and itself is approximately equal to \"a\". It also checks if the product of the pseudo-inverse with the product of \"a\" with itself and the pseudo-inverse is approximately equal to the pseudo-inverse.",
            "code": "import numpy as np\na = np.random.randn(9, 6)\na = np.dot(a, a.T)\nB = pinvh(a)\nnp.allclose(a, np.dot(a, np.dot(B, a)))\nnp.allclose(B, np.dot(B, np.dot(a, B)))\n",
            "masked_code": "import numpy as np\na = np.random.randn(9, 6)\na = np.dot(a, a.T)\n<line_mask>\nnp.allclose(a, np.dot(a, np.dot(B, a)))\nnp.allclose(B, np.dot(B, np.dot(a, B)))\n",
            "masked_line": "B = pinvh(a)",
            "answer": "pinvh",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_746"
        },
        {
            "dependency": "scikit-learn",
            "version": "==0.19.0",
            "time": "2017-08-11",
            "description": "The code calculates the Normalized Discounted Cumulative Gain (NDCG) score for a given set of true labels and predicted scores at a given cut-off point k. It first computes the NDCG score for the input y_true and y_score lists when k=2, then updates the y_score list and computes the NDCG score again with the updated scores.",
            "code": "y_true = [1, 0, 2]\ny_score = [[0.15, 0.55, 0.2], [0.7, 0.2, 0.1], [0.06, 0.04, 0.9]]\nndcg_score(y_true, y_score, k=2)\n1.0\ny_score = [[0.9, 0.5, 0.8], [0.7, 0.2, 0.1], [0.06, 0.04, 0.9]]\nndcg_score(y_true, y_score, k=2)\n0.66666666666666663",
            "masked_code": "y_true = [1, 0, 2]\ny_score = [[0.15, 0.55, 0.2], [0.7, 0.2, 0.1], [0.06, 0.04, 0.9]]\n<line_mask>\n1.0\ny_score = [[0.9, 0.5, 0.8], [0.7, 0.2, 0.1], [0.06, 0.04, 0.9]]\nndcg_score(y_true, y_score, k=2)\n0.66666666666666663",
            "masked_line": "ndcg_score(y_true, y_score, k=2)",
            "answer": "ndcg_score",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_747"
        },
        {
            "dependency": "scikit-learn",
            "version": "==0.20.0",
            "time": "2018-09-25",
            "description": "This code extracts and parses a date string in the format of \"year/month/day\", then retrieves specific elements such as the year, month, and day from the parsed date string.",
            "code": "integer = Word(nums)\ndate_str = integer(\"year\") + '/' + integer(\"month\") + '/' + integer(\"day\")           \n\nresult = date_str.parseString(\"1999/12/31\")\nprint(result.get(\"year\")) # -> '1999'\nprint(result.get(\"hour\", \"not specified\")) # -> 'not specified'\nprint(result.get(\"hour\")) # -> None",
            "masked_code": "integer = Word(nums)\ndate_str = integer(\"year\") + '/' + integer(\"month\") + '/' + integer(\"day\")           \n\nresult = date_str.parseString(\"1999/12/31\")\n<line_mask>\nprint(result.get(\"hour\", \"not specified\")) # -> 'not specified'\nprint(result.get(\"hour\")) # -> None",
            "masked_line": "print(result.get(\"year\")) # -> '1999'",
            "answer": "get",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_748"
        },
        {
            "dependency": "scikit-learn",
            "version": "==0.20.0",
            "time": "2018-09-25",
            "description": "The function make_palindrome takes a list of tokens, reverses each token and appends it to the original list, then concatenates all tokens into a single string.",
            "code": "def make_palindrome(tokens):\n    tokens.extend(reversed([t[::-1] for t in tokens]))\n    return ''.join(tokens)\n\npatt = OneOrMore(Word(alphas))\nprint(patt.addParseAction(make_palindrome).parseString(\"lskdj sdlkjf lksd\")) # -> 'lskdjsdlkjflksddsklfjkldsjdksl'",
            "masked_code": "def make_palindrome(tokens):\n    <line_mask>\n    return ''.join(tokens)\n\npatt = OneOrMore(Word(alphas))\nprint(patt.addParseAction(make_palindrome).parseString(\"lskdj sdlkjf lksd\")) # -> 'lskdjsdlkjflksddsklfjkldsjdksl'",
            "masked_line": "tokens.extend(reversed([t[::-1] for t in tokens]))",
            "answer": "extend",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_749"
        },
        {
            "dependency": "scikit-learn",
            "version": "==0.20.0",
            "time": "2018-09-25",
            "description": "The code separates the input string into multiple words and stores them in a list.",
            "code": "patt = OneOrMore(Word(alphas))\nresult = patt.parseString(\"sldkj lsdkj sldkj\")\nprint(type(result), result)\nresult_list = result.asList()\nprint(type(result_list), result_list)",
            "masked_code": "patt = OneOrMore(Word(alphas))\nresult = patt.parseString(\"sldkj lsdkj sldkj\")\nprint(type(result), result)\n<line_mask>\nprint(type(result_list), result_list)",
            "masked_line": "result_list = result.asList()",
            "answer": "asList",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_750"
        },
        {
            "dependency": "scikit-learn",
            "version": "==0.20.0",
            "time": "2018-09-25",
            "description": "The code parses user information from a string and categorizes it into age, social security number, or house number.",
            "code": "integer = Word(nums)\nssn_expr = Regex(r\"\\d\\d\\d-\\d\\d-\\d\\d\\d\\d\")\nhouse_number_expr = Suppress('#') + Word(nums, alphanums)\nuser_data = (Group(house_number_expr)(\"house_number\") \n            | Group(ssn_expr)(\"ssn\")\n            | Group(integer)(\"age\"))\nuser_info = OneOrMore(user_data)\n\nresult = user_info.parseString(\"22 111-22-3333 #221B\")\nfor item in result:\n    print(item.getName(), ':', item[0])",
            "masked_code": "integer = Word(nums)\nssn_expr = Regex(r\"\\d\\d\\d-\\d\\d-\\d\\d\\d\\d\")\nhouse_number_expr = Suppress('#') + Word(nums, alphanums)\nuser_data = (Group(house_number_expr)(\"house_number\") \n            | Group(ssn_expr)(\"ssn\")\n            | Group(integer)(\"age\"))\nuser_info = OneOrMore(user_data)\n\nresult = user_info.parseString(\"22 111-22-3333 #221B\")\nfor item in result:\n    <line_mask>",
            "masked_line": "print(item.getName(), ':', item[0])",
            "answer": "getName",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_751"
        },
        {
            "dependency": "scikit-learn",
            "version": "==0.20.0",
            "time": "2018-09-25",
            "description": "The code parses a string representing a nested function call with arguments and prints the result in a pretty format.",
            "code": "ident = Word(alphas, alphanums)\nnum = Word(nums)\nfunc = Forward()\nterm = ident | num | Group('(' + func + ')')\nfunc <<= ident + Group(Optional(delimitedList(term)))\nresult = func.parseString(\"fna a,b,(fnb c,d,200),100\")\nresult.pprint(width=40)",
            "masked_code": "ident = Word(alphas, alphanums)\nnum = Word(nums)\nfunc = Forward()\nterm = ident | num | Group('(' + func + ')')\nfunc <<= ident + Group(Optional(delimitedList(term)))\nresult = func.parseString(\"fna a,b,(fnb c,d,200),100\")\n<line_mask>",
            "masked_line": "result.pprint(width=40)",
            "answer": "pprint",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_752"
        },
        {
            "dependency": "scikit-learn",
            "version": "==0.20.0",
            "time": "2018-09-25",
            "description": "This code is parsing a date string in the format \"yyyy/mm/dd\" and extracting the year, month, and day components from the input string.",
            "code": "integer = Word(nums)\ndate_str = integer(\"year\") + '/' + integer(\"month\") + '/' + integer(\"day\")           \ndate_str.parseString(\"1999/12/31\")\n\nParserElement.inlineLiteralsUsing(Suppress)\ndate_str = integer(\"year\") + '/' + integer(\"month\") + '/' + integer(\"day\")           \ndate_str.parseString(\"1999/12/31\")",
            "masked_code": "integer = Word(nums)\ndate_str = integer(\"year\") + '/' + integer(\"month\") + '/' + integer(\"day\")           \ndate_str.parseString(\"1999/12/31\")\n\n<line_mask>\ndate_str = integer(\"year\") + '/' + integer(\"month\") + '/' + integer(\"day\")           \ndate_str.parseString(\"1999/12/31\")",
            "masked_line": "ParserElement.inlineLiteralsUsing(Suppress)",
            "answer": "inlineLiteralsUsing",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_753"
        },
        {
            "dependency": "scikit-learn",
            "version": "==0.20.0",
            "time": "2018-09-25",
            "description": "This code snippet parses and converts numeric values followed by a unit identifier (K for kilobytes, M for megabytes) into their corresponding byte values. It then prints the parsed and converted values for the input string \"5K 100 640K 256M\".",
            "code": "integer = Word(nums).setParseAction(lambda toks: int(toks[0]))\nintegerK = integer.copy().addParseAction(lambda toks: toks[0]*1024) + Suppress(\"K\")\nintegerM = integer.copy().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress(\"M\")\nprint(OneOrMore(integerK | integerM | integer).parseString(\"5K 100 640K 256M\"))\nintegerM = integer().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress(\"M\")",
            "masked_code": "integer = Word(nums).setParseAction(lambda toks: int(toks[0]))\nintegerK = integer.copy().addParseAction(lambda toks: toks[0]*1024) + Suppress(\"K\")\n<line_mask>\nprint(OneOrMore(integerK | integerM | integer).parseString(\"5K 100 640K 256M\"))\nintegerM = integer().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress(\"M\")",
            "masked_line": "integerM = integer.copy().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress(\"M\")",
            "answer": "copy",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_754"
        },
        {
            "dependency": "scikit-learn",
            "version": "==0.20.0",
            "time": "2018-09-25",
            "description": "The code assigns the integer values for year, month, and day to the variables \"year\", \"month\", and \"day\" respectively.",
            "code": "integer.setResultsName(\"year\")\ninteger.setResultsName(\"month\")\ninteger.setResultsName(\"day\")\ninteger(\"year\")\ninteger(\"month\")\ninteger(\"day\")",
            "masked_code": "integer.setResultsName(\"year\")\n<line_mask>\ninteger.setResultsName(\"day\")\ninteger(\"year\")\ninteger(\"month\")\ninteger(\"day\")",
            "masked_line": "integer.setResultsName(\"month\")",
            "answer": "setResultsName",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_755"
        },
        {
            "dependency": "scikit-learn",
            "version": "==0.20.0",
            "time": "2018-09-25",
            "description": "The code parses a date string in the format \"YYYY/MM/DD\" into a list of integers corresponding to the year, month, and day respectively.",
            "code": "integer = Word(nums)\ndate_str = integer + '/' + integer + '/' + integer\n\ndate_str.parseString(\"1999/12/31\")  # -> ['1999', '/', '12', '/', '31']\n\n# use parse action to convert to ints at parse time\ninteger = Word(nums).setParseAction(lambda toks: int(toks[0]))\ndate_str = integer + '/' + integer + '/' + integer\n\n# note that integer fields are now ints, not strings\ndate_str.parseString(\"1999/12/31\")  # -> [1999, '/', 12, '/', 31]",
            "masked_code": "integer = Word(nums)\ndate_str = integer + '/' + integer + '/' + integer\n\ndate_str.parseString(\"1999/12/31\")  # -> ['1999', '/', '12', '/', '31']\n\n# use parse action to convert to ints at parse time\n<line_mask>\ndate_str = integer + '/' + integer + '/' + integer\n\n# note that integer fields are now ints, not strings\ndate_str.parseString(\"1999/12/31\")  # -> [1999, '/', 12, '/', 31]",
            "masked_line": "integer = Word(nums).setParseAction(lambda toks: int(toks[0]))",
            "answer": "setParseAction",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_756"
        },
        {
            "dependency": "scikit-learn",
            "version": "==0.20.0",
            "time": "2018-09-25",
            "description": "The code defines a grammar for parsing either a word consisting of alphabetic characters or a number consisting of digits. It also sets debugging mode for the word parser. Finally, it parses a string containing alternating words and numbers.",
            "code": "wd = Word(alphas).setName(\"alphaword\")\ninteger = Word(nums).setName(\"numword\")\nterm = wd | integer\n\n# turn on debugging for wd\nwd.setDebug()\n\nOneOrMore(term).parseString(\"abc 123 xyz 890\")",
            "masked_code": "wd = Word(alphas).setName(\"alphaword\")\ninteger = Word(nums).setName(\"numword\")\nterm = wd | integer\n\n# turn on debugging for wd\n<line_mask>\n\nOneOrMore(term).parseString(\"abc 123 xyz 890\")",
            "masked_line": "wd.setDebug()",
            "answer": "setDebug",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_757"
        },
        {
            "dependency": "scikit-learn",
            "version": "==0.20.0",
            "time": "2018-09-25",
            "description": "The code defines a CloseMatch object that compares a given pattern with a parsed string. It allows for a certain number of mismatches between the pattern and the string. The function parseString compares the parsed string with the pattern, and returns the parsed string along with information about any mismatches found, such as their positions.",
            "code": "patt = CloseMatch(\"ATCATCGAATGGA\")\npatt.parseString(\"ATCATCGAAXGGA\") # -> (['ATCATCGAAXGGA'], {'mismatches': [[9]], 'original': ['ATCATCGAATGGA']})\npatt.parseString(\"ATCAXCGAAXGGA\") # -> Exception: Expected 'ATCATCGAATGGA' (with up to 1 mismatches) (at char 0), (line:1, col:1)\n\n# exact match\npatt.parseString(\"ATCATCGAATGGA\") # -> (['ATCATCGAATGGA'], {'mismatches': [[]], 'original': ['ATCATCGAATGGA']})\n\n# close match allowing up to 2 mismatches\npatt = CloseMatch(\"ATCATCGAATGGA\", maxMismatches=2)\npatt.parseString(\"ATCAXCGAAXGGA\") # -> (['ATCAXCGAAXGGA'], {'mismatches': [[4, 9]], 'original': ['ATCATCGAATGGA']})",
            "masked_code": "patt = CloseMatch(\"ATCATCGAATGGA\")\npatt.parseString(\"ATCATCGAAXGGA\") # -> (['ATCATCGAAXGGA'], {'mismatches': [[9]], 'original': ['ATCATCGAATGGA']})\npatt.parseString(\"ATCAXCGAAXGGA\") # -> Exception: Expected 'ATCATCGAATGGA' (with up to 1 mismatches) (at char 0), (line:1, col:1)\n\n# exact match\npatt.parseString(\"ATCATCGAATGGA\") # -> (['ATCATCGAATGGA'], {'mismatches': [[]], 'original': ['ATCATCGAATGGA']})\n\n# close match allowing up to 2 mismatches\n<line_mask>\npatt.parseString(\"ATCAXCGAAXGGA\") # -> (['ATCAXCGAAXGGA'], {'mismatches': [[4, 9]], 'original': ['ATCATCGAATGGA']})",
            "masked_line": "patt = CloseMatch(\"ATCATCGAATGGA\", maxMismatches=2)",
            "answer": "CloseMatch",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_758"
        },
        {
            "dependency": "scikit-learn",
            "version": "==0.20.0",
            "time": "2018-09-25",
            "description": "The code parses a string representing a function call and returns the function name along with its arguments as a list. If the arguments are grouped together, they are returned as a sublist within the main list.",
            "code": "ident = Word(alphas)\nnum = Word(nums)\nterm = ident | num\nfunc = ident + Optional(delimitedList(term))\nprint(func.parseString(\"fn a,b,100\"))  # -> ['fn', 'a', 'b', '100']\n\nfunc = ident + Group(Optional(delimitedList(term)))\nprint(func.parseString(\"fn a,b,100\"))  # -> ['fn', ['a', 'b', '100']]",
            "masked_code": "ident = Word(alphas)\nnum = Word(nums)\nterm = ident | num\nfunc = ident + Optional(delimitedList(term))\nprint(func.parseString(\"fn a,b,100\"))  # -> ['fn', 'a', 'b', '100']\n\n<line_mask>\nprint(func.parseString(\"fn a,b,100\"))  # -> ['fn', ['a', 'b', '100']]",
            "masked_line": "func = ident + Group(Optional(delimitedList(term)))",
            "answer": "Group",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_759"
        },
        {
            "dependency": "scikit-learn",
            "version": "==0.20.0",
            "time": "2018-09-25",
            "description": "The code parses a text string containing attribute-value pairs separated by colons, and stores the attributes and values in a dictionary. It then prints the parsed results and accesses specific attribute values from the dictionary.",
            "code": "data_word = Word(alphas)\nlabel = data_word + FollowedBy(':')\nattr_expr = Group(label + Suppress(':') + OneOrMore(data_word).setParseAction(' '.join))\n\ntext = \"shape: SQUARE posn: upper left color: light blue texture: burlap\"\nattr_expr = (label + Suppress(':') + OneOrMore(data_word, stopOn=label).setParseAction(' '.join))\n\nprint(OneOrMore(attr_expr).parseString(text).dump())\n\nresult = Dict(OneOrMore(Group(attr_expr))).parseString(text)\nprint(result.dump())\n\nprint(result['shape'])        \nprint(result.asDict())",
            "masked_code": "data_word = Word(alphas)\nlabel = data_word + FollowedBy(':')\nattr_expr = Group(label + Suppress(':') + OneOrMore(data_word).setParseAction(' '.join))\n\ntext = \"shape: SQUARE posn: upper left color: light blue texture: burlap\"\nattr_expr = (label + Suppress(':') + OneOrMore(data_word, stopOn=label).setParseAction(' '.join))\n\nprint(OneOrMore(attr_expr).parseString(text).dump())\n\n<line_mask>\nprint(result.dump())\n\nprint(result['shape'])        \nprint(result.asDict())",
            "masked_line": "result = Dict(OneOrMore(Group(attr_expr))).parseString(text)",
            "answer": "Dict",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_760"
        },
        {
            "dependency": "scikit-learn",
            "version": "==0.20.0",
            "time": "2018-09-25",
            "description": "The code generates a binary array indicating missing values in the input dataset X2 by comparing it with X1.",
            "code": "indicator = MissingIndicator()\nindicator.fit(X1)\nX2_tr = indicator.transform(X2)\nX2_tr\narray([[False,  True],\n       [ True, False],\n       [False, False]])",
            "masked_code": "<line_mask>\nindicator.fit(X1)\nX2_tr = indicator.transform(X2)\nX2_tr\narray([[False,  True],\n       [ True, False],\n       [False, False]])",
            "masked_line": "indicator = MissingIndicator()",
            "answer": "MissingIndicator",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_761"
        },
        {
            "dependency": "scikit-learn",
            "version": "==0.20.0",
            "time": "2018-09-25",
            "description": "This code performs ordinal encoding on a dataset.",
            "code": "from sklearn.preprocessing import OrdinalEncoder\nenc = OrdinalEncoder()\nX = [['Male', 1], ['Female', 3], ['Female', 2]]\nenc.fit(X)\nenc.categories_\nenc.transform([['Female', 3], ['Male', 1]])\nenc.inverse_transform([[1, 0], [0, 1]])",
            "masked_code": "<line_mask>\nenc = OrdinalEncoder()\nX = [['Male', 1], ['Female', 3], ['Female', 2]]\nenc.fit(X)\nenc.categories_\nenc.transform([['Female', 3], ['Male', 1]])\nenc.inverse_transform([[1, 0], [0, 1]])",
            "masked_line": "from sklearn.preprocessing import OrdinalEncoder",
            "answer": "OrdinalEncoder",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_762"
        },
        {
            "dependency": "scikit-learn",
            "version": "==0.20.0",
            "time": "2018-09-25",
            "description": "The code defines variables for comparison operators, variables, numbers, and terms, and creates a comparison expression pattern. The code searches for this pattern in the given string \"B = 12  AA=23 B<=AA AA>12\".",
            "code": "comp_oper = oneOf(\"< = > <= >= !=\")\nvar = Word(alphas)\nnumber = Word(nums)\nterm = var | number\ncomparison_expr = term + comp_oper + term\nprint(comparison_expr.searchString(\"B = 12  AA=23 B<=AA AA>12\"))",
            "masked_code": "<line_mask>\nvar = Word(alphas)\nnumber = Word(nums)\nterm = var | number\ncomparison_expr = term + comp_oper + term\nprint(comparison_expr.searchString(\"B = 12  AA=23 B<=AA AA>12\"))",
            "masked_line": "comp_oper = oneOf(\"< = > <= >= !=\")",
            "answer": "oneOf",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_763"
        },
        {
            "dependency": "scikit-learn",
            "version": "==0.20.0",
            "time": "2018-09-25",
            "description": "The code parses text data into a dictionary format with attribute labels and values. It then prints the parsed result, accesses specific attributes ('shape'), and prints the result as a dictionary.",
            "code": "attr_expr = (label + Suppress(':') + OneOrMore(data_word, stopOn=label).setParseAction(' '.join))\nprint(OneOrMore(attr_expr).parseString(text).dump())\n\nattr_label = label\nattr_value = Suppress(':') + OneOrMore(data_word, stopOn=label).setParseAction(' '.join)\n\nresult = dictOf(attr_label, attr_value).parseString(text)\nprint(result.dump())\nprint(result['shape'])\nprint(result.shape)\nprint(result.asDict())",
            "masked_code": "attr_expr = (label + Suppress(':') + OneOrMore(data_word, stopOn=label).setParseAction(' '.join))\nprint(OneOrMore(attr_expr).parseString(text).dump())\n\nattr_label = label\nattr_value = Suppress(':') + OneOrMore(data_word, stopOn=label).setParseAction(' '.join)\n\n<line_mask>\nprint(result.dump())\nprint(result['shape'])\nprint(result.shape)\nprint(result.asDict())",
            "masked_line": "result = dictOf(attr_label, attr_value).parseString(text)",
            "answer": "dictOf",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_764"
        },
        {
            "dependency": "scikit-learn",
            "version": "==0.20.0",
            "time": "2018-09-25",
            "description": "This code extracts text within specified HTML tags \"<b>\" and \"<i>\" from a given string \"src\".",
            "code": "src = \"this is test <b> bold <i>text</i> </b> normal text \"\nfor tag in (\"b\",\"i\"):\n    opener,closer = makeHTMLTags(tag)\n    patt = originalTextFor(opener + SkipTo(closer) + closer)\n    print(patt.searchString(src)[0])\n",
            "masked_code": "src = \"this is test <b> bold <i>text</i> </b> normal text \"\nfor tag in (\"b\",\"i\"):\n    opener,closer = makeHTMLTags(tag)\n    <line_mask>\n    print(patt.searchString(src)[0])\n",
            "masked_line": "patt = originalTextFor(opener + SkipTo(closer) + closer)",
            "answer": "originalTextFor",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_765"
        },
        {
            "dependency": "scikit-learn",
            "version": "==0.20.0",
            "time": "2018-09-25",
            "description": "The code parses HTML content to extract and print the body of div tags with specific attributes and values. It first targets div tags with a type attribute set to \"grid\", then moves on to match any div tags with a type attribute, regardless of the value.",
            "code": "div,div_end = makeHTMLTags(\"div\")\n\n# only match div tag having a type attribute with value \"grid\"\ndiv_grid = div().setParseAction(withAttribute(type=\"grid\"))\ngrid_expr = div_grid + SkipTo(div | div_end)(\"body\")\nfor grid_header in grid_expr.searchString(html):\n    print(grid_header.body)\n\n# construct a match with any div tag having a type attribute, regardless of the value\ndiv_any_type = div().setParseAction(withAttribute(type=withAttribute.ANY_VALUE))\ndiv_expr = div_any_type + SkipTo(div | div_end)(\"body\")\nfor div_header in div_expr.searchString(html):\n    print(div_header.body)",
            "masked_code": "div,div_end = makeHTMLTags(\"div\")\n\n# only match div tag having a type attribute with value \"grid\"\ndiv_grid = div().setParseAction(withAttribute(type=\"grid\"))\ngrid_expr = div_grid + SkipTo(div | div_end)(\"body\")\nfor grid_header in grid_expr.searchString(html):\n    print(grid_header.body)\n\n# construct a match with any div tag having a type attribute, regardless of the value\n<line_mask>\ndiv_expr = div_any_type + SkipTo(div | div_end)(\"body\")\nfor div_header in div_expr.searchString(html):\n    print(div_header.body)",
            "masked_line": "div_any_type = div().setParseAction(withAttribute(type=withAttribute.ANY_VALUE))",
            "answer": "withAttribute",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_766"
        },
        {
            "dependency": "scikit-learn",
            "version": "==0.20.0",
            "time": "2018-09-25",
            "description": "The code parses HTML content to extract and print the body content of div elements with class \"grid\" and div elements with any class attribute.",
            "code": "div,div_end = makeHTMLTags(\"div\")\ndiv_grid = div().setParseAction(withClass(\"grid\"))\n\ngrid_expr = div_grid + SkipTo(div | div_end)(\"body\")\nfor grid_header in grid_expr.searchString(html):\n    print(grid_header.body)\n\ndiv_any_type = div().setParseAction(withClass(withAttribute.ANY_VALUE))\ndiv_expr = div_any_type + SkipTo(div | div_end)(\"body\")\nfor div_header in div_expr.searchString(html):\n    print(div_header.body)",
            "masked_code": "div,div_end = makeHTMLTags(\"div\")\ndiv_grid = div().setParseAction(withClass(\"grid\"))\n\ngrid_expr = div_grid + SkipTo(div | div_end)(\"body\")\nfor grid_header in grid_expr.searchString(html):\n    print(grid_header.body)\n\n<line_mask>\ndiv_expr = div_any_type + SkipTo(div | div_end)(\"body\")\nfor div_header in div_expr.searchString(html):\n    print(div_header.body)",
            "masked_line": "div_any_type = div().setParseAction(withClass(withAttribute.ANY_VALUE))",
            "answer": "withClass",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_767"
        },
        {
            "dependency": "scikit-learn",
            "version": "==0.20.0",
            "time": "2018-09-25",
            "description": "The code uses the bytescale function to rescale the pixel values in the input image array to fit within a specified range (default is 0-255). The function returns a new array with the rescaled pixel values in the uint8 data type. The function can also take additional parameters to specify the range of input values (cmin and cmax) or the range of output values (high and low).",
            "code": "from scipy.misc import bytescale\nimg = np.array([[ 91.06794177,   3.39058326,  84.4221549 ],\n...                 [ 73.88003259,  80.91433048,   4.88878881],\n...                 [ 51.53875334,  34.45808177,  27.5873488 ]])\nbytescale(img)\narray([[255,   0, 236],\n       [205, 225,   4],\n       [140,  90,  70]], dtype=uint8)\nbytescale(img, high=200, low=100)\narray([[200, 100, 192],\n       [180, 188, 102],\n       [155, 135, 128]], dtype=uint8)\nbytescale(img, cmin=0, cmax=255)\narray([[91,  3, 84],\n       [74, 81,  5],\n       [52, 34, 28]], dtype=uint8)",
            "masked_code": "from scipy.misc import bytescale\nimg = np.array([[ 91.06794177,   3.39058326,  84.4221549 ],\n...                 [ 73.88003259,  80.91433048,   4.88878881],\n...                 [ 51.53875334,  34.45808177,  27.5873488 ]])\nbytescale(img)\narray([[255,   0, 236],\n       [205, 225,   4],\n       [140,  90,  70]], dtype=uint8)\n<line_mask>\narray([[200, 100, 192],\n       [180, 188, 102],\n       [155, 135, 128]], dtype=uint8)\nbytescale(img, cmin=0, cmax=255)\narray([[91,  3, 84],\n       [74, 81,  5],\n       [52, 34, 28]], dtype=uint8)",
            "masked_line": "bytescale(img, high=200, low=100)",
            "answer": "bytescale",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_768"
        },
        {
            "dependency": "scikit-learn",
            "version": "==0.20.0",
            "time": "2018-09-25",
            "description": "The code generates two images: one is a grayscale gradient image from black to white, and the other is an RGB gradient image with a varying red channel and an inverse blue channel. Both images are saved as .png files.",
            "code": "from scipy.misc import imsave\nx = np.zeros((255, 255), dtype=np.uint8)\nx[:] = np.arange(255)\nimsave('gradient.png', x)\n\nrgb = np.zeros((255, 255, 3), dtype=np.uint8)\nrgb[..., 0] = np.arange(255)\nrgb[..., 1] = 55\nrgb[..., 2] = 1 - np.arange(255)\nimsave('rgb_gradient.png', rgb)",
            "masked_code": "from scipy.misc import imsave\nx = np.zeros((255, 255), dtype=np.uint8)\nx[:] = np.arange(255)\nimsave('gradient.png', x)\n\nrgb = np.zeros((255, 255, 3), dtype=np.uint8)\nrgb[..., 0] = np.arange(255)\nrgb[..., 1] = 55\nrgb[..., 2] = 1 - np.arange(255)\n<line_mask>",
            "masked_line": "imsave('rgb_gradient.png', rgb)",
            "answer": "imsave",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_769"
        },
        {
            "dependency": "scikit-learn",
            "version": "==0.20.0",
            "time": "2018-09-25",
            "description": "This code snippet defines a function that checks if the input value is a scalar NaN (Not a Number) by comparing it to np.nan, and returns True if it is a scalar NaN, and False otherwise.",
            "code": "is_scalar_nan(np.nan)\nTrue\nis_scalar_nan(float(\"nan\"))\nTrue\nis_scalar_nan(None)\nFalse\nis_scalar_nan(\"\")\nFalse\nis_scalar_nan([np.nan])\nFalse",
            "masked_code": "is_scalar_nan(np.nan)\nTrue\nis_scalar_nan(float(\"nan\"))\nTrue\nis_scalar_nan(None)\nFalse\n<line_mask>\nFalse\nis_scalar_nan([np.nan])\nFalse",
            "masked_line": "is_scalar_nan(\"\")",
            "answer": "is_scalar_nan",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_770"
        },
        {
            "dependency": "scikit-learn",
            "version": "==0.20.0",
            "time": "2018-09-25",
            "description": "The code compares the performance of models with different hyperparameter values by evaluating them. If the model with hyperparameter C=1 performs better than C=10, then it further evaluates the model with C=0.1.",
            "code": "def _run_search(self, evaluate_candidates):\n    'Try C=0.1 only if C=1 is better than C=10'\n    all_results = evaluate_candidates([{'C': 1}, {'C': 10}])\n    score = all_results['mean_test_score']\n    if score[0] < score[1]:\n        evaluate_candidates([{'C': 0.1}])",
            "masked_code": "<line_mask>\n    'Try C=0.1 only if C=1 is better than C=10'\n    all_results = evaluate_candidates([{'C': 1}, {'C': 10}])\n    score = all_results['mean_test_score']\n    if score[0] < score[1]:\n        evaluate_candidates([{'C': 0.1}])",
            "masked_line": "def _run_search(self, evaluate_candidates):",
            "answer": "_run_search",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_771"
        },
        {
            "dependency": "scikit-learn",
            "version": "==0.19.2",
            "time": "2018-07-15",
            "description": "The code sets the number of jobs for parallel processing tasks based on the number of available CPU cores, ensuring that at least one core is reserved for the system.",
            "code": "from sklearn.utils import _get_n_jobs\n_get_n_jobs(4)\njobs = _get_n_jobs(-2)\nassert jobs == max(cpu_count() - 1, 1)\n_get_n_jobs(0)\n",
            "masked_code": "from sklearn.utils import _get_n_jobs\n_get_n_jobs(4)\n<line_mask>\nassert jobs == max(cpu_count() - 1, 1)\n_get_n_jobs(0)\n",
            "masked_line": "jobs = _get_n_jobs(-2)",
            "answer": "_get_n_jobs",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_772"
        },
        {
            "dependency": "scikit-learn",
            "version": "==0.21.0",
            "time": "2019-05-09",
            "description": "The code fits a Voting Regressor model using a Linear Regression and a Random Forest Regressor with specified parameters on the given dataset X (features) and y (target values), and then predicts the target values for the same dataset X.",
            "code": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.ensemble import RandomForestRegressor\nfrom sklearn.ensemble import VotingRegressor\n\nr1 = LinearRegression()\nr2 = RandomForestRegressor(n_estimators=10, random_state=1)\nX = np.array([[1, 1], [2, 4], [3, 9], [4, 16], [5, 25], [6, 36]])\ny = np.array([2, 6, 12, 20, 30, 42])\ner = VotingRegressor([('lr', r1), ('rf', r2)])\nprint(er.fit(X, y).predict(X))",
            "masked_code": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.ensemble import RandomForestRegressor\n<line_mask>\n\nr1 = LinearRegression()\nr2 = RandomForestRegressor(n_estimators=10, random_state=1)\nX = np.array([[1, 1], [2, 4], [3, 9], [4, 16], [5, 25], [6, 36]])\ny = np.array([2, 6, 12, 20, 30, 42])\ner = VotingRegressor([('lr', r1), ('rf', r2)])\nprint(er.fit(X, y).predict(X))",
            "masked_line": "from sklearn.ensemble import VotingRegressor",
            "answer": "VotingRegressor",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_773"
        },
        {
            "dependency": "scikit-learn",
            "version": "==0.22",
            "time": "2019-12-02",
            "description": "This code performs missing value imputation using KNN (K-Nearest Neighbors) algorithm on the input data X.",
            "code": "import numpy as np\nfrom sklearn.impute import KNNImputer\nX = [[1, 2, np.nan], [3, 4, 3], [np.nan, 6, 5], [8, 8, 7]]\nimputer = KNNImputer(n_neighbors=2)\nimputer.fit_transform(X)",
            "masked_code": "import numpy as np\n<line_mask>\nX = [[1, 2, np.nan], [3, 4, 3], [np.nan, 6, 5], [8, 8, 7]]\nimputer = KNNImputer(n_neighbors=2)\nimputer.fit_transform(X)",
            "masked_line": "from sklearn.impute import KNNImputer",
            "answer": "KNNImputer",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_774"
        },
        {
            "dependency": "scikit-learn",
            "version": "==0.22",
            "time": "2019-12-02",
            "description": "This code calculates and displays the Receiver Operating Characteristic (ROC) curve for a binary classification model by comparing the true labels (y) with the predicted probabilities (pred). It then calculates the Area Under the Curve (AUC) for the ROC curve and displays the ROC curve with the AUC value using matplotlib.",
            "code": "import matplotlib.pyplot as plt\nimport numpy as np\nfrom sklearn import metrics\ny = np.array([0, 0, 1, 1])\npred = np.array([0.1, 0.4, 0.35, 0.8])\nfpr, tpr, thresholds = metrics.roc_curve(y, pred)\nroc_auc = metrics.auc(fpr, tpr)\ndisplay = metrics.RocCurveDisplay(fpr=fpr, tpr=tpr, roc_auc=roc_auc, estimator_name='example estimator')\ndisplay.plot()\nplt.show()",
            "masked_code": "import matplotlib.pyplot as plt\nimport numpy as np\nfrom sklearn import metrics\ny = np.array([0, 0, 1, 1])\npred = np.array([0.1, 0.4, 0.35, 0.8])\nfpr, tpr, thresholds = metrics.roc_curve(y, pred)\nroc_auc = metrics.auc(fpr, tpr)\n<line_mask>\ndisplay.plot()\nplt.show()",
            "masked_line": "display = metrics.RocCurveDisplay(fpr=fpr, tpr=tpr, roc_auc=roc_auc, estimator_name='example estimator')",
            "answer": "RocCurveDisplay",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_775"
        },
        {
            "dependency": "scikit-learn",
            "version": "==0.22",
            "time": "2019-12-02",
            "description": "Generate 1000 random values from a logarithmically uniform distribution within the range of 0.001 to 10, compute the minimum and maximum values of these random values.",
            "code": "from sklearn.utils.fixes import loguniform\nrv = loguniform(1e-3, 1e1)\nrvs = rv.rvs(random_state=42, size=1000)\nrvs.min()  # doctest: +SKIP\nrvs.max()  # doctest: +SKIP\n",
            "masked_code": "<line_mask>\nrv = loguniform(1e-3, 1e1)\nrvs = rv.rvs(random_state=42, size=1000)\nrvs.min()  # doctest: +SKIP\nrvs.max()  # doctest: +SKIP\n",
            "masked_line": "from sklearn.utils.fixes import loguniform",
            "answer": "loguniform",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_776"
        },
        {
            "dependency": "scikit-learn",
            "version": "==0.22",
            "time": "2019-12-02",
            "description": "This code calculates the Euclidean distances between the rows of a matrix X, including handling of NaN values.",
            "code": "from sklearn.metrics.pairwise import nan_euclidean_distances\nnan = float(\"NaN\")\nX = [[0, 1], [1, nan]]\nnan_euclidean_distances(X, X) # distance between rows of X\nnan_euclidean_distances(X, [[0, 0]]) # get distance to origin\n",
            "masked_code": "from sklearn.metrics.pairwise import nan_euclidean_distances\nnan = float(\"NaN\")\nX = [[0, 1], [1, nan]]\nnan_euclidean_distances(X, X) # distance between rows of X\n<line_mask>\n",
            "masked_line": "nan_euclidean_distances(X, [[0, 0]]) # get distance to origin",
            "answer": "nan_euclidean_distances",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_777"
        },
        {
            "dependency": "scikit-learn",
            "version": "==0.22",
            "time": "2019-12-02",
            "description": "The code performs incremental PCA (Principal Component Analysis) on the input data X, allowing for processing in batches instead of all at once.",
            "code": "import numpy as np\nfrom sklearn.decomposition import IncrementalPCA\nX = np.array([[-1, -1], [-2, -1], [-3, -2],\n              [1, 1], [2, 1], [3, 2]])\nipca = IncrementalPCA(n_components=2, batch_size=3)\nipca.fit(X)\nipca.transform(X) # doctest: +SKIP",
            "masked_code": "import numpy as np\nfrom sklearn.decomposition import IncrementalPCA\nX = np.array([[-1, -1], [-2, -1], [-3, -2],\n              [1, 1], [2, 1], [3, 2]])\nipca = IncrementalPCA(n_components=2, batch_size=3)\nipca.fit(X)\n<line_mask>",
            "masked_line": "ipca.transform(X) # doctest: +SKIP",
            "answer": "transform",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_778"
        },
        {
            "dependency": "scikit-learn",
            "version": "==0.24.0",
            "time": "2020-12-22",
            "description": "This code performs feature selection using Sequential Feature Selection with a K-Nearest Neighbors classifier on the Iris dataset.",
            "code": "from sklearn.feature_selection import SequentialFeatureSelector\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.datasets import load_iris\nX, y = load_iris(return_X_y=True)\nknn = KNeighborsClassifier(n_neighbors=3)\nsfs = SequentialFeatureSelector(knn, n_features_to_select=3)\nsfs.fit(X, y)\nsfs.get_support()\nsfs.transform(X).shape\n",
            "masked_code": "<line_mask>\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.datasets import load_iris\nX, y = load_iris(return_X_y=True)\nknn = KNeighborsClassifier(n_neighbors=3)\nsfs = SequentialFeatureSelector(knn, n_features_to_select=3)\nsfs.fit(X, y)\nsfs.get_support()\nsfs.transform(X).shape\n",
            "masked_line": "from sklearn.feature_selection import SequentialFeatureSelector",
            "answer": "SequentialFeatureSelector",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_779"
        },
        {
            "dependency": "scikit-learn",
            "version": "==0.24.0",
            "time": "2020-12-22",
            "description": "This code generates a Detection Error Tradeoff (DET) curve based on the true labels 'y' and the predicted probabilities 'pred'. The DET curve is displayed with false positive rate (FPR) on the x-axis and false negative rate (FNR) on the y-axis, using an estimator named 'example estimator'.",
            "code": "import numpy as np\nfrom sklearn import metrics\n\ny = np.array([0, 0, 1, 1])\npred = np.array([0.1, 0.4, 0.35, 0.8])\nfpr, fnr, thresholds = metrics.det_curve(y, pred)\ndisplay = metrics.DetCurveDisplay(\n    fpr=fpr, fnr=fnr, estimator_name='example estimator'\n)\ndisplay.plot()\nplt.show()      # doctest: +SKIP",
            "masked_code": "import numpy as np\nfrom sklearn import metrics\n\ny = np.array([0, 0, 1, 1])\npred = np.array([0.1, 0.4, 0.35, 0.8])\nfpr, fnr, thresholds = metrics.det_curve(y, pred)\n<line_mask>\n    fpr=fpr, fnr=fnr, estimator_name='example estimator'\n)\ndisplay.plot()\nplt.show()      # doctest: +SKIP",
            "masked_line": "display = metrics.DetCurveDisplay(",
            "answer": "DetCurveDisplay",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_780"
        },
        {
            "dependency": "scikit-learn",
            "version": "==0.24.0",
            "time": "2020-12-22",
            "description": "The code calculates the detection error tradeoff (DET) curve using the given true labels and predicted scores. The DET curve shows the false positive rate (fpr) and false negative rate (fnr) at different decision thresholds. The thresholds at which the fpr and fnr are calculated are also returned.",
            "code": "from sklearn.metrics import det_curve\ny_true = np.array([0, 0, 1, 1])\ny_scores = np.array([0.1, 0.4, 0.35, 0.8])\nfpr, fnr, thresholds = det_curve(y_true, y_scores)\nfpr\narray([0.5, 0.5, 0. ])\nfnr\narray([0. , 0.5, 0.5])\nthresholds\narray([0.35, 0.4 , 0.8 ])",
            "masked_code": "<line_mask>\ny_true = np.array([0, 0, 1, 1])\ny_scores = np.array([0.1, 0.4, 0.35, 0.8])\nfpr, fnr, thresholds = det_curve(y_true, y_scores)\nfpr\narray([0.5, 0.5, 0. ])\nfnr\narray([0. , 0.5, 0.5])\nthresholds\narray([0.35, 0.4 , 0.8 ])",
            "masked_line": "from sklearn.metrics import det_curve",
            "answer": "det_curve",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_781"
        },
        {
            "dependency": "scikit-learn",
            "version": "==0.24.0",
            "time": "2020-12-22",
            "description": "The code calculates the top k accuracy score of a model's predictions compared to the true labels, where k is specified. It can be calculated with or without normalization.",
            "code": "import numpy as np\nfrom sklearn.metrics import top_k_accuracy_score\ny_true = np.array([0, 1, 2, 2])\ny_score = np.array([[0.5, 0.2, 0.2],  \n                    [0.3, 0.4, 0.2],  \n                    [0.2, 0.4, 0.3],  \n                    [0.7, 0.2, 0.1]]) \ntop_k_accuracy_score(y_true, y_score, k=2)\ntop_k_accuracy_score(y_true, y_score, k=2, normalize=False)",
            "masked_code": "import numpy as np\n<line_mask>\ny_true = np.array([0, 1, 2, 2])\ny_score = np.array([[0.5, 0.2, 0.2],  \n                    [0.3, 0.4, 0.2],  \n                    [0.2, 0.4, 0.3],  \n                    [0.7, 0.2, 0.1]]) \ntop_k_accuracy_score(y_true, y_score, k=2)\ntop_k_accuracy_score(y_true, y_score, k=2, normalize=False)",
            "masked_line": "from sklearn.metrics import top_k_accuracy_score",
            "answer": "top_k_accuracy_score",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_782"
        },
        {
            "dependency": "scikit-learn",
            "version": "==0.24.0",
            "time": "2020-12-22",
            "description": "The code calculates the mean absolute percentage error between true and predicted values for regression tasks. The function can handle single or multiple output regression tasks.",
            "code": "from sklearn.metrics import mean_absolute_percentage_error\ny_true = [3, -0.5, 2, 7]\ny_pred = [2.5, 0.0, 2, 8]\nmean_absolute_percentage_error(y_true, y_pred)\ny_true = [[0.5, 1], [-1, 1], [7, -6]]\ny_pred = [[0, 2], [-1, 2], [8, -5]]\nmean_absolute_percentage_error(y_true, y_pred)\nmean_absolute_percentage_error(y_true, y_pred, multioutput=[0.3, 0.7])\n",
            "masked_code": "<line_mask>\ny_true = [3, -0.5, 2, 7]\ny_pred = [2.5, 0.0, 2, 8]\nmean_absolute_percentage_error(y_true, y_pred)\ny_true = [[0.5, 1], [-1, 1], [7, -6]]\ny_pred = [[0, 2], [-1, 2], [8, -5]]\nmean_absolute_percentage_error(y_true, y_pred)\nmean_absolute_percentage_error(y_true, y_pred, multioutput=[0.3, 0.7])\n",
            "masked_line": "from sklearn.metrics import mean_absolute_percentage_error",
            "answer": "mean_absolute_percentage_error",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_783"
        },
        {
            "dependency": "scikit-learn",
            "version": "==1.0",
            "time": "2021-09-24",
            "description": "The code performs spline transformation on a 1-dimensional array X with 6 elements, using a quadratic spline with 3 knots.",
            "code": "import numpy as np\nfrom sklearn.preprocessing import SplineTransformer\nX = np.arange(6).reshape(6, 1)\nspline = SplineTransformer(degree=2, n_knots=3)\nspline.fit_transform(X)",
            "masked_code": "import numpy as np\n<line_mask>\nX = np.arange(6).reshape(6, 1)\nspline = SplineTransformer(degree=2, n_knots=3)\nspline.fit_transform(X)",
            "masked_line": "from sklearn.preprocessing import SplineTransformer",
            "answer": "SplineTransformer",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_784"
        },
        {
            "dependency": "scikit-learn",
            "version": "==1.1.0",
            "time": "2022-05-12",
            "description": "This code segment performs bisecting k-means clustering on a dataset X to divide it into 3 clusters. It then assigns labels to the data points in X, predicts the cluster label for new data points [0, 0] and [12, 3], and identifies the cluster centers of the resulting clusters.",
            "code": "from sklearn.cluster import BisectingKMeans\nimport numpy as np\nX = np.array([[1, 2], [1, 4], [1, 0],\n              [10, 2], [10, 4], [10, 0],\n              [10, 6], [10, 8], [10, 10]])\nbisect_means = BisectingKMeans(n_clusters=3, random_state=0).fit(X)\nbisect_means.labels_\nbisect_means.predict([[0, 0], [12, 3]])\nbisect_means.cluster_centers_",
            "masked_code": "<line_mask>\nimport numpy as np\nX = np.array([[1, 2], [1, 4], [1, 0],\n              [10, 2], [10, 4], [10, 0],\n              [10, 6], [10, 8], [10, 10]])\nbisect_means = BisectingKMeans(n_clusters=3, random_state=0).fit(X)\nbisect_means.labels_\nbisect_means.predict([[0, 0], [12, 3]])\nbisect_means.cluster_centers_",
            "masked_line": "from sklearn.cluster import BisectingKMeans",
            "answer": "BisectingKMeans",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_785"
        },
        {
            "dependency": "scikit-learn",
            "version": "==1.2.0",
            "time": "2022-12-08",
            "description": "This code generates a learning curve display for a decision tree classifier using the Iris dataset. It shows the relationship between training and test scores as the training size increases.",
            "code": "import matplotlib.pyplot as plt\nfrom sklearn.datasets import load_iris\nfrom sklearn.model_selection import LearningCurveDisplay, learning_curve\nfrom sklearn.tree import DecisionTreeClassifier\nX, y = load_iris(return_X_y=True)\ntree = DecisionTreeClassifier(random_state=0)\ntrain_sizes, train_scores, test_scores = learning_curve(\n    tree, X, y)\ndisplay = LearningCurveDisplay(train_sizes=train_sizes,\n    train_scores=train_scores, test_scores=test_scores, score_name=\"Score\")\ndisplay.plot()\nplt.show()",
            "masked_code": "import matplotlib.pyplot as plt\nfrom sklearn.datasets import load_iris\n<line_mask>\nfrom sklearn.tree import DecisionTreeClassifier\nX, y = load_iris(return_X_y=True)\ntree = DecisionTreeClassifier(random_state=0)\ntrain_sizes, train_scores, test_scores = learning_curve(\n    tree, X, y)\ndisplay = LearningCurveDisplay(train_sizes=train_sizes,\n    train_scores=train_scores, test_scores=test_scores, score_name=\"Score\")\ndisplay.plot()\nplt.show()",
            "masked_line": "from sklearn.model_selection import LearningCurveDisplay, learning_curve",
            "answer": "LearningCurveDisplay",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_786"
        },
        {
            "dependency": "streamlit",
            "version": "==0.19.0",
            "time": "2018-11-21",
            "description": "This code defines and creates options with default values and descriptions in different sections.",
            "code": "_create_option('section.optionName',\n    description = 'Put the description here.',\n    default_val = 12345)\n\n@_create_option('section.optionName')\ndef _section_option_name():\n    \"\"\"Put the description here.\"\"\"\n    return 12345\n\n@_create_option('section.memoizedOptionName')\n@util.memoize\ndef _section_memoized_option_name():\n    \"\"\"Put the description here.\"\"\"\n    return 12345",
            "masked_code": "<line_mask>\n    description = 'Put the description here.',\n    default_val = 12345)\n\n@_create_option('section.optionName')\ndef _section_option_name():\n    \"\"\"Put the description here.\"\"\"\n    return 12345\n\n@_create_option('section.memoizedOptionName')\n@util.memoize\ndef _section_memoized_option_name():\n    \"\"\"Put the description here.\"\"\"\n    return 12345",
            "masked_line": "_create_option('section.optionName',",
            "answer": "_create_option",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_787"
        },
        {
            "dependency": "streamlit",
            "version": "==0.27.0",
            "time": "2019-02-21",
            "description": "The code generates a scatter plot using Altair library with random data from a Pandas DataFrame. The plot displays column 'a' on the x-axis, column 'b' on the y-axis, column 'c' as the size of the circles, and column 'c' as the color of the circles.",
            "code": "import pandas as pd\nimport numpy as np\nimport altair as alt\n\ndf = pd.DataFrame(\n    np.random.randn(200, 3),\n    columns=['a', 'b', 'c'])\n\nc = alt.Chart(df).mark_circle().encode(\n    x='a', y='b', size='c', color='c')\n\nst.altair_chart(c)",
            "masked_code": "import pandas as pd\nimport numpy as np\nimport altair as alt\n\ndf = pd.DataFrame(\n    np.random.randn(200, 3),\n    columns=['a', 'b', 'c'])\n\nc = alt.Chart(df).mark_circle().encode(\n    x='a', y='b', size='c', color='c')\n\n<line_mask>",
            "masked_line": "st.altair_chart(c)",
            "answer": "altair_chart",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_788"
        },
        {
            "dependency": "streamlit",
            "version": "==0.35.0",
            "time": "2019-04-27",
            "description": "The code creates a simple line chart using the Bokeh library in Python and displays it using the Streamlit framework.",
            "code": "import streamlit as st\nfrom bokeh.plotting import figure\n\nx = [1, 2, 3, 4, 5]\ny = [6, 7, 2, 4, 5]\n\np = figure(\n    title='simple line example',\n    x_axis_label='x',\n    y_axis_label='y')\n\np.line(x, y, legend='Trend', line_width=2)\n\nst.bokeh_chart(p)",
            "masked_code": "import streamlit as st\nfrom bokeh.plotting import figure\n\nx = [1, 2, 3, 4, 5]\ny = [6, 7, 2, 4, 5]\n\np = figure(\n    title='simple line example',\n    x_axis_label='x',\n    y_axis_label='y')\n\np.line(x, y, legend='Trend', line_width=2)\n\n<line_mask>",
            "masked_line": "st.bokeh_chart(p)",
            "answer": "bokeh_chart",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_789"
        },
        {
            "dependency": "streamlit",
            "version": "==0.45.0",
            "time": "2019-08-28",
            "description": "The code creates a new instance of a Cache object from the st module. If the Cache object is successfully created, data is fetched from a URL, processed, and assigned to the data attribute of the Cache object.",
            "code": "c = st.Cache()\nif c:\n    # Fetch data from URL here, and then clean it up. Finally assign to c.\n    c.data = ...\n\nif c := st.Cache():\n    # Fetch data from URL here, and then clean it up. Finally assign to c.\n    c.data = ...",
            "masked_code": "c = st.Cache()\nif c:\n    # Fetch data from URL here, and then clean it up. Finally assign to c.\n    c.data = ...\n\n<line_mask>\n    # Fetch data from URL here, and then clean it up. Finally assign to c.\n    c.data = ...",
            "masked_line": "if c := st.Cache():",
            "answer": "Cache",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_790"
        },
        {
            "dependency": "streamlit",
            "version": "==0.65.0",
            "time": "2020-08-12",
            "description": "The code generates a scatter plot using Altair library with random data from a Pandas DataFrame. The plot displays 'a' on the x-axis, 'b' on the y-axis, size and color specified by 'c', and tooltip showing values of 'a', 'b', and 'c'.",
            "code": "import pandas as pd\nimport numpy as np\nimport altair as alt\n\ndf = pd.DataFrame(\n    np.random.randn(200, 3),\n    columns=['a', 'b', 'c'])\n\nc = alt.Chart(df).mark_circle().encode(\n    x='a', y='b', size='c', color='c', tooltip=['a', 'b', 'c'])\n\nst.altair_chart(c, use_container_width=True)",
            "masked_code": "import pandas as pd\nimport numpy as np\nimport altair as alt\n\ndf = pd.DataFrame(\n    np.random.randn(200, 3),\n    columns=['a', 'b', 'c'])\n\nc = alt.Chart(df).mark_circle().encode(\n    x='a', y='b', size='c', color='c', tooltip=['a', 'b', 'c'])\n\n<line_mask>",
            "masked_line": "st.altair_chart(c, use_container_width=True)",
            "answer": "altair_chart",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_791"
        },
        {
            "dependency": "streamlit",
            "version": "==0.65.0",
            "time": "2020-08-12",
            "description": "The code generates a simple line plot using the Bokeh library and displays it using the Streamlit framework.",
            "code": "import streamlit as st\nfrom bokeh.plotting import figure\n\nx = [1, 2, 3, 4, 5]\ny = [6, 7, 2, 4, 5]\n\np = figure(\n    title='simple line example',\n    x_axis_label='x',\n    y_axis_label='y')\n\np.line(x, y, legend='Trend', line_width=2)\n\nst.bokeh_chart(p, use_container_width=True)",
            "masked_code": "import streamlit as st\nfrom bokeh.plotting import figure\n\nx = [1, 2, 3, 4, 5]\ny = [6, 7, 2, 4, 5]\n\np = figure(\n    title='simple line example',\n    x_axis_label='x',\n    y_axis_label='y')\n\np.line(x, y, legend='Trend', line_width=2)\n\n<line_mask>",
            "masked_line": "st.bokeh_chart(p, use_container_width=True)",
            "answer": "bokeh_chart",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_792"
        },
        {
            "dependency": "streamlit",
            "version": "==0.65.0",
            "time": "2020-08-12",
            "description": "The code generates a custom distribution plot with three groups of data (Group 1, Group 2, Group 3), each represented by a histogram. The bins sizes for the histograms are set to [.1, .25, .5]. The plot is then displayed using Streamlit.",
            "code": "import streamlit as st\nimport plotly.figure_factory as ff\nimport numpy as np\n\n# Add histogram data\nx1 = np.random.randn(200) - 2\nx2 = np.random.randn(200)\nx3 = np.random.randn(200) + 2\n\n# Group data together\nhist_data = [x1, x2, x3]\n\ngroup_labels = ['Group 1', 'Group 2', 'Group 3']\n\n# Create distplot with custom bin_size\nfig = ff.create_distplot(\n        hist_data, group_labels, bin_size=[.1, .25, .5])\n\n# Plot!\nst.plotly_chart(fig, use_container_width=True)",
            "masked_code": "import streamlit as st\nimport plotly.figure_factory as ff\nimport numpy as np\n\n# Add histogram data\nx1 = np.random.randn(200) - 2\nx2 = np.random.randn(200)\nx3 = np.random.randn(200) + 2\n\n# Group data together\nhist_data = [x1, x2, x3]\n\ngroup_labels = ['Group 1', 'Group 2', 'Group 3']\n\n# Create distplot with custom bin_size\nfig = ff.create_distplot(\n        hist_data, group_labels, bin_size=[.1, .25, .5])\n\n# Plot!\n<line_mask>",
            "masked_line": "st.plotly_chart(fig, use_container_width=True)",
            "answer": "plotly_chart",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_793"
        },
        {
            "dependency": "streamlit",
            "version": "==0.65.0",
            "time": "2020-08-12",
            "description": "The code generates a histogram plot of 100 random numbers sampled from a normal distribution with mean 1 and standard deviation 1, using 20 bins.",
            "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\narr = np.random.normal(1, 1, size=100)\nplt.hist(arr, bins=20)\n\nst.pyplot()\n",
            "masked_code": "import matplotlib.pyplot as plt\nimport numpy as np\n\narr = np.random.normal(1, 1, size=100)\nplt.hist(arr, bins=20)\n\n<line_mask>\n",
            "masked_line": "st.pyplot()",
            "answer": "pyplot",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_794"
        },
        {
            "dependency": "streamlit",
            "version": "==0.64.0",
            "time": "2020-07-23",
            "description": "The code generates a customized distribution plot using Plotly Figure Factory in a Streamlit application. It randomly generates three sets of data, groups them together, and creates a distribution plot with custom bin sizes for each group label. Finally, it displays the plot in the Streamlit application.",
            "code": "import streamlit as st\nimport plotly.figure_factory as ff\nimport numpy as np\n\n# Add histogram data\nx1 = np.random.randn(200) - 2\nx2 = np.random.randn(200)\nx3 = np.random.randn(200) + 2\n\n# Group data together\nhist_data = [x1, x2, x3]\n\ngroup_labels = ['Group 1', 'Group 2', 'Group 3']\n\n# Create distplot with custom bin_size\nfig = ff.create_distplot(\n        hist_data, group_labels, bin_size=[.1, .25, .5])\n\n# Plot!\nst.plotly_chart(fig, use_container_width=True)",
            "masked_code": "import streamlit as st\nimport plotly.figure_factory as ff\nimport numpy as np\n\n# Add histogram data\nx1 = np.random.randn(200) - 2\nx2 = np.random.randn(200)\nx3 = np.random.randn(200) + 2\n\n# Group data together\nhist_data = [x1, x2, x3]\n\ngroup_labels = ['Group 1', 'Group 2', 'Group 3']\n\n# Create distplot with custom bin_size\nfig = ff.create_distplot(\n        hist_data, group_labels, bin_size=[.1, .25, .5])\n\n# Plot!\n<line_mask>",
            "masked_line": "st.plotly_chart(fig, use_container_width=True)",
            "answer": "plotly_chart",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_795"
        },
        {
            "dependency": "streamlit",
            "version": "==0.64.0",
            "time": "2020-07-23",
            "description": "The code creates a simple line plot using the Bokeh library in Streamlit, displaying the relationship between the x and y values provided in the lists.",
            "code": "import streamlit as st\nfrom bokeh.plotting import figure\n\nx = [1, 2, 3, 4, 5]\ny = [6, 7, 2, 4, 5]\n\np = figure(\n    title='simple line example',\n    x_axis_label='x',\n    y_axis_label='y')\n\np.line(x, y, legend='Trend', line_width=2)\n\nst.bokeh_chart(p, use_container_width=True)",
            "masked_code": "import streamlit as st\nfrom bokeh.plotting import figure\n\nx = [1, 2, 3, 4, 5]\ny = [6, 7, 2, 4, 5]\n\np = figure(\n    title='simple line example',\n    x_axis_label='x',\n    y_axis_label='y')\n\np.line(x, y, legend='Trend', line_width=2)\n\n<line_mask>",
            "masked_line": "st.bokeh_chart(p, use_container_width=True)",
            "answer": "bokeh_chart",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_796"
        },
        {
            "dependency": "streamlit",
            "version": "==0.64.0",
            "time": "2020-07-23",
            "description": "The code allows the user to use slider widgets to input values for age, a range of values, appointment time, and start time, and then displays the selected values or times in a message.",
            "code": "age = st.slider('How old are you?', 0, 130, 25)\nst.write(\"I'm \", age, 'years old')\n\nvalues = st.slider(\n    'Select a range of values',\n    0.0, 100.0, (25.0, 75.0))\nst.write('Values:', values)\n\nfrom datetime import time\nappointment = st.slider(\n    \"Schedule your appointment:\",\n    value=(time(11, 30), time(12, 45))\n)\nst.write(\"You're scheduled for:\", appointment)\n\nfrom datetime import datetime\nstart_time = st.slider(\n    \"When do you start?\",\n    value=datetime(2020, 1, 1, 9, 30),\n    format=\"MM/DD/YY - hh:mm\"\n)\nst.write(\"Start time:\", start_time)",
            "masked_code": "<line_mask>\nst.write(\"I'm \", age, 'years old')\n\nvalues = st.slider(\n    'Select a range of values',\n    0.0, 100.0, (25.0, 75.0))\nst.write('Values:', values)\n\nfrom datetime import time\nappointment = st.slider(\n    \"Schedule your appointment:\",\n    value=(time(11, 30), time(12, 45))\n)\nst.write(\"You're scheduled for:\", appointment)\n\nfrom datetime import datetime\nstart_time = st.slider(\n    \"When do you start?\",\n    value=datetime(2020, 1, 1, 9, 30),\n    format=\"MM/DD/YY - hh:mm\"\n)\nst.write(\"Start time:\", start_time)",
            "masked_line": "age = st.slider('How old are you?', 0, 130, 25)",
            "answer": "slider",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_797"
        },
        {
            "dependency": "streamlit",
            "version": "==0.74.0",
            "time": "2021-01-07",
            "description": "The code creates a container using Streamlit's beta_container function, and then writes some text and displays a bar chart inside the container. It also creates another container and writes text inside it.",
            "code": "with st.beta_container():\n    st.write(\"This is inside the container\")\n    st.bar_chart(np.random.randn(50, 3))\n\ncontainer = st.beta_container()\ncontainer.write(\"This is inside the container\")\ncontainer.write(\"This is inside too\")\n",
            "masked_code": "with st.beta_container():\n    st.write(\"This is inside the container\")\n    st.bar_chart(np.random.randn(50, 3))\n\n<line_mask>\ncontainer.write(\"This is inside the container\")\ncontainer.write(\"This is inside too\")\n",
            "masked_line": "container = st.beta_container()",
            "answer": "beta_container",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_798"
        },
        {
            "dependency": "streamlit",
            "version": "==0.73.1",
            "time": "2020-12-21",
            "description": "The code creates a Streamlit beta container and writes text inside it along with a bar chart displaying random data. It then creates another Streamlit beta container, writes text inside it, and writes more text inside the same container.",
            "code": "with st.beta_container():\n    st.write(\"This is inside the container\")\n    st.bar_chart(np.random.randn(50, 3))\n\ncontainer = st.beta_container()\ncontainer.write(\"This is inside the container\")\ncontainer.write(\"This is inside too\")\n",
            "masked_code": "<line_mask>\n    st.write(\"This is inside the container\")\n    st.bar_chart(np.random.randn(50, 3))\n\ncontainer = st.beta_container()\ncontainer.write(\"This is inside the container\")\ncontainer.write(\"This is inside too\")\n",
            "masked_line": "with st.beta_container():",
            "answer": "beta_container",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_799"
        },
        {
            "dependency": "streamlit",
            "version": "==0.73.1",
            "time": "2020-12-21",
            "description": "This code displays three columns, each containing a header with an image of a different animal (cat, dog, owl). The images are displayed with the specified URLs and they are resized to fit the width of their respective columns.",
            "code": "col1, col2, col3 = st.beta_columns(3)\n\nwith col1:\n    st.header(\"A cat\")\n    st.image(\"https://static.streamlit.io/examples/cat.jpg\", use_column_width=True)\n\nwith col2:\n    st.header(\"A dog\")\n    st.image(\"https://static.streamlit.io/examples/dog.jpg\", use_column_width=True)\n\nwith col3:\n    st.header(\"An owl\")\n    st.image(\"https://static.streamlit.io/examples/owl.jpg\", use_column_width=True)\n",
            "masked_code": "<line_mask>\n\nwith col1:\n    st.header(\"A cat\")\n    st.image(\"https://static.streamlit.io/examples/cat.jpg\", use_column_width=True)\n\nwith col2:\n    st.header(\"A dog\")\n    st.image(\"https://static.streamlit.io/examples/dog.jpg\", use_column_width=True)\n\nwith col3:\n    st.header(\"An owl\")\n    st.image(\"https://static.streamlit.io/examples/owl.jpg\", use_column_width=True)\n",
            "masked_line": "col1, col2, col3 = st.beta_columns(3)",
            "answer": "beta_columns",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_800"
        },
        {
            "dependency": "streamlit",
            "version": "==0.85.0",
            "time": "2021-07-22",
            "description": "The code creates a scatter plot using Altair library, where the x-axis is represented by column 'a', the y-axis is represented by column 'b', the size of the circles is determined by column 'c', the color of the circles is also determined by column 'c', and the tooltip displays the values of columns 'a', 'b', and 'c'.",
            "code": "import pandas as pd\nimport numpy as np\nimport altair as alt\n\ndf = pd.DataFrame(\n    np.random.randn(200, 3),\n    columns=['a', 'b', 'c'])\n\nc = alt.Chart(df).mark_circle().encode(\n    x='a', y='b', size='c', color='c', tooltip=['a', 'b', 'c'])\n\nst._arrow_altair_chart(c, use_container_width=True)",
            "masked_code": "import pandas as pd\nimport numpy as np\nimport altair as alt\n\ndf = pd.DataFrame(\n    np.random.randn(200, 3),\n    columns=['a', 'b', 'c'])\n\nc = alt.Chart(df).mark_circle().encode(\n    x='a', y='b', size='c', color='c', tooltip=['a', 'b', 'c'])\n\n<line_mask>",
            "masked_line": "st._arrow_altair_chart(c, use_container_width=True)",
            "answer": "_arrow_altair_chart",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_801"
        },
        {
            "dependency": "streamlit",
            "version": "==0.85.0",
            "time": "2021-07-22",
            "description": "The code generates a scatter plot using random data with 3 variables (a, b, c) and displays it using Altair library.",
            "code": "import pandas as pd\nimport numpy as np\nimport altair as alt\n\ndf = pd.DataFrame(\n    np.random.randn(200, 3),\n    columns=['a', 'b', 'c'])\n\nc = alt.Chart(df).mark_circle().encode(\n    x='a', y='b', size='c', color='c', tooltip=['a', 'b', 'c'])\n\nst.altair_chart(c, use_container_width=True)",
            "masked_code": "import pandas as pd\nimport numpy as np\nimport altair as alt\n\ndf = pd.DataFrame(\n    np.random.randn(200, 3),\n    columns=['a', 'b', 'c'])\n\nc = alt.Chart(df).mark_circle().encode(\n    x='a', y='b', size='c', color='c', tooltip=['a', 'b', 'c'])\n\n<line_mask>",
            "masked_line": "st.altair_chart(c, use_container_width=True)",
            "answer": "altair_chart",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_802"
        },
        {
            "dependency": "streamlit",
            "version": "==0.85.0",
            "time": "2021-07-22",
            "description": "The code creates two DataFrames with random values and 20 columns each. It then displays the first DataFrame in a table and line chart using Streamlit. After that, it adds the second DataFrame to the table and updates the line chart with the data from the second DataFrame. Finally, it creates a Vega-Lite chart with the first DataFrame and updates it with the data from the second DataFrame using a named dataset.",
            "code": "df1 = pd.DataFrame(\n   np.random.randn(50, 20),\n   columns=('col %d' % i for i in range(20)))\nmy_table = st.table(df1)\n\ndf2 = pd.DataFrame(\n   np.random.randn(50, 20),\n   columns=('col %d' % i for i in range(20)))\nmy_table.add_rows(df2)\n\nmy_chart = st.line_chart(df1)\nmy_chart.add_rows(df2)\n\nmy_chart = st.vega_lite_chart({\n    'mark': 'line',\n    'encoding': {'x': 'a', 'y': 'b'},\n    'datasets': {\n      'some_fancy_name': df1,  # <-- named dataset\n     },\n    'data': {'name': 'some_fancy_name'},\n}),\nmy_chart.add_rows(some_fancy_name=df2)  # <-- name used as keyword\n",
            "masked_code": "df1 = pd.DataFrame(\n   np.random.randn(50, 20),\n   columns=('col %d' % i for i in range(20)))\nmy_table = st.table(df1)\n\ndf2 = pd.DataFrame(\n   np.random.randn(50, 20),\n   columns=('col %d' % i for i in range(20)))\n<line_mask>\n\nmy_chart = st.line_chart(df1)\nmy_chart.add_rows(df2)\n\nmy_chart = st.vega_lite_chart({\n    'mark': 'line',\n    'encoding': {'x': 'a', 'y': 'b'},\n    'datasets': {\n      'some_fancy_name': df1,  # <-- named dataset\n     },\n    'data': {'name': 'some_fancy_name'},\n}),\nmy_chart.add_rows(some_fancy_name=df2)  # <-- name used as keyword\n",
            "masked_line": "my_table.add_rows(df2)",
            "answer": "add_rows",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_803"
        },
        {
            "dependency": "streamlit",
            "version": "==0.85.0",
            "time": "2021-07-22",
            "description": "The code generates a scatter plot using Altair library to visualize a pandas DataFrame with random data. The scatter plot displays columns 'a' and 'b' as x and y coordinates, column 'c' as size and color of circles, and shows tooltips with values of 'a', 'b', and 'c' when hovering over the circles.",
            "code": "import pandas as pd\nimport numpy as np\nimport altair as alt\n\ndf = pd.DataFrame(\n    np.random.randn(200, 3),\n    columns=['a', 'b', 'c'])\n\nc = alt.Chart(df).mark_circle().encode(\n    x='a', y='b', size='c', color='c', tooltip=['a', 'b', 'c'])\n\nst._legacy_altair_chart(c, use_container_width=True)",
            "masked_code": "import pandas as pd\nimport numpy as np\nimport altair as alt\n\ndf = pd.DataFrame(\n    np.random.randn(200, 3),\n    columns=['a', 'b', 'c'])\n\nc = alt.Chart(df).mark_circle().encode(\n    x='a', y='b', size='c', color='c', tooltip=['a', 'b', 'c'])\n\n<line_mask>",
            "masked_line": "st._legacy_altair_chart(c, use_container_width=True)",
            "answer": "_legacy_altair_chart",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_804"
        },
        {
            "dependency": "streamlit",
            "version": "==0.85.0",
            "time": "2021-07-22",
            "description": "This code generates random data frames, adds rows from a second data frame to the first one, creates a line chart using the first data frame, adds rows from the second data frame to the line chart, and finally creates a Vega-Lite line chart using the first data frame and adds rows from the second data frame to it.",
            "code": "df1 = pd.DataFrame(\n   np.random.randn(50, 20),\n   columns=('col %d' % i for i in range(20)))\n\nmy_table = st._legacy_table(df1)\n\ndf2 = pd.DataFrame(\n   np.random.randn(50, 20),\n   columns=('col %d' % i for i in range(20)))\n\nmy_table._legacy_add_rows(df2)\n\nmy_chart = st._legacy_line_chart(df1)\nmy_chart._legacy_add_rows(df2)\n\nmy_chart = st._legacy_vega_lite_chart({\n    'mark': 'line',\n    'encoding': {'x': 'a', 'y': 'b'},\n    'datasets': {\n        'some_fancy_name': df1,  # <-- named dataset\n    },\n    'data': {'name': 'some_fancy_name'},\n}),\nmy_chart._legacy_add_rows(some_fancy_name=df2)  # <-- name used as keyword\n",
            "masked_code": "df1 = pd.DataFrame(\n   np.random.randn(50, 20),\n   columns=('col %d' % i for i in range(20)))\n\nmy_table = st._legacy_table(df1)\n\ndf2 = pd.DataFrame(\n   np.random.randn(50, 20),\n   columns=('col %d' % i for i in range(20)))\n\n<line_mask>\n\nmy_chart = st._legacy_line_chart(df1)\nmy_chart._legacy_add_rows(df2)\n\nmy_chart = st._legacy_vega_lite_chart({\n    'mark': 'line',\n    'encoding': {'x': 'a', 'y': 'b'},\n    'datasets': {\n        'some_fancy_name': df1,  # <-- named dataset\n    },\n    'data': {'name': 'some_fancy_name'},\n}),\nmy_chart._legacy_add_rows(some_fancy_name=df2)  # <-- name used as keyword\n",
            "masked_line": "my_table._legacy_add_rows(df2)",
            "answer": "_legacy_add_rows",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_805"
        },
        {
            "dependency": "streamlit",
            "version": "==0.85.0",
            "time": "2021-07-22",
            "description": "The code generates two random DataFrames, adds rows from the second DataFrame to a table, creates a line chart with the first DataFrame, adds rows from the second DataFrame to the line chart, and finally creates a Vega-Lite line chart using both DataFrames as datasets.",
            "code": "df1 = pd.DataFrame(\n   np.random.randn(50, 20),\n   columns=('col %d' % i for i in range(20)))\n\ndf2 = pd.DataFrame(\n   np.random.randn(50, 20),\n   columns=('col %d' % i for i in range(20)))\n\nmy_table._arrow_add_rows(df2)\n\nmy_chart = st._arrow_line_chart(df1)\nmy_chart._arrow_add_rows(df2)\n\nmy_chart = st._arrow_vega_lite_chart({\n    'mark': 'line',\n    'encoding': {'x': 'a', 'y': 'b'},\n    'datasets': {\n      'some_fancy_name': df1,  # <-- named dataset\n     },\n    'data': {'name': 'some_fancy_name'},\n}),\nmy_chart._arrow_add_rows(some_fancy_name=df2)  # <-- name used as keyword",
            "masked_code": "df1 = pd.DataFrame(\n   np.random.randn(50, 20),\n   columns=('col %d' % i for i in range(20)))\n\ndf2 = pd.DataFrame(\n   np.random.randn(50, 20),\n   columns=('col %d' % i for i in range(20)))\n\nmy_table._arrow_add_rows(df2)\n\nmy_chart = st._arrow_line_chart(df1)\n<line_mask>\n\nmy_chart = st._arrow_vega_lite_chart({\n    'mark': 'line',\n    'encoding': {'x': 'a', 'y': 'b'},\n    'datasets': {\n      'some_fancy_name': df1,  # <-- named dataset\n     },\n    'data': {'name': 'some_fancy_name'},\n}),\nmy_chart._arrow_add_rows(some_fancy_name=df2)  # <-- name used as keyword",
            "masked_line": "my_chart._arrow_add_rows(df2)",
            "answer": "_arrow_add_rows",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_806"
        },
        {
            "dependency": "streamlit",
            "version": "==0.84.2",
            "time": "2021-07-19",
            "description": "The code checks if there is a Cache object 'c' available from the st module. If 'c' exists, data is fetched from a URL, cleaned up, and assigned to the 'data' attribute of 'c'.",
            "code": "c = st.Cache()\nif c:\n    # Fetch data from URL here, and then clean it up. Finally assign to c.\n    c.data = ...\n\nif c := st.Cache():\n    # Fetch data from URL here, and then clean it up. Finally assign to c.\n    c.data = ...",
            "masked_code": "c = st.Cache()\nif c:\n    # Fetch data from URL here, and then clean it up. Finally assign to c.\n    c.data = ...\n\n<line_mask>\n    # Fetch data from URL here, and then clean it up. Finally assign to c.\n    c.data = ...",
            "masked_line": "if c := st.Cache():",
            "answer": "Cache",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_807"
        },
        {
            "dependency": "streamlit",
            "version": "==0.84.2",
            "time": "2021-07-19",
            "description": "The code generates a scatter plot using Altair library, where the x-axis represents column 'a', y-axis represents column 'b', the size of the circles represents column 'c', the color of the circles also represents column 'c', and the tooltip shows values of columns 'a', 'b', and 'c'.",
            "code": "import pandas as pd\nimport numpy as np\nimport altair as alt\n\ndf = pd.DataFrame(\n    np.random.randn(200, 3),\n    columns=['a', 'b', 'c'])\n\nc = alt.Chart(df).mark_circle().encode(\n    x='a', y='b', size='c', color='c', tooltip=['a', 'b', 'c'])\n\nst.altair_chart(c, use_container_width=True)",
            "masked_code": "import pandas as pd\nimport numpy as np\nimport altair as alt\n\ndf = pd.DataFrame(\n    np.random.randn(200, 3),\n    columns=['a', 'b', 'c'])\n\nc = alt.Chart(df).mark_circle().encode(\n    x='a', y='b', size='c', color='c', tooltip=['a', 'b', 'c'])\n\n<line_mask>",
            "masked_line": "st.altair_chart(c, use_container_width=True)",
            "answer": "altair_chart",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_808"
        },
        {
            "dependency": "streamlit",
            "version": "==0.84.2",
            "time": "2021-07-19",
            "description": "The code generates two dataframes with random values and creates a table using one dataframe. It then adds rows from the second dataframe to the table. Next, it creates a line chart using the first dataframe and adds rows from the second dataframe to the chart. Lastly, it creates another line chart using vega-lite, assigns the first dataframe to a named dataset, and then adds rows from the second dataframe to the chart using the named dataset.",
            "code": "df1 = pd.DataFrame(\n    np.random.randn(50, 20),\n    columns=('col %d' % i for i in range(20)))\n\nmy_table = st.table(df1)\n\ndf2 = pd.DataFrame(\n    np.random.randn(50, 20),\n    columns=('col %d' % i for i in range(20)))\n\nmy_table.add_rows(df2)\n\nmy_chart = st.line_chart(df1)\nmy_chart.add_rows(df2)\n\nmy_chart = st.vega_lite_chart({\n    'mark': 'line',\n    'encoding': {'x': 'a', 'y': 'b'},\n    'datasets': {\n        'some_fancy_name': df1,  # <-- named dataset\n    },\n    'data': {'name': 'some_fancy_name'},\n}),\nmy_chart.add_rows(some_fancy_name=df2)  # <-- name used as keyword\n",
            "masked_code": "df1 = pd.DataFrame(\n    np.random.randn(50, 20),\n    columns=('col %d' % i for i in range(20)))\n\nmy_table = st.table(df1)\n\ndf2 = pd.DataFrame(\n    np.random.randn(50, 20),\n    columns=('col %d' % i for i in range(20)))\n\nmy_table.add_rows(df2)\n\nmy_chart = st.line_chart(df1)\nmy_chart.add_rows(df2)\n\nmy_chart = st.vega_lite_chart({\n    'mark': 'line',\n    'encoding': {'x': 'a', 'y': 'b'},\n    'datasets': {\n        'some_fancy_name': df1,  # <-- named dataset\n    },\n    'data': {'name': 'some_fancy_name'},\n}),\n<line_mask>\n",
            "masked_line": "my_chart.add_rows(some_fancy_name=df2)  # <-- name used as keyword",
            "answer": "add_rows",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_809"
        },
        {
            "dependency": "streamlit",
            "version": "==1.22.0",
            "time": "2023-04-27",
            "description": "The code connects to a Snowpark database using Streamlit, retrieves data from a table named \"mytable\", limits the data to 10 rows, converts it to a pandas dataframe, and displays the dataframe in Streamlit.",
            "code": "import streamlit as st\n\nconn = st.experimental_connection(\"snowpark\")\nwith conn.safe_session() as session:\n    df = session.table(\"mytable\").limit(10).to_pandas()\n\nst.dataframe(df)",
            "masked_code": "import streamlit as st\n\nconn = st.experimental_connection(\"snowpark\")\n<line_mask>\n    df = session.table(\"mytable\").limit(10).to_pandas()\n\nst.dataframe(df)",
            "masked_line": "with conn.safe_session() as session:",
            "answer": "safe_session",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_810"
        },
        {
            "dependency": "streamlit",
            "version": "==1.24.0",
            "time": "2023-06-27",
            "description": "The code displays chat messages with different users (\"user\" and \"assistant\") and shows random data in line chart and bar chart formats.",
            "code": "import streamlit as st\nimport numpy as np\n\nwith st.chat_message(\"user\"):\n    st.write(\"Hello \")\n    st.line_chart(np.random.randn(30, 3))\n\nimport streamlit as st\nimport numpy as np\n\nmessage = st.chat_message(\"assistant\")\nmessage.write(\"Hello human\")\nmessage.bar_chart(np.random.randn(30, 3))\n",
            "masked_code": "import streamlit as st\nimport numpy as np\n\n<line_mask>\n    st.write(\"Hello \")\n    st.line_chart(np.random.randn(30, 3))\n\nimport streamlit as st\nimport numpy as np\n\nmessage = st.chat_message(\"assistant\")\nmessage.write(\"Hello human\")\nmessage.bar_chart(np.random.randn(30, 3))\n",
            "masked_line": "with st.chat_message(\"user\"):",
            "answer": "chat_message",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_811"
        },
        {
            "dependency": "streamlit",
            "version": "==1.30.0",
            "time": "2024-01-11",
            "description": "The code allows the user to navigate between different pages within an application using buttons for \"Home\", \"Page 1\", and \"Page 2\". Each button triggers a page switch to a specific python file associated with that page.",
            "code": "if st.button(\"Home\"):\n    st.switch_page(\"your_app.py\")\nif st.button(\"Page 1\"):\n    st.switch_page(\"pages/page_1.py\")\nif st.button(\"Page 2\"):\n    st.switch_page(\"pages/page_2.py\")",
            "masked_code": "if st.button(\"Home\"):\n    st.switch_page(\"your_app.py\")\nif st.button(\"Page 1\"):\n    <line_mask>\nif st.button(\"Page 2\"):\n    st.switch_page(\"pages/page_2.py\")",
            "masked_line": "st.switch_page(\"pages/page_1.py\")",
            "answer": "switch_page",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_812"
        },
        {
            "dependency": "tensorboard",
            "version": "==1.13.0",
            "time": "2019-02-25",
            "description": "The code defines the functionality of merging two dimensions using the tf.Dimension class. The result of merging two dimensions is a new dimension object with the size of the merged dimensions. If one of the dimensions is None, the result will have the size of the other dimension. If the sizes of the two dimensions are not equal, a ValueError is raised.",
            "code": "tf.Dimension(n)   .merge_with(tf.Dimension(n))    == tf.Dimension(n)\ntf.Dimension(n)   .merge_with(tf.Dimension(None)) == tf.Dimension(n)\ntf.Dimension(None).merge_with(tf.Dimension(n))    == tf.Dimension(n)\ntf.Dimension(None).merge_with(tf.Dimension(None)) == tf.Dimension(None)\ntf.Dimension(n)   .merge_with(tf.Dimension(m))  # raises ValueError for n != m\n",
            "masked_code": "tf.Dimension(n)   .merge_with(tf.Dimension(n))    == tf.Dimension(n)\ntf.Dimension(n)   .merge_with(tf.Dimension(None)) == tf.Dimension(n)\ntf.Dimension(None).merge_with(tf.Dimension(n))    == tf.Dimension(n)\n<line_mask>\ntf.Dimension(n)   .merge_with(tf.Dimension(m))  # raises ValueError for n != m\n",
            "masked_line": "tf.Dimension(None).merge_with(tf.Dimension(None)) == tf.Dimension(None)",
            "answer": "merge_with",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_813"
        },
        {
            "dependency": "tensorboard",
            "version": "==2.2.2",
            "time": "2020-05-27",
            "description": "The code defines three functions, where function_1 and function_2 have a decorator log_latency applied to them, and function_3 contains a context manager log_latency.",
            "code": "@log_latency\ndef function_1():\n    pass\n\n@log_latency(\"custom_label\")\ndef function_2():\n    pass\n\ndef function_3():\n    with log_latency(\"region_within_function\"):\n        pass",
            "masked_code": "@log_latency\ndef function_1():\n    pass\n\n<line_mask>\ndef function_2():\n    pass\n\ndef function_3():\n    with log_latency(\"region_within_function\"):\n        pass",
            "masked_line": "@log_latency(\"custom_label\")",
            "answer": "log_latency",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_814"
        },
        {
            "dependency": "tensorboardX",
            "version": "==1.7",
            "time": "2019-05-20",
            "description": "This code generates a histogram of dummy data values, calculates the sum of squares of the values, and writes the histogram data along with summary statistics to a file using a SummaryWriter object.",
            "code": "import numpy as np\ndummy_data = []\nfor idx, value in enumerate(range(30)):\n    dummy_data += [idx + 0.001] * value\nvalues = np.array(dummy_data).astype(float).reshape(-1)\ncounts, limits = np.histogram(values)\nsum_sq = values.dot(values)\nwith SummaryWriter() as summary_writer:\n    summary_writer.add_histogram_raw(\n            tag='hist_dummy_data',\n            min=values.min(),\n            max=values.max(),\n            num=len(values),\n            sum=values.sum(),\n            sum_squares=sum_sq,\n            bucket_limits=limits[1:].tolist(),\n            bucket_counts=counts.tolist(),\n            global_step=0)",
            "masked_code": "import numpy as np\ndummy_data = []\nfor idx, value in enumerate(range(30)):\n    dummy_data += [idx + 0.001] * value\nvalues = np.array(dummy_data).astype(float).reshape(-1)\ncounts, limits = np.histogram(values)\nsum_sq = values.dot(values)\nwith SummaryWriter() as summary_writer:\n    <line_mask>\n            tag='hist_dummy_data',\n            min=values.min(),\n            max=values.max(),\n            num=len(values),\n            sum=values.sum(),\n            sum_squares=sum_sq,\n            bucket_limits=limits[1:].tolist(),\n            bucket_counts=counts.tolist(),\n            global_step=0)",
            "masked_line": "summary_writer.add_histogram_raw(",
            "answer": "add_histogram_raw",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_815"
        },
        {
            "dependency": "tensorboardX",
            "version": "==1.8",
            "time": "2019-07-04",
            "description": "This code generates a 3D mesh visualization using tensor data for vertices, colors, and faces, and saves it using TensorBoardX's SummaryWriter.",
            "code": "from tensorboardX import SummaryWriter\nvertices_tensor = np.array([[\n    [1, 1, 1],\n    [-1, -1, 1],\n    [1, -1, -1],\n    [-1, 1, -1],\n]], dtype=float)\ncolors_tensor = np.array([[\n    [255, 0, 0],\n    [0, 255, 0],\n    [0, 0, 255],\n    [255, 0, 255],\n]], dtype=int)\nfaces_tensor = np.array([[\n    [0, 2, 3],\n    [0, 3, 1],\n    [0, 1, 2],\n    [1, 3, 2],\n]], dtype=int)\n\nwriter = SummaryWriter()\nwriter.add_mesh('my_mesh', vertices=vertices_tensor, colors=colors_tensor, faces=faces_tensor)\n\nwriter.close()",
            "masked_code": "from tensorboardX import SummaryWriter\nvertices_tensor = np.array([[\n    [1, 1, 1],\n    [-1, -1, 1],\n    [1, -1, -1],\n    [-1, 1, -1],\n]], dtype=float)\ncolors_tensor = np.array([[\n    [255, 0, 0],\n    [0, 255, 0],\n    [0, 0, 255],\n    [255, 0, 255],\n]], dtype=int)\nfaces_tensor = np.array([[\n    [0, 2, 3],\n    [0, 3, 1],\n    [0, 1, 2],\n    [1, 3, 2],\n]], dtype=int)\n\nwriter = SummaryWriter()\n<line_mask>\n\nwriter.close()",
            "masked_line": "writer.add_mesh('my_mesh', vertices=vertices_tensor, colors=colors_tensor, faces=faces_tensor)",
            "answer": "add_mesh",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_816"
        },
        {
            "dependency": "tensorboardX",
            "version": "==2.1",
            "time": "2020-07-05",
            "description": "This code creates a global summary writer instance using the GlobalSummaryWriter class and adds text logs to it.",
            "code": "from tensorboardX import GlobalSummaryWriter\nwriter = GlobalSummaryWriter.getSummaryWriter()  # This creates a new instance.\nwriter.add_text('my_log', 'greeting from global1')\nwriter = GlobalSummaryWriter.getSummaryWriter()  # Get the instance in global1.py.\nwriter.add_text('my_log', 'greeting from global2')",
            "masked_code": "from tensorboardX import GlobalSummaryWriter\nwriter = GlobalSummaryWriter.getSummaryWriter()  # This creates a new instance.\nwriter.add_text('my_log', 'greeting from global1')\n<line_mask>\nwriter.add_text('my_log', 'greeting from global2')",
            "masked_line": "writer = GlobalSummaryWriter.getSummaryWriter()  # Get the instance in global1.py.",
            "answer": "getSummaryWriter",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_817"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.0.0",
            "time": "2017-02-11",
            "description": "The code defines a class `Affine` and creates instances of the `Affine` class with different parameters such as `shift`, `scale_identity_multiplier`, `scale_diag`, `scale_perturb_factor`, and `scale_perturb_diag`. It generates a matrix `scale` using these parameters and operations involving them.",
            "code": "scale = (\n  scale_identity_multiplier * tf.diag(tf.ones(d)) +\n  tf.diag(scale_diag) +\n  scale_tril +\n  scale_perturb_factor @ diag(scale_perturb_diag) @\n    tf.transpose([scale_perturb_factor])\n)\n\nb = Affine()\n\nb = Affine(shift=[1., 2, 3])\n\nb = Affine(shift=[1., 2, 3],\n           scale_identity_multiplier=2.)\n\nb = Affine(shift=[1., 2, 3],\n           scale_diag=[-1., 2, 1])\n\nb = Affine(shift=[1., 2, 3],\n           scale_perturb_factor=[[1., 0],\n                                 [0, 1],\n                                 [1, 1]])\n\nb = Affine(shift=[1., 2, 3],\n           scale_diag=[1., 3, 3],\n           scale_perturb_diag=[2., 1],\n           scale_perturb_factor=[[1., 0],\n                                 [0, 1],\n                                 [1, 1]])\n",
            "masked_code": "scale = (\n  scale_identity_multiplier * tf.diag(tf.ones(d)) +\n  tf.diag(scale_diag) +\n  scale_tril +\n  scale_perturb_factor @ diag(scale_perturb_diag) @\n    tf.transpose([scale_perturb_factor])\n)\n\nb = Affine()\n\nb = Affine(shift=[1., 2, 3])\n\nb = Affine(shift=[1., 2, 3],\n           scale_identity_multiplier=2.)\n\nb = Affine(shift=[1., 2, 3],\n           scale_diag=[-1., 2, 1])\n\nb = Affine(shift=[1., 2, 3],\n           scale_perturb_factor=[[1., 0],\n                                 [0, 1],\n                                 [1, 1]])\n\n<line_mask>\n           scale_diag=[1., 3, 3],\n           scale_perturb_diag=[2., 1],\n           scale_perturb_factor=[[1., 0],\n                                 [0, 1],\n                                 [1, 1]])\n",
            "masked_line": "b = Affine(shift=[1., 2, 3],",
            "answer": "Affine",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_818"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.0.0",
            "time": "2017-02-11",
            "description": "The code creates a linear operator that behaves like a 10 x 2 x 2 matrix. It then solves linear systems for batches of length 10. It first solves one linear system (R=1) for every member of the batch with a RHS of shape 10 x 2 x 1. It then solves five linear systems (R=5) for every member of the batch with a RHS of shape 10 x 2 x 5. Finally, it accesses the solution to the linear system at index 3 for the third column of the RHS.",
            "code": "# Create an operator acting like a 10 x 2 x 2 matrix.\noperator = LinearOperator(...)\noperator.shape # = 10 x 2 x 2\n\n# Solve one linear system (R = 1) for every member of the length 10 batch.\nRHS = ... # shape 10 x 2 x 1\nX = operator.solve(RHS)  # shape 10 x 2 x 1\n\n# Solve five linear systems (R = 5) for every member of the length 10 batch.\nRHS = ... # shape 10 x 2 x 5\nX = operator.solve(RHS)\nX[3, :, 2]  # Solution to the linear system A[3, :, :] X = RHS[3, :, 2]\n",
            "masked_code": "# Create an operator acting like a 10 x 2 x 2 matrix.\noperator = LinearOperator(...)\noperator.shape # = 10 x 2 x 2\n\n# Solve one linear system (R = 1) for every member of the length 10 batch.\nRHS = ... # shape 10 x 2 x 1\nX = operator.solve(RHS)  # shape 10 x 2 x 1\n\n# Solve five linear systems (R = 5) for every member of the length 10 batch.\nRHS = ... # shape 10 x 2 x 5\n<line_mask>\nX[3, :, 2]  # Solution to the linear system A[3, :, :] X = RHS[3, :, 2]\n",
            "masked_line": "X = operator.solve(RHS)",
            "answer": "solve",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_819"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.0.0",
            "time": "2017-02-11",
            "description": "The code parses examples from a BigQuery table with specified schema, reads and processes the data including features like name, age, and state.",
            "code": "# Assume a BigQuery has the following schema,\n#     name      STRING,\n#     age       INT,\n#     state     STRING\n\n# Create the parse_examples list of features.\nfeatures = dict(\n  name=tf.FixedLenFeature([1], tf.string),\n  age=tf.FixedLenFeature([1], tf.int32),\n  state=tf.FixedLenFeature([1], dtype=tf.string, default_value=\"UNK\"))\n\n# Create a Reader.\nreader = bigquery_reader_ops.BigQueryReader(project_id=PROJECT,\n                                            dataset_id=DATASET,\n                                            table_id=TABLE,\n                                            timestamp_millis=TIME,\n                                            num_partitions=NUM_PARTITIONS,\n                                            features=features)\n\n# Populate a queue with the BigQuery Table partitions.\nqueue = tf.training.string_input_producer(reader.partitions())\n\n# Read and parse examples.\nrow_id, examples_serialized = reader.read(queue)\nexamples = tf.parse_example(examples_serialized, features=features)\n\n# Process the Tensors examples[\"name\"], examples[\"age\"], etc...\n",
            "masked_code": "# Assume a BigQuery has the following schema,\n#     name      STRING,\n#     age       INT,\n#     state     STRING\n\n# Create the parse_examples list of features.\nfeatures = dict(\n  name=tf.FixedLenFeature([1], tf.string),\n  age=tf.FixedLenFeature([1], tf.int32),\n  state=tf.FixedLenFeature([1], dtype=tf.string, default_value=\"UNK\"))\n\n# Create a Reader.\n<line_mask>\n                                            dataset_id=DATASET,\n                                            table_id=TABLE,\n                                            timestamp_millis=TIME,\n                                            num_partitions=NUM_PARTITIONS,\n                                            features=features)\n\n# Populate a queue with the BigQuery Table partitions.\nqueue = tf.training.string_input_producer(reader.partitions())\n\n# Read and parse examples.\nrow_id, examples_serialized = reader.read(queue)\nexamples = tf.parse_example(examples_serialized, features=features)\n\n# Process the Tensors examples[\"name\"], examples[\"age\"], etc...\n",
            "masked_line": "reader = bigquery_reader_ops.BigQueryReader(project_id=PROJECT,",
            "answer": "BigQueryReader",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_820"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.0.0",
            "time": "2017-02-11",
            "description": "The code saves checkpoints and summaries during training with the SingularMonitoredSession, running the training operation until the session should stop.",
            "code": "saver_hook = CheckpointSaverHook(...)\nsummary_hook = SummaryHook(...)\nwith SingularMonitoredSession(hooks=[saver_hook, summary_hook]) as sess:\n  while not sess.should_stop():\n    sess.run(train_op)\n",
            "masked_code": "saver_hook = CheckpointSaverHook(...)\nsummary_hook = SummaryHook(...)\n<line_mask>\n  while not sess.should_stop():\n    sess.run(train_op)\n",
            "masked_line": "with SingularMonitoredSession(hooks=[saver_hook, summary_hook]) as sess:",
            "answer": "SingularMonitoredSession",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_821"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.0.0",
            "time": "2017-02-11",
            "description": "This code creates input data (`x` and `y`) for a machine learning model using numpy arrays, and then sets up a data input function for TensorFlow session with specific parameters (batch size, shuffle, num_epochs).",
            "code": "age = np.arange(4) * 1.0\nheight = np.arange(32, 36)\nx = {'age': age, 'height': height}\ny = np.arange(-32, -28)\n\nwith tf.Session() as session:\n  input_fn = numpy_io.numpy_input_fn(\n      x, y, batch_size=2, shuffle=False, num_epochs=1)\n",
            "masked_code": "age = np.arange(4) * 1.0\nheight = np.arange(32, 36)\nx = {'age': age, 'height': height}\ny = np.arange(-32, -28)\n\nwith tf.Session() as session:\n  <line_mask>\n      x, y, batch_size=2, shuffle=False, num_epochs=1)\n",
            "masked_line": "input_fn = numpy_io.numpy_input_fn(",
            "answer": "numpy_input_fn",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_822"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.0.0",
            "time": "2017-02-11",
            "description": "The code is creating a lookup table from a vocabulary file and converting a list of strings into their corresponding indices in the table.",
            "code": "features = tf.constant([\"emerson\", \"lake\", \"and\", \"palmer\"])\ntable = tf.contrib.lookup.string_to_index_table_from_file(\n    vocabulary_file=\"test.txt\", num_oov_buckets=1)\nids = table.lookup(features)\n...\ntf.tables_initializer().run()\n",
            "masked_code": "features = tf.constant([\"emerson\", \"lake\", \"and\", \"palmer\"])\n<line_mask>\n    vocabulary_file=\"test.txt\", num_oov_buckets=1)\nids = table.lookup(features)\n...\ntf.tables_initializer().run()\n",
            "masked_line": "table = tf.contrib.lookup.string_to_index_table_from_file(",
            "answer": "string_to_index_table_from_file",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_823"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.0.0",
            "time": "2017-02-11",
            "description": "This code initializes a variable `v` using TensorFlow, then loads new values into `v` and prints the updated values.",
            "code": "v = tf.Variable([1, 2])\ninit = tf.global_variables_initializer()\n\nwith tf.Session() as sess:\n    sess.run(init)\n    # Usage passing the session explicitly.\n    v.load([2, 3], sess)\n    print(v.eval(sess)) # prints [2 3]\n    # Usage with the default session.  The 'with' block\n    # above makes 'sess' the default session.\n    v.load([3, 4], sess)\n    print(v.eval()) # prints [3 4]\n",
            "masked_code": "v = tf.Variable([1, 2])\ninit = tf.global_variables_initializer()\n\nwith tf.Session() as sess:\n    sess.run(init)\n    # Usage passing the session explicitly.\n    v.load([2, 3], sess)\n    print(v.eval(sess)) # prints [2 3]\n    # Usage with the default session.  The 'with' block\n    # above makes 'sess' the default session.\n    <line_mask>\n    print(v.eval()) # prints [3 4]\n",
            "masked_line": "v.load([3, 4], sess)",
            "answer": "load",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_824"
        },
        {
            "dependency": "tensorflow",
            "version": "==0.12.0",
            "time": "2016-12-19",
            "description": "This code creates two variables 'v' and 'w' within the variable scope \"foo\" and then retrieves the variable 'v' within the same scope, with reuse enabled.",
            "code": "with tf.variable_scope(\"foo\"):\n    v = tf.get_variable(\"v\", [1])  # v.name == \"foo/v:0\"\n    w = tf.get_variable(\"w\", [1])  # w.name == \"foo/w:0\"\nwith tf.variable_scope(\"foo\", reuse=True):\n    v1 = tf.get_variable(\"v\")  # The same as v above.\n",
            "masked_code": "with tf.variable_scope(\"foo\"):\n    v = tf.get_variable(\"v\", [1])  # v.name == \"foo/v:0\"\n    w = tf.get_variable(\"w\", [1])  # w.name == \"foo/w:0\"\nwith tf.variable_scope(\"foo\", reuse=True):\n    <line_mask>\n",
            "masked_line": "v1 = tf.get_variable(\"v\")  # The same as v above.",
            "answer": "get_variable",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_825"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.1.0",
            "time": "2017-04-21",
            "description": "This code creates instances of the Logistic distribution using TensorFlow and calculates the cumulative distribution function, probability density function, and generates random samples from the distribution for different parameters.",
            "code": "dist = tf.contrib.distributions.Logistic(loc=0., scale=3.)\ndist.cdf(1.)\ndist = tf.contrib.distributions.Logistic(loc=[1, 2.], scale=[11, 22.])\ndist.prob([0, 1.5])\ndist.sample([3])\ndist = tf.contrib.distributions.Logistic(loc=1., scale=[11, 22.])\ndist.prob(3.0)\n",
            "masked_code": "<line_mask>\ndist.cdf(1.)\ndist = tf.contrib.distributions.Logistic(loc=[1, 2.], scale=[11, 22.])\ndist.prob([0, 1.5])\ndist.sample([3])\ndist = tf.contrib.distributions.Logistic(loc=1., scale=[11, 22.])\ndist.prob(3.0)\n",
            "masked_line": "dist = tf.contrib.distributions.Logistic(loc=0., scale=3.)",
            "answer": "Logistic",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_826"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.1.0",
            "time": "2017-04-21",
            "description": "The code creates instances of OneHotCategorical distribution using probabilities or logits, and then calculates the probability of given samples under the distribution.",
            "code": "p = [0.1, 0.5, 0.4]\ndist = OneHotCategorical(probs=p)\n\nlogits = [-2, 2, 0]\ndist = OneHotCategorical(logits=logits)\n\np = [0.1, 0.4, 0.5]\ndist = OneHotCategorical(probs=p)\ndist.prob([0,1,0])\n\nsamples = [[0,1,0], [1,0,0]]\ndist.prob(samples)\n",
            "masked_code": "p = [0.1, 0.5, 0.4]\n<line_mask>\n\nlogits = [-2, 2, 0]\ndist = OneHotCategorical(logits=logits)\n\np = [0.1, 0.4, 0.5]\ndist = OneHotCategorical(probs=p)\ndist.prob([0,1,0])\n\nsamples = [[0,1,0], [1,0,0]]\ndist.prob(samples)\n",
            "masked_line": "dist = OneHotCategorical(probs=p)",
            "answer": "OneHotCategorical",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_827"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.1.0",
            "time": "2017-04-21",
            "description": "The function of this code is to use LambdaCallback to print the batch number at the beginning of every batch, plot the loss after every epoch, and terminate some processes after finishing model training.",
            "code": "# Print the batch number at the beginning of every batch.\nbatch_print_callback = LambdaCallback(\n    on_batch_begin=lambda batch,logs: print(batch))\n\n# Plot the loss after every epoch.\nimport numpy as np\nimport matplotlib.pyplot as plt\nplot_loss_callback = LambdaCallback(\n    on_epoch_end=lambda epoch, logs: plt.plot(np.arange(epoch),\n                                              logs['loss']))\n\n# Terminate some processes after having finished model training.\nprocesses = ...\ncleanup_callback = LambdaCallback(\n    on_train_end=lambda logs: [\n        p.terminate() for p in processes if p.is_alive()])\n\nmodel.fit(...,\n          callbacks=[batch_print_callback,\n                     plot_loss_callback,\n                     cleanup_callback])\n",
            "masked_code": "# Print the batch number at the beginning of every batch.\n<line_mask>\n    on_batch_begin=lambda batch,logs: print(batch))\n\n# Plot the loss after every epoch.\nimport numpy as np\nimport matplotlib.pyplot as plt\nplot_loss_callback = LambdaCallback(\n    on_epoch_end=lambda epoch, logs: plt.plot(np.arange(epoch),\n                                              logs['loss']))\n\n# Terminate some processes after having finished model training.\nprocesses = ...\ncleanup_callback = LambdaCallback(\n    on_train_end=lambda logs: [\n        p.terminate() for p in processes if p.is_alive()])\n\nmodel.fit(...,\n          callbacks=[batch_print_callback,\n                     plot_loss_callback,\n                     cleanup_callback])\n",
            "masked_line": "batch_print_callback = LambdaCallback(",
            "answer": "LambdaCallback",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_828"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.1.0",
            "time": "2017-04-21",
            "description": "The code creates a neural network model with two hidden layers, each containing 32 units, and an input layer with 500 input dimensions.",
            "code": "model = Sequential()\nmodel.add(Dense(32, input_dim=500))\nmodel.add(Dense(32))\n\nmodel = Sequential()\nmodel.add(Dense(32, input_shape=(500,)))\nmodel.add(Dense(32))\n\nmodel = Sequential()\nmodel.add(Dense(32, batch_input_shape=(None, 500)))\nmodel.add(Dense(32))\n",
            "masked_code": "model = Sequential()\nmodel.add(Dense(32, input_dim=500))\nmodel.add(Dense(32))\n\nmodel = Sequential()\nmodel.add(Dense(32, input_shape=(500,)))\nmodel.add(Dense(32))\n\n<line_mask>\nmodel.add(Dense(32, batch_input_shape=(None, 500)))\nmodel.add(Dense(32))\n",
            "masked_line": "model = Sequential()",
            "answer": "Sequential",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_829"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.1.0",
            "time": "2017-04-21",
            "description": "This function performs antirectification on the input data by subtracting the mean along axis 1, normalizing using L2 norm along axis 1, and then splitting the data into positive and negative parts before concatenating them back together.",
            "code": "def antirectifier(x):\n    x -= K.mean(x, axis=1, keepdims=True)\n    x = K.l2_normalize(x, axis=1)\n    pos = K.relu(x)\n    neg = K.relu(-x)\n    return K.concatenate([pos, neg], axis=1)\nmodel.add(Lambda(antirectifier))\n",
            "masked_code": "def antirectifier(x):\n    x -= K.mean(x, axis=1, keepdims=True)\n    x = K.l2_normalize(x, axis=1)\n    pos = K.relu(x)\n    neg = K.relu(-x)\n    return K.concatenate([pos, neg], axis=1)\n<line_mask>\n",
            "masked_line": "model.add(Lambda(antirectifier))",
            "answer": "Lambda",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_830"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.1.0",
            "time": "2017-04-21",
            "description": "The code defines a neural network model using two Bidirectional LSTM layers with 10 units each, followed by a Dense layer with 5 units and a softmax activation function. The model is compiled with a categorical crossentropy loss function and the RMSprop optimizer.",
            "code": "model = Sequential()\nmodel.add(Bidirectional(LSTM(10, return_sequences=True), input_shape=(5, 10)))\nmodel.add(Bidirectional(LSTM(10)))\nmodel.add(Dense(5))\nmodel.add(Activation('softmax'))\nmodel.compile(loss='categorical_crossentropy', optimizer='rmsprop')\n",
            "masked_code": "model = Sequential()\n<line_mask>\nmodel.add(Bidirectional(LSTM(10)))\nmodel.add(Dense(5))\nmodel.add(Activation('softmax'))\nmodel.compile(loss='categorical_crossentropy', optimizer='rmsprop')\n",
            "masked_line": "model.add(Bidirectional(LSTM(10, return_sequences=True), input_shape=(5, 10)))",
            "answer": "Bidirectional",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_831"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.1.0",
            "time": "2017-04-21",
            "description": "The code creates two placeholder tensors of shape (2, 2) with different sparsity settings, and then checks if each tensor is sparse or not.",
            "code": "from keras import backend as K\na = K.placeholder((2, 2), sparse=False)\nprint(K.is_sparse(a))\nFalse\nb = K.placeholder((2, 2), sparse=True)\nprint(K.is_sparse(b))\nTrue\n",
            "masked_code": "from keras import backend as K\na = K.placeholder((2, 2), sparse=False)\n<line_mask>\nFalse\nb = K.placeholder((2, 2), sparse=True)\nprint(K.is_sparse(b))\nTrue\n",
            "masked_line": "print(K.is_sparse(a))",
            "answer": "is_sparse",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_832"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.1.0",
            "time": "2017-04-21",
            "description": "This code creates a sparse tensor with shape (2, 2) using the Keras backend. It then checks if the tensor 'b' is sparse, converts it to a dense tensor and checks if the converted tensor 'c' is sparse.",
            "code": "from keras import backend as K\nb = K.placeholder((2, 2), sparse=True)\nprint(K.is_sparse(b))\nc = K.to_dense(b)\nprint(K.is_sparse(c))\n",
            "masked_code": "from keras import backend as K\nb = K.placeholder((2, 2), sparse=True)\nprint(K.is_sparse(b))\n<line_mask>\nprint(K.is_sparse(c))\n",
            "masked_line": "c = K.to_dense(b)",
            "answer": "to_dense",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_833"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.1.0",
            "time": "2017-04-21",
            "description": "This code snippet creates a placeholder tensor with shape (2, 4, 5) using the Keras backend, then initializes a variable tensor with values [[1, 2], [3, 4]] using the same backend.",
            "code": "from keras import backend as K\ninput = K.placeholder(shape=(2, 4, 5))\nK.int_shape(input)\nval = np.array([[1, 2], [3, 4]])\nkvar = K.variable(value=val)\nK.int_shape(kvar)\n",
            "masked_code": "from keras import backend as K\ninput = K.placeholder(shape=(2, 4, 5))\n<line_mask>\nval = np.array([[1, 2], [3, 4]])\nkvar = K.variable(value=val)\nK.int_shape(kvar)\n",
            "masked_line": "K.int_shape(input)",
            "answer": "int_shape",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_834"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.1.0",
            "time": "2017-04-21",
            "description": "The code defines and checks the data type of placeholders and variables in a Keras backend.",
            "code": "from keras import backend as K\nK.dtype(K.placeholder(shape=(2,4,5)))\nK.dtype(K.placeholder(shape=(2,4,5), dtype='float32'))\nK.dtype(K.placeholder(shape=(2,4,5), dtype='float64'))\nkvar = K.variable(np.array([[1, 2], [3, 4]]))\nK.dtype(kvar)\nkvar = K.variable(np.array([[1, 2], [3, 4]]), dtype='float32')\nK.dtype(kvar)\n",
            "masked_code": "from keras import backend as K\nK.dtype(K.placeholder(shape=(2,4,5)))\nK.dtype(K.placeholder(shape=(2,4,5), dtype='float32'))\n<line_mask>\nkvar = K.variable(np.array([[1, 2], [3, 4]]))\nK.dtype(kvar)\nkvar = K.variable(np.array([[1, 2], [3, 4]]), dtype='float32')\nK.dtype(kvar)\n",
            "masked_line": "K.dtype(K.placeholder(shape=(2,4,5), dtype='float64'))",
            "answer": "dtype",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_835"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.1.0",
            "time": "2017-04-21",
            "description": "The code creates a table for looking up the indexes of words in a vocabulary file, then uses the table to lookup the indexes of the words \"emerson\", \"lake\", \"and\", and \"palmer\" in the vocabulary file. Finally, it initializes the table.",
            "code": "features = tf.constant([\"emerson\", \"lake\", \"and\", \"palmer\"])\ntable = tf.contrib.lookup.index_table_from_file(\n    vocabulary_file=\"test.txt\", num_oov_buckets=1)\nids = table.lookup(features)\n...\ntf.tables_initializer().run()\n",
            "masked_code": "features = tf.constant([\"emerson\", \"lake\", \"and\", \"palmer\"])\n<line_mask>\n    vocabulary_file=\"test.txt\", num_oov_buckets=1)\nids = table.lookup(features)\n...\ntf.tables_initializer().run()\n",
            "masked_line": "table = tf.contrib.lookup.index_table_from_file(",
            "answer": "index_table_from_file",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_836"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.10.0",
            "time": "2018-08-07",
            "description": "The code fetches image data, labels, and bounding boxes from a Bigtable named \"my_table\" with keys prefixed by \"imagenet\". It then processes the image data by parsing and cropping it. Finally, the processed data is batched into training samples.",
            "code": "table = bigtable_client.table(\"my_table\")\nkey_dataset = table.get_keys_prefix(\"imagenet\")\nimages = key_dataset.apply(table.lookup_columns((\"cf1\", \"image\"),\n                                                (\"cf2\", \"label\"),\n                                                (\"cf2\", \"boundingbox\")))\ntraining_data = images.map(parse_and_crop, num_parallel_calls=64).batch(128)\n\ntable = bigtable_client.table(\"my_table\")\nkey_dataset = table.get_keys_prefix(\"imagenet\")\nimages = key_dataset.apply(table.lookup_columns(\n    cf1=\"image\", cf2=(\"label\", \"boundingbox\")))\ntraining_data = images.map(parse_and_crop, num_parallel_calls=64).batch(128)",
            "masked_code": "table = bigtable_client.table(\"my_table\")\nkey_dataset = table.get_keys_prefix(\"imagenet\")\n<line_mask>\n                                                (\"cf2\", \"label\"),\n                                                (\"cf2\", \"boundingbox\")))\ntraining_data = images.map(parse_and_crop, num_parallel_calls=64).batch(128)\n\ntable = bigtable_client.table(\"my_table\")\nkey_dataset = table.get_keys_prefix(\"imagenet\")\nimages = key_dataset.apply(table.lookup_columns(\n    cf1=\"image\", cf2=(\"label\", \"boundingbox\")))\ntraining_data = images.map(parse_and_crop, num_parallel_calls=64).batch(128)",
            "masked_line": "images = key_dataset.apply(table.lookup_columns((\"cf1\", \"image\"),",
            "answer": "lookup_columns",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_837"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.10.0",
            "time": "2018-08-07",
            "description": "The code defines bijectors and constructs a transformed distribution using TensorFlow Probability. The ScaleTriL bijector is used with different parameters such as Exp, Identity, and a Chain of bijectors including AffineScalar and Softplus. The TransformedDistribution is created with a Normal distribution transformed by CholeskyOuterProduct and ScaleTriL bijectors.",
            "code": "tfb = tf.contrib.distributions.bijectors\nb = tfb.ScaleTriL(\n     diag_bijector=tfb.Exp(),\n     diag_shift=None)\nb.forward(x=[0., 0., 0.])\nb.inverse(y=[[1., 0],\n             [.5, 2]])\ndist = tfd.TransformedDistribution(\n        tfd.Normal(tf.zeros(6), tf.ones(6)),\n        tfb.Chain([tfb.CholeskyOuterProduct(), tfb.ScaleTriL()]))\nb = tfb.ScaleTriL(\n     diag_bijector=tfb.Identity(),\n     diag_shift=None)\nb = tfb.ScaleTriL(\n     diag_bijector=tfb.Chain([\n       tfb.AffineScalar(shift=1e-3),\n       tfb.Softplus(),\n       tfb.AffineScalar(shift=0.5413)]),\n     diag_shift=None)",
            "masked_code": "tfb = tf.contrib.distributions.bijectors\n<line_mask>\n     diag_bijector=tfb.Exp(),\n     diag_shift=None)\nb.forward(x=[0., 0., 0.])\nb.inverse(y=[[1., 0],\n             [.5, 2]])\ndist = tfd.TransformedDistribution(\n        tfd.Normal(tf.zeros(6), tf.ones(6)),\n        tfb.Chain([tfb.CholeskyOuterProduct(), tfb.ScaleTriL()]))\nb = tfb.ScaleTriL(\n     diag_bijector=tfb.Identity(),\n     diag_shift=None)\nb = tfb.ScaleTriL(\n     diag_bijector=tfb.Chain([\n       tfb.AffineScalar(shift=1e-3),\n       tfb.Softplus(),\n       tfb.AffineScalar(shift=0.5413)]),\n     diag_shift=None)",
            "masked_line": "b = tfb.ScaleTriL(",
            "answer": "ScaleTriL",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_838"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.12.1",
            "time": "2019-04-18",
            "description": "The code initializes a sampling process using an initial set of arguments and tensors. It then iterates over time steps, generating sample IDs based on cell output and state. At each time step, it updates the sampling process and generates the next inputs, state, and a boolean flag indicating if the process has finished.",
            "code": "sampler = Sampler(init_args)\n(initial_finished, initial_inputs) = sampler.initialize(input_tensors)\nfor time_step in range(time):\n  cell_output, cell_state = cell.call(cell_input, previous_state)\n  sample_ids = sampler.sample(time_step, cell_output, cell_state)\n  (finished, next_inputs, next_state) = sampler.next_inputs(\n      time_step,cell_output, cell_state)",
            "masked_code": "<line_mask>\n(initial_finished, initial_inputs) = sampler.initialize(input_tensors)\nfor time_step in range(time):\n  cell_output, cell_state = cell.call(cell_input, previous_state)\n  sample_ids = sampler.sample(time_step, cell_output, cell_state)\n  (finished, next_inputs, next_state) = sampler.next_inputs(\n      time_step,cell_output, cell_state)",
            "masked_line": "sampler = Sampler(init_args)",
            "answer": "Sampler",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_839"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.12.1",
            "time": "2019-04-18",
            "description": "This code snippet implements a while loop where the value of 'n' decrements by 1 in each iteration until it reaches 0, and the variable 's' is assigned the value of 'n'.",
            "code": "while n > 0:\n    n = n - 1\n    s = n\n\ns = Undefined('s')\ninit_state = (s,)\ns = while_loop(cond, body, init_state)\n",
            "masked_code": "while n > 0:\n    n = n - 1\n    s = n\n\n<line_mask>\ninit_state = (s,)\ns = while_loop(cond, body, init_state)\n",
            "masked_line": "s = Undefined('s')",
            "answer": "Undefined",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_840"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.12.1",
            "time": "2019-04-18",
            "description": "The code generates a range of numbers based on the provided parameters. The range starts from the first parameter (inclusive), ends at the second parameter (exclusive), and increments by the third parameter if provided. If the increment is negative, the range counts down instead of up. If the parameters are not valid to generate a range, an empty list is returned.",
            "code": "Dataset.range(5) == [0, 1, 2, 3, 4]\nDataset.range(2, 5) == [2, 3, 4]\nDataset.range(1, 5, 2) == [1, 3]\nDataset.range(1, 5, -2) == []\nDataset.range(5, 1) == []\nDataset.range(5, 1, -2) == [5, 3]\n",
            "masked_code": "Dataset.range(5) == [0, 1, 2, 3, 4]\nDataset.range(2, 5) == [2, 3, 4]\nDataset.range(1, 5, 2) == [1, 3]\nDataset.range(1, 5, -2) == []\nDataset.range(5, 1) == []\n<line_mask>\n",
            "masked_line": "Dataset.range(5, 1, -2) == [5, 3]",
            "answer": "range",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_841"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.12.1",
            "time": "2019-04-18",
            "description": "The code generates a function that zips together multiple sets of elements into tuples based on the corresponding index positions. It can zip two sets, three sets, or combinations of sets containing integers and tuples.",
            "code": "a = { 1, 2, 3 }\nb = { 4, 5, 6 }\nc = { (7, 8), (9, 10), (11, 12) }\nd = { 13, 14 }\n\nDataset.zip((a, b)) == { (1, 4), (2, 5), (3, 6) }\nDataset.zip((b, a)) == { (4, 1), (5, 2), (6, 3) }\n\nDataset.zip((a, b, c)) == { (1, 4, (7, 8)),\n                            (2, 5, (9, 10)),\n                            (3, 6, (11, 12)) }\n\nDataset.zip((a, d)) == { (1, 13), (2, 14) }\n",
            "masked_code": "a = { 1, 2, 3 }\nb = { 4, 5, 6 }\nc = { (7, 8), (9, 10), (11, 12) }\nd = { 13, 14 }\n\nDataset.zip((a, b)) == { (1, 4), (2, 5), (3, 6) }\nDataset.zip((b, a)) == { (4, 1), (5, 2), (6, 3) }\n\n<line_mask>\n                            (2, 5, (9, 10)),\n                            (3, 6, (11, 12)) }\n\nDataset.zip((a, d)) == { (1, 13), (2, 14) }\n",
            "masked_line": "Dataset.zip((a, b, c)) == { (1, 4, (7, 8)),",
            "answer": "zip",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_842"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.12.1",
            "time": "2019-04-18",
            "description": "The code filters a TensorFlow dataset to keep only elements less than 3, then further filters the dataset to keep only elements equal to 1.",
            "code": "d = tf.data.Dataset.from_tensor_slices([1, 2, 3])\n\nd = d.filter(lambda x: x < 3) # [1, 2]\n\n# `tf.math.equal(x, y)` is required for equality comparison\ndef filter_fn(x):\n  return tf.math.equal(x, 1)\n\nd = d.filter(filter_fn) # [1]\n",
            "masked_code": "d = tf.data.Dataset.from_tensor_slices([1, 2, 3])\n\n<line_mask>\n\n# `tf.math.equal(x, y)` is required for equality comparison\ndef filter_fn(x):\n  return tf.math.equal(x, 1)\n\nd = d.filter(filter_fn) # [1]\n",
            "masked_line": "d = d.filter(lambda x: x < 3) # [1, 2]",
            "answer": "filter",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_843"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.12.1",
            "time": "2019-04-18",
            "description": "The code creates a mirrored strategy for distributing training data across multiple GPUs. It then creates a dataset with numbers from 0 to 9 and batches them into groups of 2. The dataset is distributed using the mirrored strategy. Finally, the code iterates over the distributed dataset, running a train step function on each batch of data using the strategy's experimental_run_v2 method.",
            "code": "strategy = tf.distribute.MirroredStrategy()\n\n# Create a dataset\ndataset = dataset_ops.Dataset.range(10).batch(2)\n\n# Distribute that dataset\ndist_dataset = strategy.experimental_distribute_dataset(dataset)\n# Iterate over the distributed dataset\nfor x in dist_dataset:\n  # process dataset elements\n  strategy.experimental_run_v2(train_step, args=(x,))\n",
            "masked_code": "strategy = tf.distribute.MirroredStrategy()\n\n# Create a dataset\ndataset = dataset_ops.Dataset.range(10).batch(2)\n\n# Distribute that dataset\n<line_mask>\n# Iterate over the distributed dataset\nfor x in dist_dataset:\n  # process dataset elements\n  strategy.experimental_run_v2(train_step, args=(x,))\n",
            "masked_line": "dist_dataset = strategy.experimental_distribute_dataset(dataset)",
            "answer": "experimental_distribute_dataset",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_844"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.12.1",
            "time": "2019-04-18",
            "description": "This code defines an input function that creates a dataset with a batch size based on input context, shards the dataset based on input context parameters, and then uses a distributed strategy to run a replica function on the dataset iterator.",
            "code": "\ndef input_fn(input_context):\n  batch_size = input_context.get_per_replica_batch_size(global_batch_size)\n  d = tf.data.Dataset.from_tensors([[1.]]).repeat().batch(batch_size)\n  return d.shard(input_context.num_input_pipelines,\n                 input_context.input_pipeline_id)\nwith strategy.scope():\n  iterator = strategy.make_input_fn_iterator(input_fn)\n  replica_results = strategy.experimental_run(replica_fn, iterator)\n",
            "masked_code": "\ndef input_fn(input_context):\n  batch_size = input_context.get_per_replica_batch_size(global_batch_size)\n  d = tf.data.Dataset.from_tensors([[1.]]).repeat().batch(batch_size)\n  return d.shard(input_context.num_input_pipelines,\n                 input_context.input_pipeline_id)\nwith strategy.scope():\n  <line_mask>\n  replica_results = strategy.experimental_run(replica_fn, iterator)\n",
            "masked_line": "iterator = strategy.make_input_fn_iterator(input_fn)",
            "answer": "make_input_fn_iterator",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_845"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.12.1",
            "time": "2019-04-18",
            "description": "The code defines a variable \"v\" using tensorflow, and checks if the variable was created within a specific scope defined by the strategy object. The first block of code returns True because the variable was indeed created within the scope, while the second block of code returns False because the variable was created outside of the scope.",
            "code": "with strategy.scope():\n    v = tf.Variable(1.)\nstrategy.variable_created_in_scope(v)\nTrue\n\nv = tf.Variable(1.)\nstrategy.variable_created_in_scope(v)\nFalse",
            "masked_code": "with strategy.scope():\n    v = tf.Variable(1.)\n<line_mask>\nTrue\n\nv = tf.Variable(1.)\nstrategy.variable_created_in_scope(v)\nFalse",
            "masked_line": "strategy.variable_created_in_scope(v)",
            "answer": "variable_created_in_scope",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_846"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.12.2",
            "time": "2019-04-18",
            "description": "The code creates a DNNClassifier using TensorFlow and trains it using the provided training input function. It also uses an InMemoryEvaluatorHook to evaluate the model using the evaluation input function during training.",
            "code": "def train_input_fn():\n  ...\n  return train_dataset\n\ndef eval_input_fn():\n  ...\n  return eval_dataset\n\nestimator = tf.estimator.DNNClassifier(...)\n\nevaluator = tf.contrib.estimator.InMemoryEvaluatorHook(\n    estimator, eval_input_fn)\nestimator.train(train_input_fn, hooks=[evaluator])\n",
            "masked_code": "def train_input_fn():\n  ...\n  return train_dataset\n\ndef eval_input_fn():\n  ...\n  return eval_dataset\n\nestimator = tf.estimator.DNNClassifier(...)\n\n<line_mask>\n    estimator, eval_input_fn)\nestimator.train(train_input_fn, hooks=[evaluator])\n",
            "masked_line": "evaluator = tf.contrib.estimator.InMemoryEvaluatorHook(",
            "answer": "InMemoryEvaluatorHook",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_847"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.2.0",
            "time": "2017-06-14",
            "description": "The code calculates the specified percentile value for the input array, with different interpolation methods and axis selections for multidimensional arrays.",
            "code": "# Get 30th percentile with default ('nearest') interpolation.\nx = [1., 2., 3., 4.]\npercentile(x, q=30.)\n\n# Get 30th percentile with 'lower' interpolation\nx = [1., 2., 3., 4.]\npercentile(x, q=30., interpolation='lower')\n\n# Get 100th percentile (maximum).  By default, this is computed over every dim\nx = [[1., 2.]\n     [3., 4.]]\npercentile(x, q=100.)\n\n# Treat the leading dim as indexing samples, and find the 100th quantile (max)\n# over all such samples.\nx = [[1., 2.]\n     [3., 4.]]\npercentile(x, q=100., axis=[0])\n",
            "masked_code": "# Get 30th percentile with default ('nearest') interpolation.\nx = [1., 2., 3., 4.]\n<line_mask>\n\n# Get 30th percentile with 'lower' interpolation\nx = [1., 2., 3., 4.]\npercentile(x, q=30., interpolation='lower')\n\n# Get 100th percentile (maximum).  By default, this is computed over every dim\nx = [[1., 2.]\n     [3., 4.]]\npercentile(x, q=100.)\n\n# Treat the leading dim as indexing samples, and find the 100th quantile (max)\n# over all such samples.\nx = [[1., 2.]\n     [3., 4.]]\npercentile(x, q=100., axis=[0])\n",
            "masked_line": "percentile(x, q=30.)",
            "answer": "percentile",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_848"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.2.0",
            "time": "2017-06-14",
            "description": "The code generates a random dot stereogram image from the input image array using TensorFlow.",
            "code": "img=[[1,2,3,3,2,1],\n     [1,2,3,4,5,2],\n     [1,2,3,4,5,3],\n     [1,2,3,4,5,4],\n     [6,5,4,4,5,5]]\nsession = tf.InteractiveSession()\nsirds = single_image_random_dot_stereograms(\n    img,\n    convergence_dots_size=8,\n    number_colors=256,normalize=True)\n\nout = sirds.eval()\npng = tf.image.encode_png(out).eval()\nwith open('picture_out.png', 'wb') as f:\n  f.write(png)\n",
            "masked_code": "img=[[1,2,3,3,2,1],\n     [1,2,3,4,5,2],\n     [1,2,3,4,5,3],\n     [1,2,3,4,5,4],\n     [6,5,4,4,5,5]]\nsession = tf.InteractiveSession()\n<line_mask>\n    img,\n    convergence_dots_size=8,\n    number_colors=256,normalize=True)\n\nout = sirds.eval()\npng = tf.image.encode_png(out).eval()\nwith open('picture_out.png', 'wb') as f:\n  f.write(png)\n",
            "masked_line": "sirds = single_image_random_dot_stereograms(",
            "answer": "single_image_random_dot_stereograms",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_849"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.2.0",
            "time": "2017-06-14",
            "description": "This code generates a dataset with 10 samples, each sample containing random values for 'height', 'age' and 'label'. The generated dataset is then used to create an input function for a TensorFlow session with specified batch size, shuffle behavior, and number of epochs.",
            "code": "def generator():\n    for index in range(10):\n        yield {'height': np.random.randint(32,36),\n               'age': np.random.randint(18, 80),\n               'label': np.ones(1)}\n\nwith tf.Session() as session:\n    input_fn = generator_io.generator_input_fn(\n        generator, target_key=\"label\", batch_size=2, shuffle=False,\n        num_epochs=1)\n",
            "masked_code": "def generator():\n    for index in range(10):\n        yield {'height': np.random.randint(32,36),\n               'age': np.random.randint(18, 80),\n               'label': np.ones(1)}\n\nwith tf.Session() as session:\n    <line_mask>\n        generator, target_key=\"label\", batch_size=2, shuffle=False,\n        num_epochs=1)\n",
            "masked_line": "input_fn = generator_io.generator_input_fn(",
            "answer": "generator_input_fn",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_850"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.2.0",
            "time": "2017-06-14",
            "description": "This code performs feature engineering by creating a bucketized version of the 'price' feature and then using it as input for a linear model to make predictions.",
            "code": "price = numeric_column('price')\ncolumns = [price, ...]\nfeatures = tf.parse_example(..., features=make_parse_example_spec(columns))\ndense_tensor = input_layer(features, columns)\n\nbucketized_price = bucketized_column(price, boundaries=[...])\ncolumns = [bucketized_price, ...]\nfeatures = tf.parse_example(..., features=make_parse_example_spec(columns))\nlinear_prediction = linear_model(features, columns)\n",
            "masked_code": "<line_mask>\ncolumns = [price, ...]\nfeatures = tf.parse_example(..., features=make_parse_example_spec(columns))\ndense_tensor = input_layer(features, columns)\n\nbucketized_price = bucketized_column(price, boundaries=[...])\ncolumns = [bucketized_price, ...]\nfeatures = tf.parse_example(..., features=make_parse_example_spec(columns))\nlinear_prediction = linear_model(features, columns)\n",
            "masked_line": "price = numeric_column('price')",
            "answer": "numeric_column",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_851"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.2.0",
            "time": "2017-06-14",
            "description": "The code defines a categorical column 'colors' with a vocabulary list and default value, creates a feature column list including 'colors', parses features using 'make_parse_example_spec', and generates linear predictions using a linear model. Then, it creates embedding columns for 'colors' and other columns, parses features again, and generates a dense tensor using the input layer.",
            "code": "colors = categorical_column_with_vocabulary_list(\n    key='colors', vocabulary_list=('X', 'R', 'G', 'B', 'Y'), default_value=0)\ncolumns = [colors, ...]\nfeatures = tf.parse_example(..., features=make_parse_example_spec(columns))\nlinear_prediction, _, _ = linear_model(features, columns)\n\ncolumns = [embedding_column(colors, 3),...]\nfeatures = tf.parse_example(..., features=make_parse_example_spec(columns))\ndense_tensor = input_layer(features, columns)\n",
            "masked_code": "<line_mask>\n    key='colors', vocabulary_list=('X', 'R', 'G', 'B', 'Y'), default_value=0)\ncolumns = [colors, ...]\nfeatures = tf.parse_example(..., features=make_parse_example_spec(columns))\nlinear_prediction, _, _ = linear_model(features, columns)\n\ncolumns = [embedding_column(colors, 3),...]\nfeatures = tf.parse_example(..., features=make_parse_example_spec(columns))\ndense_tensor = input_layer(features, columns)\n",
            "masked_line": "colors = categorical_column_with_vocabulary_list(",
            "answer": "categorical_column_with_vocabulary_list",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_852"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.2.0",
            "time": "2017-06-14",
            "description": "This code snippet prepares input data for a linear model and an embedding layer for a neural network model in TensorFlow.",
            "code": "video_id = categorical_column_with_identity(\n    key='video_id', num_buckets=1000000, default_value=0)\ncolumns = [video_id, ...]\nfeatures = tf.parse_example(..., features=make_parse_example_spec(columns))\nlinear_prediction, _, _ = linear_model(features, columns)\n\ncolumns = [embedding_column(video_id, 9),...]\nfeatures = tf.parse_example(..., features=make_parse_example_spec(columns))\ndense_tensor = input_layer(features, columns)\n",
            "masked_code": "<line_mask>\n    key='video_id', num_buckets=1000000, default_value=0)\ncolumns = [video_id, ...]\nfeatures = tf.parse_example(..., features=make_parse_example_spec(columns))\nlinear_prediction, _, _ = linear_model(features, columns)\n\ncolumns = [embedding_column(video_id, 9),...]\nfeatures = tf.parse_example(..., features=make_parse_example_spec(columns))\ndense_tensor = input_layer(features, columns)\n",
            "masked_line": "video_id = categorical_column_with_identity(",
            "answer": "categorical_column_with_identity",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_853"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.2.0",
            "time": "2017-06-14",
            "description": "This code snippet creates a linear model for making predictions using weighted categorical features.",
            "code": "categorical_column = categorical_column_with_hash_bucket(\n    column_name='terms', hash_bucket_size=1000)\nweighted_column = weighted_categorical_column(\n    categorical_column=categorical_column, weight_feature_key='frequencies')\ncolumns = [weighted_column, ...]\nfeatures = tf.parse_example(..., features=make_parse_example_spec(columns))\nlinear_prediction, _, _ = linear_model(features, columns)\n",
            "masked_code": "categorical_column = categorical_column_with_hash_bucket(\n    column_name='terms', hash_bucket_size=1000)\n<line_mask>\n    categorical_column=categorical_column, weight_feature_key='frequencies')\ncolumns = [weighted_column, ...]\nfeatures = tf.parse_example(..., features=make_parse_example_spec(columns))\nlinear_prediction, _, _ = linear_model(features, columns)\n",
            "masked_line": "weighted_column = weighted_categorical_column(",
            "answer": "weighted_categorical_column",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_854"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.2.0",
            "time": "2017-06-14",
            "description": "The code generates a sequence of numbers based on the given parameters.",
            "code": "Dataset.range(5)\nDataset.range(2, 5)\nDataset.range(1, 5, 2)\nDataset.range(1, 5, -2)\nDataset.range(5, 1)\nDataset.range(5, 1, -2)",
            "masked_code": "Dataset.range(5)\nDataset.range(2, 5)\nDataset.range(1, 5, 2)\nDataset.range(1, 5, -2)\n<line_mask>\nDataset.range(5, 1, -2)",
            "masked_line": "Dataset.range(5, 1)",
            "answer": "range",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_855"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.2.0",
            "time": "2017-06-14",
            "description": "This code defines a function called `range` in a class called `Dataset`, which generates a list of numbers based on the input parameters. The function can generate a list of numbers starting from a specified start value (defaulting to 0 if not provided) up to but not including a specified end value, with an optional step value provided to determine the spacing between numbers in the list. If the step value is negative, the function generates an empty list.",
            "code": "Dataset.range(5) == [0, 1, 2, 3, 4]\nDataset.range(2, 5) == [2, 3, 4]\nDataset.range(1, 5, 2) == [1, 3]\nDataset.range(1, 5, -2) == []\nDataset.range(5, 1) == []\nDataset.range(5, 1, -2) == [5, 3]\n",
            "masked_code": "Dataset.range(5) == [0, 1, 2, 3, 4]\nDataset.range(2, 5) == [2, 3, 4]\nDataset.range(1, 5, 2) == [1, 3]\nDataset.range(1, 5, -2) == []\n<line_mask>\nDataset.range(5, 1, -2) == [5, 3]\n",
            "masked_line": "Dataset.range(5, 1) == []",
            "answer": "range",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_856"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.3.0",
            "time": "2017-08-17",
            "description": "The code defines and initializes a VectorExponential distribution with specific parameters for single and batch observations in a multi-variate space. It then computes the probability density function of the given observations and returns the result as a scalar or vector depending on the input shape.",
            "code": "ds = tf.contrib.distributions\nla = tf.contrib.linalg\n\n# Initialize a single 2-variate VectorExponential, supported on\n# {(x, y) in R^2 : x > 0, y > 0}.\n\n# The first component has pdf exp{-x}, the second 0.5 exp{-x / 2}\nvex = ds.VectorExponentialDiag(scale_diag=[1., 2.])\n\n# Compute the pdf of an`R^2` observation; return a scalar.\nvex.prob([3., 4.]).eval()  # shape: []\n\n# Initialize a 2-batch of 3-variate Vector Exponential's.\nloc = [[1., 2, 3],\n       [1., 0, 0]]              # shape: [2, 3]\nscale_diag = [[1., 2, 3],\n              [0.5, 1, 1.5]]     # shape: [2, 3]\n\nvex = ds.VectorExponentialDiag(loc, scale_diag)\n\n# Compute the pdf of two `R^3` observations; return a length-2 vector.\nx = [[1.9, 2.2, 3.1],\n     [10., 1.0, 9.0]]     # shape: [2, 3]\nvex.prob(x).eval()    # shape: [2]\n",
            "masked_code": "ds = tf.contrib.distributions\nla = tf.contrib.linalg\n\n# Initialize a single 2-variate VectorExponential, supported on\n# {(x, y) in R^2 : x > 0, y > 0}.\n\n# The first component has pdf exp{-x}, the second 0.5 exp{-x / 2}\nvex = ds.VectorExponentialDiag(scale_diag=[1., 2.])\n\n# Compute the pdf of an`R^2` observation; return a scalar.\nvex.prob([3., 4.]).eval()  # shape: []\n\n# Initialize a 2-batch of 3-variate Vector Exponential's.\nloc = [[1., 2, 3],\n       [1., 0, 0]]              # shape: [2, 3]\nscale_diag = [[1., 2, 3],\n              [0.5, 1, 1.5]]     # shape: [2, 3]\n\n<line_mask>\n\n# Compute the pdf of two `R^3` observations; return a length-2 vector.\nx = [[1.9, 2.2, 3.1],\n     [10., 1.0, 9.0]]     # shape: [2, 3]\nvex.prob(x).eval()    # shape: [2]\n",
            "masked_line": "vex = ds.VectorExponentialDiag(loc, scale_diag)",
            "answer": "VectorExponentialDiag",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_857"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.3.0",
            "time": "2017-08-17",
            "description": "The code initializes VectorExponential distributions with different parameters and computes the probability density function (pdf) of observations based on the specified distribution parameters.",
            "code": "ds = tf.contrib.distributions\nla = tf.contrib.linalg\n\n# Initialize a single 2-variate VectorExponential, supported on\n# {(x, y) in R^2 : x > 0, y > 0}.\nmat = [[1.0, 0.1],\n       [0.1, 1.0]]\n\nvex = ds.VectorExponentialLinearOperator(\n    scale=la.LinearOperatorFullMatrix(mat))\n\n# Compute the pdf of an`R^2` observation; return a scalar.\nvex.prob([1., 2.]).eval()  # shape: []\n\n# Initialize a 2-batch of 3-variate Vector Exponential's.\nmu = [[1., 2, 3],\n      [1., 0, 0]]              # shape: [2, 3]\nscale_diag = [[1., 2, 3],\n              [0.5, 1, 1.5]]     # shape: [2, 3]\n\nvex = ds.VectorExponentialLinearOperator(\n    loc=mu,\n    scale=la.LinearOperatorDiag(scale_diag))\n\n# Compute the pdf of two `R^3` observations; return a length-2 vector.\nx = [[1.9, 2.2, 3.1],\n     [10., 1.0, 9.0]]     # shape: [2, 3]\nvex.prob(x).eval()    # shape: [2]\n",
            "masked_code": "ds = tf.contrib.distributions\nla = tf.contrib.linalg\n\n# Initialize a single 2-variate VectorExponential, supported on\n# {(x, y) in R^2 : x > 0, y > 0}.\nmat = [[1.0, 0.1],\n       [0.1, 1.0]]\n\n<line_mask>\n    scale=la.LinearOperatorFullMatrix(mat))\n\n# Compute the pdf of an`R^2` observation; return a scalar.\nvex.prob([1., 2.]).eval()  # shape: []\n\n# Initialize a 2-batch of 3-variate Vector Exponential's.\nmu = [[1., 2, 3],\n      [1., 0, 0]]              # shape: [2, 3]\nscale_diag = [[1., 2, 3],\n              [0.5, 1, 1.5]]     # shape: [2, 3]\n\nvex = ds.VectorExponentialLinearOperator(\n    loc=mu,\n    scale=la.LinearOperatorDiag(scale_diag))\n\n# Compute the pdf of two `R^3` observations; return a length-2 vector.\nx = [[1.9, 2.2, 3.1],\n     [10., 1.0, 9.0]]     # shape: [2, 3]\nvex.prob(x).eval()    # shape: [2]\n",
            "masked_line": "vex = ds.VectorExponentialLinearOperator(",
            "answer": "VectorExponentialLinearOperator",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_858"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.3.0",
            "time": "2017-08-17",
            "description": "The code creates a DebugClassifier object and defines input functions for training and evaluation. It fits the model using the training data, evaluates the cross entropy loss using the evaluation data, predicts the most commonly seen class in training data, and outputs the class distribution from the training data for new samples.",
            "code": "# Build DebugClassifier\nclassifier = DebugClassifier()\n\n# Input builders\ndef input_fn_train(): # returns x, y (where y represents label's class index).\n  pass\n\ndef input_fn_eval(): # returns x, y (where y represents label's class index).\n  pass\n\n# Fit model.\nclassifier.fit(input_fn=input_fn_train)\n\n# Evaluate cross entropy between the test and train labels.\nloss = classifier.evaluate(input_fn=input_fn_eval)[\"loss\"]\n\n# predict_class outputs the most commonly seen class in training.\npredicted_label = classifier.predict_class(new_samples)\n\n# predict_proba outputs the class distribution from training.\nlabel_distribution = classifier.predict_proba(new_samples)\n",
            "masked_code": "# Build DebugClassifier\n<line_mask>\n\n# Input builders\ndef input_fn_train(): # returns x, y (where y represents label's class index).\n  pass\n\ndef input_fn_eval(): # returns x, y (where y represents label's class index).\n  pass\n\n# Fit model.\nclassifier.fit(input_fn=input_fn_train)\n\n# Evaluate cross entropy between the test and train labels.\nloss = classifier.evaluate(input_fn=input_fn_eval)[\"loss\"]\n\n# predict_class outputs the most commonly seen class in training.\npredicted_label = classifier.predict_class(new_samples)\n\n# predict_proba outputs the class distribution from training.\nlabel_distribution = classifier.predict_proba(new_samples)\n",
            "masked_line": "classifier = DebugClassifier()",
            "answer": "DebugClassifier",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_859"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.3.0",
            "time": "2017-08-17",
            "description": "The code builds a DebugRegressor model, defines input builders for training and evaluation data, fits the model using the training data, evaluates the squared-loss between the test and train targets, and predicts target scores based on new samples using the trained model.",
            "code": "# Build DebugRegressor\nregressor = DebugRegressor()\n\n# Input builders\ndef input_fn_train(): # returns x, y (where y represents label's class index).\n  pass\n\ndef input_fn_eval(): # returns x, y (where y represents label's class index).\n  pass\n\n# Fit model.\nregressor.fit(input_fn=input_fn_train)\n\n# Evaluate squared-loss between the test and train targets.\nloss = regressor.evaluate(input_fn=input_fn_eval)[\"loss\"]\n\n# predict_scores outputs mean value seen during training.\npredicted_targets = regressor.predict_scores(new_samples)\n",
            "masked_code": "# Build DebugRegressor\n<line_mask>\n\n# Input builders\ndef input_fn_train(): # returns x, y (where y represents label's class index).\n  pass\n\ndef input_fn_eval(): # returns x, y (where y represents label's class index).\n  pass\n\n# Fit model.\nregressor.fit(input_fn=input_fn_train)\n\n# Evaluate squared-loss between the test and train targets.\nloss = regressor.evaluate(input_fn=input_fn_eval)[\"loss\"]\n\n# predict_scores outputs mean value seen during training.\npredicted_targets = regressor.predict_scores(new_samples)\n",
            "masked_line": "regressor = DebugRegressor()",
            "answer": "DebugRegressor",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_860"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.4.0",
            "time": "2017-11-01",
            "description": "The code defines two independent distributions: \n1. The first independent distribution is a 2-dimensional normal distribution with loc [-1., 1] and scale [0.1, 0.5], where all batch dimensions have been absorbed into the event dimensions.\n2. The second independent distribution is a 2-dimensional bivariate normal distribution with loc [[-1., 1], [1, -1]] and scale_identity_multiplier [1., 0.5], where all batch dimensions have been absorbed into the event dimensions.",
            "code": "ds = tf.contrib.distributions\n\n# Make independent distribution from a 2-batch Normal.\nind = ds.Independent(\n    distribution=ds.Normal(loc=[-1., 1], scale=[0.1, 0.5]),\n    reduce_batch_ndims=1)\n\n# All batch dims have been \"absorbed\" into event dims.\nind.batch_shape  # ==> []\nind.event_shape  # ==> [2]\n\n# Make independent distribution from a 2-batch bivariate Normal.\nind = ds.Independent(\n    distribution=ds.MultivariateNormalDiag(\n        loc=[[-1., 1], [1, -1]],\n        scale_identity_multiplier=[1., 0.5]),\n    reduce_batch_ndims=1)\n\n# All batch dims have been \"absorbed\" into event dims.\nind.batch_shape  # ==> []\nind.event_shape  # ==> [2, 2]\n",
            "masked_code": "ds = tf.contrib.distributions\n\n# Make independent distribution from a 2-batch Normal.\nind = ds.Independent(\n    distribution=ds.Normal(loc=[-1., 1], scale=[0.1, 0.5]),\n    reduce_batch_ndims=1)\n\n# All batch dims have been \"absorbed\" into event dims.\nind.batch_shape  # ==> []\nind.event_shape  # ==> [2]\n\n# Make independent distribution from a 2-batch bivariate Normal.\n<line_mask>\n    distribution=ds.MultivariateNormalDiag(\n        loc=[[-1., 1], [1, -1]],\n        scale_identity_multiplier=[1., 0.5]),\n    reduce_batch_ndims=1)\n\n# All batch dims have been \"absorbed\" into event dims.\nind.batch_shape  # ==> []\nind.event_shape  # ==> [2, 2]\n",
            "masked_line": "ind = ds.Independent(",
            "answer": "Independent",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_861"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.7.0",
            "time": "2018-03-29",
            "description": "The code saves and restores checkpoint files for a model during training using TensorFlow's eager execution mode.",
            "code": "import tensorflow as tf\nimport tensorflow.contrib.eager as tfe\nimport os\n\ncheckpoint_directory = \"/tmp/training_checkpoints\"\ncheckpoint_prefix = os.path.join(checkpoint_directory, \"ckpt\")\n\nroot = tfe.Checkpoint(optimizer=optimizer, model=model)\nroot.restore(tf.train.latest_checkpoint(checkpoint_directory))\nfor _ in range(num_training_steps):\n  optimizer.minimize( ... )\nroot.save(file_prefix=checkpoint_prefix)\n",
            "masked_code": "import tensorflow as tf\nimport tensorflow.contrib.eager as tfe\nimport os\n\ncheckpoint_directory = \"/tmp/training_checkpoints\"\ncheckpoint_prefix = os.path.join(checkpoint_directory, \"ckpt\")\n\n<line_mask>\nroot.restore(tf.train.latest_checkpoint(checkpoint_directory))\nfor _ in range(num_training_steps):\n  optimizer.minimize( ... )\nroot.save(file_prefix=checkpoint_prefix)\n",
            "masked_line": "root = tfe.Checkpoint(optimizer=optimizer, model=model)",
            "answer": "Checkpoint",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_862"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.7.0",
            "time": "2018-03-29",
            "description": "This code snippet creates a rating sequence numeric column and a watches sequence categorical column with an identity mapping function. It then creates an embedding layer for the watches column with a dimension of 10. The code defines a list of columns and uses them to parse examples and create a feature input layer for a Recurrent Neural Network (RNN). Finally, it sets up an RNN cell with a basic RNN cell type and uses it to perform dynamic RNN computation on the input sequence data.",
            "code": "rating = sequence_numeric_column('rating')\nwatches = sequence_categorical_column_with_identity(\n    'watches', num_buckets=1000)\nwatches_embedding = embedding_column(watches, dimension=10)\ncolumns = [rating, watches]\n\nfeatures = tf.parse_example(..., features=make_parse_example_spec(columns))\ninput_layer, sequence_length = sequence_input_layer(features, columns)\n\nrnn_cell = tf.nn.rnn_cell.BasicRNNCell(hidden_size)\noutputs, state = tf.nn.dynamic_rnn(\n    rnn_cell, inputs=input_layer, sequence_length=sequence_length)\n",
            "masked_code": "rating = sequence_numeric_column('rating')\nwatches = sequence_categorical_column_with_identity(\n    'watches', num_buckets=1000)\nwatches_embedding = embedding_column(watches, dimension=10)\ncolumns = [rating, watches]\n\nfeatures = tf.parse_example(..., features=make_parse_example_spec(columns))\n<line_mask>\n\nrnn_cell = tf.nn.rnn_cell.BasicRNNCell(hidden_size)\noutputs, state = tf.nn.dynamic_rnn(\n    rnn_cell, inputs=input_layer, sequence_length=sequence_length)\n",
            "masked_line": "input_layer, sequence_length = sequence_input_layer(features, columns)",
            "answer": "sequence_input_layer",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_863"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.7.0",
            "time": "2018-03-29",
            "description": "The code constructs a sequence input layer for a recurrent neural network (RNN) model in TensorFlow. It creates a sequence categorical column with identity for watches data, creates an embedding column for watches data with a dimension of 10, and constructs a list of columns including the watches embedding. It then parses the input data using a specified parse example specification with the columns, creates a sequence input layer using the parsed features and columns, sets up a basic RNN cell with a specified hidden size, and runs the dynamic RNN operation with the RNN cell, input layer, and sequence lengths to generate outputs and states.",
            "code": "watches = sequence_categorical_column_with_identity(\n    'watches', num_buckets=1000)\nwatches_embedding = embedding_column(watches, dimension=10)\ncolumns = [watches_embedding]\n\nfeatures = tf.parse_example(..., features=make_parse_example_spec(columns))\ninput_layer, sequence_length = sequence_input_layer(features, columns)\n\nrnn_cell = tf.nn.rnn_cell.BasicRNNCell(hidden_size)\noutputs, state = tf.nn.dynamic_rnn(\n    rnn_cell, inputs=input_layer, sequence_length=sequence_length)",
            "masked_code": "<line_mask>\n    'watches', num_buckets=1000)\nwatches_embedding = embedding_column(watches, dimension=10)\ncolumns = [watches_embedding]\n\nfeatures = tf.parse_example(..., features=make_parse_example_spec(columns))\ninput_layer, sequence_length = sequence_input_layer(features, columns)\n\nrnn_cell = tf.nn.rnn_cell.BasicRNNCell(hidden_size)\noutputs, state = tf.nn.dynamic_rnn(\n    rnn_cell, inputs=input_layer, sequence_length=sequence_length)",
            "masked_line": "watches = sequence_categorical_column_with_identity(",
            "answer": "sequence_categorical_column_with_identity",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_864"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.7.0",
            "time": "2018-03-29",
            "description": "The code performs token embedding for a categorical sequence column using a hash bucket, creates an input layer and sequence length for a neural network model, defines a recurrent neural network cell with a specified hidden size, and runs dynamic RNN on the input data to get outputs and final state.",
            "code": "tokens = sequence_categorical_column_with_hash_bucket(\n    'tokens', hash_bucket_size=1000)\ntokens_embedding = embedding_column(tokens, dimension=10)\ncolumns = [tokens_embedding]\n\nfeatures = tf.parse_example(..., features=make_parse_example_spec(columns))\ninput_layer, sequence_length = sequence_input_layer(features, columns)\n\nrnn_cell = tf.nn.rnn_cell.BasicRNNCell(hidden_size)\noutputs, state = tf.nn.dynamic_rnn(\n    rnn_cell, inputs=input_layer, sequence_length=sequence_length)",
            "masked_code": "<line_mask>\n    'tokens', hash_bucket_size=1000)\ntokens_embedding = embedding_column(tokens, dimension=10)\ncolumns = [tokens_embedding]\n\nfeatures = tf.parse_example(..., features=make_parse_example_spec(columns))\ninput_layer, sequence_length = sequence_input_layer(features, columns)\n\nrnn_cell = tf.nn.rnn_cell.BasicRNNCell(hidden_size)\noutputs, state = tf.nn.dynamic_rnn(\n    rnn_cell, inputs=input_layer, sequence_length=sequence_length)",
            "masked_line": "tokens = sequence_categorical_column_with_hash_bucket(",
            "answer": "sequence_categorical_column_with_hash_bucket",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_865"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.7.0",
            "time": "2018-03-29",
            "description": "This code implements a sequence model using a Basic RNN cell in TensorFlow. It first creates a categorical column 'states' with a vocabulary file containing state names, then embeds this categorical column using a 10-dimensional embedding. The input features are parsed using the specified columns, and a sequence input layer is created. Finally, a Basic RNN cell is initialized with a specified hidden size, and the dynamic RNN function is used to process the input data through the RNN cell, generating outputs and state.",
            "code": "states = sequence_categorical_column_with_vocabulary_file(\n    key='states', vocabulary_file='/us/states.txt', vocabulary_size=50,\n    num_oov_buckets=5)\nstates_embedding = embedding_column(states, dimension=10)\ncolumns = [states_embedding]\n\nfeatures = tf.parse_example(..., features=make_parse_example_spec(columns))\ninput_layer, sequence_length = sequence_input_layer(features, columns)\n\nrnn_cell = tf.nn.rnn_cell.BasicRNNCell(hidden_size)\noutputs, state = tf.nn.dynamic_rnn(\n    rnn_cell, inputs=input_layer, sequence_length=sequence_length)\n",
            "masked_code": "<line_mask>\n    key='states', vocabulary_file='/us/states.txt', vocabulary_size=50,\n    num_oov_buckets=5)\nstates_embedding = embedding_column(states, dimension=10)\ncolumns = [states_embedding]\n\nfeatures = tf.parse_example(..., features=make_parse_example_spec(columns))\ninput_layer, sequence_length = sequence_input_layer(features, columns)\n\nrnn_cell = tf.nn.rnn_cell.BasicRNNCell(hidden_size)\noutputs, state = tf.nn.dynamic_rnn(\n    rnn_cell, inputs=input_layer, sequence_length=sequence_length)\n",
            "masked_line": "states = sequence_categorical_column_with_vocabulary_file(",
            "answer": "sequence_categorical_column_with_vocabulary_file",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_866"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.7.0",
            "time": "2018-03-29",
            "description": "The code creates an RNN model using TensorFlow to process input sequences of categorical colors encoded as strings (R, G, B, Y) with the given vocabulary list. It uses a BasicRNNCell with a specified hidden size to process the input sequences and produce output states.",
            "code": "colors = sequence_categorical_column_with_vocabulary_list(\n    key='colors', vocabulary_list=('R', 'G', 'B', 'Y'),\n    num_oov_buckets=2)\ncolors_embedding = embedding_column(colors, dimension=3)\ncolumns = [colors_embedding]\n\nfeatures = tf.parse_example(..., features=make_parse_example_spec(columns))\ninput_layer, sequence_length = sequence_input_layer(features, columns)\n\nrnn_cell = tf.nn.rnn_cell.BasicRNNCell(hidden_size)\noutputs, state = tf.nn.dynamic_rnn(\n    rnn_cell, inputs=input_layer, sequence_length=sequence_length)\n",
            "masked_code": "<line_mask>\n    key='colors', vocabulary_list=('R', 'G', 'B', 'Y'),\n    num_oov_buckets=2)\ncolors_embedding = embedding_column(colors, dimension=3)\ncolumns = [colors_embedding]\n\nfeatures = tf.parse_example(..., features=make_parse_example_spec(columns))\ninput_layer, sequence_length = sequence_input_layer(features, columns)\n\nrnn_cell = tf.nn.rnn_cell.BasicRNNCell(hidden_size)\noutputs, state = tf.nn.dynamic_rnn(\n    rnn_cell, inputs=input_layer, sequence_length=sequence_length)\n",
            "masked_line": "colors = sequence_categorical_column_with_vocabulary_list(",
            "answer": "sequence_categorical_column_with_vocabulary_list",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_867"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.7.0",
            "time": "2018-03-29",
            "description": "The code initializes a sequence categorical column named 'watches' with 1000 buckets, creates a sequence embedding column with a dimension of 10 for 'watches', and sets 'watches' as a column. It then parses the example features using the column specification, creates a sequence input layer using the features and columns, defines a BasicRNNCell with a specified hidden size, and performs dynamic RNN computation using the input layer and sequence lengths to generate outputs and states.",
            "code": "watches = sequence_categorical_column_with_identity(\n    'watches', num_buckets=1000)\nwatches_embedding = _sequence_embedding_column(watches, dimension=10)\ncolumns = [watches]\n\nfeatures = tf.parse_example(..., features=make_parse_example_spec(columns))\ninput_layer, sequence_length = sequence_input_layer(features, columns)\n\nrnn_cell = tf.nn.rnn_cell.BasicRNNCell(hidden_size)\noutputs, state = tf.nn.dynamic_rnn(\n    rnn_cell, inputs=input_layer, sequence_length=sequence_length)\n",
            "masked_code": "watches = sequence_categorical_column_with_identity(\n    'watches', num_buckets=1000)\n<line_mask>\ncolumns = [watches]\n\nfeatures = tf.parse_example(..., features=make_parse_example_spec(columns))\ninput_layer, sequence_length = sequence_input_layer(features, columns)\n\nrnn_cell = tf.nn.rnn_cell.BasicRNNCell(hidden_size)\noutputs, state = tf.nn.dynamic_rnn(\n    rnn_cell, inputs=input_layer, sequence_length=sequence_length)\n",
            "masked_line": "watches_embedding = _sequence_embedding_column(watches, dimension=10)",
            "answer": "_sequence_embedding_column",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_868"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.7.0",
            "time": "2018-03-29",
            "description": "The code performs sequence processing using a basic RNN cell in TensorFlow. It creates a categorical column for colors with a specified vocabulary list, creates an indicator column for the colors, and then parses the input features according to the specified columns. Finally, it constructs a dynamic RNN model with the specified RNN cell and input layer.",
            "code": "colors = sequence_categorical_column_with_vocabulary_list(\n    key='colors', vocabulary_list=('R', 'G', 'B', 'Y'))\ncolors_indicator = _sequence_indicator_column(colors)\ncolumns = [colors]\n\nfeatures = tf.parse_example(..., features=make_parse_example_spec(columns))\ninput_layer, sequence_length = sequence_input_layer(features, columns)\n\nrnn_cell = tf.nn.rnn_cell.BasicRNNCell(hidden_size)\noutputs, state = tf.nn.dynamic_rnn(\n    rnn_cell, inputs=input_layer, sequence_length=sequence_length)\n",
            "masked_code": "colors = sequence_categorical_column_with_vocabulary_list(\n    key='colors', vocabulary_list=('R', 'G', 'B', 'Y'))\n<line_mask>\ncolumns = [colors]\n\nfeatures = tf.parse_example(..., features=make_parse_example_spec(columns))\ninput_layer, sequence_length = sequence_input_layer(features, columns)\n\nrnn_cell = tf.nn.rnn_cell.BasicRNNCell(hidden_size)\noutputs, state = tf.nn.dynamic_rnn(\n    rnn_cell, inputs=input_layer, sequence_length=sequence_length)\n",
            "masked_line": "colors_indicator = _sequence_indicator_column(colors)",
            "answer": "_sequence_indicator_column",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_869"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.7.0",
            "time": "2018-03-29",
            "description": "This code creates a simple RNN model in TensorFlow for sequence data, where the temperature data is used as input features. The RNN cell used is BasicRNNCell with a specified hidden size. The code processes the input sequence data through the RNN cell and outputs the final state of the RNN and the output sequence.",
            "code": "temperature = sequence_numeric_column('temperature')\ncolumns = [temperature]\n\nfeatures = tf.parse_example(..., features=make_parse_example_spec(columns))\ninput_layer, sequence_length = sequence_input_layer(features, columns)\n\nrnn_cell = tf.nn.rnn_cell.BasicRNNCell(hidden_size)\noutputs, state = tf.nn.dynamic_rnn(\n    rnn_cell, inputs=input_layer, sequence_length=sequence_length)",
            "masked_code": "<line_mask>\ncolumns = [temperature]\n\nfeatures = tf.parse_example(..., features=make_parse_example_spec(columns))\ninput_layer, sequence_length = sequence_input_layer(features, columns)\n\nrnn_cell = tf.nn.rnn_cell.BasicRNNCell(hidden_size)\noutputs, state = tf.nn.dynamic_rnn(\n    rnn_cell, inputs=input_layer, sequence_length=sequence_length)",
            "masked_line": "temperature = sequence_numeric_column('temperature')",
            "answer": "sequence_numeric_column",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_870"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.8.0",
            "time": "2018-04-27",
            "description": "The functions generate random numbers from a beta distribution using TensorFlow's random gamma functions and return the ratio of two randomly generated gamma variables.",
            "code": "def broken_beta(shape, alpha, beta, seed):\n  x = tf.random_gamma(shape, alpha, seed=seed)\n  y = tf.random_gamma(shape, beta, seed=seed)\n  return x / (x + y)\n\ndef random_beta(shape, alpha, beta, seed):        \n  seed = SeedStream(seed, salt=\"random_beta\")     \n  x = tf.random_gamma(shape, alpha, seed=seed())  \n  y = tf.random_gamma(shape, beta, seed=seed())   \n  return x / (x + y)\n",
            "masked_code": "def broken_beta(shape, alpha, beta, seed):\n  x = tf.random_gamma(shape, alpha, seed=seed)\n  y = tf.random_gamma(shape, beta, seed=seed)\n  return x / (x + y)\n\ndef random_beta(shape, alpha, beta, seed):        \n  <line_mask>\n  x = tf.random_gamma(shape, alpha, seed=seed())  \n  y = tf.random_gamma(shape, beta, seed=seed())   \n  return x / (x + y)\n",
            "masked_line": "seed = SeedStream(seed, salt=\"random_beta\")",
            "answer": "SeedStream",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_872"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.8.0",
            "time": "2018-04-27",
            "description": "This code generates time series data and targets in batches using the TimeseriesGenerator class. It creates batches of input-output pairs with a specified length, sampling rate, and batch size. The generated data batches are then accessed and verified for correctness.",
            "code": "from keras.preprocessing.sequence import TimeseriesGenerator\nimport numpy as np\n\ndata = np.array([[i] for i in range(50)])\ntargets = np.array([[i] for i in range(50)])\n\ndata_gen = TimeseriesGenerator(data, targets,\n                               length=10, sampling_rate=2,\n                               batch_size=2)\nassert len(data_gen) == 20\n\nbatch_0 = data_gen[0]\nx, y = batch_0\nassert np.array_equal(x,\n                      np.array([[[0], [2], [4], [6], [8]],\n                                [[1], [3], [5], [7], [9]]]))\nassert np.array_equal(y,\n                      np.array([[10], [11]]))\n",
            "masked_code": "from keras.preprocessing.sequence import TimeseriesGenerator\nimport numpy as np\n\ndata = np.array([[i] for i in range(50)])\ntargets = np.array([[i] for i in range(50)])\n\n<line_mask>\n                               length=10, sampling_rate=2,\n                               batch_size=2)\nassert len(data_gen) == 20\n\nbatch_0 = data_gen[0]\nx, y = batch_0\nassert np.array_equal(x,\n                      np.array([[[0], [2], [4], [6], [8]],\n                                [[1], [3], [5], [7], [9]]]))\nassert np.array_equal(y,\n                      np.array([[10], [11]]))\n",
            "masked_line": "data_gen = TimeseriesGenerator(data, targets,",
            "answer": "TimeseriesGenerator",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_873"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.9.0",
            "time": "2018-07-09",
            "description": "The code defines a class `SlotManager` that inherits from `tf.contrib.checkpoint.Checkpointable`. Within the class, it initializes a unique name tracker named `slotdeps` and creates several variables with unique names using the `slotdeps.track` method. Each variable is assigned a value and a unique name.",
            "code": "class SlotManager(tf.contrib.checkpoint.Checkpointable):\n\n  def __init__(self):\n    # Create a dependency named \"slotdeps\" on the container.\n    self.slotdeps = tf.contrib.checkpoint.UniqueNameTracker()\n    slotdeps = self.slotdeps\n    slots = []\n    slots.append(slotdeps.track(tfe.Variable(3.), \"x\"))  # Named \"x\"\n    slots.append(slotdeps.track(tfe.Variable(4.), \"y\"))\n    slots.append(slotdeps.track(tfe.Variable(5.), \"x\"))  # Named \"x_1\"\n",
            "masked_code": "class SlotManager(tf.contrib.checkpoint.Checkpointable):\n\n  def __init__(self):\n    # Create a dependency named \"slotdeps\" on the container.\n    <line_mask>\n    slotdeps = self.slotdeps\n    slots = []\n    slots.append(slotdeps.track(tfe.Variable(3.), \"x\"))  # Named \"x\"\n    slots.append(slotdeps.track(tfe.Variable(4.), \"y\"))\n    slots.append(slotdeps.track(tfe.Variable(5.), \"x\"))  # Named \"x_1\"\n",
            "masked_line": "self.slotdeps = tf.contrib.checkpoint.UniqueNameTracker()",
            "answer": "UniqueNameTracker",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_874"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.9.0",
            "time": "2018-07-09",
            "description": "The code trains a TensorFlow Estimator model continuously until a stopping condition is met, evaluating the model's performance on an evaluation dataset after each training iteration. If a custom stopping condition is met, the training loop terminates.",
            "code": "est = tf.estimator.Estimator(model_fn)\nwhile True:\n  est.train(\n      train_input_fn,\n      hooks=[tf.contrib.data.CheckpointInputPipelineHook(est)],\n      steps=train_steps_per_eval)\n  # Note: We do not pass the hook here.\n  metrics = est.evaluate(eval_input_fn)\n  if should_stop_the_training(metrics):\n    break\n",
            "masked_code": "est = tf.estimator.Estimator(model_fn)\nwhile True:\n  est.train(\n      train_input_fn,\n      <line_mask>\n      steps=train_steps_per_eval)\n  # Note: We do not pass the hook here.\n  metrics = est.evaluate(eval_input_fn)\n  if should_stop_the_training(metrics):\n    break\n",
            "masked_line": "hooks=[tf.contrib.data.CheckpointInputPipelineHook(est)],",
            "answer": "CheckpointInputPipelineHook",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_875"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.9.0",
            "time": "2018-07-09",
            "description": "The code defines two functions, `train_input_fn` and `eval_input_fn`, which are used to provide the training and evaluation datasets. It then creates a DNNClassifier estimator using TensorFlow. An InMemoryEvaluatorHook is used to evaluate the model during training, with the evaluation dataset provided by `eval_input_fn`. The estimator is then trained using the training dataset provided by `train_input_fn` and the evaluation hook.",
            "code": "def train_input_fn():\n  ...\n  return train_dataset\n\ndef eval_input_fn():\n  ...\n  return eval_dataset\n\nestimator = tf.estimator.DNNClassifier(...)\n\nevaluator = tf.contrib.estimator.InMemoryEvaluatorHook(\n    estimator, eval_input_fn)\nestimator.train(train_input_fn, hooks=[evaluator])\n",
            "masked_code": "def train_input_fn():\n  ...\n  return train_dataset\n\ndef eval_input_fn():\n  ...\n  return eval_dataset\n\nestimator = tf.estimator.DNNClassifier(...)\n\n<line_mask>\n    estimator, eval_input_fn)\nestimator.train(train_input_fn, hooks=[evaluator])\n",
            "masked_line": "evaluator = tf.contrib.estimator.InMemoryEvaluatorHook(",
            "answer": "InMemoryEvaluatorHook",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_876"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.9.0",
            "time": "2018-07-09",
            "description": "The code generates a visual representation of a TensorFlow checkpoint file in SVG format.",
            "code": "import tensorflow as tf\nimport pydot\n\ndot_string = tf.contrib.checkpoint.dot_graph_from_checkpoint('/path/to/ckpt')\nparsed, = pydot.graph_from_dot_data(dot_string)\nparsed.write_svg('/tmp/tensorflow/visualized_checkpoint.svg')\n",
            "masked_code": "import tensorflow as tf\nimport pydot\n\n<line_mask>\nparsed, = pydot.graph_from_dot_data(dot_string)\nparsed.write_svg('/tmp/tensorflow/visualized_checkpoint.svg')\n",
            "masked_line": "dot_string = tf.contrib.checkpoint.dot_graph_from_checkpoint('/path/to/ckpt')",
            "answer": "dot_graph_from_checkpoint",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_877"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.9.0",
            "time": "2018-07-09",
            "description": "The code defines a custom model function \"_my_model_fn\" for an estimator using logistic regression head and Adagrad optimizer. It takes features, labels, and mode as inputs, computes logits using a keras model, and creates an estimator specification using the logistic regression head for the given features, labels, mode, optimizer, and logits. The function is then used to create an estimator using tf.estimator.Estimator.",
            "code": "my_head = tf.contrib.estimator.logistic_regression_head()\nmy_estimator = tf.contrib.estimator.DNNEstimator(\n    head=my_head,\n    hidden_units=...,\n    feature_columns=...)\n\n\ndef _my_model_fn(features, labels, mode):\n  my_head = tf.contrib.estimator.logistic_regression_head()\n  logits = tf.keras.Model(...)(features)\n\n  return my_head.create_estimator_spec(\n      features=features,\n      mode=mode,\n      labels=labels,\n      optimizer=tf.AdagradOptimizer(learning_rate=0.1),\n      logits=logits)\nmy_estimator = tf.estimator.Estimator(model_fn=_my_model_fn)\n",
            "masked_code": "<line_mask>\nmy_estimator = tf.contrib.estimator.DNNEstimator(\n    head=my_head,\n    hidden_units=...,\n    feature_columns=...)\n\n\ndef _my_model_fn(features, labels, mode):\n  my_head = tf.contrib.estimator.logistic_regression_head()\n  logits = tf.keras.Model(...)(features)\n\n  return my_head.create_estimator_spec(\n      features=features,\n      mode=mode,\n      labels=labels,\n      optimizer=tf.AdagradOptimizer(learning_rate=0.1),\n      logits=logits)\nmy_estimator = tf.estimator.Estimator(model_fn=_my_model_fn)\n",
            "masked_line": "my_head = tf.contrib.estimator.logistic_regression_head()",
            "answer": "logistic_regression_head",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_878"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.9.0",
            "time": "2018-07-09",
            "description": "The code contributes to retrieving a set of names for checkpoint variables from the latest checkpoint in a specified directory.",
            "code": "object_graph = tf.contrib.checkpoint.object_metadata(\n    tf.train.latest_checkpoint(checkpoint_directory))\nckpt_variable_names = set()\nfor node in object_graph.nodes:\n  for attribute in node.attributes:\n    ckpt_variable_names.add(attribute.full_name)",
            "masked_code": "<line_mask>\n    tf.train.latest_checkpoint(checkpoint_directory))\nckpt_variable_names = set()\nfor node in object_graph.nodes:\n  for attribute in node.attributes:\n    ckpt_variable_names.add(attribute.full_name)",
            "masked_line": "object_graph = tf.contrib.checkpoint.object_metadata(",
            "answer": "object_metadata",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_879"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.14.0",
            "time": "2023-09-21",
            "description": "The code defines a custom gradient operation called \"Relayout\" and implements the function \"func\", which takes an input tensor x, creates a tensor z of ones with the same shape as x, relayouts z like x, and returns the sum of x and z.",
            "code": "@ops.RegisterGradient(\"Relayout\")\ndef _relayout_gradient(op, grad):\n  return relayout_like(grad, layout_input=op.inputs[0])\n\n@tf.function\ndef func(x):\n  z = tf.ones(x.shape)\n  z = dtensor.relayout_like(z, x)\n  return x + z",
            "masked_code": "@ops.RegisterGradient(\"Relayout\")\ndef _relayout_gradient(op, grad):\n  <line_mask>\n\n@tf.function\ndef func(x):\n  z = tf.ones(x.shape)\n  z = dtensor.relayout_like(z, x)\n  return x + z",
            "masked_line": "return relayout_like(grad, layout_input=op.inputs[0])",
            "answer": "relayout_like",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_880"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.14.0",
            "time": "2023-09-21",
            "description": "This code normalizes each split of a tensor before splitting it across logical devices using a given strategy.",
            "code": "def normalize_each_split(split):\n  return split - tf.math.reduce_mean(split)\n\ndef tpu_computation(x):\n  x_split = strategy.experimental_split_to_logical_devices(\n              x, [num_cores_per_replica, 1])\n  y = experimental_map_outside_compilation(\n        normalize_each_split, x_split)\n  y_split = strategy.experimental_split_to_logical_devices(\n              x, [num_cores_per_replica, 1])\n  return y_split\n",
            "masked_code": "def normalize_each_split(split):\n  return split - tf.math.reduce_mean(split)\n\ndef tpu_computation(x):\n  x_split = strategy.experimental_split_to_logical_devices(\n              x, [num_cores_per_replica, 1])\n  <line_mask>\n        normalize_each_split, x_split)\n  y_split = strategy.experimental_split_to_logical_devices(\n              x, [num_cores_per_replica, 1])\n  return y_split\n",
            "masked_line": "y = experimental_map_outside_compilation(",
            "answer": "experimental_map_outside_compilation",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_881"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.14.1",
            "time": "2023-11-10",
            "description": "The function f takes input x and returns it as output.",
            "code": "@tf.function\ndef f(x):\n  return x\n\nf_concrete = f.get_concrete_function(tf.constant(1.0))\nf_concrete = f.get_concrete_function(x=tf.constant(1.0))\n\n@tf.function\ndef f(x):\n  return x\n\nf_concrete = f.get_concrete_function(tf.TensorSpec([], tf.float64))\n\n@tf.function(input_signature=[tf.TensorSpec(None, tf.float32)])\ndef f(x):\n  return x\n\nf_concrete = f.get_concrete_function()",
            "masked_code": "@tf.function\ndef f(x):\n  return x\n\nf_concrete = f.get_concrete_function(tf.constant(1.0))\nf_concrete = f.get_concrete_function(x=tf.constant(1.0))\n\n@tf.function\ndef f(x):\n  return x\n\n<line_mask>\n\n@tf.function(input_signature=[tf.TensorSpec(None, tf.float32)])\ndef f(x):\n  return x\n\nf_concrete = f.get_concrete_function()",
            "masked_line": "f_concrete = f.get_concrete_function(tf.TensorSpec([], tf.float64))",
            "answer": "get_concrete_function",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_882"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.2.0",
            "time": "2020-05-05",
            "description": "The code creates a MemoryChecker object to track memory usage. It then creates a list of tensors containing the constant value 1 and records the memory usage after each tensor creation. Finally, it reports the memory usage and checks for memory leaks if all but one tensor is removed.",
            "code": "with MemoryChecker() as memory_checker:\n  tensors = []\n  for _ in range(10):\n    tensors.append(tf.constant(1))\n    memory_checker.record_snapshot()\n\nmemory_checker.report()\nmemory_checker.assert_no_leak_if_all_possibly_except_one()",
            "masked_code": "<line_mask>\n  tensors = []\n  for _ in range(10):\n    tensors.append(tf.constant(1))\n    memory_checker.record_snapshot()\n\nmemory_checker.report()\nmemory_checker.assert_no_leak_if_all_possibly_except_one()",
            "masked_line": "with MemoryChecker() as memory_checker:",
            "answer": "MemoryChecker",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_883"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.2.0",
            "time": "2020-05-05",
            "description": "This code segment calculates the recall at a precision of 0.8 for a given set of predicted values and ground truth labels. It first computes the recall without any sample weights, and then calculates the recall with specified sample weights. The output of each calculation is the recall value in numpy format.",
            "code": "m = tf.keras.metrics.RecallAtPrecision(0.8, num_thresholds=1)\n_ = m.update_state([0, 0, 1, 1], [0, 0.5, 0.3, 0.9])\nm.result().numpy()\n\nm.reset_states()\n_ = m.update_state([0, 0, 1, 1], [0, 0.5, 0.3, 0.9],\n                   sample_weight=[1, 0, 0, 1])\nm.result().numpy()\n",
            "masked_code": "<line_mask>\n_ = m.update_state([0, 0, 1, 1], [0, 0.5, 0.3, 0.9])\nm.result().numpy()\n\nm.reset_states()\n_ = m.update_state([0, 0, 1, 1], [0, 0.5, 0.3, 0.9],\n                   sample_weight=[1, 0, 0, 1])\nm.result().numpy()\n",
            "masked_line": "m = tf.keras.metrics.RecallAtPrecision(0.8, num_thresholds=1)",
            "answer": "RecallAtPrecision",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_884"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.2.0",
            "time": "2020-05-05",
            "description": "The code filters the devices in the TensorFlow cluster configuration based on the worker and parameter server roles specified in the code, and connects to the cluster using the updated device filters.",
            "code": "cdf = tf.config.experimental.ClusterDeviceFilters()\nfor i in range(num_workers):\n  cdf.set_device_filters('worker', i, ['/job:ps'])\nfor i in range(num_ps):\n  cdf.set_device_filters('ps', i, ['/job:worker'])\n\ntf.config.experimental_connect_to_cluster(cluster_def,\n                                          cluster_device_filters=cdf)\n",
            "masked_code": "<line_mask>\nfor i in range(num_workers):\n  cdf.set_device_filters('worker', i, ['/job:ps'])\nfor i in range(num_ps):\n  cdf.set_device_filters('ps', i, ['/job:worker'])\n\ntf.config.experimental_connect_to_cluster(cluster_def,\n                                          cluster_device_filters=cdf)\n",
            "masked_line": "cdf = tf.config.experimental.ClusterDeviceFilters()",
            "answer": "ClusterDeviceFilters",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_885"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.2.0",
            "time": "2020-05-05",
            "description": "The code extracts text parts and floats from a given string, returning the text parts as a list and the floats as a numpy array.",
            "code": "text_parts, floats = _FloatExtractor()(\"Text 1.0 Text\")\ntext_parts\n[\"Text \", \" Text\"]\nfloats\nnp.array([1.0])",
            "masked_code": "<line_mask>\ntext_parts\n[\"Text \", \" Text\"]\nfloats\nnp.array([1.0])",
            "masked_line": "text_parts, floats = _FloatExtractor()(\"Text 1.0 Text\")",
            "answer": "_FloatExtractor",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_886"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.2.0",
            "time": "2020-05-05",
            "description": "The code loads a TFRecord dataset from a file, checks if the cardinality of the dataset is unknown, then asserts that the dataset has a cardinality of 42.",
            "code": "dataset = tf.data.TFRecordDataset(\"examples.tfrecord\")\ncardinality = tf.data.experimental.cardinality(dataset)\nprint((cardinality == tf.data.experimental.UNKNOWN_CARDINALITY).numpy())\nTrue\ndataset = dataset.apply(tf.data.experimental.assert_cardinality(42))\nprint(tf.data.experimental.cardinality(dataset).numpy())\n42",
            "masked_code": "dataset = tf.data.TFRecordDataset(\"examples.tfrecord\")\ncardinality = tf.data.experimental.cardinality(dataset)\nprint((cardinality == tf.data.experimental.UNKNOWN_CARDINALITY).numpy())\nTrue\n<line_mask>\nprint(tf.data.experimental.cardinality(dataset).numpy())\n42",
            "masked_line": "dataset = dataset.apply(tf.data.experimental.assert_cardinality(42))",
            "answer": "assert_cardinality",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_887"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.2.0",
            "time": "2020-05-05",
            "description": "The code defines a function `f(x)` that adds 1 to the input `x`, and then calls this function with the input value of 1. The code captures the graph generated during the function call and allows for inspection of the graph.",
            "code": "@def_function.function\ndef f(x):\n  return x + constant_op.constant(1.)\n\nwith context.collect_graphs() as graphs:\n  with ops.device(\"CPU:0\"):\n    f(constant_op.constant(1.))\n\ngraph, = graphs  # `graph` contains a single GraphDef for inspection\n",
            "masked_code": "@def_function.function\ndef f(x):\n  return x + constant_op.constant(1.)\n\n<line_mask>\n  with ops.device(\"CPU:0\"):\n    f(constant_op.constant(1.))\n\ngraph, = graphs  # `graph` contains a single GraphDef for inspection\n",
            "masked_line": "with context.collect_graphs() as graphs:",
            "answer": "collect_graphs",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_888"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.2.0",
            "time": "2020-05-05",
            "description": "The code attempts to run a training loop for a certain number of steps, updating a metric `loss` within a try-except block. If an OutOfRangeError is raised during the training loop, the error is cleared and the final value of `loss` is logged.",
            "code": "try:\n  with tf.experimental.async_scope():\n    for _ in range(num_steps):\n      # Step function updates the metric `loss` internally\n      train_step_fn()\nexcept tf.errors.OutOfRangeError:\n  tf.experimental.async_clear_error()\nlogging.info('loss =', loss.numpy())\n",
            "masked_code": "try:\n  <line_mask>\n    for _ in range(num_steps):\n      # Step function updates the metric `loss` internally\n      train_step_fn()\nexcept tf.errors.OutOfRangeError:\n  tf.experimental.async_clear_error()\nlogging.info('loss =', loss.numpy())\n",
            "masked_line": "with tf.experimental.async_scope():",
            "answer": "async_scope",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_889"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.2.0",
            "time": "2020-05-05",
            "description": "This code defines a test function called test_foo that saves a Sequential model with two Dense layers to a specified directory using a specified save format. It then loads the saved model from the directory.",
            "code": "@testing_utils.run_with_all_saved_model_formats\ndef test_foo(self):\n    save_format = testing_utils.get_save_format()\n    saved_model_dir = '/tmp/saved_model/'\n    model = keras.models.Sequential()\n    model.add(keras.layers.Dense(2, input_shape=(3,)))\n    model.add(keras.layers.Dense(3))\n    model.compile(loss='mse', optimizer='sgd', metrics=['acc'])\n\n    keras.models.save_model(model, saved_model_dir, save_format=save_format)\n    model = keras.models.load_model(saved_model_dir)",
            "masked_code": "<line_mask>\ndef test_foo(self):\n    save_format = testing_utils.get_save_format()\n    saved_model_dir = '/tmp/saved_model/'\n    model = keras.models.Sequential()\n    model.add(keras.layers.Dense(2, input_shape=(3,)))\n    model.add(keras.layers.Dense(3))\n    model.compile(loss='mse', optimizer='sgd', metrics=['acc'])\n\n    keras.models.save_model(model, saved_model_dir, save_format=save_format)\n    model = keras.models.load_model(saved_model_dir)",
            "masked_line": "@testing_utils.run_with_all_saved_model_formats",
            "answer": "run_with_all_saved_model_formats",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_890"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.2.0",
            "time": "2020-05-05",
            "description": "The code pads sequences with zeros, a specified value, or truncates them based on the provided parameters such as padding position, padding value, and maximum sequence length.",
            "code": "sequence = [[1], [2, 3], [4, 5, 6]]\ntf.keras.preprocessing.sequence.pad_sequences(sequence)\narray([[0, 0, 1],\n       [0, 2, 3],\n       [4, 5, 6]], dtype=int32)\n\ntf.keras.preprocessing.sequence.pad_sequences(sequence, value=-1)\narray([[-1, -1,  1],\n       [-1,  2,  3],\n       [ 4,  5,  6]], dtype=int32)\n\ntf.keras.preprocessing.sequence.pad_sequences(sequence, padding='post')\narray([[1, 0, 0],\n       [2, 3, 0],\n       [4, 5, 6]], dtype=int32)\n\ntf.keras.preprocessing.sequence.pad_sequences(sequence, maxlen=2)\narray([[0, 1],\n       [2, 3],\n       [5, 6]], dtype=int32)\n",
            "masked_code": "sequence = [[1], [2, 3], [4, 5, 6]]\n<line_mask>\narray([[0, 0, 1],\n       [0, 2, 3],\n       [4, 5, 6]], dtype=int32)\n\ntf.keras.preprocessing.sequence.pad_sequences(sequence, value=-1)\narray([[-1, -1,  1],\n       [-1,  2,  3],\n       [ 4,  5,  6]], dtype=int32)\n\ntf.keras.preprocessing.sequence.pad_sequences(sequence, padding='post')\narray([[1, 0, 0],\n       [2, 3, 0],\n       [4, 5, 6]], dtype=int32)\n\ntf.keras.preprocessing.sequence.pad_sequences(sequence, maxlen=2)\narray([[0, 1],\n       [2, 3],\n       [5, 6]], dtype=int32)\n",
            "masked_line": "tf.keras.preprocessing.sequence.pad_sequences(sequence)",
            "answer": "pad_sequences",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_891"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.2.0",
            "time": "2020-05-05",
            "description": "This code calculates the set difference between two lists x and y. It returns a list containing elements from x that are not present in y and the indices of these elements in list x.",
            "code": "def setdiff1d(x, y):\n    out = [val for val in x if val not in y]\n    idx = [x.index(val) for val in out]\n    return out, idx\n\nx = [1, 2, 3, 4, 5, 6]\ny = [1, 3, 5]\nout, idx = setdiff1d(x, y)\nprint(\"ListDiff(out={}, idx={})\".format(out, idx))\n",
            "masked_code": "def setdiff1d(x, y):\n    out = [val for val in x if val not in y]\n    idx = [x.index(val) for val in out]\n    return out, idx\n\nx = [1, 2, 3, 4, 5, 6]\ny = [1, 3, 5]\n<line_mask>\nprint(\"ListDiff(out={}, idx={})\".format(out, idx))\n",
            "masked_line": "out, idx = setdiff1d(x, y)",
            "answer": "setdiff1d",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_892"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.2.0",
            "time": "2020-05-05",
            "description": "The code performs logical AND operation between two boolean tensors.",
            "code": "a = tf.constant([True])\nb = tf.constant([False])\ntf.math.logical_and(a, b)\n\n\nc = tf.constant([True])\nx = tf.constant([False, True, True, False])\ntf.math.logical_and(c, x)\n\n\ny = tf.constant([False, False, True, True])\nz = tf.constant([False, True, False, True])\ntf.math.logical_and(y, z)\n",
            "masked_code": "a = tf.constant([True])\nb = tf.constant([False])\n<line_mask>\n\n\nc = tf.constant([True])\nx = tf.constant([False, True, True, False])\ntf.math.logical_and(c, x)\n\n\ny = tf.constant([False, False, True, True])\nz = tf.constant([False, True, False, True])\ntf.math.logical_and(y, z)\n",
            "masked_line": "tf.math.logical_and(a, b)",
            "answer": "logical_and",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_893"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.3.0",
            "time": "2020-07-24",
            "description": "The code sets up a dispatch server and a worker server using TensorFlow's experimental service module. It creates a dataset with range 10 and distributes it using the dispatch server. Finally, it prints the dataset as a list after iterating over it using numpy iterator. The dispatch server is also set up to join at port 5050.",
            "code": "dispatcher = tf.data.experimental.service.DispatchServer(port=0)\ndispatcher_address = dispatcher.target.split(\"://\")[1]\nworker = tf.data.experimental.service.WorkerServer(\n    port=0, dispatcher_address=dispatcher_address)\ndataset = tf.data.Dataset.range(10)\ndataset = dataset.apply(tf.data.experimental.service.distribute(\n    processing_mode=\"parallel_epochs\", service=dispatcher.target))\nprint(list(dataset.as_numpy_iterator()))\n\ndispatcher = tf.data.experimental.service.DispatchServer(port=5050)\ndispatcher.join()",
            "masked_code": "<line_mask>\ndispatcher_address = dispatcher.target.split(\"://\")[1]\nworker = tf.data.experimental.service.WorkerServer(\n    port=0, dispatcher_address=dispatcher_address)\ndataset = tf.data.Dataset.range(10)\ndataset = dataset.apply(tf.data.experimental.service.distribute(\n    processing_mode=\"parallel_epochs\", service=dispatcher.target))\nprint(list(dataset.as_numpy_iterator()))\n\ndispatcher = tf.data.experimental.service.DispatchServer(port=5050)\ndispatcher.join()",
            "masked_line": "dispatcher = tf.data.experimental.service.DispatchServer(port=0)",
            "answer": "DispatchServer",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_894"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.3.0",
            "time": "2020-07-24",
            "description": "The code defines a worker server for distributed TensorFlow data processing, connects to a dispatcher, creates a dataset with a range of 10 elements, distributes the dataset for parallel epoch processing, and prints the dataset elements. The worker server with port 5051 joins the dispatcher server with address \"grpc://localhost:5050\".",
            "code": "worker = tf.data.experimental.service.WorkerServer(\n    port=0, dispatcher_address=dispatcher_address)\ndataset = tf.data.Dataset.range(10)\ndataset = dataset.apply(tf.data.experimental.service.distribute(\n    processing_mode=\"parallel_epochs\", service=dispatcher.target))\nprint(list(dataset.as_numpy_iterator()))\n\nworker = tf.data.experimental.service.WorkerServer(\n    port=5051, dispatcher_address=\"grpc://localhost:5050\")\nworker.join()",
            "masked_code": "<line_mask>\n    port=0, dispatcher_address=dispatcher_address)\ndataset = tf.data.Dataset.range(10)\ndataset = dataset.apply(tf.data.experimental.service.distribute(\n    processing_mode=\"parallel_epochs\", service=dispatcher.target))\nprint(list(dataset.as_numpy_iterator()))\n\nworker = tf.data.experimental.service.WorkerServer(\n    port=5051, dispatcher_address=\"grpc://localhost:5050\")\nworker.join()",
            "masked_line": "worker = tf.data.experimental.service.WorkerServer(",
            "answer": "WorkerServer",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_895"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.3.0",
            "time": "2020-07-24",
            "description": "This code snippet generates a dataset with a single element of value 42, creates an iterator for the dataset, retrieves the next element from the iterator as an optional value, and checks if the optional value has a value. The code then prints the result of whether the optional value has a value and the value of the optional value (42 in this case). Finally, it retrieves the next element from the iterator again and checks if the optional value has a value, printing the result (False).",
            "code": "dataset = tf.data.Dataset.from_tensors(42)\niterator = iter(dataset)\noptional = iterator.get_next_as_optional()\nprint(optional.has_value())\ntf.Tensor(True, shape=(), dtype=bool)\nprint(optional.get_value())\ntf.Tensor(42, shape=(), dtype=int32)\noptional = iterator.get_next_as_optional()\nprint(optional.has_value())\ntf.Tensor(False, shape=(), dtype=bool)",
            "masked_code": "dataset = tf.data.Dataset.from_tensors(42)\niterator = iter(dataset)\n<line_mask>\nprint(optional.has_value())\ntf.Tensor(True, shape=(), dtype=bool)\nprint(optional.get_value())\ntf.Tensor(42, shape=(), dtype=int32)\noptional = iterator.get_next_as_optional()\nprint(optional.has_value())\ntf.Tensor(False, shape=(), dtype=bool)",
            "masked_line": "optional = iterator.get_next_as_optional()",
            "answer": "get_next_as_optional",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_896"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.3.0",
            "time": "2020-07-24",
            "description": "This code sets up a TPUStrategy for distributing a dataset on a TPU machine. It connects to a TPU cluster resolver, initializes the TPU system, creates a TPUStrategy, and distributes the dataset for training on the TPU machine.",
            "code": "# Setup TPUStrategy\nresolver = tf.distribute.cluster_resolver.TPUClusterResolver(tpu='')\ntf.config.experimental_connect_to_cluster(resolver)\ntf.tpu.experimental.initialize_tpu_system(resolver)\nstrategy = tf.distribute.TPUStrategy(resolver)\n\ndataset = tf.data.Dataset.range(16)\ndistributed_dataset_on_host = (\n    strategy.experimental_distribute_dataset(\n        dataset,\n        tf.distribute.InputOptions(\n            experimental_prefetch_to_device=False)))\n",
            "masked_code": "# Setup TPUStrategy\nresolver = tf.distribute.cluster_resolver.TPUClusterResolver(tpu='')\ntf.config.experimental_connect_to_cluster(resolver)\ntf.tpu.experimental.initialize_tpu_system(resolver)\nstrategy = tf.distribute.TPUStrategy(resolver)\n\ndataset = tf.data.Dataset.range(16)\ndistributed_dataset_on_host = (\n    strategy.experimental_distribute_dataset(\n        dataset,\n        <line_mask>\n            experimental_prefetch_to_device=False)))\n",
            "masked_line": "tf.distribute.InputOptions(",
            "answer": "InputOptions",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_897"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.3.0",
            "time": "2020-07-24",
            "description": "The code defines a function that runs a given replica function on the input data, distributed across multiple replicas using a TensorFlow strategy. The replica function simply multiplies the input by 2.",
            "code": "@tf.function\ndef run():\n  def value_fn(value_context):\n    return value_context.num_replicas_in_sync\n  distributed_values = (\n      strategy.experimental_distribute_values_from_function(value_fn))\n  def replica_fn(input):\n    return input * 2\n  return strategy.run(replica_fn, args=(distributed_values,))",
            "masked_code": "@tf.function\ndef run():\n  def value_fn(value_context):\n    return value_context.num_replicas_in_sync\n  distributed_values = (\n      strategy.experimental_distribute_values_from_function(value_fn))\n  def replica_fn(input):\n    return input * 2\n  <line_mask>",
            "masked_line": "return strategy.run(replica_fn, args=(distributed_values,))",
            "answer": "run",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_898"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.3.0",
            "time": "2020-07-24",
            "description": "The code snippet creates a CategoryEncoding layer in TensorFlow Keras with a specified maximum number of tokens and output mode. The layer is then applied to input data to encode the categories into a count representation.",
            "code": "layer = tf.keras.layers.experimental.preprocessing.CategoryEncoding(\n          max_tokens=4, output_mode=\"count\")\nlayer([[0, 1], [0, 0], [1, 2], [3, 1]])\n\nlayer = tf.keras.layers.experimental.preprocessing.CategoryEncoding(\n          max_tokens=4, output_mode=\"count\")\ncount_weights = np.array([[.1, .2], [.1, .1], [.2, .3], [.4, .2]])\nlayer([[0, 1], [0, 0], [1, 2], [3, 1]], count_weights=count_weights)\n",
            "masked_code": "<line_mask>\n          max_tokens=4, output_mode=\"count\")\nlayer([[0, 1], [0, 0], [1, 2], [3, 1]])\n\nlayer = tf.keras.layers.experimental.preprocessing.CategoryEncoding(\n          max_tokens=4, output_mode=\"count\")\ncount_weights = np.array([[.1, .2], [.1, .1], [.2, .3], [.4, .2]])\nlayer([[0, 1], [0, 0], [1, 2], [3, 1]], count_weights=count_weights)\n",
            "masked_line": "layer = tf.keras.layers.experimental.preprocessing.CategoryEncoding(",
            "answer": "CategoryEncoding",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_899"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.3.0",
            "time": "2020-07-24",
            "description": "The code creates a static hash table using TensorFlow to map keys to values, where keys are integers in the range of 0 to 99 and values are strings representing double the key value. It then looks up the values for keys 0, 1, and 2 in the hash table and asserts that the output values are [\"0\", \"2\", \"4\"].",
            "code": "keys = tf.data.Dataset.range(100)\nvalues = tf.data.Dataset.range(100).map(\n    lambda x: string_ops.as_string(x * 2))\nds = tf.data.Dataset.zip((keys, values))\ninit = tf.lookup.experimental.DatasetInitializer(ds)\ntable = tf.lookup.StaticHashTable(init, \"\")\noutput = table.lookup([0, 1, 2])\nassertEquals(outputs, [\"0\", \"2\", \"4\"])",
            "masked_code": "keys = tf.data.Dataset.range(100)\nvalues = tf.data.Dataset.range(100).map(\n    lambda x: string_ops.as_string(x * 2))\nds = tf.data.Dataset.zip((keys, values))\n<line_mask>\ntable = tf.lookup.StaticHashTable(init, \"\")\noutput = table.lookup([0, 1, 2])\nassertEquals(outputs, [\"0\", \"2\", \"4\"])",
            "masked_line": "init = tf.lookup.experimental.DatasetInitializer(ds)",
            "answer": "DatasetInitializer",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_900"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.3.0",
            "time": "2020-07-24",
            "description": "The code segments create RowPartition objects with different row partitioning methods based on the provided input values.",
            "code": "p1 = RowPartition.from_row_lengths([4, 0, 3, 1, 0])\np2 = RowPartition.from_row_splits([0, 4, 4, 7, 8, 8])\np3 = RowPartition.from_row_starts([0, 4, 4, 7, 8], nvals=8)\np4 = RowPartition.from_row_limits([4, 4, 7, 8, 8])\np5 = RowPartition.from_value_rowids([0, 0, 0, 0, 2, 2, 2, 3], nrows=5)\n",
            "masked_code": "p1 = RowPartition.from_row_lengths([4, 0, 3, 1, 0])\np2 = RowPartition.from_row_splits([0, 4, 4, 7, 8, 8])\np3 = RowPartition.from_row_starts([0, 4, 4, 7, 8], nvals=8)\np4 = RowPartition.from_row_limits([4, 4, 7, 8, 8])\n<line_mask>\n",
            "masked_line": "p5 = RowPartition.from_value_rowids([0, 0, 0, 0, 2, 2, 2, 3], nrows=5)",
            "answer": "RowPartition",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_901"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.3.0",
            "time": "2020-07-24",
            "description": "This code initializes a profiler to track the performance of a TensorFlow program. It then iterates through a specified number of training steps, creating a trace event for each step to monitor and analyze the training process. Finally, the profiler is stopped after all steps are completed.",
            "code": "tf.profiler.experimental.start('logdir')\nfor step in range(num_steps):\n  # Creates a trace event for each training step with the step number.\n  with tf.profiler.experimental.Trace(\"Train\", step_num=step):\n    train_fn()\ntf.profiler.experimental.stop()\n",
            "masked_code": "tf.profiler.experimental.start('logdir')\nfor step in range(num_steps):\n  # Creates a trace event for each training step with the step number.\n  <line_mask>\n    train_fn()\ntf.profiler.experimental.stop()\n",
            "masked_line": "with tf.profiler.experimental.Trace(\"Train\", step_num=step):",
            "answer": "Trace",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_902"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.3.0",
            "time": "2020-07-24",
            "description": "This code creates a TensorFlow dataset from a range of numbers, squares each element, applies a distributed service to process the dataset in parallel across multiple epochs, increments each element by 1, and prints the resulting dataset elements.",
            "code": "\ndataset = tf.data.Dataset.range(5)\ndataset = dataset.map(lambda x: x*x)\ndataset = dataset.apply(\n    tf.data.experimental.service.distribute(\"parallel_epochs\",\n                                            \"grpc://dataservice:5000\"))\ndataset = dataset.map(lambda x: x+1)\n\nfor element in dataset:\n  print(element)  # prints { 1, 2, 5, 10, 17 }\n\n",
            "masked_code": "\ndataset = tf.data.Dataset.range(5)\ndataset = dataset.map(lambda x: x*x)\ndataset = dataset.apply(\n    <line_mask>\n                                            \"grpc://dataservice:5000\"))\ndataset = dataset.map(lambda x: x+1)\n\nfor element in dataset:\n  print(element)  # prints { 1, 2, 5, 10, 17 }\n\n",
            "masked_line": "tf.data.experimental.service.distribute(\"parallel_epochs\",",
            "answer": "distribute",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_903"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.3.0",
            "time": "2020-07-24",
            "description": "This code snippet is creating a time series dataset from an array where the input data is sliced with the last 10 elements removed, the targets are created by taking the last 10 elements of the original data. The dataset is then generated using TensorFlow's time series dataset utility function with a sequence length of 10. Finally, it is validating that the first batch from the dataset contains the correct input and target sequences by comparing them to the original data.",
            "code": "input_data = data[:-10]\ntargets = data[10:]\ndataset = tf.keras.preprocessing.timeseries_dataset_from_array(\n    input_data, targets, sequence_length=10)\nfor batch in dataset:\n  inputs, targets = batch\n  assert np.array_equal(inputs[0], data[:10])  # First sequence: steps [0-9]\n  assert np.array_equal(targets[0], data[10])  # Corresponding target: step 10\n  break\n",
            "masked_code": "input_data = data[:-10]\ntargets = data[10:]\n<line_mask>\n    input_data, targets, sequence_length=10)\nfor batch in dataset:\n  inputs, targets = batch\n  assert np.array_equal(inputs[0], data[:10])  # First sequence: steps [0-9]\n  assert np.array_equal(targets[0], data[10])  # Corresponding target: step 10\n  break\n",
            "masked_line": "dataset = tf.keras.preprocessing.timeseries_dataset_from_array(",
            "answer": "timeseries_dataset_from_array",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_904"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.3.0",
            "time": "2020-07-24",
            "description": "The code defines two functions `f1` and `f2` that each return a constant value. It then executes a function on a specific device (CPU or GPU) based on the dictionary provided, with `f1` as the default function.",
            "code": "def f1(): return tf.constant(1)\ndef f2(): return tf.constant(2)\nr = tf.execute_fn_for_device({\"CPU\": f1, \"GPU\": f2}, default_fn=f1)\n",
            "masked_code": "def f1(): return tf.constant(1)\ndef f2(): return tf.constant(2)\n<line_mask>\n",
            "masked_line": "r = tf.execute_fn_for_device({\"CPU\": f1, \"GPU\": f2}, default_fn=f1)",
            "answer": "execute_fn_for_device",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_905"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.3.0",
            "time": "2020-07-24",
            "description": "Generate a 10x2x3 tensor of random values from a truncated normal distribution with specified mean, standard deviation, minimum values, and maximum values.",
            "code": "means = 0.\nstddevs = tf.math.exp(tf.random.uniform(shape=[2, 3]))\nminvals = [-1., -2., -1000.]\nmaxvals = [[10000.], [1.]]\ny = tf.random.stateless_parameterized_truncated_normal(\n  shape=[10, 2, 3], seed=[7, 17],\n  means=means, stddevs=stddevs, minvals=minvals, maxvals=maxvals)\ny.shape",
            "masked_code": "means = 0.\nstddevs = tf.math.exp(tf.random.uniform(shape=[2, 3]))\nminvals = [-1., -2., -1000.]\nmaxvals = [[10000.], [1.]]\n<line_mask>\n  shape=[10, 2, 3], seed=[7, 17],\n  means=means, stddevs=stddevs, minvals=minvals, maxvals=maxvals)\ny.shape",
            "masked_line": "y = tf.random.stateless_parameterized_truncated_normal(",
            "answer": "stateless_parameterized_truncated_normal",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_906"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.3.0",
            "time": "2020-07-24",
            "description": "The code converts a TensorFlow ragged tensor into a string representation. The function `ragged_tensor_to_string` converts the ragged tensor into a string containing the nested lists of values within the tensor, with an option to summarize the output by specifying a limit on the number of elements displayed in each nested list.",
            "code": "rt1 = tf.ragged.constant([[1, 2, 3], [4, 5]])\nragged_tensor_to_string(rt1).numpy()\nb'[[1, 2, 3], [4, 5]]'\n\nrt2 = tf.ragged.constant([[['a'], ['b', 'c']], [['d', 'e', 'f'], []]])\nragged_tensor_to_string(rt2).numpy()\nb\"[[['a'], ['b', 'c']], [['d', 'e', 'f'], []]]\"\n\nrt3 = tf.ragged.constant([[1], [2, 3, 4, 5, 6], [], [], [7], [8, 9]])\nragged_tensor_to_string(rt3, summarize=2).numpy()\nb'[[1], [2, 3, ..., 5, 6], ..., [7], [8, 9]]'",
            "masked_code": "rt1 = tf.ragged.constant([[1, 2, 3], [4, 5]])\nragged_tensor_to_string(rt1).numpy()\nb'[[1, 2, 3], [4, 5]]'\n\nrt2 = tf.ragged.constant([[['a'], ['b', 'c']], [['d', 'e', 'f'], []]])\n<line_mask>\nb\"[[['a'], ['b', 'c']], [['d', 'e', 'f'], []]]\"\n\nrt3 = tf.ragged.constant([[1], [2, 3, 4, 5, 6], [], [], [7], [8, 9]])\nragged_tensor_to_string(rt3, summarize=2).numpy()\nb'[[1], [2, 3, ..., 5, 6], ..., [7], [8, 9]]'",
            "masked_line": "ragged_tensor_to_string(rt2).numpy()",
            "answer": "ragged_tensor_to_string",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_907"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.3.0",
            "time": "2020-07-24",
            "description": "The code creates a dataset containing integers from 0 to 41, and then prints the cardinality of the dataset. It then repeats the dataset, calculates the cardinality again, and prints whether the cardinality equals to infinite cardinality. Finally, it filters the dataset by keeping all elements and checks if the cardinality is unknown, then prints the result.",
            "code": "dataset = tf.data.Dataset.range(42)\nprint(dataset.cardinality().numpy())\ndataset = dataset.repeat()\ncardinality = dataset.cardinality()\nprint((cardinality == tf.data.INFINITE_CARDINALITY).numpy())\ndataset = dataset.filter(lambda x: True)\ncardinality = dataset.cardinality()\nprint((cardinality == tf.data.UNKNOWN_CARDINALITY).numpy())",
            "masked_code": "dataset = tf.data.Dataset.range(42)\nprint(dataset.cardinality().numpy())\ndataset = dataset.repeat()\n<line_mask>\nprint((cardinality == tf.data.INFINITE_CARDINALITY).numpy())\ndataset = dataset.filter(lambda x: True)\ncardinality = dataset.cardinality()\nprint((cardinality == tf.data.UNKNOWN_CARDINALITY).numpy())",
            "masked_line": "cardinality = dataset.cardinality()",
            "answer": "cardinality",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_908"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.3.0",
            "time": "2020-07-24",
            "description": "The code sets up a multi-process runner for executing tasks. It defines a function proc_func that includes user code to be run and sets a breakpoint for debugging. Another function follow_ups is defined to sleep for 5 seconds before starting a single process for evaluation. The main portion of the code initiates a multi-process runner with specified parameters, starts a thread for follow-up tasks, and then starts the chief task in the process. The code finally waits for all processes to join before completion.",
            "code": "def proc_func():\n  # user code to be run\n  import pdb; pdb.set_trace()\n\ndef follow_ups():\n  time.sleep(5)\n  mpr.start_single_process(\n      task_type='evaluator',\n      task_id=0)\n\nmpr = multi_process_runner.MultiProcessRunner(\n    proc_func,\n    multi_worker_test_base.create_cluster_spec(\n        has_chief=True, num_workers=1))\nthreading.Thread(target=follow_ups).start()\nmpr.start_in_process_as(as_task_type='chief', as_task_id=0)\nmpr.join()\n",
            "masked_code": "def proc_func():\n  # user code to be run\n  import pdb; pdb.set_trace()\n\ndef follow_ups():\n  time.sleep(5)\n  mpr.start_single_process(\n      task_type='evaluator',\n      task_id=0)\n\nmpr = multi_process_runner.MultiProcessRunner(\n    proc_func,\n    multi_worker_test_base.create_cluster_spec(\n        has_chief=True, num_workers=1))\nthreading.Thread(target=follow_ups).start()\n<line_mask>\nmpr.join()\n",
            "masked_line": "mpr.start_in_process_as(as_task_type='chief', as_task_id=0)",
            "answer": "start_in_process_as",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_909"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.4.0",
            "time": "2020-12-12",
            "description": "The code creates a dataset with numbers from 0 to 7, splits the dataset into batches of size 4, and then re-batches the dataset with a total of 3 replicas. Finally, it prints out each element of the dataset.",
            "code": "ds = tf.data.Dataset.range(8)\nds = ds.batch(4)\nds = _LegacyRebatchDataset(ds, num_replicas=3)\nfor elem in ds:\n  print(elem)\n",
            "masked_code": "ds = tf.data.Dataset.range(8)\nds = ds.batch(4)\n<line_mask>\nfor elem in ds:\n  print(elem)\n",
            "masked_line": "ds = _LegacyRebatchDataset(ds, num_replicas=3)",
            "answer": "_LegacyRebatchDataset",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_910"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.7.0",
            "time": "2021-11-01",
            "description": "The code defines a class \"Vehicle\" with attributes \"top_speed\" and \"mpg\" as TensorFlow Tensors. It then creates a batch of Vehicle instances with given top speeds and miles per gallon values. Finally, it calculates the product of top speed and mpg for each vehicle in the batch using tf.map_fn and returns the result as a numpy array of integers.",
            "code": "class Vehicle(BatchableExtensionType):\n    top_speed: tf.Tensor\n    mpg: tf.Tensor\n\nbatch = Vehicle([120, 150, 80], [30, 40, 12])\ntf.map_fn(lambda vehicle: vehicle.top_speed * vehicle.mpg, batch,\n          fn_output_signature=tf.int32).numpy()",
            "masked_code": "<line_mask>\n    top_speed: tf.Tensor\n    mpg: tf.Tensor\n\nbatch = Vehicle([120, 150, 80], [30, 40, 12])\ntf.map_fn(lambda vehicle: vehicle.top_speed * vehicle.mpg, batch,\n          fn_output_signature=tf.int32).numpy()",
            "masked_line": "class Vehicle(BatchableExtensionType):",
            "answer": "BatchableExtensionType",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_911"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.7.4",
            "time": "2022-09-01",
            "description": "This code calculates the layer normalization of the input data along axis 1, which involves normalizing the input data by subtracting the mean and dividing by the standard deviation, then scaling and shifting the normalized data using gamma and beta parameters.",
            "code": "data = tf.constant(np.arange(10).reshape(5, 2) * 10, dtype=tf.float32)\nprint(data)\n\n\nlayer = tf.keras.layers.LayerNormalization(axis=1)\noutput = layer(data)\nprint(output)\n\n\nmean_i = sum(x_i[j] for j in range(k)) / k\nvar_i = sum((x_i[j] - mean_i) ** 2 for j in range(k)) / k\n\n\nx_i_normalized = (x_i - mean_i) / sqrt(var_i + epsilon)\n\n\noutput_i = x_i_normalized * gamma + beta\n",
            "masked_code": "data = tf.constant(np.arange(10).reshape(5, 2) * 10, dtype=tf.float32)\nprint(data)\n\n\n<line_mask>\noutput = layer(data)\nprint(output)\n\n\nmean_i = sum(x_i[j] for j in range(k)) / k\nvar_i = sum((x_i[j] - mean_i) ** 2 for j in range(k)) / k\n\n\nx_i_normalized = (x_i - mean_i) / sqrt(var_i + epsilon)\n\n\noutput_i = x_i_normalized * gamma + beta\n",
            "masked_line": "layer = tf.keras.layers.LayerNormalization(axis=1)",
            "answer": "LayerNormalization",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_912"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.7.4",
            "time": "2022-09-01",
            "description": "The code performs category crossing on two input lists by combining their elements.",
            "code": "inp_1 = ['a', 'b', 'c']\ninp_2 = ['d', 'e', 'f']\nlayer = tf.keras.layers.experimental.preprocessing.CategoryCrossing()\nlayer([inp_1, inp_2])\n\ninp_1 = ['a', 'b', 'c']\ninp_2 = ['d', 'e', 'f']\nlayer = tf.keras.layers.experimental.preprocessing.CategoryCrossing(\n   separator='-')\nlayer([inp_1, inp_2])",
            "masked_code": "inp_1 = ['a', 'b', 'c']\ninp_2 = ['d', 'e', 'f']\nlayer = tf.keras.layers.experimental.preprocessing.CategoryCrossing()\nlayer([inp_1, inp_2])\n\ninp_1 = ['a', 'b', 'c']\ninp_2 = ['d', 'e', 'f']\n<line_mask>\n   separator='-')\nlayer([inp_1, inp_2])",
            "masked_line": "layer = tf.keras.layers.experimental.preprocessing.CategoryCrossing(",
            "answer": "CategoryCrossing",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_913"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.7.4",
            "time": "2022-09-01",
            "description": "The code is using the CategoryEncoding layer from the TensorFlow.keras library to encode categorical inputs into numerical representations. The functionality described includes one-hot encoding, multi-hot encoding, and count encoding modes based on the specified parameters in each code snippet.",
            "code": "layer = tf.keras.layers.experimental.preprocessing.CategoryEncoding(\n          num_tokens=4, output_mode=\"one_hot\")\nlayer([3, 2, 0, 1])\n\n\nlayer = tf.keras.layers.experimental.preprocessing.CategoryEncoding(\n          num_tokens=4, output_mode=\"multi_hot\")\nlayer([[0, 1], [0, 0], [1, 2], [3, 1]])\n\n\nlayer = tf.keras.layers.experimental.preprocessing.CategoryEncoding(\n          num_tokens=4, output_mode=\"count\")\ncount_weights = np.array([[.1, .2], [.1, .1], [.2, .3], [.4, .2]])\nlayer([[0, 1], [0, 0], [1, 2], [3, 1]], count_weights=count_weights)\n",
            "masked_code": "<line_mask>\n          num_tokens=4, output_mode=\"one_hot\")\nlayer([3, 2, 0, 1])\n\n\nlayer = tf.keras.layers.experimental.preprocessing.CategoryEncoding(\n          num_tokens=4, output_mode=\"multi_hot\")\nlayer([[0, 1], [0, 0], [1, 2], [3, 1]])\n\n\nlayer = tf.keras.layers.experimental.preprocessing.CategoryEncoding(\n          num_tokens=4, output_mode=\"count\")\ncount_weights = np.array([[.1, .2], [.1, .1], [.2, .3], [.4, .2]])\nlayer([[0, 1], [0, 0], [1, 2], [3, 1]], count_weights=count_weights)\n",
            "masked_line": "layer = tf.keras.layers.experimental.preprocessing.CategoryEncoding(",
            "answer": "CategoryEncoding",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_914"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.7.4",
            "time": "2022-09-01",
            "description": "The code generates time series data and its corresponding target data with specific length, sampling rate, and batch size using the TimeseriesGenerator.",
            "code": "from keras.preprocessing.sequence import TimeseriesGenerator\nimport numpy as np\ndata = np.array([[i] for i in range(50)])\ntargets = np.array([[i] for i in range(50)])\ndata_gen = TimeseriesGenerator(data, targets,\n                               length=10, sampling_rate=2,\n                               batch_size=2)\nassert len(data_gen) == 20\nbatch_0 = data_gen[0]\nx, y = batch_0\nassert np.array_equal(x,\n                      np.array([[[0], [2], [4], [6], [8]],\n                                [[1], [3], [5], [7], [9]]]))\nassert np.array_equal(y,\n                      np.array([[10], [11]]))\n",
            "masked_code": "<line_mask>\nimport numpy as np\ndata = np.array([[i] for i in range(50)])\ntargets = np.array([[i] for i in range(50)])\ndata_gen = TimeseriesGenerator(data, targets,\n                               length=10, sampling_rate=2,\n                               batch_size=2)\nassert len(data_gen) == 20\nbatch_0 = data_gen[0]\nx, y = batch_0\nassert np.array_equal(x,\n                      np.array([[[0], [2], [4], [6], [8]],\n                                [[1], [3], [5], [7], [9]]]))\nassert np.array_equal(y,\n                      np.array([[10], [11]]))\n",
            "masked_line": "from keras.preprocessing.sequence import TimeseriesGenerator",
            "answer": "TimeseriesGenerator",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_915"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.7.4",
            "time": "2022-09-01",
            "description": "This code snippet aims to perform training of a neural network model using Stochastic Gradient Descent (SGD) optimizer with a specified learning rate. It utilizes a dynamic loss scaling technique to mitigate numerical instability during training. The code calculates the logits output of the model, computes the softmax cross-entropy loss, applies the dynamic loss scaling, computes the gradients, and updates the model parameters using SGD optimization.",
            "code": "opt = tf.keras.optimizers.SGD(1.0)\nmodel_loss_scale = tf.mixed_precision.experimental.DynamicLossScale()\n\nfor step in training_steps:\n  with LossScaleGradientTape(model_loss_scale) as tape:\n    logits = ...  # Run model and get logits\n    loss = tf.nn.softmax_cross_entropy_with_logits(logits=logits,\n                                                   labels=labels)\n    loss = tf.reduce_mean(loss)\n  vars = tape.watched_variables()\n  grads = tape.gradient(loss, vars)\n  opt.apply_gradients(zip(grads, vars))\n",
            "masked_code": "opt = tf.keras.optimizers.SGD(1.0)\nmodel_loss_scale = tf.mixed_precision.experimental.DynamicLossScale()\n\nfor step in training_steps:\n  <line_mask>\n    logits = ...  # Run model and get logits\n    loss = tf.nn.softmax_cross_entropy_with_logits(logits=logits,\n                                                   labels=labels)\n    loss = tf.reduce_mean(loss)\n  vars = tape.watched_variables()\n  grads = tape.gradient(loss, vars)\n  opt.apply_gradients(zip(grads, vars))\n",
            "masked_line": "with LossScaleGradientTape(model_loss_scale) as tape:",
            "answer": "LossScaleGradientTape",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_916"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.7.4",
            "time": "2022-09-01",
            "description": "The code creates two datasets from lists of numbers, zips them together into a single dataset as tuples, and then unzips the tuples back into two separate datasets. It then zips the datasets into a single dataset as a dictionary and unzips them back into two separate datasets.",
            "code": "ds1 = tf.data.Dataset.from_tensor_slices([1, 2, 3])\nds2 = tf.data.Dataset.from_tensor_slices([4, 5, 6])\nds_zipped_tuple = tf.data.Dataset.zip((ds1, ds2))\nds_unzipped_tuple = _unzip_dataset(ds_zipped_tuple)\nds_zipped_dict = tf.data.Dataset.zip({'ds1': ds1, 'ds2': ds2})\nds_unzipped_dict = _unzip_dataset(ds_zipped_dict)",
            "masked_code": "ds1 = tf.data.Dataset.from_tensor_slices([1, 2, 3])\nds2 = tf.data.Dataset.from_tensor_slices([4, 5, 6])\nds_zipped_tuple = tf.data.Dataset.zip((ds1, ds2))\n<line_mask>\nds_zipped_dict = tf.data.Dataset.zip({'ds1': ds1, 'ds2': ds2})\nds_unzipped_dict = _unzip_dataset(ds_zipped_dict)",
            "masked_line": "ds_unzipped_tuple = _unzip_dataset(ds_zipped_tuple)",
            "answer": "_unzip_dataset",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_917"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.7.4",
            "time": "2022-09-01",
            "description": "The code pads sequences in a list to ensure they are of the same length either by adding zeros at the beginning ('pre') or end ('post') of the sequences, by setting a different value for padding, or by cutting off sequences that exceed a maximum length specified.",
            "code": "sequence = [[1], [2, 3], [4, 5, 6]]\ntf.keras.preprocessing.sequence.pad_sequences(sequence)\narray([[0, 0, 1],\n       [0, 2, 3],\n       [4, 5, 6]], dtype=int32)\n\ntf.keras.preprocessing.sequence.pad_sequences(sequence, value=-1)\narray([[-1, -1,  1],\n       [-1,  2,  3],\n       [ 4,  5,  6]], dtype=int32)\n\ntf.keras.preprocessing.sequence.pad_sequences(sequence, padding='post')\narray([[1, 0, 0],\n       [2, 3, 0],\n       [4, 5, 6]], dtype=int32)\n\ntf.keras.preprocessing.sequence.pad_sequences(sequence, maxlen=2)\narray([[0, 1],\n       [2, 3],\n       [5, 6]], dtype=int32)\n",
            "masked_code": "sequence = [[1], [2, 3], [4, 5, 6]]\n<line_mask>\narray([[0, 0, 1],\n       [0, 2, 3],\n       [4, 5, 6]], dtype=int32)\n\ntf.keras.preprocessing.sequence.pad_sequences(sequence, value=-1)\narray([[-1, -1,  1],\n       [-1,  2,  3],\n       [ 4,  5,  6]], dtype=int32)\n\ntf.keras.preprocessing.sequence.pad_sequences(sequence, padding='post')\narray([[1, 0, 0],\n       [2, 3, 0],\n       [4, 5, 6]], dtype=int32)\n\ntf.keras.preprocessing.sequence.pad_sequences(sequence, maxlen=2)\narray([[0, 1],\n       [2, 3],\n       [5, 6]], dtype=int32)\n",
            "masked_line": "tf.keras.preprocessing.sequence.pad_sequences(sequence)",
            "answer": "pad_sequences",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_918"
        },
        {
            "dependency": "tensorflow_datasets",
            "version": "==1.2.0",
            "time": "2019-08-19",
            "description": "The code sets up the folder containing checksums for a dataset, adds the checksum directory for when the dataset is imported, and defines a class for a custom dataset.",
            "code": "\n# Set-up the folder containing the 'my_dataset.txt' checksums.\nchecksum_dir = os.path.join(os.path.dirname(__file__), 'checksums/')\nchecksum_dir = os.path.normpath(checksum_dir)\n\n# Add the checksum dir (will be executed when the user import your dataset)\ntfds.download.add_checksums_dir(checksum_dir)\n\nclass MyDataset(tfds.core.DatasetBuilder):\n  ...\n",
            "masked_code": "\n# Set-up the folder containing the 'my_dataset.txt' checksums.\nchecksum_dir = os.path.join(os.path.dirname(__file__), 'checksums/')\nchecksum_dir = os.path.normpath(checksum_dir)\n\n# Add the checksum dir (will be executed when the user import your dataset)\n<line_mask>\n\nclass MyDataset(tfds.core.DatasetBuilder):\n  ...\n",
            "masked_line": "tfds.download.add_checksums_dir(checksum_dir)",
            "answer": "add_checksums_dir",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_919"
        },
        {
            "dependency": "tensorflow_datasets",
            "version": "==1.2.0",
            "time": "2019-08-19",
            "description": "The function `as_dataset` generates a fake dataset containing images and labels, with each image being a 28x28x1 array of ones and each label being assigned as the remainder of the index divided by 10. The dataset is then loaded using `tfds.load` with the split specified as 'train', and the fake data examples generated by `as_dataset` are iterated through using a for loop.",
            "code": "def as_dataset(self, *args, **kwargs):\n  return tf.data.Dataset.from_generator(\n      lambda: ({\n          'image': np.ones(shape=(28, 28, 1), dtype=np.uint8),\n          'label': i % 10,\n      } for i in range(num_examples)),\n      output_types=self.info.features.dtype,\n      output_shapes=self.info.features.shape,\n  )\n\nwith mock_data(as_dataset_fn=as_dataset):\n  ds = tfds.load('some_dataset', split='train')\n\n  for ex in ds:  # ds will yield the fake data example of 'as_dataset'.\n    ex\n",
            "masked_code": "def as_dataset(self, *args, **kwargs):\n  return tf.data.Dataset.from_generator(\n      lambda: ({\n          'image': np.ones(shape=(28, 28, 1), dtype=np.uint8),\n          'label': i % 10,\n      } for i in range(num_examples)),\n      output_types=self.info.features.dtype,\n      output_shapes=self.info.features.shape,\n  )\n\n<line_mask>\n  ds = tfds.load('some_dataset', split='train')\n\n  for ex in ds:  # ds will yield the fake data example of 'as_dataset'.\n    ex\n",
            "masked_line": "with mock_data(as_dataset_fn=as_dataset):",
            "answer": "mock_data",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_920"
        },
        {
            "dependency": "tensorflow_datasets",
            "version": "==3.2.0",
            "time": "2020-07-10",
            "description": "The code creates a mock file system using MockFs and adds content to files '/path/to/file1' and '/path/to/file2'. It then checks if file '/path/to/file1' exists, writes content to '/path/to/file2', renames '/path/to/file1' to '/path/to/file1_moved', and asserts that the contents of the files in the mock file system match the expected values.",
            "code": "fs = MockFs()\nwith fs.mock():\n\n  fs.add_file('/path/to/file1', 'Content of file 1')\n\n  assert tf.io.gfile.exists('/path/to/file1')\n  with tf.io.gfile.GFile('/path/to/file2', 'w') as f:\n    f.write('Content of file 2')\n  tf.io.gfile.rename('/path/to/file1', '/path/to/file1_moved')\n\n  assert fs.files == {\n      '/path/to/file2': 'Content of file 2',\n      '/path/to/file1_moved': 'Content of file 1',\n  }\n",
            "masked_code": "<line_mask>\nwith fs.mock():\n\n  fs.add_file('/path/to/file1', 'Content of file 1')\n\n  assert tf.io.gfile.exists('/path/to/file1')\n  with tf.io.gfile.GFile('/path/to/file2', 'w') as f:\n    f.write('Content of file 2')\n  tf.io.gfile.rename('/path/to/file1', '/path/to/file1_moved')\n\n  assert fs.files == {\n      '/path/to/file2': 'Content of file 2',\n      '/path/to/file1_moved': 'Content of file 1',\n  }\n",
            "masked_line": "fs = MockFs()",
            "answer": "MockFs",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_921"
        },
        {
            "dependency": "tensorflow_datasets",
            "version": "==4.3.0",
            "time": "2021-05-06",
            "description": "The code retrieves all markdown files in the 'docs/catalog' directory of the 'tensorflow/datasets' GitHub repository. It also verifies that the GitHub path object contains the correct subpath, repo, and branch information.",
            "code": "path = GithubPath.from_repo('tensorflow/datasets')\npath = path / 'docs' / 'catalog'\nassert path.is_dir()\ndatasets = [\n    p.name for p in path.iterdir() if p.match('*.md')\n]\n\npath = GithubPath('github://tensorflow/datasets/tree/master/docs/README.md')\nassert path.subpath == 'docs/README.md'\nassert path.repo == 'tensorflow/datasets'\nassert path.branch == 'master'",
            "masked_code": "path = GithubPath.from_repo('tensorflow/datasets')\npath = path / 'docs' / 'catalog'\nassert path.is_dir()\ndatasets = [\n    p.name for p in path.iterdir() if p.match('*.md')\n]\n\n<line_mask>\nassert path.subpath == 'docs/README.md'\nassert path.repo == 'tensorflow/datasets'\nassert path.branch == 'master'",
            "masked_line": "path = GithubPath('github://tensorflow/datasets/tree/master/docs/README.md')",
            "answer": "GithubPath",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_922"
        },
        {
            "dependency": "tensorflow_datasets",
            "version": "==4.3.0",
            "time": "2021-05-06",
            "description": "The code defines a custom dataset class `MyDataset` which extends the `GeneratorBasedBuilder` class from the `datasets` module. The code then loads a dataset `my_dataset` using the `tfds.load` function provided by TensorFlow Datasets, which uses the corresponding `datasets` API for loading the dataset.",
            "code": "import tensorflow_datasets as tfds\n\nwith tfds.core.community.mock_huggingface_import():\n  import datasets  # `datasets` is a _MockedHFDatasets\n\n# Using `datasets.Xyz` uses the corresponding `tfds.Xyz` API\nclass MyDataset(datasets.GeneratorBasedBuilder):\n  version = datasets.Version('1.0.0')\n  ...\n\n# This works !!\nds = tfds.load('my_dataset')\n",
            "masked_code": "import tensorflow_datasets as tfds\n\n<line_mask>\n  import datasets  # `datasets` is a _MockedHFDatasets\n\n# Using `datasets.Xyz` uses the corresponding `tfds.Xyz` API\nclass MyDataset(datasets.GeneratorBasedBuilder):\n  version = datasets.Version('1.0.0')\n  ...\n\n# This works !!\nds = tfds.load('my_dataset')\n",
            "masked_line": "with tfds.core.community.mock_huggingface_import():",
            "answer": "mock_huggingface_import",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_923"
        },
        {
            "dependency": "torch",
            "version": "==1.1.0",
            "time": "2019-04-30",
            "description": "This code generates the Cartesian product of two tensors created from the input lists 'a' and 'b'.",
            "code": "a = [1, 2, 3]\nb = [4, 5]\ntensor_a = torch.tensor(a)\ntensor_b = torch.tensor(b)\ntorch.cartesian_prod(tensor_a, tensor_b)\ntensor([[1, 4],\n        [1, 5],\n        [2, 4],\n        [2, 5],\n        [3, 4],\n        [3, 5]])",
            "masked_code": "a = [1, 2, 3]\nb = [4, 5]\ntensor_a = torch.tensor(a)\ntensor_b = torch.tensor(b)\n<line_mask>\ntensor([[1, 4],\n        [1, 5],\n        [2, 4],\n        [2, 5],\n        [3, 4],\n        [3, 5]])",
            "masked_line": "torch.cartesian_prod(tensor_a, tensor_b)",
            "answer": "cartesian_prod",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_924"
        },
        {
            "dependency": "torch",
            "version": "==1.1.0",
            "time": "2019-04-30",
            "description": "The code performs LU decomposition on a randomly generated 2x3x3 tensor using the torch.lu() function in PyTorch. It then checks if the LU factorization succeeded for all samples and prints a success message if it did.",
            "code": "A = torch.randn(2, 3, 3)\nA_LU, pivots = torch.lu(A)\nA_LU\ntensor([[[ 1.3506,  2.5558, -0.0816],\n         [ 0.1684,  1.1551,  0.1940],\n         [ 0.1193,  0.6189, -0.5497]],\n\n        [[ 0.4526,  1.2526, -0.3285],\n         [-0.7988,  0.7175, -0.9701],\n         [ 0.2634, -0.9255, -0.3459]]])\npivots\ntensor([[ 3,  3,  3],\n        [ 3,  3,  3]], dtype=torch.int32)\nA_LU, pivots, info = torch.lu(A, get_infos=True)\nif info.nonzero().size(0) == 0:\n    print('LU factorization succeeded for all samples!')\n",
            "masked_code": "A = torch.randn(2, 3, 3)\nA_LU, pivots = torch.lu(A)\nA_LU\ntensor([[[ 1.3506,  2.5558, -0.0816],\n         [ 0.1684,  1.1551,  0.1940],\n         [ 0.1193,  0.6189, -0.5497]],\n\n        [[ 0.4526,  1.2526, -0.3285],\n         [-0.7988,  0.7175, -0.9701],\n         [ 0.2634, -0.9255, -0.3459]]])\npivots\ntensor([[ 3,  3,  3],\n        [ 3,  3,  3]], dtype=torch.int32)\n<line_mask>\nif info.nonzero().size(0) == 0:\n    print('LU factorization succeeded for all samples!')\n",
            "masked_line": "A_LU, pivots, info = torch.lu(A, get_infos=True)",
            "answer": "lu",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_925"
        },
        {
            "dependency": "torch",
            "version": "==1.0.1",
            "time": "2019-02-07",
            "description": "This code generates a 4x4 tensor with random values and then finds the index of the maximum value along each row of the tensor.",
            "code": "a = torch.randn(4, 4)\na\ntensor([[ 1.3398,  0.2663, -0.2686,  0.2450],\n        [-0.7401, -0.8805, -0.3402, -1.1936],\n        [ 0.4907, -1.3948, -1.0691, -0.3132],\n        [-1.6092,  0.5419, -0.2993,  0.3195]])\n\ntorch.argmax(a, dim=1)\ntensor([ 0,  2,  0,  1])",
            "masked_code": "a = torch.randn(4, 4)\na\ntensor([[ 1.3398,  0.2663, -0.2686,  0.2450],\n        [-0.7401, -0.8805, -0.3402, -1.1936],\n        [ 0.4907, -1.3948, -1.0691, -0.3132],\n        [-1.6092,  0.5419, -0.2993,  0.3195]])\n\n<line_mask>\ntensor([ 0,  2,  0,  1])",
            "masked_line": "torch.argmax(a, dim=1)",
            "answer": "argmax",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_926"
        },
        {
            "dependency": "torch",
            "version": "==1.10.0",
            "time": "2021-10-15",
            "description": "The code defines two lambda functions to calculate values based on the epoch, creates a LambdaSL scheduler with these lambda functions, then iterates through 100 epochs to train, validate, and adjust the scheduler.",
            "code": "lambda1 = lambda epoch: epoch // 30\nlambda2 = lambda epoch: 0.95 ** epoch\nscheduler = LambdaSL(sparsifier, sl_lambda=[lambda1, lambda2])\nfor epoch in range(100):\n    train(...)\n    validate(...)\n    scheduler.step()",
            "masked_code": "lambda1 = lambda epoch: epoch // 30\nlambda2 = lambda epoch: 0.95 ** epoch\n<line_mask>\nfor epoch in range(100):\n    train(...)\n    validate(...)\n    scheduler.step()",
            "masked_line": "scheduler = LambdaSL(sparsifier, sl_lambda=[lambda1, lambda2])",
            "answer": "LambdaSL",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_927"
        },
        {
            "dependency": "torch",
            "version": "==1.10.0",
            "time": "2021-10-15",
            "description": "This Python code defines a class called Inplace that implements methods for forward and backward operations. The forward method takes an input tensor x, increments its values by 1 in place, marks the input tensor as dirty, and returns the modified input tensor. The backward method simply returns the gradient of the output.",
            "code": "class Inplace(Function):\n    @staticmethod\n    def forward(ctx, x):\n        x_npy = x.numpy() # x_npy shares storage with x\n        x_npy += 1\n        ctx.mark_dirty(x)\n        return x\n\n    @staticmethod\n    @once_differentiable\n    def backward(ctx, grad_output):\n        return grad_output\n",
            "masked_code": "class Inplace(Function):\n    @staticmethod\n    def forward(ctx, x):\n        x_npy = x.numpy() # x_npy shares storage with x\n        x_npy += 1\n        <line_mask>\n        return x\n\n    @staticmethod\n    @once_differentiable\n    def backward(ctx, grad_output):\n        return grad_output\n",
            "masked_line": "ctx.mark_dirty(x)",
            "answer": "mark_dirty",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_928"
        },
        {
            "dependency": "torch",
            "version": "==1.10.0",
            "time": "2021-10-15",
            "description": "The given Python code calculates the gradient of the function y = a*b*c*a with respect to the inputs a, b, and c.",
            "code": "def f(a, b, c):\n    prod_1 = a * b\n    with torch.autograd.graph.save_on_cpu():\n        prod_2 = prod_1 * c\n    y = prod_2 * a\n    return y\n\ny = f(a, b, c)\n\ndel a, b, c\n\ny.sum().backward()\n",
            "masked_code": "def f(a, b, c):\n    prod_1 = a * b\n    <line_mask>\n        prod_2 = prod_1 * c\n    y = prod_2 * a\n    return y\n\ny = f(a, b, c)\n\ndel a, b, c\n\ny.sum().backward()\n",
            "masked_line": "with torch.autograd.graph.save_on_cpu():",
            "answer": "save_on_cpu",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_929"
        },
        {
            "dependency": "torch",
            "version": "==1.10.0",
            "time": "2021-10-15",
            "description": "The code defines a neural network model consisting of two linear layers with input sizes 16 and 8, and output sizes 8 and 4 respectively. A dropout layer is added between the linear layers. The model is then moved to the GPU specified by 'cuda:1' and is split into 8 chunks for processing.",
            "code": "fc1 = nn.Linear(16, 8).cuda(0)\nfc2 = nn.Linear(8, 4).cuda(1)\ndropout = nn.Dropout()\n\n# Dropout does not have any parameters/buffers, but we want to\n# run it on cuda:1 to avoid any GPU to CPU transfers.\nmodel = nn.Sequential(fc1, fc2, WithDevice(dropout, 'cuda:1'))\nmodel = Pipe(model, chunks=8)",
            "masked_code": "fc1 = nn.Linear(16, 8).cuda(0)\nfc2 = nn.Linear(8, 4).cuda(1)\ndropout = nn.Dropout()\n\n# Dropout does not have any parameters/buffers, but we want to\n# run it on cuda:1 to avoid any GPU to CPU transfers.\n<line_mask>\nmodel = Pipe(model, chunks=8)",
            "masked_line": "model = nn.Sequential(fc1, fc2, WithDevice(dropout, 'cuda:1'))",
            "answer": "WithDevice",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_930"
        },
        {
            "dependency": "torch",
            "version": "==1.10.0",
            "time": "2021-10-15",
            "description": "The code defines a dispatcher function 'f' that can register different types of functions. It registers an 'inc' function for integers that increments the input by 1, a 'dec' function for floats that decrements the input by 1, and a 'reverse' function for lists and tuples that reverses the input. It then calls the dispatcher function 'f' with different inputs.",
            "code": "f = Dispatcher('f')\n@f.register(int)\ndef inc(x):\n    return x + 1\n@f.register(float)\ndef dec(x):\n    return x - 1\n@f.register(list)\n@f.register(tuple)\ndef reverse(x):\n    return x[::-1]\nf(1)\nf(1.0)\nf([1, 2, 3])",
            "masked_code": "f = Dispatcher('f')\n@f.register(int)\ndef inc(x):\n    return x + 1\n<line_mask>\ndef dec(x):\n    return x - 1\n@f.register(list)\n@f.register(tuple)\ndef reverse(x):\n    return x[::-1]\nf(1)\nf(1.0)\nf([1, 2, 3])",
            "masked_line": "@f.register(float)",
            "answer": "register",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_931"
        },
        {
            "dependency": "torch",
            "version": "==1.10.0",
            "time": "2021-10-15",
            "description": "The code sets up a learning rate scheduler that decreases the learning rate by a factor of 0.5 every 4 iterations. It then runs a training loop for 100 epochs, where it trains the model and validates the model's performance while updating the learning rate at each iteration.",
            "code": "scheduler = ConstantLR(optimizer=self.opt, factor=0.5, total_iters=4)\nfor epoch in range(100):\n    train(...)\n    validate(...)\n    scheduler.step()",
            "masked_code": "<line_mask>\nfor epoch in range(100):\n    train(...)\n    validate(...)\n    scheduler.step()",
            "masked_line": "scheduler = ConstantLR(optimizer=self.opt, factor=0.5, total_iters=4)",
            "answer": "ConstantLR",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_932"
        },
        {
            "dependency": "torch",
            "version": "==1.10.0",
            "time": "2021-10-15",
            "description": "The code implements a linear learning rate scheduler for an optimizer with a starting factor of 0.5 and a total of 4 iterations. In each epoch (100 in total), it trains and validates the model using the specified functions and updates the learning rate using the scheduler.",
            "code": "scheduler = LinearLR(optimizer, start_factor=0.5, total_iters=4)\nfor epoch in range(100):\n    train(...)\n    validate(...)\n    scheduler.step()",
            "masked_code": "<line_mask>\nfor epoch in range(100):\n    train(...)\n    validate(...)\n    scheduler.step()",
            "masked_line": "scheduler = LinearLR(optimizer, start_factor=0.5, total_iters=4)",
            "answer": "LinearLR",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_933"
        },
        {
            "dependency": "torch",
            "version": "==1.10.0",
            "time": "2021-10-15",
            "description": "The code defines three learning rate schedulers: ConstantLR with a factor of 0.1 for 2 total iterations, ExponentialLR with a gamma of 0.9, and SequentialLR which sequentially applies the previously defined schedulers at specific milestones. The code then loops through 100 epochs, running training and validation functions, and updates the learning rate according to the scheduler at each step.",
            "code": "scheduler1 = ConstantLR(self.opt, factor=0.1, total_iters=2)\nscheduler2 = ExponentialLR(self.opt, gamma=0.9)\nscheduler = SequentialLR(self.opt, schedulers=[scheduler1, scheduler2], milestones=[2])\nfor epoch in range(100):\n    train(...)\n    validate(...)\n    scheduler.step()",
            "masked_code": "scheduler1 = ConstantLR(self.opt, factor=0.1, total_iters=2)\nscheduler2 = ExponentialLR(self.opt, gamma=0.9)\n<line_mask>\nfor epoch in range(100):\n    train(...)\n    validate(...)\n    scheduler.step()",
            "masked_line": "scheduler = SequentialLR(self.opt, schedulers=[scheduler1, scheduler2], milestones=[2])",
            "answer": "SequentialLR",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_934"
        },
        {
            "dependency": "torch",
            "version": "==1.10.0",
            "time": "2021-10-15",
            "description": "The code defines two learning rate schedulers, one with a constant learning rate factor of 0.1 for a total of 2 iterations, and another with an exponential decay factor of 0.9. It then chains these two schedulers together into one scheduler and applies it in a training loop over 100 epochs by alternating between training and validating the model and updating the learning rate using the chained scheduler.",
            "code": "scheduler1 = ConstantLR(self.opt, factor=0.1, total_iters=2)\nscheduler2 = ExponentialLR(self.opt, gamma=0.9)\nscheduler = ChainedScheduler([scheduler1, scheduler2])\nfor epoch in range(100):\n    train(...)\n    validate(...)\n    scheduler.step()",
            "masked_code": "scheduler1 = ConstantLR(self.opt, factor=0.1, total_iters=2)\nscheduler2 = ExponentialLR(self.opt, gamma=0.9)\n<line_mask>\nfor epoch in range(100):\n    train(...)\n    validate(...)\n    scheduler.step()",
            "masked_line": "scheduler = ChainedScheduler([scheduler1, scheduler2])",
            "answer": "ChainedScheduler",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_935"
        },
        {
            "dependency": "torch",
            "version": "==1.10.0",
            "time": "2021-10-15",
            "description": "This code creates subgroups for intra-machine communication, performs an allreduce operation within the machine using the created subgroups, and cleans up by destroying the process groups.",
            "code": "# Create intra-machine subgroups.\ncur_subgroup, subgroups = dist.new_subgroups()\n# Allreduce within the machine.\nrank = dist.get_rank()\ntensor = torch.ones(1, device=rank) * rank\ndist.all_reduce(tensor, group=cur_subgroup)\ntensor\ntensor([8])     # Assume 8 is the number of CUDA devices per machine.\n# Cleanup.\nfor subgroup in subgroups:\n    dist.destroy_process_group(subgroup)\n",
            "masked_code": "# Create intra-machine subgroups.\n<line_mask>\n# Allreduce within the machine.\nrank = dist.get_rank()\ntensor = torch.ones(1, device=rank) * rank\ndist.all_reduce(tensor, group=cur_subgroup)\ntensor\ntensor([8])     # Assume 8 is the number of CUDA devices per machine.\n# Cleanup.\nfor subgroup in subgroups:\n    dist.destroy_process_group(subgroup)\n",
            "masked_line": "cur_subgroup, subgroups = dist.new_subgroups()",
            "answer": "new_subgroups",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_936"
        },
        {
            "dependency": "torch",
            "version": "==1.3.0",
            "time": "2019-10-10",
            "description": "This code uses PyTorch's autograd profiler to profile the computation graph. It first calculates y = x^2, then calculates z = y^3 with the specified label \"label-z\", and finally performs backpropagation on y. The profiler is then used to print a table of the average timings of each function call, sorted by the total self CPU time.",
            "code": "with torch.autograd.profiler.profile() as prof:\n    y = x ** 2\n    with torch.autograd.profiler.record_function(\"label-z\"): # label the block\n        z = y ** 3\n    y.backward()\n\nprint(prof.key_averages().table(sort_by=\"self_cpu_time_total\"))\n",
            "masked_code": "with torch.autograd.profiler.profile() as prof:\n    y = x ** 2\n    <line_mask>\n        z = y ** 3\n    y.backward()\n\nprint(prof.key_averages().table(sort_by=\"self_cpu_time_total\"))\n",
            "masked_line": "with torch.autograd.profiler.record_function(\"label-z\"): # label the block",
            "answer": "record_function",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_937"
        },
        {
            "dependency": "torch",
            "version": "==1.3.0",
            "time": "2019-10-10",
            "description": "The code defines a class method called \"memory_efficient\" that takes an input tensor x, it then adds 10 to x and returns the result. An instance of the class is created using torch.jit.script with the argument use_memory_efficient set to False, then saved to a file \"m.pt\". Another instance is created with use_memory_efficient set to True, which raises an exception when called with a random tensor of size 100.",
            "code": "@torch.jit.unused\ndef memory_efficient(self, x):\n    import pdb\n    pdb.set_trace()\n    return x + 10\n\nm = torch.jit.script(MyModule(use_memory_efficent=False))\nm.save(\"m.pt\")\n\nm = torch.jit.script(MyModule(use_memory_efficient=True))\n# exception raised\nm(torch.rand(100))",
            "masked_code": "<line_mask>\ndef memory_efficient(self, x):\n    import pdb\n    pdb.set_trace()\n    return x + 10\n\nm = torch.jit.script(MyModule(use_memory_efficent=False))\nm.save(\"m.pt\")\n\nm = torch.jit.script(MyModule(use_memory_efficient=True))\n# exception raised\nm(torch.rand(100))",
            "masked_line": "@torch.jit.unused",
            "answer": "unused",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_938"
        },
        {
            "dependency": "torch",
            "version": "==1.6.0",
            "time": "2020-07-24",
            "description": "This code creates tensors A, B, C, D, and E using torch, and then it uses the torch.block_diag function to concatenate them diagonally into a single tensor.",
            "code": "import torch\nA = torch.tensor([[0, 1], [1, 0]])\nB = torch.tensor([[3, 4, 5], [6, 7, 8]])\nC = torch.tensor(7)\nD = torch.tensor([1, 2, 3])\nE = torch.tensor([[4], [5], [6]])\ntorch.block_diag(A, B, C, D, E)",
            "masked_code": "import torch\nA = torch.tensor([[0, 1], [1, 0]])\nB = torch.tensor([[3, 4, 5], [6, 7, 8]])\nC = torch.tensor(7)\nD = torch.tensor([1, 2, 3])\nE = torch.tensor([[4], [5], [6]])\n<line_mask>",
            "masked_line": "torch.block_diag(A, B, C, D, E)",
            "answer": "block_diag",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_939"
        },
        {
            "dependency": "torch",
            "version": "==1.6.0",
            "time": "2020-07-24",
            "description": "The code creates two future objects (fut0, fut1), collects them into a single future object (fut), sets results for fut0 and fut1, waits for the completion of all futures in fut, and prints the results of fut0 and fut1.",
            "code": "import torch\n\nfut0 = torch.futures.Future()\nfut1 = torch.futures.Future()\n\nfut = torch.futures.collect_all([fut0, fut1])\n\nfut0.set_result(0)\nfut1.set_result(1)\n\nfut_list = fut.wait()\nprint(f\"fut0 result = {fut_list[0].wait()}\")\nprint(f\"fut1 result = {fut_list[1].wait()}\")",
            "masked_code": "import torch\n\nfut0 = torch.futures.Future()\nfut1 = torch.futures.Future()\n\n<line_mask>\n\nfut0.set_result(0)\nfut1.set_result(1)\n\nfut_list = fut.wait()\nprint(f\"fut0 result = {fut_list[0].wait()}\")\nprint(f\"fut1 result = {fut_list[1].wait()}\")",
            "masked_line": "fut = torch.futures.collect_all([fut0, fut1])",
            "answer": "collect_all",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_940"
        },
        {
            "dependency": "torch",
            "version": "==1.6.0",
            "time": "2020-07-24",
            "description": "The code loads a LiteScriptModule from a saved file path or from a BytesIO object and loads all tensors to the original device.",
            "code": "import torch\nimport io\n\n# Load LiteScriptModule from saved file path\ntorch.jit._load_for_lite_interpreter('lite_script_module.pt')\n\n# Load LiteScriptModule from io.BytesIO object\nwith open('lite_script_module.pt', 'rb') as f:\n    buffer = io.BytesIO(f.read())\n\n# Load all tensors to the original device\ntorch.jit.mobile._load_for_lite_interpreter(buffer)",
            "masked_code": "import torch\nimport io\n\n# Load LiteScriptModule from saved file path\ntorch.jit._load_for_lite_interpreter('lite_script_module.pt')\n\n# Load LiteScriptModule from io.BytesIO object\nwith open('lite_script_module.pt', 'rb') as f:\n    buffer = io.BytesIO(f.read())\n\n# Load all tensors to the original device\n<line_mask>",
            "masked_line": "torch.jit.mobile._load_for_lite_interpreter(buffer)",
            "answer": "_load_for_lite_interpreter",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_941"
        },
        {
            "dependency": "torch",
            "version": "==1.6.0",
            "time": "2020-07-24",
            "description": "This code performs quantized 1D convolution operation using the provided inputs, filters, and bias with specified padding, scale, and zero point values.",
            "code": "from torch.nn.quantized import functional as qF\nfilters = torch.randn(33, 16, 3, dtype=torch.float)\ninputs = torch.randn(20, 16, 50, dtype=torch.float)\nbias = torch.randn(33, dtype=torch.float)\n\nscale, zero_point = 1.0, 0\ndtype_inputs = torch.quint8\ndtype_filters = torch.qint8\n\nq_filters = torch.quantize_per_tensor(filters, scale, zero_point, dtype_filters)\nq_inputs = torch.quantize_per_tensor(inputs, scale, zero_point, dtype_inputs)\nqF.conv1d(q_inputs, q_filters, bias, padding=1, scale=scale, zero_point=zero_point)\n",
            "masked_code": "from torch.nn.quantized import functional as qF\nfilters = torch.randn(33, 16, 3, dtype=torch.float)\ninputs = torch.randn(20, 16, 50, dtype=torch.float)\nbias = torch.randn(33, dtype=torch.float)\n\nscale, zero_point = 1.0, 0\ndtype_inputs = torch.quint8\ndtype_filters = torch.qint8\n\nq_filters = torch.quantize_per_tensor(filters, scale, zero_point, dtype_filters)\nq_inputs = torch.quantize_per_tensor(inputs, scale, zero_point, dtype_inputs)\n<line_mask>\n",
            "masked_line": "qF.conv1d(q_inputs, q_filters, bias, padding=1, scale=scale, zero_point=zero_point)",
            "answer": "conv1d",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_942"
        },
        {
            "dependency": "torch",
            "version": "==1.7.0",
            "time": "2020-10-23",
            "description": "The code creates a neural network model with a linear layer of input size 50 and output size 50, followed by reshaping the output into a 2x5x5 tensor. This process is repeated multiple times with different configurations for reshaping the output tensor.",
            "code": "m = nn.Sequential(\n    nn.Linear(50, 50),\n    nn.Unflatten(1, (2, 5, 5))\n)\noutput = m(output)\noutput.size()\n\nm = nn.Sequential(\n    nn.Linear(50, 50),\n    nn.Unflatten(1, torch.Size([2, 5, 5]))\n)\noutput = m(output)\noutput.size()\n\nm = nn.Sequential(\n    nn.Linear(50, 50),\n    nn.Unflatten('features', (('C', 2), ('H', 50), ('W',50)))\n)\noutput = m(output)\noutput.size()\n",
            "masked_code": "m = nn.Sequential(\n    nn.Linear(50, 50),\n    nn.Unflatten(1, (2, 5, 5))\n)\noutput = m(output)\noutput.size()\n\nm = nn.Sequential(\n    nn.Linear(50, 50),\n    nn.Unflatten(1, torch.Size([2, 5, 5]))\n)\noutput = m(output)\noutput.size()\n\nm = nn.Sequential(\n    nn.Linear(50, 50),\n    <line_mask>\n)\noutput = m(output)\noutput.size()\n",
            "masked_line": "nn.Unflatten('features', (('C', 2), ('H', 50), ('W',50)))",
            "answer": "Unflatten",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_943"
        },
        {
            "dependency": "torch",
            "version": "==1.7.0",
            "time": "2020-10-23",
            "description": "The code converts the input tensor into a 2-dimensional tensor by adding a new dimension if the input tensor is not already 2-dimensional.",
            "code": "x = torch.tensor(1.)\ntorch.atleast_2d(x)\nx = torch.randn(2,2)\ntorch.atleast_2d(x)\nx = torch.tensor(0.5)\ny = torch.tensor(1.)\ntorch.atleast_2d((x,y))",
            "masked_code": "x = torch.tensor(1.)\ntorch.atleast_2d(x)\nx = torch.randn(2,2)\n<line_mask>\nx = torch.tensor(0.5)\ny = torch.tensor(1.)\ntorch.atleast_2d((x,y))",
            "masked_line": "torch.atleast_2d(x)",
            "answer": "atleast_2d",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_944"
        },
        {
            "dependency": "torch",
            "version": "==2.2.0",
            "time": "2024-01-10",
            "description": "The code serializes an ONNX program generated from a PyTorch model and saves it to a destination file in the ONNX format using Protobuf serialization.",
            "code": "class ProtobufONNXProgramSerializer:\n    def serialize(\n        self, onnx_program: torch.onnx.ONNXProgram, destination: io.BufferedIOBase\n    ) -> None:\n        destination.write(onnx_program.model_proto.SerializeToString())\n\nmodel = MyModel()\narg1 = torch.randn(2, 2, 2)  # positional input 1\ntorch.onnx.dynamo_export(model, arg1).save(\n    destination=\"exported_model.onnx\",\n    serializer=ProtobufONNXProgramSerializer(),\n)",
            "masked_code": "class ProtobufONNXProgramSerializer:\n    <line_mask>\n        self, onnx_program: torch.onnx.ONNXProgram, destination: io.BufferedIOBase\n    ) -> None:\n        destination.write(onnx_program.model_proto.SerializeToString())\n\nmodel = MyModel()\narg1 = torch.randn(2, 2, 2)  # positional input 1\ntorch.onnx.dynamo_export(model, arg1).save(\n    destination=\"exported_model.onnx\",\n    serializer=ProtobufONNXProgramSerializer(),\n)",
            "masked_line": "def serialize(",
            "answer": "serialize",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_945"
        },
        {
            "dependency": "torch",
            "version": "==2.2.0",
            "time": "2024-01-10",
            "description": "The code defines a series of test functions using different combinations of parameters and decorators based on certain conditions. Each test function is used to test different scenarios or properties of functions, operations, modules, or objects in the codebase.",
            "code": "@decorateIf(unittest.skip, lambda params: params[\"x\"] == 2)\n@parametrize(\"x\", range(5))\ndef test_foo(self, x):\n    ...\n\n@parametrize(\"x,y\", [(1, 'foo'), (2, 'bar'), (3, 'baz')])\n@decorateIf(\n    unittest.expectedFailure,\n    lambda params: params[\"x\"] == 3 and params[\"y\"] == \"baz\"\n)\ndef test_bar(self, x, y):\n    ...\n\n@decorateIf(\n    unittest.expectedFailure,\n    lambda params: params[\"op\"].name == \"add\" and params[\"dtype\"] == torch.float16\n)\n@ops(op_db)\ndef test_op_foo(self, device, dtype, op):\n    ...\n\n@decorateIf(\n    unittest.skip,\n    lambda params: params[\"module_info\"].module_cls is torch.nn.Linear and params[\"device\"] == \"cpu\"\n)\n@modules(module_db)\ndef test_module_foo(self, device, dtype, module_info):\n    ...",
            "masked_code": "@decorateIf(unittest.skip, lambda params: params[\"x\"] == 2)\n@parametrize(\"x\", range(5))\ndef test_foo(self, x):\n    ...\n\n@parametrize(\"x,y\", [(1, 'foo'), (2, 'bar'), (3, 'baz')])\n@decorateIf(\n    unittest.expectedFailure,\n    lambda params: params[\"x\"] == 3 and params[\"y\"] == \"baz\"\n)\ndef test_bar(self, x, y):\n    ...\n\n<line_mask>\n    unittest.expectedFailure,\n    lambda params: params[\"op\"].name == \"add\" and params[\"dtype\"] == torch.float16\n)\n@ops(op_db)\ndef test_op_foo(self, device, dtype, op):\n    ...\n\n@decorateIf(\n    unittest.skip,\n    lambda params: params[\"module_info\"].module_cls is torch.nn.Linear and params[\"device\"] == \"cpu\"\n)\n@modules(module_db)\ndef test_module_foo(self, device, dtype, module_info):\n    ...",
            "masked_line": "@decorateIf(",
            "answer": "decorateIf",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_946"
        },
        {
            "dependency": "torch",
            "version": "==2.2.0",
            "time": "2024-01-10",
            "description": "The code checks if the specified version number is a pre-release version.",
            "code": "Version(\"1.2.3\").is_prerelease\nVersion(\"1.2.3a1\").is_prerelease\nVersion(\"1.2.3b1\").is_prerelease\nVersion(\"1.2.3rc1\").is_prerelease\nVersion(\"1.2.3dev1\").is_prerelease",
            "masked_code": "Version(\"1.2.3\").is_prerelease\n<line_mask>\nVersion(\"1.2.3b1\").is_prerelease\nVersion(\"1.2.3rc1\").is_prerelease\nVersion(\"1.2.3dev1\").is_prerelease",
            "masked_line": "Version(\"1.2.3a1\").is_prerelease",
            "answer": "is_prerelease",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_947"
        },
        {
            "dependency": "torch",
            "version": "==2.2.0",
            "time": "2024-01-10",
            "description": "The code uses the torch.unravel_index function to convert flat indices to multi-dimensional indices in a given shape. It handles single and multiple input indices, and can work with different shapes such as 2D, 3D, and 4D.",
            "code": "import torch\ntorch.unravel_index(torch.tensor(4), (3, 2))\ntorch.unravel_index(torch.tensor([4, 1]), (3, 2))\ntorch.unravel_index(torch.tensor([0, 1, 2, 3, 4, 5]), (3, 2))\ntorch.unravel_index(torch.tensor([1234, 5678]), (10, 10, 10, 10))\ntorch.unravel_index(torch.tensor([[1234], [5678]]), (10, 10, 10, 10))\ntorch.unravel_index(torch.tensor([[1234], [5678]]), (100, 100))\n",
            "masked_code": "import torch\ntorch.unravel_index(torch.tensor(4), (3, 2))\ntorch.unravel_index(torch.tensor([4, 1]), (3, 2))\ntorch.unravel_index(torch.tensor([0, 1, 2, 3, 4, 5]), (3, 2))\ntorch.unravel_index(torch.tensor([1234, 5678]), (10, 10, 10, 10))\n<line_mask>\ntorch.unravel_index(torch.tensor([[1234], [5678]]), (100, 100))\n",
            "masked_line": "torch.unravel_index(torch.tensor([[1234], [5678]]), (10, 10, 10, 10))",
            "answer": "unravel_index",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_948"
        },
        {
            "dependency": "torch",
            "version": "==2.2.0",
            "time": "2024-01-10",
            "description": "This code defines a custom Torch library function \"mylib::sin\" for calculating the sine of a Tensor input, implements it for the CPU, and tests its correctness by comparing the output with the input after applying the function.",
            "code": "torch.library.define(\"mylib::sin\", \"(Tensor x) -> Tensor\")\n@torch.library.impl(\"mylibrary::sin\", \"cpu\")\ndef f(x):\n    return torch.from_numpy(np.sin(x.numpy()))\nx = torch.randn(3)\ny = torch.ops.mylib.sin(x)\nassert torch.allclose(y, x)",
            "masked_code": "<line_mask>\n@torch.library.impl(\"mylibrary::sin\", \"cpu\")\ndef f(x):\n    return torch.from_numpy(np.sin(x.numpy()))\nx = torch.randn(3)\ny = torch.ops.mylib.sin(x)\nassert torch.allclose(y, x)",
            "masked_line": "torch.library.define(\"mylib::sin\", \"(Tensor x) -> Tensor\")",
            "answer": "define",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_949"
        },
        {
            "dependency": "torch",
            "version": "==2.2.0",
            "time": "2024-01-10",
            "description": "The code distributes a randomly generated tensor onto a specified mesh using a given placement strategy and then converts the tensor into a partition specification for XLA processing.",
            "code": "t = torch.randn(4, 8, 8)\ndt_mesh = DeviceMesh(\"xla\", torch.arange(8).reshape(2,4))\nplacements = [Replicate(), Shard(0)]\nmy_dtensor = distribute_tensor(t, dt_mesh, placements)\n\npartition_spec = convert_to_xla_partition_spec(t, placements)\n",
            "masked_code": "t = torch.randn(4, 8, 8)\ndt_mesh = DeviceMesh(\"xla\", torch.arange(8).reshape(2,4))\nplacements = [Replicate(), Shard(0)]\nmy_dtensor = distribute_tensor(t, dt_mesh, placements)\n\n<line_mask>\n",
            "masked_line": "partition_spec = convert_to_xla_partition_spec(t, placements)",
            "answer": "convert_to_xla_partition_spec",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_950"
        },
        {
            "dependency": "torch",
            "version": "==2.2.0",
            "time": "2024-01-10",
            "description": "The code creates two PyTorch tensors with float data type and requires gradient tracking, and then creates a nested tensor using these two tensors. The final output indicates that the nested tensor is a leaf node in the computation graph.",
            "code": "a = torch.arange(3, dtype=torch.float, requires_grad=True)\nb = torch.arange(5, dtype=torch.float, requires_grad=True)\nnt = torch.nested.nested_tensor([a, b], requires_grad=True)\nnt.is_leaf\nTrue\n",
            "masked_code": "a = torch.arange(3, dtype=torch.float, requires_grad=True)\nb = torch.arange(5, dtype=torch.float, requires_grad=True)\n<line_mask>\nnt.is_leaf\nTrue\n",
            "masked_line": "nt = torch.nested.nested_tensor([a, b], requires_grad=True)",
            "answer": "nested_tensor",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_951"
        },
        {
            "dependency": "torch",
            "version": "==2.2.0",
            "time": "2024-01-10",
            "description": "The function returns a list of all the leaves (values) in the input tree dictionary, including leaves from nested sub-trees.",
            "code": "tree = {'b': (2, [3, 4]), 'a': 1, 'c': None, 'd': 5}\ntree_leaves(tree)\n[1, 2, 3, 4, None, 5]\ntree_leaves(1)\n[1]\ntree_leaves(None)\n[None]",
            "masked_code": "tree = {'b': (2, [3, 4]), 'a': 1, 'c': None, 'd': 5}\ntree_leaves(tree)\n[1, 2, 3, 4, None, 5]\ntree_leaves(1)\n[1]\n<line_mask>\n[None]",
            "masked_line": "tree_leaves(None)",
            "answer": "tree_leaves",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_952"
        },
        {
            "dependency": "torch",
            "version": "==2.2.0",
            "time": "2024-01-10",
            "description": "This code defines a function that takes a tree data structure as input and returns a list of all the leaf nodes in the tree. Leaf nodes are nodes that do not have any child nodes.",
            "code": "tree = {'b': (2, [3, 4]), 'a': 1, 'c': None, 'd': 5}\ntree_leaves(tree)\n[1, 2, 3, 4, None, 5]\ntree_leaves(1)\n[1]\ntree_leaves(None)\n[None]",
            "masked_code": "tree = {'b': (2, [3, 4]), 'a': 1, 'c': None, 'd': 5}\n<line_mask>\n[1, 2, 3, 4, None, 5]\ntree_leaves(1)\n[1]\ntree_leaves(None)\n[None]",
            "masked_line": "tree_leaves(tree)",
            "answer": "tree_leaves",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_953"
        },
        {
            "dependency": "torchaudio",
            "version": "==0.9.0",
            "time": "2021-06-15",
            "description": "The code loads a pre-trained Wav2Vec2 model, saves its state dictionary to a file, and then loads the model state dictionary back into a new Wav2Vec2 model with a specified number of output units.",
            "code": "from torchaudio.models.wav2vec2.utils import import_huggingface_model\n\noriginal = Wav2Vec2ForCTC.from_pretrained(\"facebook/wav2vec2-large-960h\")\nmodel = import_huggingface_model(original)\ntorch.save(model.state_dict(), \"wav2vec2-base-960h.pt\")\n\nmodel = wav2vec2_large(num_out=32)\nmodel.load_state_dict(torch.load(\"wav2vec2-base-960h.pt\"))\n",
            "masked_code": "from torchaudio.models.wav2vec2.utils import import_huggingface_model\n\noriginal = Wav2Vec2ForCTC.from_pretrained(\"facebook/wav2vec2-large-960h\")\nmodel = import_huggingface_model(original)\ntorch.save(model.state_dict(), \"wav2vec2-base-960h.pt\")\n\n<line_mask>\nmodel.load_state_dict(torch.load(\"wav2vec2-base-960h.pt\"))\n",
            "masked_line": "model = wav2vec2_large(num_out=32)",
            "answer": "wav2vec2_large",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_954"
        },
        {
            "dependency": "torchaudio",
            "version": "==0.9.0",
            "time": "2021-06-15",
            "description": "This code loads a pre-trained Wav2Vec2 model from Hugging Face, imports it, loads an audio waveform from a file, and then uses the model to generate logits for the input waveform.",
            "code": "from torchaudio.models.wav2vec2.utils import import_huggingface_model\n\noriginal = Wav2Vec2ForCTC.from_pretrained(\"facebook/wav2vec2-base-960h\")\nmodel = import_huggingface_model(original)\n\nwaveforms, _ = torchaudio.load(\"audio.wav\")\nlogits, _ = model(waveforms)\n",
            "masked_code": "from torchaudio.models.wav2vec2.utils import import_huggingface_model\n\noriginal = Wav2Vec2ForCTC.from_pretrained(\"facebook/wav2vec2-base-960h\")\n<line_mask>\n\nwaveforms, _ = torchaudio.load(\"audio.wav\")\nlogits, _ = model(waveforms)\n",
            "masked_line": "model = import_huggingface_model(original)",
            "answer": "import_huggingface_model",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_955"
        },
        {
            "dependency": "torchaudio",
            "version": "==0.8.1",
            "time": "2021-03-20",
            "description": "This code sets the encoding information for an audio file, including the encoding type, bits per sample, compression, and various options like reversing bytes, nibbles, and bits, as well as setting the endianness of the audio data.",
            "code": "ei = torchaudio.sox_encodinginfo_t()\nei.encoding = torchaudio.get_sox_encoding_t(1)\nei.bits_per_sample = 16\nei.compression = 0\nei.reverse_bytes = torchaudio.get_sox_option_t(2)\nei.reverse_nibbles = torchaudio.get_sox_option_t(2)\nei.reverse_bits = torchaudio.get_sox_option_t(2)\nei.opposite_endian = torchaudio.get_sox_bool(0)\n",
            "masked_code": "<line_mask>\nei.encoding = torchaudio.get_sox_encoding_t(1)\nei.bits_per_sample = 16\nei.compression = 0\nei.reverse_bytes = torchaudio.get_sox_option_t(2)\nei.reverse_nibbles = torchaudio.get_sox_option_t(2)\nei.reverse_bits = torchaudio.get_sox_option_t(2)\nei.opposite_endian = torchaudio.get_sox_bool(0)\n",
            "masked_line": "ei = torchaudio.sox_encodinginfo_t()",
            "answer": "sox_encodinginfo_t",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_956"
        },
        {
            "dependency": "torchaudio",
            "version": "==2.1.0",
            "time": "2023-09-21",
            "description": "The code defines a dictionary mapping characters to integer values, with optional exclusion of a specific character (\"*\").",
            "code": "from torchaudio.pipelines import MMS_FA as bundle\nbundle.get_dict()\n{'-': 0, 'a': 1, 'i': 2, 'e': 3, 'n': 4, 'o': 5, 'u': 6, 't': 7, 's': 8, 'r': 9, 'm': 10, 'k': 11, 'l': 12, 'd': 13, 'g': 14, 'h': 15, 'y': 16, 'b': 17, 'p': 18, 'w': 19, 'c': 20, 'v': 21, 'j': 22, 'z': 23, 'f': 24, \"'\": 25, 'q': 26, 'x': 27, '*': 28}\nbundle.get_dict(star=None)\n{'-': 0, 'a': 1, 'i': 2, 'e': 3, 'n': 4, 'o': 5, 'u': 6, 't': 7, 's': 8, 'r': 9, 'm': 10, 'k': 11, 'l': 12, 'd': 13, 'g': 14, 'h': 15, 'y': 16, 'b': 17, 'p': 18, 'w': 19, 'c': 20, 'v': 21, 'j': 22, 'z': 23, 'f': 24, \"'\": 25, 'q': 26, 'x': 27}\n",
            "masked_code": "from torchaudio.pipelines import MMS_FA as bundle\nbundle.get_dict()\n{'-': 0, 'a': 1, 'i': 2, 'e': 3, 'n': 4, 'o': 5, 'u': 6, 't': 7, 's': 8, 'r': 9, 'm': 10, 'k': 11, 'l': 12, 'd': 13, 'g': 14, 'h': 15, 'y': 16, 'b': 17, 'p': 18, 'w': 19, 'c': 20, 'v': 21, 'j': 22, 'z': 23, 'f': 24, \"'\": 25, 'q': 26, 'x': 27, '*': 28}\n<line_mask>\n{'-': 0, 'a': 1, 'i': 2, 'e': 3, 'n': 4, 'o': 5, 'u': 6, 't': 7, 's': 8, 'r': 9, 'm': 10, 'k': 11, 'l': 12, 'd': 13, 'g': 14, 'h': 15, 'y': 16, 'b': 17, 'p': 18, 'w': 19, 'c': 20, 'v': 21, 'j': 22, 'z': 23, 'f': 24, \"'\": 25, 'q': 26, 'x': 27}\n",
            "masked_line": "bundle.get_dict(star=None)",
            "answer": "get_dict",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_957"
        },
        {
            "dependency": "torchaudio",
            "version": "==2.1.0",
            "time": "2023-09-21",
            "description": "The code decodes a sequence of emissions using the CTC decoder and returns the final hypothesis after processing each emission step by step.",
            "code": "decoder = torchaudio.models.decoder.ctc_decoder(...)\ndecoder.decode_begin()\ndecoder.decode_step(emission1)\ndecoder.decode_step(emission2)\ndecoder.decode_end()\nresult = decoder.get_final_hypothesis()",
            "masked_code": "decoder = torchaudio.models.decoder.ctc_decoder(...)\ndecoder.decode_begin()\n<line_mask>\ndecoder.decode_step(emission2)\ndecoder.decode_end()\nresult = decoder.get_final_hypothesis()",
            "masked_line": "decoder.decode_step(emission1)",
            "answer": "decode_step",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_958"
        },
        {
            "dependency": "torchvision",
            "version": "==0.4.0",
            "time": "2019-08-06",
            "description": "The code creates an instance of the MNASNet model with 1000 classes and a width scale factor of 1.0. It then generates a random tensor \"x\" with shape (1, 3, 224, 224) and passes it through the model to obtain an output \"y\". It then calculates the dimensionality of \"y\" using the dim() method and the total number of elements in \"y\" using the nelement() method.",
            "code": "model = MNASNet(1000, 1.0)\nx = torch.rand(1, 3, 224, 224)\ny = model(x)\ny.dim()\ny.nelement()",
            "masked_code": "<line_mask>\nx = torch.rand(1, 3, 224, 224)\ny = model(x)\ny.dim()\ny.nelement()",
            "masked_line": "model = MNASNet(1000, 1.0)",
            "answer": "MNASNet",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_959"
        },
        {
            "dependency": "torchvision",
            "version": "==0.5.0",
            "time": "2020-01-13",
            "description": "The code performs 2D deformable convolution operation on the input tensor using the given offset and weight tensors, resulting in an output tensor with a specific shape.",
            "code": "input = torch.rand(1, 3, 10, 10)\nkh, kw = 3, 3\nweight = torch.rand(5, 3, kh, kw)\noffset = torch.rand(5, 2 * kh * kw, 8, 8)\nout = deform_conv2d(input, offset, weight)\nprint(out.shape)\n",
            "masked_code": "input = torch.rand(1, 3, 10, 10)\nkh, kw = 3, 3\nweight = torch.rand(5, 3, kh, kw)\noffset = torch.rand(5, 2 * kh * kw, 8, 8)\n<line_mask>\nprint(out.shape)\n",
            "masked_line": "out = deform_conv2d(input, offset, weight)",
            "answer": "deform_conv2d",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_960"
        },
        {
            "dependency": "torchvision",
            "version": "==0.8.0",
            "time": "2020-10-27",
            "description": "This code initializes a ResNet-50 backbone with a feature pyramid network (FPN) and loads pre-trained weights. It then generates a random input tensor of shape (1, 3, 64, 64) and passes it through the backbone to obtain a dictionary of output feature maps for different levels of the FPN. The code finally prints the shapes of the output feature maps.",
            "code": "from torchvision.models.detection.backbone_utils import resnet_fpn_backbone\nbackbone = resnet_fpn_backbone('resnet50', pretrained=True, trainable_layers=3)\nx = torch.rand(1,3,64,64)\noutput = backbone(x)\nprint([(k, v.shape) for k, v in output.items()])\n",
            "masked_code": "from torchvision.models.detection.backbone_utils import resnet_fpn_backbone\n<line_mask>\nx = torch.rand(1,3,64,64)\noutput = backbone(x)\nprint([(k, v.shape) for k, v in output.items()])\n",
            "masked_line": "backbone = resnet_fpn_backbone('resnet50', pretrained=True, trainable_layers=3)",
            "answer": "resnet_fpn_backbone",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_961"
        },
        {
            "dependency": "tqdm",
            "version": "==4.40.0",
            "time": "2019-12-01",
            "description": "This code reads chunks of data from a file object with a specified chunk size using a loop until there is no more data left to read.",
            "code": "with tqdm.wrapattr(file_obj, \"read\", total=file_obj.size) as fobj:\n    while True:\n        chunk = fobj.read(chunk_size)\n        if not chunk:\n            break",
            "masked_code": "<line_mask>\n    while True:\n        chunk = fobj.read(chunk_size)\n        if not chunk:\n            break",
            "masked_line": "with tqdm.wrapattr(file_obj, \"read\", total=file_obj.size) as fobj:",
            "answer": "wrapattr",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_962"
        },
        {
            "dependency": "tqdm",
            "version": "==4.60.0",
            "time": "2021-04-06",
            "description": "This code redirects console logging to tqdm.write() using logging_redirect_tqdm while iterating through a range of 9, and outputs a console log message when i is equal to 4.",
            "code": "import logging\nfrom tqdm import trange\nfrom tqdm.contrib.logging import logging_redirect_tqdm\n\nLOG = logging.getLogger(__name__)\n\nif __name__ == '__main__':\n    logging.basicConfig(level=logging.INFO)\n    with logging_redirect_tqdm():\n        for i in trange(9):\n            if i == 4:\n                LOG.info(\"console logging redirected to `tqdm.write()`\")\n    # logging restored\n",
            "masked_code": "import logging\nfrom tqdm import trange\n<line_mask>\n\nLOG = logging.getLogger(__name__)\n\nif __name__ == '__main__':\n    logging.basicConfig(level=logging.INFO)\n    with logging_redirect_tqdm():\n        for i in trange(9):\n            if i == 4:\n                LOG.info(\"console logging redirected to `tqdm.write()`\")\n    # logging restored\n",
            "masked_line": "from tqdm.contrib.logging import logging_redirect_tqdm",
            "answer": "logging_redirect_tqdm",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_963"
        },
        {
            "dependency": "traitlets",
            "version": "==4.1.0",
            "time": "2016-01-15",
            "description": "The code defines a function foo that raises a RuntimeWarning with the message \"bar\". The code then sets a simple filter for warnings to 'once' and calls foo within the context manager. After that, it imports the assert_warns function from numpy.testing and calls foo again. Finally, it uses the all_warnings context manager to check if the assert_warns function correctly raises a RuntimeWarning when calling foo.",
            "code": "import warnings\ndef foo():\n    warnings.warn(RuntimeWarning(\"bar\"))\n\nwith warnings.catch_warnings():\n    warnings.simplefilter('once')\n    foo()\n\nfrom numpy.testing import assert_warns\nfoo()\n\nwith all_warnings():\n    assert_warns(RuntimeWarning, foo)",
            "masked_code": "import warnings\ndef foo():\n    warnings.warn(RuntimeWarning(\"bar\"))\n\nwith warnings.catch_warnings():\n    warnings.simplefilter('once')\n    foo()\n\nfrom numpy.testing import assert_warns\nfoo()\n\n<line_mask>\n    assert_warns(RuntimeWarning, foo)",
            "masked_line": "with all_warnings():",
            "answer": "all_warnings",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_964"
        },
        {
            "dependency": "transformers",
            "version": "==2.1.0",
            "time": "2019-10-09",
            "description": "This code segment uses the CTRL model and tokenizer from the transformers library to encode a given text input, then feeds it into the model to generate outputs. It calculates the loss and logits based on the input text.",
            "code": "import torch\nfrom transformers import CTRLTokenizer, CTRLLMHeadModel\n\ntokenizer = CTRLTokenizer.from_pretrained('ctrl')\nmodel = CTRLLMHeadModel.from_pretrained('ctrl')\n\ninput_ids = torch.tensor(tokenizer.encode(\"Links Hello, my dog is cute\")).unsqueeze(0)  # Batch size 1\noutputs = model(input_ids, labels=input_ids)\nloss, logits = outputs[:2]",
            "masked_code": "import torch\nfrom transformers import CTRLTokenizer, CTRLLMHeadModel\n\ntokenizer = CTRLTokenizer.from_pretrained('ctrl')\n<line_mask>\n\ninput_ids = torch.tensor(tokenizer.encode(\"Links Hello, my dog is cute\")).unsqueeze(0)  # Batch size 1\noutputs = model(input_ids, labels=input_ids)\nloss, logits = outputs[:2]",
            "masked_line": "model = CTRLLMHeadModel.from_pretrained('ctrl')",
            "answer": "CTRLLMHeadModel",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_965"
        },
        {
            "dependency": "transformers",
            "version": "==2.1.0",
            "time": "2019-10-09",
            "description": "The code tokenizes a given input text using the CTRL tokenizer and passes it through a pre-trained CTRL model to obtain the last hidden states of the model.",
            "code": "import tensorflow as tf\nfrom transformers import CTRLTokenizer, TFCTRLModel\n\ntokenizer = CTRLTokenizer.from_pretrained('ctrl')\nmodel = TFCTRLModel.from_pretrained('ctrl')\ninput_ids = tf.constant(tokenizer.encode(\"Hello, my dog is cute\"))[None, :]  # Batch size 1\noutputs = model(input_ids)\nlast_hidden_states = outputs[0]  # The last hidden-state is the first element of the output tuple",
            "masked_code": "import tensorflow as tf\n<line_mask>\n\ntokenizer = CTRLTokenizer.from_pretrained('ctrl')\nmodel = TFCTRLModel.from_pretrained('ctrl')\ninput_ids = tf.constant(tokenizer.encode(\"Hello, my dog is cute\"))[None, :]  # Batch size 1\noutputs = model(input_ids)\nlast_hidden_states = outputs[0]  # The last hidden-state is the first element of the output tuple",
            "masked_line": "from transformers import CTRLTokenizer, TFCTRLModel",
            "answer": "TFCTRLModel",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_966"
        },
        {
            "dependency": "transformers",
            "version": "==2.1.0",
            "time": "2019-10-09",
            "description": "This code segment utilizes the CTRL model and tokenizer to generate a prediction for the input text \"Links Hello, my dog is cute\" and calculates the loss based on the predicted output.",
            "code": "import torch\nfrom transformers import CTRLTokenizer, TFCTRLLMHeadModel\n\ntokenizer = CTRLTokenizer.from_pretrained('ctrl')\nmodel = TFCTRLLMHeadModel.from_pretrained('ctrl')\n\ninput_ids = torch.tensor(tokenizer.encode(\"Links Hello, my dog is cute\")).unsqueeze(0)  # Batch size 1\noutputs = model(input_ids, labels=input_ids)\nloss, logits = outputs[:2]",
            "masked_code": "import torch\nfrom transformers import CTRLTokenizer, TFCTRLLMHeadModel\n\ntokenizer = CTRLTokenizer.from_pretrained('ctrl')\n<line_mask>\n\ninput_ids = torch.tensor(tokenizer.encode(\"Links Hello, my dog is cute\")).unsqueeze(0)  # Batch size 1\noutputs = model(input_ids, labels=input_ids)\nloss, logits = outputs[:2]",
            "masked_line": "model = TFCTRLLMHeadModel.from_pretrained('ctrl')",
            "answer": "TFCTRLLMHeadModel",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_967"
        },
        {
            "dependency": "transformers",
            "version": "==2.2.0",
            "time": "2019-11-26",
            "description": "The code utilizes a pre-trained transformer model to tokenize and encode the input text \"Hello, my dog is cute\". The model then generates the last hidden states based on the input, which can be further utilized for downstream natural language processing tasks.",
            "code": "import tensorflow as tf\nfrom transformers import XxxTokenizer, TFXxxModel\n\ntokenizer = XxxTokenizer.from_pretrained('xxx-base-uncased')\nmodel = TFXxxModel.from_pretrained('xxx-base-uncased')\ninput_ids = tf.constant(tokenizer.encode(\"Hello, my dog is cute\"))[None, :]  # Batch size 1\noutputs = model(input_ids)\nlast_hidden_states = outputs[0]  # The last hidden-state is the first element of the output tuple",
            "masked_code": "import tensorflow as tf\nfrom transformers import XxxTokenizer, TFXxxModel\n\ntokenizer = XxxTokenizer.from_pretrained('xxx-base-uncased')\n<line_mask>\ninput_ids = tf.constant(tokenizer.encode(\"Hello, my dog is cute\"))[None, :]  # Batch size 1\noutputs = model(input_ids)\nlast_hidden_states = outputs[0]  # The last hidden-state is the first element of the output tuple",
            "masked_line": "model = TFXxxModel.from_pretrained('xxx-base-uncased')",
            "answer": "TFXxxModel",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_968"
        },
        {
            "dependency": "transformers",
            "version": "==2.2.0",
            "time": "2019-11-26",
            "description": "This code segment loads a pre-trained Xxx language model and tokenizer using TensorFlow and transformers library. It then encodes the input text \"Hello, my dog is cute\" using the tokenizer and passes it through the model to generate prediction scores for masked tokens.",
            "code": "import tensorflow as tf\nfrom transformers import XxxTokenizer, TFXxxForMaskedLM\n\ntokenizer = XxxTokenizer.from_pretrained('xxx-base-uncased')\nmodel = TFXxxForMaskedLM.from_pretrained('xxx-base-uncased')\ninput_ids = tf.constant(tokenizer.encode(\"Hello, my dog is cute\"))[None, :]  # Batch size 1\noutputs = model(input_ids)\nprediction_scores = outputs[0]",
            "masked_code": "import tensorflow as tf\nfrom transformers import XxxTokenizer, TFXxxForMaskedLM\n\ntokenizer = XxxTokenizer.from_pretrained('xxx-base-uncased')\n<line_mask>\ninput_ids = tf.constant(tokenizer.encode(\"Hello, my dog is cute\"))[None, :]  # Batch size 1\noutputs = model(input_ids)\nprediction_scores = outputs[0]",
            "masked_line": "model = TFXxxForMaskedLM.from_pretrained('xxx-base-uncased')",
            "answer": "TFXxxForMaskedLM",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_969"
        },
        {
            "dependency": "transformers",
            "version": "==2.2.0",
            "time": "2019-11-26",
            "description": "The code performs sequence classification using a pre-trained Xxx model and tokenizer from the Transformers library, using the input text \"Hello, my dog is cute\" to generate logits as the output.",
            "code": "import tensorflow as tf\nfrom transformers import XxxTokenizer, TFXxxForSequenceClassification\n\ntokenizer = XxxTokenizer.from_pretrained('xxx-base-uncased')\nmodel = TFXxxForSequenceClassification.from_pretrained('xxx-base-uncased')\ninput_ids = tf.constant(tokenizer.encode(\"Hello, my dog is cute\"))[None, :]  # Batch size 1\noutputs = model(input_ids)\nlogits = outputs[0]",
            "masked_code": "import tensorflow as tf\nfrom transformers import XxxTokenizer, TFXxxForSequenceClassification\n\ntokenizer = XxxTokenizer.from_pretrained('xxx-base-uncased')\n<line_mask>\ninput_ids = tf.constant(tokenizer.encode(\"Hello, my dog is cute\"))[None, :]  # Batch size 1\noutputs = model(input_ids)\nlogits = outputs[0]",
            "masked_line": "model = TFXxxForSequenceClassification.from_pretrained('xxx-base-uncased')",
            "answer": "TFXxxForSequenceClassification",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_970"
        },
        {
            "dependency": "transformers",
            "version": "==2.2.0",
            "time": "2019-11-26",
            "description": "This code uses a pre-trained xxx-base-uncased model from the Transformers library to perform token classification on the input text \"Hello, my dog is cute\".",
            "code": "import tensorflow as tf\nfrom transformers import XxxTokenizer, TFXxxForTokenClassification\n\ntokenizer = XxxTokenizer.from_pretrained('xxx-base-uncased')\nmodel = TFXxxForTokenClassification.from_pretrained('xxx-base-uncased')\ninput_ids = tf.constant(tokenizer.encode(\"Hello, my dog is cute\"))[None, :]  # Batch size 1\noutputs = model(input_ids)\nscores = outputs[0]",
            "masked_code": "import tensorflow as tf\n<line_mask>\n\ntokenizer = XxxTokenizer.from_pretrained('xxx-base-uncased')\nmodel = TFXxxForTokenClassification.from_pretrained('xxx-base-uncased')\ninput_ids = tf.constant(tokenizer.encode(\"Hello, my dog is cute\"))[None, :]  # Batch size 1\noutputs = model(input_ids)\nscores = outputs[0]",
            "masked_line": "from transformers import XxxTokenizer, TFXxxForTokenClassification",
            "answer": "TFXxxForTokenClassification",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_971"
        },
        {
            "dependency": "transformers",
            "version": "==2.2.0",
            "time": "2019-11-26",
            "description": "This code uses a pre-trained transformer model to perform question answering on the input text \"Hello, my dog is cute\". The model tokenizes the input text, generates input_ids, and then outputs start_scores and end_scores for the answer span in the input text.",
            "code": "import tensorflow as tf\nfrom transformers import XxxTokenizer, TFXxxForQuestionAnswering\n\ntokenizer = XxxTokenizer.from_pretrained('xxx-base-uncased')\nmodel = TFXxxForQuestionAnswering.from_pretrained('xxx-base-uncased')\ninput_ids = tf.constant(tokenizer.encode(\"Hello, my dog is cute\"))[None, :]  # Batch size 1\noutputs = model(input_ids)\nstart_scores, end_scores = outputs[:2]",
            "masked_code": "import tensorflow as tf\n<line_mask>\n\ntokenizer = XxxTokenizer.from_pretrained('xxx-base-uncased')\nmodel = TFXxxForQuestionAnswering.from_pretrained('xxx-base-uncased')\ninput_ids = tf.constant(tokenizer.encode(\"Hello, my dog is cute\"))[None, :]  # Batch size 1\noutputs = model(input_ids)\nstart_scores, end_scores = outputs[:2]",
            "masked_line": "from transformers import XxxTokenizer, TFXxxForQuestionAnswering",
            "answer": "TFXxxForQuestionAnswering",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_972"
        },
        {
            "dependency": "transformers",
            "version": "==2.2.0",
            "time": "2019-11-26",
            "description": "This code initializes a tokenizer and a model for masked language modeling using a pre-trained model. It encodes the input text \"Hello, my dog is cute\" using the tokenizer, passes the encoded input to the model, and calculates the loss and prediction scores based on the masked language modeling task.",
            "code": "tokenizer = XxxTokenizer.from_pretrained('xxx-base-uncased')\nmodel = XxxForMaskedLM.from_pretrained('xxx-base-uncased')\ninput_ids = torch.tensor(tokenizer.encode(\"Hello, my dog is cute\")).unsqueeze(0)  # Batch size 1\noutputs = model(input_ids, masked_lm_labels=input_ids)\nloss, prediction_scores = outputs[:2]",
            "masked_code": "tokenizer = XxxTokenizer.from_pretrained('xxx-base-uncased')\n<line_mask>\ninput_ids = torch.tensor(tokenizer.encode(\"Hello, my dog is cute\")).unsqueeze(0)  # Batch size 1\noutputs = model(input_ids, masked_lm_labels=input_ids)\nloss, prediction_scores = outputs[:2]",
            "masked_line": "model = XxxForMaskedLM.from_pretrained('xxx-base-uncased')",
            "answer": "XxxForMaskedLM",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_973"
        },
        {
            "dependency": "transformers",
            "version": "==2.2.0",
            "time": "2019-11-26",
            "description": "This code segment initializes a tokenizer and a model for sequence classification. It encodes a text input, assigns a label, and then feeds the input and labels into the model to obtain the loss and logits for the prediction.",
            "code": "tokenizer = XxxTokenizer.from_pretrained('xxx-base-uncased')\nmodel = XxxForSequenceClassification.from_pretrained('xxx-base-uncased')\ninput_ids = torch.tensor(tokenizer.encode(\"Hello, my dog is cute\")).unsqueeze(0)  # Batch size 1\nlabels = torch.tensor([1]).unsqueeze(0)  # Batch size 1\noutputs = model(input_ids, labels=labels)\nloss, logits = outputs[:2]\n",
            "masked_code": "tokenizer = XxxTokenizer.from_pretrained('xxx-base-uncased')\n<line_mask>\ninput_ids = torch.tensor(tokenizer.encode(\"Hello, my dog is cute\")).unsqueeze(0)  # Batch size 1\nlabels = torch.tensor([1]).unsqueeze(0)  # Batch size 1\noutputs = model(input_ids, labels=labels)\nloss, logits = outputs[:2]\n",
            "masked_line": "model = XxxForSequenceClassification.from_pretrained('xxx-base-uncased')",
            "answer": "XxxForSequenceClassification",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_974"
        },
        {
            "dependency": "transformers",
            "version": "==2.2.0",
            "time": "2019-11-26",
            "description": "This code initializes a tokenizer and a token classification model, encodes a given input text using the tokenizer, assigns labels to the tokens, and then passes the input ids and labels to the model to obtain the loss and prediction scores.",
            "code": "tokenizer = XxxTokenizer.from_pretrained('xxx-base-uncased')\nmodel = XxxForTokenClassification.from_pretrained('xxx-base-uncased')\ninput_ids = torch.tensor(tokenizer.encode(\"Hello, my dog is cute\")).unsqueeze(0)  # Batch size 1\nlabels = torch.tensor([1] * input_ids.size(1)).unsqueeze(0)  # Batch size 1\noutputs = model(input_ids, labels=labels)\nloss, scores = outputs[:2]",
            "masked_code": "tokenizer = XxxTokenizer.from_pretrained('xxx-base-uncased')\n<line_mask>\ninput_ids = torch.tensor(tokenizer.encode(\"Hello, my dog is cute\")).unsqueeze(0)  # Batch size 1\nlabels = torch.tensor([1] * input_ids.size(1)).unsqueeze(0)  # Batch size 1\noutputs = model(input_ids, labels=labels)\nloss, scores = outputs[:2]",
            "masked_line": "model = XxxForTokenClassification.from_pretrained('xxx-base-uncased')",
            "answer": "XxxForTokenClassification",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_975"
        },
        {
            "dependency": "transformers",
            "version": "==2.2.0",
            "time": "2019-11-26",
            "description": "The code tokenizes a question and text, generates input tokens with special tokens for classification and separation, converts the input tokens to IDs using the tokenizer, assigns token types based on the position of the [SEP] token, uses a question-answering model to predict start and end scores for the answer span, converts the predicted tokens back to words, and prints the answer span as a string.",
            "code": "tokenizer = XxxTokenizer.from_pretrained('xxx-base-uncased')\nmodel = XxxForQuestionAnswering.from_pretrained('xxx-large-uncased-whole-word-masking-finetuned-squad')\nquestion, text = \"Who was Jim Henson?\", \"Jim Henson was a nice puppet\"\ninput_text = \"[CLS] \" + question + \" [SEP] \" + text + \" [SEP]\"\ninput_ids = tokenizer.encode(input_text)\ntoken_type_ids = [0 if i <= input_ids.index(102) else 1 for i in range(len(input_ids))] \nstart_scores, end_scores = model(torch.tensor([input_ids]), token_type_ids=torch.tensor([token_type_ids]))\nall_tokens = tokenizer.convert_ids_to_tokens(input_ids)  \nprint(' '.join(all_tokens[torch.argmax(start_scores) : torch.argmax(end_scores)+1]))",
            "masked_code": "tokenizer = XxxTokenizer.from_pretrained('xxx-base-uncased')\n<line_mask>\nquestion, text = \"Who was Jim Henson?\", \"Jim Henson was a nice puppet\"\ninput_text = \"[CLS] \" + question + \" [SEP] \" + text + \" [SEP]\"\ninput_ids = tokenizer.encode(input_text)\ntoken_type_ids = [0 if i <= input_ids.index(102) else 1 for i in range(len(input_ids))] \nstart_scores, end_scores = model(torch.tensor([input_ids]), token_type_ids=torch.tensor([token_type_ids]))\nall_tokens = tokenizer.convert_ids_to_tokens(input_ids)  \nprint(' '.join(all_tokens[torch.argmax(start_scores) : torch.argmax(end_scores)+1]))",
            "masked_line": "model = XxxForQuestionAnswering.from_pretrained('xxx-large-uncased-whole-word-masking-finetuned-squad')",
            "answer": "XxxForQuestionAnswering",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_976"
        },
        {
            "dependency": "transformers",
            "version": "==2.2.0",
            "time": "2019-11-26",
            "description": "This code segment initializes an ALBERT tokenizer and a pre-trained ALBERT model for sequence classification. It then encodes a text input, \"Hello, my dog is cute\", into tokens with the tokenizer and feeds the tokenized input into the model to obtain the loss and logits for binary classification.",
            "code": "tokenizer = AlbertTokenizer.from_pretrained('albert-base-v2')\nmodel = AlbertForSequenceClassification.from_pretrained('albert-base-v2')\ninput_ids = torch.tensor(tokenizer.encode(\"Hello, my dog is cute\")).unsqueeze(0)  # Batch size 1\nlabels = torch.tensor([1]).unsqueeze(0)  # Batch size 1\noutputs = model(input_ids, labels=labels)\nloss, logits = outputs[:2]\n",
            "masked_code": "tokenizer = AlbertTokenizer.from_pretrained('albert-base-v2')\n<line_mask>\ninput_ids = torch.tensor(tokenizer.encode(\"Hello, my dog is cute\")).unsqueeze(0)  # Batch size 1\nlabels = torch.tensor([1]).unsqueeze(0)  # Batch size 1\noutputs = model(input_ids, labels=labels)\nloss, logits = outputs[:2]\n",
            "masked_line": "model = AlbertForSequenceClassification.from_pretrained('albert-base-v2')",
            "answer": "AlbertForSequenceClassification",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_977"
        },
        {
            "dependency": "transformers",
            "version": "==2.2.0",
            "time": "2019-11-26",
            "description": "The code takes a question and text as input, tokenizes them using AlbertTokenizer, passes the input through AlbertForQuestionAnswering model to get start and end scores for the answer span, and finally prints out the answer tokens by decoding the token ids.",
            "code": "tokenizer = AlbertTokenizer.from_pretrained('albert-base-v2')\nmodel = AlbertForQuestionAnswering.from_pretrained('albert-base-v2')\nquestion, text = \"Who was Jim Henson?\", \"Jim Henson was a nice puppet\"\ninput_text = \"[CLS] \" + question + \" [SEP] \" + text + \" [SEP]\"\ninput_ids = tokenizer.encode(input_text)\ntoken_type_ids = [0 if i <= input_ids.index(102) else 1 for i in range(len(input_ids))] \nstart_scores, end_scores = model(torch.tensor([input_ids]), token_type_ids=torch.tensor([token_type_ids]))\nall_tokens = tokenizer.convert_ids_to_tokens(input_ids)  \nprint(' '.join(all_tokens[torch.argmax(start_scores) : torch.argmax(end_scores)+1]))",
            "masked_code": "tokenizer = AlbertTokenizer.from_pretrained('albert-base-v2')\n<line_mask>\nquestion, text = \"Who was Jim Henson?\", \"Jim Henson was a nice puppet\"\ninput_text = \"[CLS] \" + question + \" [SEP] \" + text + \" [SEP]\"\ninput_ids = tokenizer.encode(input_text)\ntoken_type_ids = [0 if i <= input_ids.index(102) else 1 for i in range(len(input_ids))] \nstart_scores, end_scores = model(torch.tensor([input_ids]), token_type_ids=torch.tensor([token_type_ids]))\nall_tokens = tokenizer.convert_ids_to_tokens(input_ids)  \nprint(' '.join(all_tokens[torch.argmax(start_scores) : torch.argmax(end_scores)+1]))",
            "masked_line": "model = AlbertForQuestionAnswering.from_pretrained('albert-base-v2')",
            "answer": "AlbertForQuestionAnswering",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_978"
        },
        {
            "dependency": "transformers",
            "version": "==2.2.0",
            "time": "2019-11-26",
            "description": "This code utilizes a pre-trained Camembert model for masked language modeling. It tokenizes the input text \"J'aime le camembert !\" using the Camembert tokenizer, then passes the input through the Camembert model to perform masked language modeling, with the model predicting the masked tokens and calculating the loss based on the actual tokens in the input.",
            "code": "tokenizer = CamembertTokenizer.from_pretrained('camembert-base')\nmodel = CamembertForMaskedLM.from_pretrained('camembert-base')\ninput_ids = torch.tensor(tokenizer.encode(\"J'aime le camembert !\")).unsqueeze(0)  # Batch size 1\noutputs = model(input_ids, masked_lm_labels=input_ids)\nloss, prediction_scores = outputs[:2]",
            "masked_code": "tokenizer = CamembertTokenizer.from_pretrained('camembert-base')\n<line_mask>\ninput_ids = torch.tensor(tokenizer.encode(\"J'aime le camembert !\")).unsqueeze(0)  # Batch size 1\noutputs = model(input_ids, masked_lm_labels=input_ids)\nloss, prediction_scores = outputs[:2]",
            "masked_line": "model = CamembertForMaskedLM.from_pretrained('camembert-base')",
            "answer": "CamembertForMaskedLM",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_979"
        },
        {
            "dependency": "transformers",
            "version": "==2.2.0",
            "time": "2019-11-26",
            "description": "The code performs multiple-choice question answering using the Camembert model. It encodes two choices, \"J'aime le camembert !\" and \"Je deteste le camembert !\", with special tokens using the CamembertTokenizer. These encoded choices are then inputted into the CamembertForMultipleChoice model along with the correct label. The model outputs the loss and classification scores for the given choices and label.",
            "code": "tokenizer = CamembertTokenizer.from_pretrained('camembert-base')\nmodel = CamembertForMultipleChoice.from_pretrained('camembert-base')\nchoices = [\"J'aime le camembert !\", \"Je deteste le camembert !\"]\ninput_ids = torch.tensor([tokenizer.encode(s, add_special_tokens=True) for s in choices]).unsqueeze(0)  # Batch size 1, 2 choices\nlabels = torch.tensor(1).unsqueeze(0)  # Batch size 1\noutputs = model(input_ids, labels=labels)\nloss, classification_scores = outputs[:2]",
            "masked_code": "tokenizer = CamembertTokenizer.from_pretrained('camembert-base')\n<line_mask>\nchoices = [\"J'aime le camembert !\", \"Je deteste le camembert !\"]\ninput_ids = torch.tensor([tokenizer.encode(s, add_special_tokens=True) for s in choices]).unsqueeze(0)  # Batch size 1, 2 choices\nlabels = torch.tensor(1).unsqueeze(0)  # Batch size 1\noutputs = model(input_ids, labels=labels)\nloss, classification_scores = outputs[:2]",
            "masked_line": "model = CamembertForMultipleChoice.from_pretrained('camembert-base')",
            "answer": "CamembertForMultipleChoice",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_980"
        },
        {
            "dependency": "transformers",
            "version": "==2.2.0",
            "time": "2019-11-26",
            "description": "This code segment initializes a Camembert tokenizer and a Camembert model for token classification. It encodes a French text \"J'aime le camembert !\" using the tokenizer, creates labels for the tokens, and feeds the input_ids and labels into the model to obtain the loss and scores for token classification.",
            "code": "tokenizer = CamembertTokenizer.from_pretrained('camembert-base')\nmodel = CamembertForTokenClassification.from_pretrained('camembert-base')\ninput_ids = torch.tensor(tokenizer.encode(\"J'aime le camembert !\", add_special_tokens=True)).unsqueeze(0)  # Batch size 1\nlabels = torch.tensor([1] * input_ids.size(1)).unsqueeze(0)  # Batch size 1\noutputs = model(input_ids, labels=labels)\nloss, scores = outputs[:2]\n",
            "masked_code": "tokenizer = CamembertTokenizer.from_pretrained('camembert-base')\n<line_mask>\ninput_ids = torch.tensor(tokenizer.encode(\"J'aime le camembert !\", add_special_tokens=True)).unsqueeze(0)  # Batch size 1\nlabels = torch.tensor([1] * input_ids.size(1)).unsqueeze(0)  # Batch size 1\noutputs = model(input_ids, labels=labels)\nloss, scores = outputs[:2]\n",
            "masked_line": "model = CamembertForTokenClassification.from_pretrained('camembert-base')",
            "answer": "CamembertForTokenClassification",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_981"
        },
        {
            "dependency": "transformers",
            "version": "==2.2.0",
            "time": "2019-11-26",
            "description": "This code segment is using a pre-trained DistilBERT model for token classification tasks. It tokenizes a given input text \"Hello, my dog is cute\", assigns labels to the tokens based on the \"1\" label, and then passes the input_ids and labels to the model to obtain loss and token classification scores.",
            "code": "tokenizer = DistilBertTokenizer.from_pretrained('distilbert-base-uncased')\nmodel = DistilBertForTokenClassification.from_pretrained('distilbert-base-uncased')\ninput_ids = torch.tensor(tokenizer.encode(\"Hello, my dog is cute\")).unsqueeze(0)  # Batch size 1\nlabels = torch.tensor([1] * input_ids.size(1)).unsqueeze(0)  # Batch size 1\noutputs = model(input_ids, labels=labels)\nloss, scores = outputs[:2]\n",
            "masked_code": "tokenizer = DistilBertTokenizer.from_pretrained('distilbert-base-uncased')\n<line_mask>\ninput_ids = torch.tensor(tokenizer.encode(\"Hello, my dog is cute\")).unsqueeze(0)  # Batch size 1\nlabels = torch.tensor([1] * input_ids.size(1)).unsqueeze(0)  # Batch size 1\noutputs = model(input_ids, labels=labels)\nloss, scores = outputs[:2]\n",
            "masked_line": "model = DistilBertForTokenClassification.from_pretrained('distilbert-base-uncased')",
            "answer": "DistilBertForTokenClassification",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_982"
        },
        {
            "dependency": "transformers",
            "version": "==2.2.0",
            "time": "2019-11-26",
            "description": "This code segment utilizes a pre-trained RoBERTa model for token classification. It encodes a input text, \"Hello, my dog is cute\", with the RobertaTokenizer, prepares the labels for the input tokens, and feeds the input_ids and labels into the RoBERTa model for token classification. Finally, it extracts the loss and scores from the model outputs.",
            "code": "tokenizer = RobertaTokenizer.from_pretrained('roberta-base')\nmodel = RobertaForTokenClassification.from_pretrained('roberta-base')\ninput_ids = torch.tensor(tokenizer.encode(\"Hello, my dog is cute\", add_special_tokens=True)).unsqueeze(0)  # Batch size 1\nlabels = torch.tensor([1] * input_ids.size(1)).unsqueeze(0)  # Batch size 1\noutputs = model(input_ids, labels=labels)\nloss, scores = outputs[:2]\n",
            "masked_code": "tokenizer = RobertaTokenizer.from_pretrained('roberta-base')\n<line_mask>\ninput_ids = torch.tensor(tokenizer.encode(\"Hello, my dog is cute\", add_special_tokens=True)).unsqueeze(0)  # Batch size 1\nlabels = torch.tensor([1] * input_ids.size(1)).unsqueeze(0)  # Batch size 1\noutputs = model(input_ids, labels=labels)\nloss, scores = outputs[:2]\n",
            "masked_line": "model = RobertaForTokenClassification.from_pretrained('roberta-base')",
            "answer": "RobertaForTokenClassification",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_983"
        },
        {
            "dependency": "transformers",
            "version": "==2.2.0",
            "time": "2019-11-26",
            "description": "This code uses a pre-trained ALBERT model to generate the last hidden states for the input text \"Hello, my dog is cute\".",
            "code": "import tensorflow as tf\nfrom transformers import AlbertTokenizer, TFAlbertModel\n\ntokenizer = AlbertTokenizer.from_pretrained('bert-base-uncased')\nmodel = TFAlbertModel.from_pretrained('bert-base-uncased')\ninput_ids = tf.constant(tokenizer.encode(\"Hello, my dog is cute\"))[None, :]  # Batch size 1\noutputs = model(input_ids)\nlast_hidden_states = outputs[0]  # The last hidden-state is the first element of the output tuple",
            "masked_code": "import tensorflow as tf\n<line_mask>\n\ntokenizer = AlbertTokenizer.from_pretrained('bert-base-uncased')\nmodel = TFAlbertModel.from_pretrained('bert-base-uncased')\ninput_ids = tf.constant(tokenizer.encode(\"Hello, my dog is cute\"))[None, :]  # Batch size 1\noutputs = model(input_ids)\nlast_hidden_states = outputs[0]  # The last hidden-state is the first element of the output tuple",
            "masked_line": "from transformers import AlbertTokenizer, TFAlbertModel",
            "answer": "TFAlbertModel",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_984"
        },
        {
            "dependency": "transformers",
            "version": "==2.2.0",
            "time": "2019-11-26",
            "description": "This code segment uses a pre-trained ALBERT model to predict the masked words in the input sentence \"Hello, my dog is cute\".",
            "code": "import tensorflow as tf\nfrom transformers import AlbertTokenizer, TFAlbertForMaskedLM\n\ntokenizer = AlbertTokenizer.from_pretrained('albert-base-v2')\nmodel = TFAlbertForMaskedLM.from_pretrained('albert-base-v2')\ninput_ids = tf.constant(tokenizer.encode(\"Hello, my dog is cute\"))[None, :]  # Batch size 1\noutputs = model(input_ids)\nprediction_scores = outputs[0]",
            "masked_code": "import tensorflow as tf\n<line_mask>\n\ntokenizer = AlbertTokenizer.from_pretrained('albert-base-v2')\nmodel = TFAlbertForMaskedLM.from_pretrained('albert-base-v2')\ninput_ids = tf.constant(tokenizer.encode(\"Hello, my dog is cute\"))[None, :]  # Batch size 1\noutputs = model(input_ids)\nprediction_scores = outputs[0]",
            "masked_line": "from transformers import AlbertTokenizer, TFAlbertForMaskedLM",
            "answer": "TFAlbertForMaskedLM",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_985"
        },
        {
            "dependency": "transformers",
            "version": "==2.2.0",
            "time": "2019-11-26",
            "description": "This code performs sequence classification using the ALBERT model to predict the class label of the input text.",
            "code": "import tensorflow as tf\nfrom transformers import AlbertTokenizer, TFAlbertForSequenceClassification\n\ntokenizer = AlbertTokenizer.from_pretrained('albert-base-v2')\nmodel = TFAlbertForSequenceClassification.from_pretrained('albert-base-v2')\ninput_ids = tf.constant(tokenizer.encode(\"Hello, my dog is cute\"))[None, :]  # Batch size 1\noutputs = model(input_ids)\nlogits = outputs[0]",
            "masked_code": "import tensorflow as tf\n<line_mask>\n\ntokenizer = AlbertTokenizer.from_pretrained('albert-base-v2')\nmodel = TFAlbertForSequenceClassification.from_pretrained('albert-base-v2')\ninput_ids = tf.constant(tokenizer.encode(\"Hello, my dog is cute\"))[None, :]  # Batch size 1\noutputs = model(input_ids)\nlogits = outputs[0]",
            "masked_line": "from transformers import AlbertTokenizer, TFAlbertForSequenceClassification",
            "answer": "TFAlbertForSequenceClassification",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_986"
        },
        {
            "dependency": "transformers",
            "version": "==2.2.0",
            "time": "2019-11-26",
            "description": "This code uses a pre-trained RoBERTa model to perform token classification on the input text \"Hello, my dog is cute\" and stores the resulting scores.",
            "code": "import tensorflow as tf\nfrom transformers import RobertaTokenizer, TFRobertaForTokenClassification\n\ntokenizer = RobertaTokenizer.from_pretrained('roberta-base')\nmodel = TFRobertaForTokenClassification.from_pretrained('roberta-base')\ninput_ids = tf.constant(tokenizer.encode(\"Hello, my dog is cute\", add_special_tokens=True))[None, :]  # Batch size 1\noutputs = model(input_ids)\nscores = outputs[0]",
            "masked_code": "import tensorflow as tf\n<line_mask>\n\ntokenizer = RobertaTokenizer.from_pretrained('roberta-base')\nmodel = TFRobertaForTokenClassification.from_pretrained('roberta-base')\ninput_ids = tf.constant(tokenizer.encode(\"Hello, my dog is cute\", add_special_tokens=True))[None, :]  # Batch size 1\noutputs = model(input_ids)\nscores = outputs[0]",
            "masked_line": "from transformers import RobertaTokenizer, TFRobertaForTokenClassification",
            "answer": "TFRobertaForTokenClassification",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_987"
        },
        {
            "dependency": "transformers",
            "version": "==2.2.2",
            "time": "2019-12-13",
            "description": "This code uses a pre-trained DistilBERT model to perform token classification on the input text \"Hello, my dog is cute\" and outputs the scores for each token in the input text.",
            "code": "import tensorflow as tf\nfrom transformers import DistilBertTokenizer, TFDistilBertForTokenClassification\n\ntokenizer = DistilBertTokenizer.from_pretrained('bert-base-uncased')\nmodel = TFDistilBertForTokenClassification.from_pretrained('bert-base-uncased')\ninput_ids = tf.constant(tokenizer.encode(\"Hello, my dog is cute\"))[None, :]  # Batch size 1\noutputs = model(input_ids)\nscores = outputs[0]",
            "masked_code": "import tensorflow as tf\nfrom transformers import DistilBertTokenizer, TFDistilBertForTokenClassification\n\ntokenizer = DistilBertTokenizer.from_pretrained('bert-base-uncased')\n<line_mask>\ninput_ids = tf.constant(tokenizer.encode(\"Hello, my dog is cute\"))[None, :]  # Batch size 1\noutputs = model(input_ids)\nscores = outputs[0]",
            "masked_line": "model = TFDistilBertForTokenClassification.from_pretrained('bert-base-uncased')",
            "answer": "TFDistilBertForTokenClassification",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_988"
        },
        {
            "dependency": "transformers",
            "version": "==2.2.2",
            "time": "2019-12-13",
            "description": "This code uses XLNet tokenizer and model for token classification to process the input sentence \"Hello, my dog is cute\" and generate scores for the sequence classification.",
            "code": "import tensorflow as tf\nfrom transformers import XLNetTokenizer, TFXLNetForTokenClassification\n\ntokenizer = XLNetTokenizer.from_pretrained('xlnet-large-cased')\nmodel = TFXLNetForSequenceClassification.from_pretrained('xlnet-large-cased')\ninput_ids = tf.constant(tokenizer.encode(\"Hello, my dog is cute\"))[None, :]  # Batch size 1\noutputs = model(input_ids)\nscores = outputs[0]",
            "masked_code": "import tensorflow as tf\n<line_mask>\n\ntokenizer = XLNetTokenizer.from_pretrained('xlnet-large-cased')\nmodel = TFXLNetForSequenceClassification.from_pretrained('xlnet-large-cased')\ninput_ids = tf.constant(tokenizer.encode(\"Hello, my dog is cute\"))[None, :]  # Batch size 1\noutputs = model(input_ids)\nscores = outputs[0]",
            "masked_line": "from transformers import XLNetTokenizer, TFXLNetForTokenClassification",
            "answer": "TFXLNetForTokenClassification",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_989"
        },
        {
            "dependency": "transformers",
            "version": "==2.9.0",
            "time": "2020-05-07",
            "description": "The code initializes a BERT-based encoder-decoder model with separate configurations for the encoder and decoder parts.",
            "code": "from transformers import BertConfig, EncoderDecoderConfig, EncoderDecoderModel\n\n# Initializing a BERT bert-base-uncased style configuration\nconfig_encoder = BertConfig()\nconfig_decoder = BertConfig()\n\nconfig = EncoderDecoderConfig.from_encoder_decoder_configs(config_encoder, config_decoder)\n\n# Initializing a Bert2Bert model from the bert-base-uncased style configurations\nmodel = EncoderDecoderModel(config=config)\n\n# Accessing the model configuration\nconfig_encoder = model.config.encoder\nconfig_decoder  = model.config.decoder",
            "masked_code": "<line_mask>\n\n# Initializing a BERT bert-base-uncased style configuration\nconfig_encoder = BertConfig()\nconfig_decoder = BertConfig()\n\nconfig = EncoderDecoderConfig.from_encoder_decoder_configs(config_encoder, config_decoder)\n\n# Initializing a Bert2Bert model from the bert-base-uncased style configurations\nmodel = EncoderDecoderModel(config=config)\n\n# Accessing the model configuration\nconfig_encoder = model.config.encoder\nconfig_decoder  = model.config.decoder",
            "masked_line": "from transformers import BertConfig, EncoderDecoderConfig, EncoderDecoderModel",
            "answer": "EncoderDecoderConfig",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_990"
        },
        {
            "dependency": "transformers",
            "version": "==2.9.0",
            "time": "2020-05-07",
            "description": "The code adds new tokens to a BERT tokenizer and resizes the token embeddings of a BERT model to match the updated vocabulary size.",
            "code": "tokenizer = BertTokenizerFast.from_pretrained('bert-base-uncased')\nmodel = BertModel.from_pretrained('bert-base-uncased')\n\nnum_added_toks = tokenizer.add_tokens(['new_tok1', 'my_new-tok2'])\nprint('We have added', num_added_toks, 'tokens')\nmodel.resize_token_embeddings(len(tokenizer))  # Notice: resize_token_embeddings expect to receive the full size of the new vocabulary, i.e. the length of the tokenizer.",
            "masked_code": "tokenizer = BertTokenizerFast.from_pretrained('bert-base-uncased')\nmodel = BertModel.from_pretrained('bert-base-uncased')\n\n<line_mask>\nprint('We have added', num_added_toks, 'tokens')\nmodel.resize_token_embeddings(len(tokenizer))  # Notice: resize_token_embeddings expect to receive the full size of the new vocabulary, i.e. the length of the tokenizer.",
            "masked_line": "num_added_toks = tokenizer.add_tokens(['new_tok1', 'my_new-tok2'])",
            "answer": "add_tokens",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_991"
        },
        {
            "dependency": "transformers",
            "version": "==2.9.0",
            "time": "2020-05-07",
            "description": "The code forward_chunk function processes hidden states using the decoder model, and the forward function applies chunking to the forward_chunk function based on specified chunk size and sequence length dimension parameters.",
            "code": "def forward_chunk(self, hidden_states):\n    hidden_states = self.decoder(hidden_states)\n    return hidden_states\n\ndef forward(self, hidden_states):\n    return apply_chunking_to_forward(self.chunk_size_lm_head, self.seq_len_dim, self.forward_chunk, hidden_states)",
            "masked_code": "def forward_chunk(self, hidden_states):\n    hidden_states = self.decoder(hidden_states)\n    return hidden_states\n\ndef forward(self, hidden_states):\n    <line_mask>",
            "masked_line": "return apply_chunking_to_forward(self.chunk_size_lm_head, self.seq_len_dim, self.forward_chunk, hidden_states)",
            "answer": "apply_chunking_to_forward",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_992"
        },
        {
            "dependency": "transformers",
            "version": "==2.9.1",
            "time": "2020-05-13",
            "description": "This code segment prepares a batch of translation inputs for a Marian Machine Translation model to translate English sentences to German. It tokenizes the source texts using the MarianTokenizer and prepares a translation batch using the provided source and target texts. The batch includes input_ids, attention_mask, decoder_input_ids, and decoder_attention_mask, which can be used as input for the translation model.",
            "code": "from transformers import MarianTokenizer\ntok = MarianTokenizer.from_pretrained('Helsinki-NLP/opus-mt-en-de')\nsrc_texts = [ \"I am a small frog.\", \"Tom asked his teacher for advice.\"]\ntgt_texts = [\"Ich bin ein kleiner Frosch.\", \"Tom bat seinen Lehrer um Rat.\"]  # optional\nbatch_enc: BatchEncoding = tok.prepare_translation_batch(src_texts, tgt_texts=tgt_texts)\n# keys  [input_ids, attention_mask, decoder_input_ids,  decoder_attention_mask].\n# model(**batch) should work\n",
            "masked_code": "<line_mask>\ntok = MarianTokenizer.from_pretrained('Helsinki-NLP/opus-mt-en-de')\nsrc_texts = [ \"I am a small frog.\", \"Tom asked his teacher for advice.\"]\ntgt_texts = [\"Ich bin ein kleiner Frosch.\", \"Tom bat seinen Lehrer um Rat.\"]  # optional\nbatch_enc: BatchEncoding = tok.prepare_translation_batch(src_texts, tgt_texts=tgt_texts)\n# keys  [input_ids, attention_mask, decoder_input_ids,  decoder_attention_mask].\n# model(**batch) should work\n",
            "masked_line": "from transformers import MarianTokenizer",
            "answer": "MarianTokenizer",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_993"
        },
        {
            "dependency": "transformers",
            "version": "==3.4.0",
            "time": "2020-10-20",
            "description": "This code creates a mask based on the input tensor x, where the values greater than 0 are set to 1 and the rest are set to 0. It then applies a custom softmax operation, XSoftmax, using the mask on the input tensor x along the last dimension.",
            "code": "import torch\nfrom transformers.modeling_deroberta import XSoftmax\n\n# Make a tensor\nx = torch.randn([4,20,100])\n\n# Create a mask\nmask = (x>0).int()\n\ny = XSoftmax.apply(x, mask, dim=-1)",
            "masked_code": "import torch\nfrom transformers.modeling_deroberta import XSoftmax\n\n# Make a tensor\nx = torch.randn([4,20,100])\n\n# Create a mask\nmask = (x>0).int()\n\n<line_mask>",
            "masked_line": "y = XSoftmax.apply(x, mask, dim=-1)",
            "answer": "XSoftmax",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_994"
        },
        {
            "dependency": "transformers",
            "version": "==3.4.0",
            "time": "2020-10-20",
            "description": "The code generates a summary of a given text using the Pegasus model.",
            "code": "from transformers import PegasusTokenizer, PegasusForConditionalGeneration\nfrom typing import List\nPGE_ARTICLE = \"PG&E stated it scheduled the blackouts in response to forecasts for high winds amid dry conditions. The aim is to reduce the risk of wildfires. Nearly 800 thousand customers were scheduled to be affected by the shutoffs which were expected to last through at least midday tomorrow.\"\nmname = \"google/pegasus-xsum\"\n\nmodel = PegasusForConditionalGeneration.from_pretrained(mname)\ntok = PegasusTokenizer.from_pretrained(mname)\nbatch = tok.prepare_seq2seq_batch(src_texts=[PGE_ARTICLE])  # don't need tgt_text for inference\ngen = model.generate(**batch)  # for forward pass: model(**batch)\nsummary: List[str] = tok.batch_decode(gen, skip_special_tokens=True)\nassert summary == \"California's largest electricity provider has turned off power to tens of thousands of customers.\"",
            "masked_code": "<line_mask>\nfrom typing import List\nPGE_ARTICLE = \"PG&E stated it scheduled the blackouts in response to forecasts for high winds amid dry conditions. The aim is to reduce the risk of wildfires. Nearly 800 thousand customers were scheduled to be affected by the shutoffs which were expected to last through at least midday tomorrow.\"\nmname = \"google/pegasus-xsum\"\n\nmodel = PegasusForConditionalGeneration.from_pretrained(mname)\ntok = PegasusTokenizer.from_pretrained(mname)\nbatch = tok.prepare_seq2seq_batch(src_texts=[PGE_ARTICLE])  # don't need tgt_text for inference\ngen = model.generate(**batch)  # for forward pass: model(**batch)\nsummary: List[str] = tok.batch_decode(gen, skip_special_tokens=True)\nassert summary == \"California's largest electricity provider has turned off power to tens of thousands of customers.\"",
            "masked_line": "from transformers import PegasusTokenizer, PegasusForConditionalGeneration",
            "answer": "PegasusForConditionalGeneration",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_995"
        },
        {
            "dependency": "transformers",
            "version": "==3.4.0",
            "time": "2020-10-20",
            "description": "The code tokenizes a given input text using the XLMProphetNetTokenizer and then encodes the tokenized input using the XLMProphetNetEncoder model to generate last hidden states for each token in the input text.",
            "code": "from transformers import XLMProphetNetTokenizer, XLMProphetNetEncoder\nimport torch\n\ntokenizer = XLMProphetNetTokenizer.from_pretrained('microsoft/xprophetnet-large-wiki100-cased')\nmodel = XLMProphetNetEncoder.from_pretrained('patrickvonplaten/xprophetnet-large-uncased-standalone', return_dict=True)\nassert model.config.is_decoder, f\"{model.__class__} has to be configured as a decoder.\"\ninputs = tokenizer(\"Hello, my dog is cute\", return_tensors=\"pt\")\noutputs = model(**inputs)\n\nlast_hidden_states = outputs.last_hidden_state",
            "masked_code": "from transformers import XLMProphetNetTokenizer, XLMProphetNetEncoder\nimport torch\n\ntokenizer = XLMProphetNetTokenizer.from_pretrained('microsoft/xprophetnet-large-wiki100-cased')\n<line_mask>\nassert model.config.is_decoder, f\"{model.__class__} has to be configured as a decoder.\"\ninputs = tokenizer(\"Hello, my dog is cute\", return_tensors=\"pt\")\noutputs = model(**inputs)\n\nlast_hidden_states = outputs.last_hidden_state",
            "masked_line": "model = XLMProphetNetEncoder.from_pretrained('patrickvonplaten/xprophetnet-large-uncased-standalone', return_dict=True)",
            "answer": "XLMProphetNetEncoder",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_996"
        },
        {
            "dependency": "transformers",
            "version": "==3.4.0",
            "time": "2020-10-20",
            "description": "The code uses a pre-trained XLMProphetNet model to generate hidden states of the input text \"Hello, my dog is cute\".",
            "code": "from transformers import XLMProphetNetTokenizer, XLMProphetNetDecoder\nimport torch\n\ntokenizer = XLMProphetNetTokenizer.from_pretrained('microsoft/xprophetnet-large-wiki100-cased')\nmodel = XLMProphetNetDecoder.from_pretrained('patrickvonplaten/xprophetnet-large-uncased-standalone', add_cross_attention=False, return_dict=True)\nassert model.config.is_decoder, f\"{model.__class__} has to be configured as a decoder.\"\ninputs = tokenizer(\"Hello, my dog is cute\", return_tensors=\"pt\")\noutputs = model(**inputs)\n\nlast_hidden_states = outputs.last_hidden_state\n",
            "masked_code": "<line_mask>\nimport torch\n\ntokenizer = XLMProphetNetTokenizer.from_pretrained('microsoft/xprophetnet-large-wiki100-cased')\nmodel = XLMProphetNetDecoder.from_pretrained('patrickvonplaten/xprophetnet-large-uncased-standalone', add_cross_attention=False, return_dict=True)\nassert model.config.is_decoder, f\"{model.__class__} has to be configured as a decoder.\"\ninputs = tokenizer(\"Hello, my dog is cute\", return_tensors=\"pt\")\noutputs = model(**inputs)\n\nlast_hidden_states = outputs.last_hidden_state\n",
            "masked_line": "from transformers import XLMProphetNetTokenizer, XLMProphetNetDecoder",
            "answer": "XLMProphetNetDecoder",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_997"
        },
        {
            "dependency": "transformers",
            "version": "==3.4.0",
            "time": "2020-10-20",
            "description": "The code uses the XLMProphetNet model and tokenizer to generate hidden states for input and output sequences.",
            "code": "from transformers import XLMProphetNetTokenizer, XLMProphetNetModel\ntokenizer = XLMProphetNetTokenizer.from_pretrained('microsoft/xprophetnet-large-wiki100-cased')\nmodel = XLMProphetNetModel.from_pretrained('microsoft/xprophetnet-large-wiki100-cased')\ninput_ids = tokenizer(\"Studies have been shown that owning a dog is good for you\", return_tensors=\"pt\").input_ids\ndecoder_input_ids = tokenizer(\"Studies show that\", return_tensors=\"pt\").input_ids\noutputs = model(input_ids=input_ids, decoder_input_ids=decoder_input_ids, return_dict=True)\nlast_hidden_states = outputs.last_hidden_state\nlast_hidden_states_ngram = outputs.last_hidden_state_ngram",
            "masked_code": "<line_mask>\ntokenizer = XLMProphetNetTokenizer.from_pretrained('microsoft/xprophetnet-large-wiki100-cased')\nmodel = XLMProphetNetModel.from_pretrained('microsoft/xprophetnet-large-wiki100-cased')\ninput_ids = tokenizer(\"Studies have been shown that owning a dog is good for you\", return_tensors=\"pt\").input_ids\ndecoder_input_ids = tokenizer(\"Studies show that\", return_tensors=\"pt\").input_ids\noutputs = model(input_ids=input_ids, decoder_input_ids=decoder_input_ids, return_dict=True)\nlast_hidden_states = outputs.last_hidden_state\nlast_hidden_states_ngram = outputs.last_hidden_state_ngram",
            "masked_line": "from transformers import XLMProphetNetTokenizer, XLMProphetNetModel",
            "answer": "XLMProphetNetModel",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_998"
        },
        {
            "dependency": "transformers",
            "version": "==3.4.0",
            "time": "2020-10-20",
            "description": "The code uses the XLMProphetNet model to generate predictions based on input text. It tokenizes the input text, generates decoder input tokens, and then uses the model to predict the next token and n-gram tokens in the sequence.",
            "code": "from transformers import XLMProphetNetTokenizer, XLMProphetNetForConditionalGeneration\ntokenizer = XLMProphetNetTokenizer.from_pretrained('microsoft/xprophetnet-large-wiki100-cased')\nmodel =  XLMProphetNetForConditionalGeneration.from_pretrained('microsoft/xprophetnet-large-wiki100-cased')\ninput_ids = tokenizer(\"Studies have been shown that owning a dog is good for you\", return_tensors=\"pt\").input_ids\ndecoder_input_ids = tokenizer(\"Studies show that\", return_tensors=\"pt\").input_ids\noutputs = model(input_ids=input_ids, decoder_input_ids=decoder_input_ids, return_dict=True)\nlogits_next_token = outputs.logits\nlogits_ngram_next_tokens = outputs.logits_ngram",
            "masked_code": "from transformers import XLMProphetNetTokenizer, XLMProphetNetForConditionalGeneration\ntokenizer = XLMProphetNetTokenizer.from_pretrained('microsoft/xprophetnet-large-wiki100-cased')\n<line_mask>\ninput_ids = tokenizer(\"Studies have been shown that owning a dog is good for you\", return_tensors=\"pt\").input_ids\ndecoder_input_ids = tokenizer(\"Studies show that\", return_tensors=\"pt\").input_ids\noutputs = model(input_ids=input_ids, decoder_input_ids=decoder_input_ids, return_dict=True)\nlogits_next_token = outputs.logits\nlogits_ngram_next_tokens = outputs.logits_ngram",
            "masked_line": "model =  XLMProphetNetForConditionalGeneration.from_pretrained('microsoft/xprophetnet-large-wiki100-cased')",
            "answer": "XLMProphetNetForConditionalGeneration",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_999"
        },
        {
            "dependency": "transformers",
            "version": "==3.4.0",
            "time": "2020-10-20",
            "description": "This code snippet uses a pre-trained MBart tokenizer to prepare a sequence-to-sequence batch for translation from English to Romanian. The English phrase \"UN Chief Says There Is No Military Solution in Syria\" is tokenized and prepared as input with the expected translation \"eful ONU declar c nu exist o soluie militar n Siria\" for the model.",
            "code": "from transformers import MBartTokenizerFast\ntokenizer = MBartTokenizerFast.from_pretrained('facebook/mbart-large-en-ro')\nexample_english_phrase = \" UN Chief Says There Is No Military Solution in Syria\"\nexpected_translation_romanian = \"eful ONU declar c nu exist o soluie militar n Siria\"\nbatch: dict = tokenizer.prepare_seq2seq_batch(\n    example_english_phrase, src_lang=\"en_XX\", tgt_lang=\"ro_RO\", tgt_texts=expected_translation_romanian\n)\n",
            "masked_code": "from transformers import MBartTokenizerFast\n<line_mask>\nexample_english_phrase = \" UN Chief Says There Is No Military Solution in Syria\"\nexpected_translation_romanian = \"eful ONU declar c nu exist o soluie militar n Siria\"\nbatch: dict = tokenizer.prepare_seq2seq_batch(\n    example_english_phrase, src_lang=\"en_XX\", tgt_lang=\"ro_RO\", tgt_texts=expected_translation_romanian\n)\n",
            "masked_line": "tokenizer = MBartTokenizerFast.from_pretrained('facebook/mbart-large-en-ro')",
            "answer": "MBartTokenizerFast",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1000"
        },
        {
            "dependency": "transformers",
            "version": "==3.4.0",
            "time": "2020-10-20",
            "description": "This code creates a progress bar with 100 steps and updates it with a percentage value from 0 to 100. It pauses for 0.07 seconds between each update to simulate a loading process. Finally, it updates the progress bar to 100%.",
            "code": "import time\n\npbar = NotebookProgressBar(100)\nfor val in range(100):\n    pbar.update(val)\n    time.sleep(0.07)\npbar.update(100)",
            "masked_code": "import time\n\n<line_mask>\nfor val in range(100):\n    pbar.update(val)\n    time.sleep(0.07)\npbar.update(100)",
            "masked_line": "pbar = NotebookProgressBar(100)",
            "answer": "NotebookProgressBar",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1001"
        },
        {
            "dependency": "transformers",
            "version": "==3.4.0",
            "time": "2020-10-20",
            "description": "The code tokenizes the input text \"Hello world!\" using the GPT2 tokenizer and then decodes the tokens back into human-readable text.",
            "code": "tokenizer = GPT2Tokenizer()\ntext = \"Hello world!\"\ntokens = tokenizer.tokenize(text)\nprint(tokens)\ntokenizer.decode(tokens)",
            "masked_code": "tokenizer = GPT2Tokenizer()\ntext = \"Hello world!\"\ntokens = tokenizer.tokenize(text)\nprint(tokens)\n<line_mask>",
            "masked_line": "tokenizer.decode(tokens)",
            "answer": "decode",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1002"
        },
        {
            "dependency": "transformers",
            "version": "==4.0.0",
            "time": "2020-11-30",
            "description": "The code is using a pre-trained MT5 model to generate a summary of an input article about negotiations in Syria. It tokenizes the input article and summary, prepares a sequence-to-sequence batch, and then uses the model to generate hidden states for the output summary.",
            "code": "from transformers import MT5Model, T5Tokenizer\nmodel = MT5Model.from_pretrained(\"google/mt5-small\")\ntokenizer = T5Tokenizer.from_pretrained(\"google/mt5-small\")\narticle = \"UN Offizier sagt, dass weiter verhandelt werden muss in Syrien.\"\nsummary = \"Weiter Verhandlung in Syrien.\"\nbatch = tokenizer.prepare_seq2seq_batch(src_texts=[article], tgt_texts=[summary], return_tensors=\"pt\")\noutputs = model(input_ids=batch.input_ids, decoder_input_ids=batch.labels)\nhidden_states = outputs.last_hidden_state",
            "masked_code": "from transformers import MT5Model, T5Tokenizer\n<line_mask>\ntokenizer = T5Tokenizer.from_pretrained(\"google/mt5-small\")\narticle = \"UN Offizier sagt, dass weiter verhandelt werden muss in Syrien.\"\nsummary = \"Weiter Verhandlung in Syrien.\"\nbatch = tokenizer.prepare_seq2seq_batch(src_texts=[article], tgt_texts=[summary], return_tensors=\"pt\")\noutputs = model(input_ids=batch.input_ids, decoder_input_ids=batch.labels)\nhidden_states = outputs.last_hidden_state",
            "masked_line": "model = MT5Model.from_pretrained(\"google/mt5-small\")",
            "answer": "MT5Model",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1004"
        },
        {
            "dependency": "transformers",
            "version": "==4.0.0",
            "time": "2020-11-30",
            "description": "The code aims to use the MT5 model to perform conditional generation by inputting an article in German and summarizing it into a shorter statement. The model generates the summary based on the input article using sequence-to-sequence preparation and outputs the loss function value as the evaluation metric.",
            "code": "from transformers import MT5ForConditionalGeneration, T5Tokenizer\nmodel = MT5ForConditionalGeneration.from_pretrained(\"google/mt5-small\")\ntokenizer = T5Tokenizer.from_pretrained(\"google/mt5-small\")\narticle = \"UN Offizier sagt, dass weiter verhandelt werden muss in Syrien.\"\nsummary = \"Weiter Verhandlung in Syrien.\"\nbatch = tokenizer.prepare_seq2seq_batch(src_texts=[article], tgt_texts=[summary], return_tensors=\"pt\")\noutputs = model(**batch)\nloss = outputs.loss",
            "masked_code": "from transformers import MT5ForConditionalGeneration, T5Tokenizer\n<line_mask>\ntokenizer = T5Tokenizer.from_pretrained(\"google/mt5-small\")\narticle = \"UN Offizier sagt, dass weiter verhandelt werden muss in Syrien.\"\nsummary = \"Weiter Verhandlung in Syrien.\"\nbatch = tokenizer.prepare_seq2seq_batch(src_texts=[article], tgt_texts=[summary], return_tensors=\"pt\")\noutputs = model(**batch)\nloss = outputs.loss",
            "masked_line": "model = MT5ForConditionalGeneration.from_pretrained(\"google/mt5-small\")",
            "answer": "MT5ForConditionalGeneration",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1005"
        },
        {
            "dependency": "transformers",
            "version": "==4.0.0",
            "time": "2020-11-30",
            "description": "The code processes text summarization by using a pre-trained TFMT5Model to generate summaries of input articles.",
            "code": "from transformers import TFMT5Model, T5Tokenizer\nmodel = TFMT5Model.from_pretrained(\"google/mt5-small\")\ntokenizer = T5Tokenizer.from_pretrained(\"google/mt5-small\")\narticle = \"UN Offizier sagt, dass weiter verhandelt werden muss in Syrien.\"\nsummary = \"Weiter Verhandlung in Syrien.\"\nbatch = tokenizer.prepare_seq2seq_batch(src_texts=[article], tgt_texts=[summary], return_tensors=\"tf\")\nbatch[\"decoder_input_ids\"] = batch[\"labels\"]\ndel batch[\"labels\"]\noutputs = model(batch)\nhidden_states = outputs.last_hidden_state",
            "masked_code": "from transformers import TFMT5Model, T5Tokenizer\n<line_mask>\ntokenizer = T5Tokenizer.from_pretrained(\"google/mt5-small\")\narticle = \"UN Offizier sagt, dass weiter verhandelt werden muss in Syrien.\"\nsummary = \"Weiter Verhandlung in Syrien.\"\nbatch = tokenizer.prepare_seq2seq_batch(src_texts=[article], tgt_texts=[summary], return_tensors=\"tf\")\nbatch[\"decoder_input_ids\"] = batch[\"labels\"]\ndel batch[\"labels\"]\noutputs = model(batch)\nhidden_states = outputs.last_hidden_state",
            "masked_line": "model = TFMT5Model.from_pretrained(\"google/mt5-small\")",
            "answer": "TFMT5Model",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1006"
        },
        {
            "dependency": "transformers",
            "version": "==4.0.0",
            "time": "2020-11-30",
            "description": "The code is preparing a sequence-to-sequence batch for text summarization using the T5 model. It takes an input article in German and generates a summary in German using the trained T5 model. The loss is calculated based on the output summary generated by the model.",
            "code": "from transformers import TFMT5ForConditionalGeneration, T5Tokenizer\nmodel = TFMT5ForConditionalGeneration.from_pretrained(\"google/mt5-small\")\ntokenizer = T5Tokenizer.from_pretrained(\"google/mt5-small\")\narticle = \"UN Offizier sagt, dass weiter verhandelt werden muss in Syrien.\"\nsummary = \"Weiter Verhandlung in Syrien.\"\nbatch = tokenizer.prepare_seq2seq_batch(src_texts=[article], tgt_texts=[summary], return_tensors=\"tf\")\noutputs = model(batch)\nloss = outputs.loss",
            "masked_code": "<line_mask>\nmodel = TFMT5ForConditionalGeneration.from_pretrained(\"google/mt5-small\")\ntokenizer = T5Tokenizer.from_pretrained(\"google/mt5-small\")\narticle = \"UN Offizier sagt, dass weiter verhandelt werden muss in Syrien.\"\nsummary = \"Weiter Verhandlung in Syrien.\"\nbatch = tokenizer.prepare_seq2seq_batch(src_texts=[article], tgt_texts=[summary], return_tensors=\"tf\")\noutputs = model(batch)\nloss = outputs.loss",
            "masked_line": "from transformers import TFMT5ForConditionalGeneration, T5Tokenizer",
            "answer": "TFMT5ForConditionalGeneration",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1007"
        },
        {
            "dependency": "transformers",
            "version": "==4.1.0",
            "time": "2020-12-17",
            "description": "The code loads a pre-trained MT5 model and tokenizer from Google's MT5-small checkpoint. It then encodes a given article using the tokenizer and extracts the last hidden state from the model's outputs.",
            "code": "from transformers import MT5EncoderModel, T5Tokenizer\nmodel = MT5EncoderModel.from_pretrained(\"google/mt5-small\")\ntokenizer = T5Tokenizer.from_pretrained(\"google/mt5-small\")\narticle = \"UN Offizier sagt, dass weiter verhandelt werden muss in Syrien.\"\ninput_ids = tokenizer(article, return_tensors=\"pt\").input_ids\noutputs = model(input_ids)\nhidden_state = outputs.last_hidden_state",
            "masked_code": "<line_mask>\nmodel = MT5EncoderModel.from_pretrained(\"google/mt5-small\")\ntokenizer = T5Tokenizer.from_pretrained(\"google/mt5-small\")\narticle = \"UN Offizier sagt, dass weiter verhandelt werden muss in Syrien.\"\ninput_ids = tokenizer(article, return_tensors=\"pt\").input_ids\noutputs = model(input_ids)\nhidden_state = outputs.last_hidden_state",
            "masked_line": "from transformers import MT5EncoderModel, T5Tokenizer",
            "answer": "MT5EncoderModel",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1008"
        },
        {
            "dependency": "transformers",
            "version": "==4.1.0",
            "time": "2020-12-17",
            "description": "The code loads a pre-trained T5 model for encoding text and a tokenizer, processes input text \"UN Offizier sagt, dass weiter verhandelt werden muss in Syrien\", and calculates the last hidden state representation of the input text using the loaded model.",
            "code": "from transformers import TFMT5EncoderModel, T5Tokenizer\nmodel = TFMT5EncoderModel.from_pretrained(\"google/mt5-small\")\ntokenizer = T5Tokenizer.from_pretrained(\"google/mt5-small\")\narticle = \"UN Offizier sagt, dass weiter verhandelt werden muss in Syrien.\"\ninput_ids = tokenizer(article, return_tensors=\"tf\").input_ids\noutputs = model(input_ids)\nhidden_state = outputs.last_hidden_state",
            "masked_code": "from transformers import TFMT5EncoderModel, T5Tokenizer\n<line_mask>\ntokenizer = T5Tokenizer.from_pretrained(\"google/mt5-small\")\narticle = \"UN Offizier sagt, dass weiter verhandelt werden muss in Syrien.\"\ninput_ids = tokenizer(article, return_tensors=\"tf\").input_ids\noutputs = model(input_ids)\nhidden_state = outputs.last_hidden_state",
            "masked_line": "model = TFMT5EncoderModel.from_pretrained(\"google/mt5-small\")",
            "answer": "TFMT5EncoderModel",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1009"
        },
        {
            "dependency": "transformers",
            "version": "==4.10.0",
            "time": "2021-08-31",
            "description": "The code initializes a Flax Encoder-Decoder model using a BERT encoder and a GPT-2 decoder. It then tokenizes a text input using a BERT tokenizer, encodes the input text using the tokenizer, and generates encoder outputs for the input text.",
            "code": "model = FlaxEncoderDecoderModel.from_encoder_decoder_pretrained('bert-base-cased', 'gpt2')\ntokenizer = BertTokenizer.from_pretrained('bert-base-cased')\ntext = \"My friends are cool but they eat too many carbs.\"\ninput_ids = tokenizer.encode(text, return_tensors='np')\nencoder_outputs = model.encode(input_ids)",
            "masked_code": "model = FlaxEncoderDecoderModel.from_encoder_decoder_pretrained('bert-base-cased', 'gpt2')\ntokenizer = BertTokenizer.from_pretrained('bert-base-cased')\ntext = \"My friends are cool but they eat too many carbs.\"\n<line_mask>\nencoder_outputs = model.encode(input_ids)",
            "masked_line": "input_ids = tokenizer.encode(text, return_tensors='np')",
            "answer": "encode",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1010"
        },
        {
            "dependency": "transformers",
            "version": "==4.11.0",
            "time": "2021-09-27",
            "description": "This python code demonstrates the functionality of a Trie data structure by storing and splitting strings based on specific substrings.",
            "code": "trie = Trie()\ntrie.split(\"[CLS] This is a extra_id_100\")\n[\"[CLS] This is a extra_id_100\"]\ntrie.add(\"[CLS]\")\ntrie.add(\"extra_id_1\")\ntrie.add(\"extra_id_100\")\ntrie.split(\"[CLS] This is a extra_id_100\")\n[\"[CLS]\", \" This is a \", \"extra_id_100\"]\n",
            "masked_code": "trie = Trie()\ntrie.split(\"[CLS] This is a extra_id_100\")\n[\"[CLS] This is a extra_id_100\"]\ntrie.add(\"[CLS]\")\ntrie.add(\"extra_id_1\")\ntrie.add(\"extra_id_100\")\n<line_mask>\n[\"[CLS]\", \" This is a \", \"extra_id_100\"]\n",
            "masked_line": "trie.split(\"[CLS] This is a extra_id_100\")",
            "answer": "split",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1011"
        },
        {
            "dependency": "transformers",
            "version": "==4.11.0",
            "time": "2021-09-27",
            "description": "The code initializes a model and tokenizer for a FlaxPegasus model for conditional text generation, encodes a given input text, decodes it to generate an output, and extracts the last hidden states from the decoder.",
            "code": "model = FlaxPegasusForConditionalGeneration.from_pretrained('google/pegasus-large')\ntokenizer = PegasusTokenizer.from_pretrained('google/pegasus-large')\ntext = \"My friends are cool but they eat too many carbs.\"\ninputs = tokenizer(text, max_length=1024, return_tensors='np')\nencoder_outputs = model.encode(**inputs)\ndecoder_start_token_id = model.config.decoder_start_token_id\ndecoder_input_ids = jnp.ones((inputs.input_ids.shape[0], 1), dtype=\"i4\") * decoder_start_token_id\noutputs = model.decode(decoder_input_ids, encoder_outputs)\nlast_decoder_hidden_states = outputs.last_hidden_state",
            "masked_code": "model = FlaxPegasusForConditionalGeneration.from_pretrained('google/pegasus-large')\ntokenizer = PegasusTokenizer.from_pretrained('google/pegasus-large')\ntext = \"My friends are cool but they eat too many carbs.\"\ninputs = tokenizer(text, max_length=1024, return_tensors='np')\nencoder_outputs = model.encode(**inputs)\ndecoder_start_token_id = model.config.decoder_start_token_id\ndecoder_input_ids = jnp.ones((inputs.input_ids.shape[0], 1), dtype=\"i4\") * decoder_start_token_id\n<line_mask>\nlast_decoder_hidden_states = outputs.last_hidden_state",
            "masked_line": "outputs = model.decode(decoder_input_ids, encoder_outputs)",
            "answer": "decode",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1012"
        },
        {
            "dependency": "transformers",
            "version": "==4.11.0",
            "time": "2021-09-27",
            "description": "The code initializes a FlaxPegasusForConditionalGeneration model and a PegasusTokenizer for text generation. It then encodes the input text using the model and decodes it to generate output logits.",
            "code": "model = FlaxPegasusForConditionalGeneration.from_pretrained('google/pegasus-large')\ntokenizer = PegasusTokenizer.from_pretrained('google/pegasus-large')\ntext = \"My friends are cool but they eat too many carbs.\"\ninputs = tokenizer(text, max_length=1024, return_tensors='np')\nencoder_outputs = model.encode(**inputs)\ndecoder_start_token_id = model.config.decoder_start_token_id\ndecoder_input_ids = jnp.ones((inputs.input_ids.shape[0], 1), dtype=\"i4\") * decoder_start_token_id\noutputs = model.decode(decoder_input_ids, encoder_outputs)\nlogits = outputs.logits",
            "masked_code": "model = FlaxPegasusForConditionalGeneration.from_pretrained('google/pegasus-large')\ntokenizer = PegasusTokenizer.from_pretrained('google/pegasus-large')\ntext = \"My friends are cool but they eat too many carbs.\"\ninputs = tokenizer(text, max_length=1024, return_tensors='np')\nencoder_outputs = model.encode(**inputs)\ndecoder_start_token_id = model.config.decoder_start_token_id\ndecoder_input_ids = jnp.ones((inputs.input_ids.shape[0], 1), dtype=\"i4\") * decoder_start_token_id\n<line_mask>\nlogits = outputs.logits",
            "masked_line": "outputs = model.decode(decoder_input_ids, encoder_outputs)",
            "answer": "decode",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1013"
        },
        {
            "dependency": "transformers",
            "version": "==4.13.0",
            "time": "2021-12-09",
            "description": "The code encodes the input text using the Blenderbot model to generate contextualized representations of the input.",
            "code": "from transformers import BlenderbotTokenizer, FlaxBlenderbotForConditionalGeneration\nmodel = FlaxBlenderbotForConditionalGeneration.from_pretrained('facebook/blenderbot-400M-distill')\ntokenizer = BlenderbotTokenizer.from_pretrained('facebook/blenderbot-400M-distill')\ntext = \"My friends are cool but they eat too many carbs.\"\ninputs = tokenizer(text, max_length=1024, return_tensors='jax')\nencoder_outputs = model.encode(**inputs)",
            "masked_code": "from transformers import BlenderbotTokenizer, FlaxBlenderbotForConditionalGeneration\nmodel = FlaxBlenderbotForConditionalGeneration.from_pretrained('facebook/blenderbot-400M-distill')\ntokenizer = BlenderbotTokenizer.from_pretrained('facebook/blenderbot-400M-distill')\ntext = \"My friends are cool but they eat too many carbs.\"\ninputs = tokenizer(text, max_length=1024, return_tensors='jax')\n<line_mask>",
            "masked_line": "encoder_outputs = model.encode(**inputs)",
            "answer": "encode",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1014"
        },
        {
            "dependency": "transformers",
            "version": "==4.13.0",
            "time": "2021-12-09",
            "description": "The code initializes a pretrained FlaxBlenderbot model and tokenizer from the 'facebook/blenderbot-400M-distill' checkpoint. It then encodes input text using the tokenizer and the model, generates initial decoder input ids, decodes the input using the model, and retrieves the last hidden states of the decoder.",
            "code": "model = FlaxBlenderbotForConditionalGeneration.from_pretrained('facebook/blenderbot-400M-distill')\ntokenizer = BlenderbotTokenizer.from_pretrained('facebook/blenderbot-400M-distill')\ninputs = tokenizer(text, max_length=1024, return_tensors='jax')\nencoder_outputs = model.encode(**inputs)\ndecoder_start_token_id = model.config.decoder_start_token_id\ndecoder_input_ids = jnp.ones((inputs.input_ids.shape[0], 1), dtype=\"i4\") * decoder_start_token_id\noutputs = model.decode(decoder_input_ids, encoder_outputs)\nlast_decoder_hidden_states = outputs.last_hidden_state",
            "masked_code": "model = FlaxBlenderbotForConditionalGeneration.from_pretrained('facebook/blenderbot-400M-distill')\ntokenizer = BlenderbotTokenizer.from_pretrained('facebook/blenderbot-400M-distill')\ninputs = tokenizer(text, max_length=1024, return_tensors='jax')\nencoder_outputs = model.encode(**inputs)\ndecoder_start_token_id = model.config.decoder_start_token_id\ndecoder_input_ids = jnp.ones((inputs.input_ids.shape[0], 1), dtype=\"i4\") * decoder_start_token_id\n<line_mask>\nlast_decoder_hidden_states = outputs.last_hidden_state",
            "masked_line": "outputs = model.decode(decoder_input_ids, encoder_outputs)",
            "answer": "decode",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1015"
        },
        {
            "dependency": "transformers",
            "version": "==4.13.0",
            "time": "2021-12-09",
            "description": "This code loads a pre-trained FlaxBlenderbot model and tokenizer from the Facebook Blenderbot-400M-distill checkpoint. It then encodes the input text \"My friends are cool but they eat too many carbs\", generates decoder input IDs, and uses the model to decode and generate logits for the given input.",
            "code": "model = FlaxBlenderbotForConditionalGeneration.from_pretrained('facebook/blenderbot-400M-distill')\ntokenizer = BlenderbotTokenizer.from_pretrained('facebook/blenderbot-400M-distill')\ntext = \"My friends are cool but they eat too many carbs.\"\ninputs = tokenizer(text, max_length=1024, return_tensors='jax')\nencoder_outputs = model.encode(**inputs)\ndecoder_start_token_id = model.config.decoder_start_token_id\ndecoder_input_ids = jnp.ones((inputs.input_ids.shape[0], 1), dtype=\"i4\") * decoder_start_token_id\noutputs = model.decode(decoder_input_ids, encoder_outputs)\nlogits = outputs.logits",
            "masked_code": "model = FlaxBlenderbotForConditionalGeneration.from_pretrained('facebook/blenderbot-400M-distill')\ntokenizer = BlenderbotTokenizer.from_pretrained('facebook/blenderbot-400M-distill')\ntext = \"My friends are cool but they eat too many carbs.\"\ninputs = tokenizer(text, max_length=1024, return_tensors='jax')\nencoder_outputs = model.encode(**inputs)\ndecoder_start_token_id = model.config.decoder_start_token_id\ndecoder_input_ids = jnp.ones((inputs.input_ids.shape[0], 1), dtype=\"i4\") * decoder_start_token_id\n<line_mask>\nlogits = outputs.logits",
            "masked_line": "outputs = model.decode(decoder_input_ids, encoder_outputs)",
            "answer": "decode",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1016"
        },
        {
            "dependency": "transformers",
            "version": "==4.13.0",
            "time": "2021-12-09",
            "description": "The code encodes the input text using a pretrained FlaxBlenderbotSmall model and tokenizer from Facebook's Blenderbot_small-90M, without utilizing any specific dependencies or function calls.",
            "code": "model = FlaxBlenderbotSmallForConditionalGeneration.from_pretrained('facebook/blenderbot_small-90M')\ntokenizer = BlenderbotSmallTokenizer.from_pretrained('facebook/blenderbot_small-90M')\ntext = \"My friends are cool but they eat too many carbs.\"\ninputs = tokenizer(text, max_length=1024, return_tensors='np')\nencoder_outputs = model.encode(**inputs)",
            "masked_code": "model = FlaxBlenderbotSmallForConditionalGeneration.from_pretrained('facebook/blenderbot_small-90M')\ntokenizer = BlenderbotSmallTokenizer.from_pretrained('facebook/blenderbot_small-90M')\ntext = \"My friends are cool but they eat too many carbs.\"\ninputs = tokenizer(text, max_length=1024, return_tensors='np')\n<line_mask>",
            "masked_line": "encoder_outputs = model.encode(**inputs)",
            "answer": "encode",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1017"
        },
        {
            "dependency": "transformers",
            "version": "==4.13.0",
            "time": "2021-12-09",
            "description": "The code initializes a pre-trained FlaxBlenderbotSmall model and tokenizer from the Facebook Blenderbot Small model. It then encodes the input text using the tokenizer and the model's encoder. Next, it prepares the decoder input ids and decodes the generated output using the model. Lastly, it retrieves the last hidden states of the decoder from the outputs.",
            "code": "model = FlaxBlenderbotSmallForConditionalGeneration.from_pretrained('facebook/blenderbot_small-90M')\ntokenizer = BlenderbotSmallTokenizer.from_pretrained('facebook/blenderbot_small-90M')\ntext = \"My friends are cool but they eat too many carbs.\"\ninputs = tokenizer(text, max_length=1024, return_tensors='np')\nencoder_outputs = model.encode(**inputs)\ndecoder_start_token_id = model.config.decoder_start_token_id\ndecoder_input_ids = jnp.ones((inputs.input_ids.shape[0], 1), dtype=\"i4\") * decoder_start_token_id\noutputs = model.decode(decoder_input_ids, encoder_outputs)\nlast_decoder_hidden_states = outputs.last_hidden_state",
            "masked_code": "model = FlaxBlenderbotSmallForConditionalGeneration.from_pretrained('facebook/blenderbot_small-90M')\ntokenizer = BlenderbotSmallTokenizer.from_pretrained('facebook/blenderbot_small-90M')\ntext = \"My friends are cool but they eat too many carbs.\"\ninputs = tokenizer(text, max_length=1024, return_tensors='np')\nencoder_outputs = model.encode(**inputs)\ndecoder_start_token_id = model.config.decoder_start_token_id\ndecoder_input_ids = jnp.ones((inputs.input_ids.shape[0], 1), dtype=\"i4\") * decoder_start_token_id\n<line_mask>\nlast_decoder_hidden_states = outputs.last_hidden_state",
            "masked_line": "outputs = model.decode(decoder_input_ids, encoder_outputs)",
            "answer": "decode",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1018"
        },
        {
            "dependency": "transformers",
            "version": "==4.13.0",
            "time": "2021-12-09",
            "description": "The code initializes a FlaxBlenderbotSmallForConditionalGeneration model and a BlenderbotSmallTokenizer for text generation tasks. It then encodes the input text using the tokenizer and the model, generates decoder input ids, and finally decodes the input to output logits for further processing.",
            "code": "model = FlaxBlenderbotSmallForConditionalGeneration.from_pretrained('facebook/blenderbot_small-90M')\ntokenizer = BlenderbotSmallTokenizer.from_pretrained('facebook/blenderbot_small-90M')\ntext = \"My friends are cool but they eat too many carbs.\"\ninputs = tokenizer(text, max_length=1024, return_tensors='np')\nencoder_outputs = model.encode(**inputs)\ndecoder_start_token_id = model.config.decoder_start_token_id\ndecoder_input_ids = jnp.ones((inputs.input_ids.shape[0], 1), dtype=\"i4\") * decoder_start_token_id\noutputs = model.decode(decoder_input_ids, encoder_outputs)\nlogits = outputs.logits",
            "masked_code": "model = FlaxBlenderbotSmallForConditionalGeneration.from_pretrained('facebook/blenderbot_small-90M')\ntokenizer = BlenderbotSmallTokenizer.from_pretrained('facebook/blenderbot_small-90M')\ntext = \"My friends are cool but they eat too many carbs.\"\ninputs = tokenizer(text, max_length=1024, return_tensors='np')\nencoder_outputs = model.encode(**inputs)\ndecoder_start_token_id = model.config.decoder_start_token_id\ndecoder_input_ids = jnp.ones((inputs.input_ids.shape[0], 1), dtype=\"i4\") * decoder_start_token_id\n<line_mask>\nlogits = outputs.logits",
            "masked_line": "outputs = model.decode(decoder_input_ids, encoder_outputs)",
            "answer": "decode",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1019"
        },
        {
            "dependency": "transformers",
            "version": "==4.13.0",
            "time": "2021-12-09",
            "description": "The code reads an image from a specific URL, extracts image features using a Vision Transformer (ViT) model, and then encodes the features using an Encoder-Decoder model composed of ViT and GPT2 models.",
            "code": "from transformers import FlaxVisionEncoderDecoderModel\nfrom PIL import Image\nimport requests\n\nurl = 'http://images.cocodataset.org/val2017/000000039769.jpg'\nimage = Image.open(requests.get(url, stream=True).raw)\n\nfeature_extractor = ViTFeatureExtractor.from_pretrained('google/vit-base-patch16-224-in21k')\n\n# initialize a vit-gpt2 from pretrained ViT and GPT2 models. Note that the cross-attention layers will be randomly initialized\nmodel = FlaxVisionEncoderDecoderModel.from_encoder_decoder_pretrained('vit', 'gpt2')\n\npixel_values = feature_extractor(images=image, return_tensors=\"np\").pixel_values\nencoder_outputs = model.encode(pixel_values)\n",
            "masked_code": "from transformers import FlaxVisionEncoderDecoderModel\nfrom PIL import Image\nimport requests\n\nurl = 'http://images.cocodataset.org/val2017/000000039769.jpg'\nimage = Image.open(requests.get(url, stream=True).raw)\n\nfeature_extractor = ViTFeatureExtractor.from_pretrained('google/vit-base-patch16-224-in21k')\n\n# initialize a vit-gpt2 from pretrained ViT and GPT2 models. Note that the cross-attention layers will be randomly initialized\nmodel = FlaxVisionEncoderDecoderModel.from_encoder_decoder_pretrained('vit', 'gpt2')\n\npixel_values = feature_extractor(images=image, return_tensors=\"np\").pixel_values\n<line_mask>\n",
            "masked_line": "encoder_outputs = model.encode(pixel_values)",
            "answer": "encode",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1020"
        },
        {
            "dependency": "transformers",
            "version": "==4.13.0",
            "time": "2021-12-09",
            "description": "The code performs text encoding using a VisionTextDualEncoderModel trained on Italian data. It takes input text in Italian describing images of a cat and a dog, tokenizes the text using the Italian tokenizer, pads the sequences, and returns the text features extracted by the model.",
            "code": "from transformers import VisionTextDualEncoderModel, AutoTokenizer\n\nmodel = VisionTextDualEncoderModel.from_pretrained(\"clip-italian/clip-italian\")\ntokenizer = AutoTokenizer.from_pretrained(\"clip-italian/clip-italian\")\n\ninputs = tokenizer([\"una foto di un gatto\", \"una foto di un cane\"],  padding=True, return_tensors=\"pt\")\ntext_features = model.get_text_features(**inputs)",
            "masked_code": "from transformers import VisionTextDualEncoderModel, AutoTokenizer\n\nmodel = VisionTextDualEncoderModel.from_pretrained(\"clip-italian/clip-italian\")\ntokenizer = AutoTokenizer.from_pretrained(\"clip-italian/clip-italian\")\n\ninputs = tokenizer([\"una foto di un gatto\", \"una foto di un cane\"],  padding=True, return_tensors=\"pt\")\n<line_mask>",
            "masked_line": "text_features = model.get_text_features(**inputs)",
            "answer": "get_text_features",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1021"
        },
        {
            "dependency": "transformers",
            "version": "==4.13.0",
            "time": "2021-12-09",
            "description": "The code retrieves features from an image using a pre-trained VisionTextDualEncoderModel and AutoFeatureExtractor without showcasing the dependencies and function calls in the code.",
            "code": "from PIL import Image\nimport requests\nfrom transformers import VisionTextDualEncoderModel, AutoFeatureExtractor\n\nmodel = VisionTextDualEncoderModel.from_pretrained(\"clip-italian/clip-italian\")\nfeature_extractor = AutoFeatureExtractor.from_pretrained(\"google/vit-base-patch16-224\")\n\nurl = \"http://images.cocodataset.org/val2017/000000039769.jpg\"\nimage = Image.open(requests.get(url, stream=True).raw)\n\ninputs = feature_extractor(images=image, return_tensors=\"pt\")\n\nimage_features = model.get_image_features(**inputs)",
            "masked_code": "from PIL import Image\nimport requests\nfrom transformers import VisionTextDualEncoderModel, AutoFeatureExtractor\n\nmodel = VisionTextDualEncoderModel.from_pretrained(\"clip-italian/clip-italian\")\nfeature_extractor = AutoFeatureExtractor.from_pretrained(\"google/vit-base-patch16-224\")\n\nurl = \"http://images.cocodataset.org/val2017/000000039769.jpg\"\nimage = Image.open(requests.get(url, stream=True).raw)\n\ninputs = feature_extractor(images=image, return_tensors=\"pt\")\n\n<line_mask>",
            "masked_line": "image_features = model.get_image_features(**inputs)",
            "answer": "get_image_features",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1022"
        },
        {
            "dependency": "transformers",
            "version": "==4.13.0",
            "time": "2021-12-09",
            "description": "The code converts the model parameters to bfloat16 format, flattens the parameters into a dictionary, creates a mask based on the parameter paths with specific conditions, unflattens the mask into a dictionary, and converts the model parameters to bfloat16 format using the mask.",
            "code": "model.params = model.to_bf16(model.params)\nflat_params = traverse_util.flatten_dict(model.params)\nmask = {path: (path[-2] != (\"LayerNorm\", \"bias\") and path[-2:] != (\"LayerNorm\", \"scale\")) for path in flat_params}\nmask = traverse_util.unflatten_dict(mask)\nmodel.params = model.to_bf16(model.params, mask)\n",
            "masked_code": "model.params = model.to_bf16(model.params)\nflat_params = traverse_util.flatten_dict(model.params)\nmask = {path: (path[-2] != (\"LayerNorm\", \"bias\") and path[-2:] != (\"LayerNorm\", \"scale\")) for path in flat_params}\nmask = traverse_util.unflatten_dict(mask)\n<line_mask>\n",
            "masked_line": "model.params = model.to_bf16(model.params, mask)",
            "answer": "to_bf16",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1023"
        },
        {
            "dependency": "transformers",
            "version": "==4.16.0",
            "time": "2022-01-27",
            "description": "The code utilizes a pre-trained CLIP model to extract text features from the provided input text descriptions of images.",
            "code": "from transformers import CLIPTokenizer, TFCLIPModel\n\nmodel = TFCLIPModel.from_pretrained(\"openai/clip-vit-base-patch32\")\ntokenizer = CLIPTokenizer.from_pretrained(\"openai/clip-vit-base-patch32\")\n\ninputs = tokenizer([\"a photo of a cat\", \"a photo of a dog\"], padding=True, return_tensors=\"tf\")\ntext_features = model.get_text_features(**inputs)\n",
            "masked_code": "from transformers import CLIPTokenizer, TFCLIPModel\n\nmodel = TFCLIPModel.from_pretrained(\"openai/clip-vit-base-patch32\")\ntokenizer = CLIPTokenizer.from_pretrained(\"openai/clip-vit-base-patch32\")\n\ninputs = tokenizer([\"a photo of a cat\", \"a photo of a dog\"], padding=True, return_tensors=\"tf\")\n<line_mask>\n",
            "masked_line": "text_features = model.get_text_features(**inputs)",
            "answer": "get_text_features",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1024"
        },
        {
            "dependency": "transformers",
            "version": "==4.16.0",
            "time": "2022-01-27",
            "description": "This code retrieves image features using the CLIP (Contrastive Language-Image Pre-training) model from an image downloaded from a URL.",
            "code": "from PIL import Image\nimport requests\nfrom transformers import CLIPProcessor, TFCLIPModel\n\nmodel = TFCLIPModel.from_pretrained(\"openai/clip-vit-base-patch32\")\nprocessor = CLIPProcessor.from_pretrained(\"openai/clip-vit-base-patch32\")\n\nurl = \"http://images.cocodataset.org/val2017/000000039769.jpg\"\nimage = Image.open(requests.get(url, stream=True).raw)\n\ninputs = processor(images=image, return_tensors=\"tf\")\n\nimage_features = model.get_image_features(**inputs)\n",
            "masked_code": "from PIL import Image\nimport requests\nfrom transformers import CLIPProcessor, TFCLIPModel\n\nmodel = TFCLIPModel.from_pretrained(\"openai/clip-vit-base-patch32\")\nprocessor = CLIPProcessor.from_pretrained(\"openai/clip-vit-base-patch32\")\n\nurl = \"http://images.cocodataset.org/val2017/000000039769.jpg\"\nimage = Image.open(requests.get(url, stream=True).raw)\n\ninputs = processor(images=image, return_tensors=\"tf\")\n\n<line_mask>\n",
            "masked_line": "image_features = model.get_image_features(**inputs)",
            "answer": "get_image_features",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1025"
        },
        {
            "dependency": "transformers",
            "version": "==4.17.0",
            "time": "2022-03-03",
            "description": "The code initializes a speech encoder-decoder model using the pre-trained wav2vec2-large-lv60 encoder and bart-large decoder. It then encodes an input sequence, generates decoder input tokens, decodes the input using the model, and retrieves the logits as outputs.",
            "code": "from transformers import FlaxSpeechEncoderDecoderModel\nimport jax.numpy as jnp\n\nmodel = FlaxSpeechEncoderDecoderModel.from_encoder_decoder_pretrained(\n    \"facebook/wav2vec2-large-lv60\", \"facebook/bart-large\"\n)\n\ninputs = jnp.ones((2, 5000), dtype=jnp.float32)\nencoder_outputs = model.encode(inputs)\n\ndecoder_start_token_id = model.config.decoder.bos_token_id\ndecoder_input_ids = jnp.ones((inputs.shape[0], 1), dtype=\"i4\") * decoder_start_token_id\n\noutputs = model.decode(decoder_input_ids, encoder_outputs)\nlogits = outputs.logits",
            "masked_code": "from transformers import FlaxSpeechEncoderDecoderModel\nimport jax.numpy as jnp\n\nmodel = FlaxSpeechEncoderDecoderModel.from_encoder_decoder_pretrained(\n    \"facebook/wav2vec2-large-lv60\", \"facebook/bart-large\"\n)\n\ninputs = jnp.ones((2, 5000), dtype=jnp.float32)\nencoder_outputs = model.encode(inputs)\n\ndecoder_start_token_id = model.config.decoder.bos_token_id\ndecoder_input_ids = jnp.ones((inputs.shape[0], 1), dtype=\"i4\") * decoder_start_token_id\n\n<line_mask>\nlogits = outputs.logits",
            "masked_line": "outputs = model.decode(decoder_input_ids, encoder_outputs)",
            "answer": "decode",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1026"
        },
        {
            "dependency": "transformers",
            "version": "==4.18.0",
            "time": "2022-04-06",
            "description": "The code fine-tunes a BERT model and then pushes it to a Hugging Face repository with various specified configurations.",
            "code": "from transformers import AutoModel\n\nmodel = AutoModel.from_pretrained(\"bert-base-cased\")\n\nmodel.push_to_hub(\"my-finetuned-bert\")\n\nmodel.push_to_hub(\"my-finetuned-bert\", use_temp_dir=True)\n\nmodel.push_to_hub(\"my-finetuned-bert\", organization=\"huggingface\")\n\nmodel.push_to_hub(\"my-finetuned-bert\", repo_url=\"https://huggingface.co/sgugger/my-finetuned-bert\")\n",
            "masked_code": "from transformers import AutoModel\n\nmodel = AutoModel.from_pretrained(\"bert-base-cased\")\n\n<line_mask>\n\nmodel.push_to_hub(\"my-finetuned-bert\", use_temp_dir=True)\n\nmodel.push_to_hub(\"my-finetuned-bert\", organization=\"huggingface\")\n\nmodel.push_to_hub(\"my-finetuned-bert\", repo_url=\"https://huggingface.co/sgugger/my-finetuned-bert\")\n",
            "masked_line": "model.push_to_hub(\"my-finetuned-bert\")",
            "answer": "push_to_hub",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1027"
        },
        {
            "dependency": "transformers",
            "version": "==4.19.0",
            "time": "2022-05-12",
            "description": "The code initializes a FlavaConfig object with style configuration, then creates a FlavaModel and FlavaForPreTraining model based on the style configuration. Finally, it accesses the configuration of both models.",
            "code": "from transformers import FlavaModel, FlavaForPreTraining, FlavaConfig\n\n# Initializing a FlavaConfig with style configuration\nconfiguration = FlavaConfig()\n\n# Initializing a FlavaModel and FlavaForPreTraining model from the style configuration\nmodel = FlavaModel(configuration)\nmodel_pre = FlavaForPreTraining(configuration)\n\n# Accessing the model configuration\nconfiguration = model.config\nconfiguration_pre = model_pre.config\n",
            "masked_code": "from transformers import FlavaModel, FlavaForPreTraining, FlavaConfig\n\n# Initializing a FlavaConfig with style configuration\n<line_mask>\n\n# Initializing a FlavaModel and FlavaForPreTraining model from the style configuration\nmodel = FlavaModel(configuration)\nmodel_pre = FlavaForPreTraining(configuration)\n\n# Accessing the model configuration\nconfiguration = model.config\nconfiguration_pre = model_pre.config\n",
            "masked_line": "configuration = FlavaConfig()",
            "answer": "FlavaConfig",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1028"
        },
        {
            "dependency": "transformers",
            "version": "==4.20.0",
            "time": "2022-06-16",
            "description": "The code tokenizes input text using the BloomTokenizerFast model from the \"bigscience/bloom\" pretrained model, providing the input ids for the tokenized text.",
            "code": "from transformers import BloomTokenizerFast\ntokenizer = BloomTokenizerFast.from_pretrained(\"bigscience/bloom\")\ntokenizer(\"Hello world\")['input_ids']\n[15496, 995]\ntokenizer(\" Hello world\")['input_ids']\n[18435, 995]\n",
            "masked_code": "<line_mask>\ntokenizer = BloomTokenizerFast.from_pretrained(\"bigscience/bloom\")\ntokenizer(\"Hello world\")['input_ids']\n[15496, 995]\ntokenizer(\" Hello world\")['input_ids']\n[18435, 995]\n",
            "masked_line": "from transformers import BloomTokenizerFast",
            "answer": "BloomTokenizerFast",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1029"
        },
        {
            "dependency": "transformers",
            "version": "==4.20.0",
            "time": "2022-06-16",
            "description": "The code uses the GPT2 tokenizer to tokenize the input text \"Hello world\" and \" Hello world\", returning their corresponding input ids.",
            "code": "from transformers import GPTNeoXTokenizerFast\ntokenizer = GPTNeoXTokenizerFast.from_pretrained(\"gpt2\")\ntokenizer(\"Hello world\")['input_ids']\n[15496, 995]\ntokenizer(\" Hello world\")['input_ids']\n[18435, 995]\n",
            "masked_code": "from transformers import GPTNeoXTokenizerFast\n<line_mask>\ntokenizer(\"Hello world\")['input_ids']\n[15496, 995]\ntokenizer(\" Hello world\")['input_ids']\n[18435, 995]\n",
            "masked_line": "tokenizer = GPTNeoXTokenizerFast.from_pretrained(\"gpt2\")",
            "answer": "GPTNeoXTokenizerFast",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1030"
        },
        {
            "dependency": "transformers",
            "version": "==4.20.0",
            "time": "2022-06-16",
            "description": "This code segment encodes the input text using the T5 model to generate encoder outputs.",
            "code": "from transformers import T5Tokenizer, FlaxLongT5ForConditionalGeneration\ntokenizer = T5Tokenizer.from_pretrained(\"t5-base\")\nmodel = FlaxLongT5ForConditionalGeneration.from_pretrained(\"google/long-t5-local-base\")\ntext = \"My friends are cool but they eat too many carbs.\"\ninputs = tokenizer(text, return_tensors=\"np\")\nencoder_outputs = model.encode(**inputs)",
            "masked_code": "from transformers import T5Tokenizer, FlaxLongT5ForConditionalGeneration\ntokenizer = T5Tokenizer.from_pretrained(\"t5-base\")\nmodel = FlaxLongT5ForConditionalGeneration.from_pretrained(\"google/long-t5-local-base\")\ntext = \"My friends are cool but they eat too many carbs.\"\ninputs = tokenizer(text, return_tensors=\"np\")\n<line_mask>",
            "masked_line": "encoder_outputs = model.encode(**inputs)",
            "answer": "encode",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1031"
        },
        {
            "dependency": "transformers",
            "version": "==4.21.0",
            "time": "2022-07-27",
            "description": "This code snippet utilizes a pretrained GroupViT model and CLIPTokenizer from the transformers library to extract text features from input phrases describing images of a cat and a dog.",
            "code": "from transformers import CLIPTokenizer, GroupViTModel\n\nmodel = GroupViTModel.from_pretrained(\"nvidia/groupvit-gcc-yfcc\")\ntokenizer = CLIPTokenizer.from_pretrained(\"nvidia/groupvit-gcc-yfcc\")\n\ninputs = tokenizer([\"a photo of a cat\", \"a photo of a dog\"], padding=True, return_tensors=\"pt\")\ntext_features = model.get_text_features(**inputs)\n",
            "masked_code": "from transformers import CLIPTokenizer, GroupViTModel\n\nmodel = GroupViTModel.from_pretrained(\"nvidia/groupvit-gcc-yfcc\")\ntokenizer = CLIPTokenizer.from_pretrained(\"nvidia/groupvit-gcc-yfcc\")\n\ninputs = tokenizer([\"a photo of a cat\", \"a photo of a dog\"], padding=True, return_tensors=\"pt\")\n<line_mask>\n",
            "masked_line": "text_features = model.get_text_features(**inputs)",
            "answer": "get_text_features",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1032"
        },
        {
            "dependency": "transformers",
            "version": "==4.21.0",
            "time": "2022-07-27",
            "description": "This code downloads an image from a given URL, extracts features from the image using a GroupViT model, and stores the extracted features in the variable image_features.",
            "code": "from PIL import Image\nimport requests\nfrom transformers import AutoProcessor, GroupViTModel\n\nmodel = GroupViTModel.from_pretrained(\"nvidia/groupvit-gcc-yfcc\")\nprocessor = AutoProcessor.from_pretrained(\"nvidia/groupvit-gcc-yfcc\")\n\nurl = \"http://images.cocodataset.org/val2017/000000039769.jpg\"\nimage = Image.open(requests.get(url, stream=True).raw)\n\ninputs = processor(images=image, return_tensors=\"pt\")\n\nimage_features = model.get_image_features(**inputs)\n",
            "masked_code": "from PIL import Image\nimport requests\nfrom transformers import AutoProcessor, GroupViTModel\n\nmodel = GroupViTModel.from_pretrained(\"nvidia/groupvit-gcc-yfcc\")\nprocessor = AutoProcessor.from_pretrained(\"nvidia/groupvit-gcc-yfcc\")\n\nurl = \"http://images.cocodataset.org/val2017/000000039769.jpg\"\nimage = Image.open(requests.get(url, stream=True).raw)\n\ninputs = processor(images=image, return_tensors=\"pt\")\n\n<line_mask>\n",
            "masked_line": "image_features = model.get_image_features(**inputs)",
            "answer": "get_image_features",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1033"
        },
        {
            "dependency": "transformers",
            "version": "==4.23.0",
            "time": "2022-10-10",
            "description": "The code utilizes the GPTNeoXJapaneseTokenizer to encode and decode text, ensuring that variant forms of the same word (like  and ) are correctly represented with the same token.",
            "code": "from transformers import GPTNeoXJapaneseTokenizer\n\ntokenizer = GPTNeoXJapaneseTokenizer.from_pretrained(\"abeja/gpt-neox-japanese-2.7b\")\n# You can confirm both  and  are encoded to 17749\ntokenizer(\"()\")[\"input_ids\"]\n[30014, 26883, 26638, 27228, 25, 26650, 31732, 31679, 27809, 26638, 17749, 31592, 17749, 31593, 321, 1281]\n\n# Both  and  are decoded to \ntokenizer.decode(tokenizer(\"()\")[\"input_ids\"])\n'()'\n",
            "masked_code": "<line_mask>\n\ntokenizer = GPTNeoXJapaneseTokenizer.from_pretrained(\"abeja/gpt-neox-japanese-2.7b\")\n# You can confirm both  and  are encoded to 17749\ntokenizer(\"()\")[\"input_ids\"]\n[30014, 26883, 26638, 27228, 25, 26650, 31732, 31679, 27809, 26638, 17749, 31592, 17749, 31593, 321, 1281]\n\n# Both  and  are decoded to \ntokenizer.decode(tokenizer(\"()\")[\"input_ids\"])\n'()'\n",
            "masked_line": "from transformers import GPTNeoXJapaneseTokenizer",
            "answer": "GPTNeoXJapaneseTokenizer",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1034"
        },
        {
            "dependency": "transformers",
            "version": "==4.25.1",
            "time": "2022-12-01",
            "description": "The code initializes a CLIPImageProcessor object with different configurations and options, such as loading a pretrained model, saving a model, loading from a specific file path, and setting normalization options. It also includes assertions to check the correctness of the settings.",
            "code": "image_processor = CLIPImageProcessor.from_pretrained(\n    \"openai/clip-vit-base-patch32\"\n)  # Download image_processing_config from huggingface.co and cache.\nimage_processor = CLIPImageProcessor.from_pretrained(\n    \"./test/saved_model/\"\n)  # E.g. image processor (or model) was saved using *save_pretrained('./test/saved_model/')*\nimage_processor = CLIPImageProcessor.from_pretrained(\"./test/saved_model/preprocessor_config.json\")\nimage_processor = CLIPImageProcessor.from_pretrained(\n    \"openai/clip-vit-base-patch32\", do_normalize=False, foo=False\n)\nassert image_processor.do_normalize is False\nimage_processor, unused_kwargs = CLIPImageProcessor.from_pretrained(\n    \"openai/clip-vit-base-patch32\", do_normalize=False, foo=False, return_unused_kwargs=True\n)\nassert image_processor.do_normalize is False\nassert unused_kwargs == {\"foo\": False}\n",
            "masked_code": "<line_mask>\n    \"openai/clip-vit-base-patch32\"\n)  # Download image_processing_config from huggingface.co and cache.\nimage_processor = CLIPImageProcessor.from_pretrained(\n    \"./test/saved_model/\"\n)  # E.g. image processor (or model) was saved using *save_pretrained('./test/saved_model/')*\nimage_processor = CLIPImageProcessor.from_pretrained(\"./test/saved_model/preprocessor_config.json\")\nimage_processor = CLIPImageProcessor.from_pretrained(\n    \"openai/clip-vit-base-patch32\", do_normalize=False, foo=False\n)\nassert image_processor.do_normalize is False\nimage_processor, unused_kwargs = CLIPImageProcessor.from_pretrained(\n    \"openai/clip-vit-base-patch32\", do_normalize=False, foo=False, return_unused_kwargs=True\n)\nassert image_processor.do_normalize is False\nassert unused_kwargs == {\"foo\": False}\n",
            "masked_line": "image_processor = CLIPImageProcessor.from_pretrained(",
            "answer": "from_pretrained",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1035"
        },
        {
            "dependency": "transformers",
            "version": "==4.26.0",
            "time": "2023-01-24",
            "description": "The code initializes an AltCLIP configuration, model, and text and vision configurations, and then creates a new AltCLIP configuration using the text and vision configurations.",
            "code": "from transformers import AltCLIPConfig, AltCLIPModel\nconfiguration = AltCLIPConfig()\nmodel = AltCLIPModel(configuration)\nconfiguration = model.config\nconfig_text = AltCLIPTextConfig()\nconfig_vision = AltCLIPVisionConfig()\nconfig = AltCLIPConfig.from_text_vision_configs(config_text, config_vision)\n",
            "masked_code": "<line_mask>\nconfiguration = AltCLIPConfig()\nmodel = AltCLIPModel(configuration)\nconfiguration = model.config\nconfig_text = AltCLIPTextConfig()\nconfig_vision = AltCLIPVisionConfig()\nconfig = AltCLIPConfig.from_text_vision_configs(config_text, config_vision)\n",
            "masked_line": "from transformers import AltCLIPConfig, AltCLIPModel",
            "answer": "AltCLIPConfig",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1036"
        },
        {
            "dependency": "transformers",
            "version": "==4.26.0",
            "time": "2023-01-24",
            "description": "The code retrieves text features from the AltCLIP model for the input text descriptions of a cat and a dog.",
            "code": "from transformers import AutoProcessor, AltCLIPModel\nmodel = AltCLIPModel.from_pretrained(\"BAAI/AltCLIP\")\nprocessor = AutoProcessor.from_pretrained(\"BAAI/AltCLIP\")\ninputs = processor(text=[\"a photo of a cat\", \"a photo of a dog\"], padding=True, return_tensors=\"pt\")\ntext_features = model.get_text_features(**inputs)\n",
            "masked_code": "from transformers import AutoProcessor, AltCLIPModel\nmodel = AltCLIPModel.from_pretrained(\"BAAI/AltCLIP\")\nprocessor = AutoProcessor.from_pretrained(\"BAAI/AltCLIP\")\ninputs = processor(text=[\"a photo of a cat\", \"a photo of a dog\"], padding=True, return_tensors=\"pt\")\n<line_mask>\n",
            "masked_line": "text_features = model.get_text_features(**inputs)",
            "answer": "get_text_features",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1037"
        },
        {
            "dependency": "transformers",
            "version": "==4.26.0",
            "time": "2023-01-24",
            "description": "This code downloads an image from a given URL, processes the image features using a pretrained AltCLIP model, and extracts the image features.",
            "code": "from PIL import Image\nimport requests\nfrom transformers import AutoProcessor, AltCLIPModel\n\nmodel = AltCLIPModel.from_pretrained(\"BAAI/AltCLIP\")\nprocessor = AutoProcessor.from_pretrained(\"BAAI/AltCLIP\")\nurl = \"http://images.cocodataset.org/val2017/000000039769.jpg\"\nimage = Image.open(requests.get(url, stream=True).raw)\ninputs = processor(images=image, return_tensors=\"pt\")\nimage_features = model.get_image_features(**inputs)\n",
            "masked_code": "from PIL import Image\nimport requests\nfrom transformers import AutoProcessor, AltCLIPModel\n\nmodel = AltCLIPModel.from_pretrained(\"BAAI/AltCLIP\")\nprocessor = AutoProcessor.from_pretrained(\"BAAI/AltCLIP\")\nurl = \"http://images.cocodataset.org/val2017/000000039769.jpg\"\nimage = Image.open(requests.get(url, stream=True).raw)\ninputs = processor(images=image, return_tensors=\"pt\")\n<line_mask>\n",
            "masked_line": "image_features = model.get_image_features(**inputs)",
            "answer": "get_image_features",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1038"
        },
        {
            "dependency": "transformers",
            "version": "==4.26.0",
            "time": "2023-01-24",
            "description": "The code initializes configurations and models for the Blip model for visual question answering (VQA) using the Salesforce/blip-vqa-base style configuration. The code also demonstrates how to access model configurations and initialize configurations using text and vision configurations.",
            "code": "from transformers import BlipConfig, BlipModel\n\n# Initializing a BlipConfig with Salesforce/blip-vqa-base style configuration\nconfiguration = BlipConfig()\n\n# Initializing a BlipPModel (with random weights) from the Salesforce/blip-vqa-base style configuration\nmodel = BlipModel(configuration)\n\n# Accessing the model configuration\nconfiguration = model.config\n\n# We can also initialize a BlipConfig from a BlipTextConfig and a BlipVisionConfig\n\n# Initializing a BLIPText and BLIPVision configuration\nconfig_text = BlipTextConfig()\nconfig_vision = BlipVisionConfig()\n\nconfig = BlipConfig.from_text_vision_configs(config_text, config_vision)\n",
            "masked_code": "from transformers import BlipConfig, BlipModel\n\n# Initializing a BlipConfig with Salesforce/blip-vqa-base style configuration\nconfiguration = BlipConfig()\n\n# Initializing a BlipPModel (with random weights) from the Salesforce/blip-vqa-base style configuration\nmodel = BlipModel(configuration)\n\n# Accessing the model configuration\nconfiguration = model.config\n\n# We can also initialize a BlipConfig from a BlipTextConfig and a BlipVisionConfig\n\n# Initializing a BLIPText and BLIPVision configuration\nconfig_text = BlipTextConfig()\nconfig_vision = BlipVisionConfig()\n\n<line_mask>\n",
            "masked_line": "config = BlipConfig.from_text_vision_configs(config_text, config_vision)",
            "answer": "BlipConfig",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1039"
        },
        {
            "dependency": "transformers",
            "version": "==4.26.0",
            "time": "2023-01-24",
            "description": "This code segment uses a pre-trained BlipModel to generate text features for descriptions of images identified by the AutoProcessor.",
            "code": "from transformers import AutoProcessor, BlipModel\n\nmodel = BlipModel.from_pretrained(\"Salesforce/blip-image-captioning-base\")\nprocessor = AutoProcessor.from_pretrained(\"Salesforce/blip-image-captioning-base\")\n\ninputs = processor(text=[\"a photo of a cat\", \"a photo of a dog\"], padding=True, return_tensors=\"pt\")\ntext_features = model.get_text_features(**inputs)\n",
            "masked_code": "from transformers import AutoProcessor, BlipModel\n\nmodel = BlipModel.from_pretrained(\"Salesforce/blip-image-captioning-base\")\nprocessor = AutoProcessor.from_pretrained(\"Salesforce/blip-image-captioning-base\")\n\ninputs = processor(text=[\"a photo of a cat\", \"a photo of a dog\"], padding=True, return_tensors=\"pt\")\n<line_mask>\n",
            "masked_line": "text_features = model.get_text_features(**inputs)",
            "answer": "get_text_features",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1040"
        },
        {
            "dependency": "transformers",
            "version": "==4.26.0",
            "time": "2023-01-24",
            "description": "This code is using a pre-trained Blip model for image captioning from Salesforce to generate captions for an input image. The code loads the model and processor, downloads an image from a URL, processes the image using the AutoProcessor, and extracts image features using the Blip model.",
            "code": "from PIL import Image\nimport requests\nfrom transformers import AutoProcessor, BlipModel\n\nmodel = BlipModel.from_pretrained(\"Salesforce/blip-image-captioning-base\")\nprocessor = AutoProcessor.from_pretrained(\"Salesforce/blip-image-captioning-base\")\n\nurl = \"http://images.cocodataset.org/val2017/000000039769.jpg\"\nimage = Image.open(requests.get(url, stream=True).raw)\n\ninputs = processor(images=image, return_tensors=\"pt\")\n\nimage_features = model.get_image_features(**inputs)\n",
            "masked_code": "from PIL import Image\nimport requests\nfrom transformers import AutoProcessor, BlipModel\n\nmodel = BlipModel.from_pretrained(\"Salesforce/blip-image-captioning-base\")\nprocessor = AutoProcessor.from_pretrained(\"Salesforce/blip-image-captioning-base\")\n\nurl = \"http://images.cocodataset.org/val2017/000000039769.jpg\"\nimage = Image.open(requests.get(url, stream=True).raw)\n\ninputs = processor(images=image, return_tensors=\"pt\")\n\n<line_mask>\n",
            "masked_line": "image_features = model.get_image_features(**inputs)",
            "answer": "get_image_features",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1041"
        },
        {
            "dependency": "transformers",
            "version": "==4.27.0",
            "time": "2023-03-15",
            "description": "The code initializes and accesses configurations for an ALIGN model using AlignConfig, AlignModel, AlignTextConfig, and AlignVisionConfig from the transformers library.",
            "code": "from transformers import AlignConfig, AlignModel\n\n# Initializing a AlignConfig with kakaobrain/align-base style configuration\nconfiguration = AlignConfig()\n\n# Initializing a AlignModel (with random weights) from the kakaobrain/align-base style configuration\nmodel = AlignModel(configuration)\n\n# Accessing the model configuration\nconfiguration = model.config\n\n# We can also initialize a AlignConfig from a AlignTextConfig and a AlignVisionConfig\nfrom transformers import AlignTextConfig, AlignVisionConfig\n\n# Initializing ALIGN Text and Vision configurations\nconfig_text = AlignTextConfig()\nconfig_vision = AlignVisionConfig()\n\nconfig = AlignConfig.from_text_vision_configs(config_text, config_vision)\n",
            "masked_code": "<line_mask>\n\n# Initializing a AlignConfig with kakaobrain/align-base style configuration\nconfiguration = AlignConfig()\n\n# Initializing a AlignModel (with random weights) from the kakaobrain/align-base style configuration\nmodel = AlignModel(configuration)\n\n# Accessing the model configuration\nconfiguration = model.config\n\n# We can also initialize a AlignConfig from a AlignTextConfig and a AlignVisionConfig\nfrom transformers import AlignTextConfig, AlignVisionConfig\n\n# Initializing ALIGN Text and Vision configurations\nconfig_text = AlignTextConfig()\nconfig_vision = AlignVisionConfig()\n\nconfig = AlignConfig.from_text_vision_configs(config_text, config_vision)\n",
            "masked_line": "from transformers import AlignConfig, AlignModel",
            "answer": "AlignConfig",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1042"
        },
        {
            "dependency": "transformers",
            "version": "==4.27.0",
            "time": "2023-03-15",
            "description": "The code initializes a model and tokenizer for aligning text and images, tokenizes two input sentences (\"a photo of a cat\" and \"a photo of a dog\") using the tokenizer, and then extracts text features using the model based on the tokenized input sentences.",
            "code": "from transformers import AutoTokenizer, AlignModel\n\nmodel = AlignModel.from_pretrained(\"kakaobrain/align-base\")\ntokenizer = AutoTokenizer.from_pretrained(\"kakaobrain/align-base\")\n\ninputs = tokenizer([\"a photo of a cat\", \"a photo of a dog\"], padding=True, return_tensors=\"pt\")\ntext_features = model.get_text_features(**inputs)\n",
            "masked_code": "from transformers import AutoTokenizer, AlignModel\n\nmodel = AlignModel.from_pretrained(\"kakaobrain/align-base\")\ntokenizer = AutoTokenizer.from_pretrained(\"kakaobrain/align-base\")\n\ninputs = tokenizer([\"a photo of a cat\", \"a photo of a dog\"], padding=True, return_tensors=\"pt\")\n<line_mask>\n",
            "masked_line": "text_features = model.get_text_features(**inputs)",
            "answer": "get_text_features",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1043"
        },
        {
            "dependency": "transformers",
            "version": "==4.27.0",
            "time": "2023-03-15",
            "description": "This code downloads an image from a given URL, processes the image using a pre-trained AlignModel and AutoProcessor from the kakaobrain library, and extracts features from the processed image using the AlignModel.",
            "code": "from PIL import Image\nimport requests\nfrom transformers import AutoProcessor, AlignModel\n\nmodel = AlignModel.from_pretrained(\"kakaobrain/align-base\")\nprocessor = AutoProcessor.from_pretrained(\"kakaobrain/align-base\")\n\nurl = \"http://images.cocodataset.org/val2017/000000039769.jpg\"\nimage = Image.open(requests.get(url, stream=True).raw)\n\ninputs = processor(images=image, return_tensors=\"pt\")\n\nimage_features = model.get_image_features(**inputs)\n",
            "masked_code": "from PIL import Image\nimport requests\nfrom transformers import AutoProcessor, AlignModel\n\nmodel = AlignModel.from_pretrained(\"kakaobrain/align-base\")\nprocessor = AutoProcessor.from_pretrained(\"kakaobrain/align-base\")\n\nurl = \"http://images.cocodataset.org/val2017/000000039769.jpg\"\nimage = Image.open(requests.get(url, stream=True).raw)\n\ninputs = processor(images=image, return_tensors=\"pt\")\n\n<line_mask>\n",
            "masked_line": "image_features = model.get_image_features(**inputs)",
            "answer": "get_image_features",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1044"
        },
        {
            "dependency": "transformers",
            "version": "==4.27.0",
            "time": "2023-03-15",
            "description": "The code loads a pre-trained Blip2 model for text generation from the \"Salesforce/blip2-opt-2.7b\" repository, sets the model to run on either a GPU (if available) or CPU, and tokenizes input text data (\"a photo of a cat\" and \"a photo of a dog\") using the AutoTokenizer. Finally, it extracts text features using the loaded model.",
            "code": "import torch\nfrom transformers import AutoTokenizer, Blip2Model\n\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\n\nmodel = Blip2Model.from_pretrained(\"Salesforce/blip2-opt-2.7b\", torch_dtype=torch.float16)\n\nmodel.to(device)  # doctest: +IGNORE_RESULT\n\ntokenizer = AutoTokenizer.from_pretrained(\"Salesforce/blip2-opt-2.7b\")\ninputs = tokenizer([\"a photo of a cat\", \"a photo of a dog\"], padding=True, return_tensors=\"pt\").to(device)\ntext_features = model.get_text_features(**inputs)\n",
            "masked_code": "import torch\nfrom transformers import AutoTokenizer, Blip2Model\n\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\n\nmodel = Blip2Model.from_pretrained(\"Salesforce/blip2-opt-2.7b\", torch_dtype=torch.float16)\n\nmodel.to(device)  # doctest: +IGNORE_RESULT\n\ntokenizer = AutoTokenizer.from_pretrained(\"Salesforce/blip2-opt-2.7b\")\ninputs = tokenizer([\"a photo of a cat\", \"a photo of a dog\"], padding=True, return_tensors=\"pt\").to(device)\n<line_mask>\n",
            "masked_line": "text_features = model.get_text_features(**inputs)",
            "answer": "get_text_features",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1045"
        },
        {
            "dependency": "transformers",
            "version": "==4.27.0",
            "time": "2023-03-15",
            "description": "This code creates configurations for CLAP model using both text and audio input.",
            "code": "from transformers import ClapConfig, ClapModel\nconfiguration = ClapConfig()\nmodel = ClapModel(configuration)\nconfiguration = model.config\nfrom transformers import ClapTextConfig, ClapAudioConfig\nconfig_text = ClapTextConfig()\nconfig_audio = ClapAudioConfig()\nconfig = ClapConfig.from_text_audio_configs(config_text, config_audio)\n",
            "masked_code": "from transformers import ClapConfig, ClapModel\n<line_mask>\nmodel = ClapModel(configuration)\nconfiguration = model.config\nfrom transformers import ClapTextConfig, ClapAudioConfig\nconfig_text = ClapTextConfig()\nconfig_audio = ClapAudioConfig()\nconfig = ClapConfig.from_text_audio_configs(config_text, config_audio)\n",
            "masked_line": "configuration = ClapConfig()",
            "answer": "ClapConfig",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1046"
        },
        {
            "dependency": "transformers",
            "version": "==4.27.0",
            "time": "2023-03-15",
            "description": "The code extracts text features using a pretrained CLAP model for the given input text data of a cat and a dog.",
            "code": "from transformers import AutoTokenizer, ClapModel\nmodel = ClapModel.from_pretrained(\"laion/clap-htsat-unfused\")\ntokenizer = AutoTokenizer.from_pretrained(\"laion/clap-htsat-unfused\")\ninputs = tokenizer([\"the sound of a cat\", \"the sound of a dog\"], padding=True, return_tensors=\"pt\")\ntext_features = model.get_text_features(**inputs)",
            "masked_code": "from transformers import AutoTokenizer, ClapModel\nmodel = ClapModel.from_pretrained(\"laion/clap-htsat-unfused\")\ntokenizer = AutoTokenizer.from_pretrained(\"laion/clap-htsat-unfused\")\ninputs = tokenizer([\"the sound of a cat\", \"the sound of a dog\"], padding=True, return_tensors=\"pt\")\n<line_mask>",
            "masked_line": "text_features = model.get_text_features(**inputs)",
            "answer": "get_text_features",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1047"
        },
        {
            "dependency": "transformers",
            "version": "==4.27.0",
            "time": "2023-03-15",
            "description": "The code loads a pretrained CLAP model and feature extractor, generates random audio data, extracts audio features from the data using the feature extractor, and then uses the model to get audio features.",
            "code": "from transformers import AutoFeatureExtractor, ClapModel\nimport torch\n\nmodel = ClapModel.from_pretrained(\"laion/clap-htsat-unfused\")\nfeature_extractor = AutoFeatureExtractor.from_pretrained(\"laion/clap-htsat-unfused\")\nrandom_audio = torch.rand((16_000))\ninputs = feature_extractor(random_audio, return_tensors=\"pt\")\naudio_features = model.get_audio_features(**inputs)\n",
            "masked_code": "from transformers import AutoFeatureExtractor, ClapModel\nimport torch\n\nmodel = ClapModel.from_pretrained(\"laion/clap-htsat-unfused\")\nfeature_extractor = AutoFeatureExtractor.from_pretrained(\"laion/clap-htsat-unfused\")\nrandom_audio = torch.rand((16_000))\ninputs = feature_extractor(random_audio, return_tensors=\"pt\")\n<line_mask>\n",
            "masked_line": "audio_features = model.get_audio_features(**inputs)",
            "answer": "get_audio_features",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1048"
        },
        {
            "dependency": "transformers",
            "version": "==4.28.0",
            "time": "2023-04-13",
            "description": "Generate a sequence of text using the GPT-2 model starting from the given input sequence.",
            "code": "from transformers import AutoModelForCausalLM, AutoTokenizer, TextStreamer\n\ntok = AutoTokenizer.from_pretrained(\"gpt2\")\nmodel = AutoModelForCausalLM.from_pretrained(\"gpt2\")\ninputs = tok([\"An increasing sequence: one,\"], return_tensors=\"pt\")\nstreamer = TextStreamer(tok)\n\n_ = model.generate(**inputs, streamer=streamer, max_new_tokens=20)\n",
            "masked_code": "from transformers import AutoModelForCausalLM, AutoTokenizer, TextStreamer\n\ntok = AutoTokenizer.from_pretrained(\"gpt2\")\nmodel = AutoModelForCausalLM.from_pretrained(\"gpt2\")\ninputs = tok([\"An increasing sequence: one,\"], return_tensors=\"pt\")\n<line_mask>\n\n_ = model.generate(**inputs, streamer=streamer, max_new_tokens=20)\n",
            "masked_line": "streamer = TextStreamer(tok)",
            "answer": "TextStreamer",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1049"
        },
        {
            "dependency": "transformers",
            "version": "==4.29.0",
            "time": "2023-05-10",
            "description": "The code initializes a SamConfig and a SamModel with the configuration set to \"facebook/sam-vit-huge\". It also allows for initializing a SamConfig from separate SamVisionConfig, SamPromptEncoderConfig, and SamMaskDecoderConfig configurations.",
            "code": "from transformers import (\n    SamVisionConfig,\n    SamPromptEncoderConfig,\n    SamMaskDecoderConfig,\n    SamModel,\n)\n\n# Initializing a SamConfig with `\"facebook/sam-vit-huge\"` style configuration\nconfiguration = SamConfig()\n\n# Initializing a SamModel (with random weights) from the `\"facebook/sam-vit-huge\"` style configuration\nmodel = SamModel(configuration)\n\n# Accessing the model configuration\nconfiguration = model.config\n\n# We can also initialize a SamConfig from a SamVisionConfig, SamPromptEncoderConfig, and SamMaskDecoderConfig\n\n# Initializing SAM vision, SAM Q-Former and language model configurations\nvision_config = SamVisionConfig()\nprompt_encoder_config = SamPromptEncoderConfig()\nmask_decoder_config = SamMaskDecoderConfig()\n\nconfig = SamConfig(vision_config, prompt_encoder_config, mask_decoder_config)\n",
            "masked_code": "from transformers import (\n    SamVisionConfig,\n    SamPromptEncoderConfig,\n    SamMaskDecoderConfig,\n    SamModel,\n)\n\n# Initializing a SamConfig with `\"facebook/sam-vit-huge\"` style configuration\nconfiguration = SamConfig()\n\n# Initializing a SamModel (with random weights) from the `\"facebook/sam-vit-huge\"` style configuration\nmodel = SamModel(configuration)\n\n# Accessing the model configuration\nconfiguration = model.config\n\n# We can also initialize a SamConfig from a SamVisionConfig, SamPromptEncoderConfig, and SamMaskDecoderConfig\n\n# Initializing SAM vision, SAM Q-Former and language model configurations\nvision_config = SamVisionConfig()\nprompt_encoder_config = SamPromptEncoderConfig()\nmask_decoder_config = SamMaskDecoderConfig()\n\n<line_mask>\n",
            "masked_line": "config = SamConfig(vision_config, prompt_encoder_config, mask_decoder_config)",
            "answer": "SamConfig",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1050"
        },
        {
            "dependency": "transformers",
            "version": "==4.30.0",
            "time": "2023-06-08",
            "description": "This code defines a task that involves training a transformer model using the Hugging Face library. It initializes a trainer with specified parameters and callbacks, and then trains the model using the provided trainer configuration. The training process may resume from a checkpoint if one is available.",
            "code": "from flytekit import current_context, task\n\n\n@task\ndef train_hf_transformer():\n    cp = current_context().checkpoint\n    trainer = Trainer(..., callbacks=[FlyteCallback()])\n    output = trainer.train(resume_from_checkpoint=cp.restore())\n",
            "masked_code": "from flytekit import current_context, task\n\n\n@task\ndef train_hf_transformer():\n    cp = current_context().checkpoint\n    <line_mask>\n    output = trainer.train(resume_from_checkpoint=cp.restore())\n",
            "masked_line": "trainer = Trainer(..., callbacks=[FlyteCallback()])",
            "answer": "FlyteCallback",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1051"
        },
        {
            "dependency": "transformers",
            "version": "==4.30.0",
            "time": "2023-06-08",
            "description": "The code initializes a local agent with a pretrained AutoModelForCausalLM model and AutoTokenizer for generating text based on the input prompt \"Draw me a picture of rivers and lakes.\"",
            "code": "import torch\nfrom transformers import AutoModelForCausalLM, AutoTokenizer, LocalAgent\n\ncheckpoint = \"bigcode/starcoder\"\nmodel = AutoModelForCausalLM.from_pretrained(checkpoint, device_map=\"auto\", torch_dtype=torch.bfloat16)\ntokenizer = AutoTokenizer.from_pretrained(checkpoint)\n\nagent = LocalAgent(model, tokenizer)\nagent.run(\"Draw me a picture of rivers and lakes.\")",
            "masked_code": "import torch\nfrom transformers import AutoModelForCausalLM, AutoTokenizer, LocalAgent\n\ncheckpoint = \"bigcode/starcoder\"\nmodel = AutoModelForCausalLM.from_pretrained(checkpoint, device_map=\"auto\", torch_dtype=torch.bfloat16)\ntokenizer = AutoTokenizer.from_pretrained(checkpoint)\n\n<line_mask>\nagent.run(\"Draw me a picture of rivers and lakes.\")",
            "masked_line": "agent = LocalAgent(model, tokenizer)",
            "answer": "LocalAgent",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1052"
        },
        {
            "dependency": "transformers",
            "version": "==4.30.0",
            "time": "2023-06-08",
            "description": "This code loads a pre-trained model and processor for Wav2Vec2 that uses CTC (Connectionist Temporal Classification) for speech-to-text conversion. It then sets the target language to Spanish and loads a pre-trained adapter for Spanish language.",
            "code": "from transformers import Wav2Vec2ForCTC, AutoProcessor\nckpt = \"facebook/mms-1b-all\"\nprocessor = AutoProcessor.from_pretrained(ckpt)\nmodel = Wav2Vec2ForCTC.from_pretrained(ckpt, target_lang=\"eng\")\nprocessor.tokenizer.set_target_lang(\"spa\")\nmodel.load_adapter(\"spa\")\n",
            "masked_code": "from transformers import Wav2Vec2ForCTC, AutoProcessor\nckpt = \"facebook/mms-1b-all\"\nprocessor = AutoProcessor.from_pretrained(ckpt)\nmodel = Wav2Vec2ForCTC.from_pretrained(ckpt, target_lang=\"eng\")\nprocessor.tokenizer.set_target_lang(\"spa\")\n<line_mask>\n",
            "masked_line": "model.load_adapter(\"spa\")",
            "answer": "load_adapter",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1053"
        },
        {
            "dependency": "transformers",
            "version": "==4.31.0",
            "time": "2023-07-18",
            "description": "This code uses a pretrained model to generate audio from a given input text with a specified voice preset. The audio is then converted into an array and the code extracts the audio data as a numpy array.",
            "code": "from transformers import AutoProcessor, BarkModel\nprocessor = AutoProcessor.from_pretrained(\"ylacombe/bark-small\")\nmodel = BarkModel.from_pretrained(\"ylacombe/bark-small\")\nvoice_preset = \"v2/en_speaker_6\"\ninputs = processor(\"Hello, my dog is cute, I need him in my life\", voice_preset=voice_preset)\naudio_array = model.generate(**inputs, semantic_max_new_tokens=100)\naudio_array = audio_array.cpu().numpy().squeeze()\n",
            "masked_code": "from transformers import AutoProcessor, BarkModel\nprocessor = AutoProcessor.from_pretrained(\"ylacombe/bark-small\")\nmodel = BarkModel.from_pretrained(\"ylacombe/bark-small\")\nvoice_preset = \"v2/en_speaker_6\"\ninputs = processor(\"Hello, my dog is cute, I need him in my life\", voice_preset=voice_preset)\n<line_mask>\naudio_array = audio_array.cpu().numpy().squeeze()\n",
            "masked_line": "audio_array = model.generate(**inputs, semantic_max_new_tokens=100)",
            "answer": "generate",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1054"
        },
        {
            "dependency": "transformers",
            "version": "==4.35.0",
            "time": "2023-11-02",
            "description": "The code processes input text data using a pretrained Owlv2Model to generate text features.",
            "code": "from transformers import AutoProcessor, Owlv2Model\n\nmodel = Owlv2Model.from_pretrained(\"google/owlv2-base-patch16-ensemble\")\nprocessor = AutoProcessor.from_pretrained(\"google/owlv2-base-patch16-ensemble\")\ninputs = processor(\n    text=[[\"a photo of a cat\", \"a photo of a dog\"], [\"photo of a astranaut\"]], return_tensors=\"pt\"\n)\ntext_features = model.get_text_features(**inputs)\n",
            "masked_code": "from transformers import AutoProcessor, Owlv2Model\n\nmodel = Owlv2Model.from_pretrained(\"google/owlv2-base-patch16-ensemble\")\nprocessor = AutoProcessor.from_pretrained(\"google/owlv2-base-patch16-ensemble\")\ninputs = processor(\n    text=[[\"a photo of a cat\", \"a photo of a dog\"], [\"photo of a astranaut\"]], return_tensors=\"pt\"\n)\n<line_mask>\n",
            "masked_line": "text_features = model.get_text_features(**inputs)",
            "answer": "get_text_features",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1055"
        },
        {
            "dependency": "transformers",
            "version": "==4.35.0",
            "time": "2023-11-02",
            "description": "The code loads a pre-trained Owlv2 model from Google and a corresponding processor, then opens an image from a URL, processes the image using the processor, and extracts image features using the Owlv2 model.",
            "code": "from PIL import Image\nimport requests\nfrom transformers import AutoProcessor, Owlv2Model\n\nmodel = Owlv2Model.from_pretrained(\"google/owlv2-base-patch16-ensemble\")\nprocessor = AutoProcessor.from_pretrained(\"google/owlv2-base-patch16-ensemble\")\nurl = \"http://images.cocodataset.org/val2017/000000039769.jpg\"\nimage = Image.open(requests.get(url, stream=True).raw)\ninputs = processor(images=image, return_tensors=\"pt\")\nimage_features = model.get_image_features(**inputs)\n",
            "masked_code": "from PIL import Image\nimport requests\nfrom transformers import AutoProcessor, Owlv2Model\n\nmodel = Owlv2Model.from_pretrained(\"google/owlv2-base-patch16-ensemble\")\nprocessor = AutoProcessor.from_pretrained(\"google/owlv2-base-patch16-ensemble\")\nurl = \"http://images.cocodataset.org/val2017/000000039769.jpg\"\nimage = Image.open(requests.get(url, stream=True).raw)\ninputs = processor(images=image, return_tensors=\"pt\")\n<line_mask>\n",
            "masked_line": "image_features = model.get_image_features(**inputs)",
            "answer": "get_image_features",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1056"
        },
        {
            "dependency": "transformers",
            "version": "==4.36.0",
            "time": "2023-12-11",
            "description": "The code initializes various configurations and models for Conditional Language Generation using the CLVP (Conditional Language Generation via Phonetics) architecture. The code demonstrates initializing configurations for text, speech, and decoder components, and combining them into a unified configuration.",
            "code": "from transformers import ClvpConfig, ClvpModelForConditionalGeneration\n\n# Initializing a ClvpConfig with susnato/clvp_dev style configuration\nconfiguration = ClvpConfig()\n\n# Initializing a ClvpModelForConditionalGeneration (with random weights) from the susnato/clvp_dev style configuration\nmodel = ClvpModelForConditionalGeneration(configuration)\n\n# Accessing the model configuration\nconfiguration = model.config\n\n# We can also initialize a CLVPConfig from a CLVPTextConfig, CLVPSpeechConfig and a CLVPAutoRegressiveConfig\nfrom transformers import ClvpEncoderConfig, ClvpDecoderConfig\n\n# Initializing a CLVP text, CLVP speech and CLVP decoder configuration\nconfig_text = ClvpEncoderConfig()\nconfig_speech = ClvpEncoderConfig()\ndecoder_config = ClvpDecoderConfig()\n\nconfig = ClvpConfig.from_sub_model_configs(config_text, config_speech, decoder_config)\n",
            "masked_code": "from transformers import ClvpConfig, ClvpModelForConditionalGeneration\n\n# Initializing a ClvpConfig with susnato/clvp_dev style configuration\n<line_mask>\n\n# Initializing a ClvpModelForConditionalGeneration (with random weights) from the susnato/clvp_dev style configuration\nmodel = ClvpModelForConditionalGeneration(configuration)\n\n# Accessing the model configuration\nconfiguration = model.config\n\n# We can also initialize a CLVPConfig from a CLVPTextConfig, CLVPSpeechConfig and a CLVPAutoRegressiveConfig\nfrom transformers import ClvpEncoderConfig, ClvpDecoderConfig\n\n# Initializing a CLVP text, CLVP speech and CLVP decoder configuration\nconfig_text = ClvpEncoderConfig()\nconfig_speech = ClvpEncoderConfig()\ndecoder_config = ClvpDecoderConfig()\n\nconfig = ClvpConfig.from_sub_model_configs(config_text, config_speech, decoder_config)\n",
            "masked_line": "configuration = ClvpConfig()",
            "answer": "ClvpConfig",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1057"
        },
        {
            "dependency": "transformers",
            "version": "==4.36.0",
            "time": "2023-12-11",
            "description": "The code defines a text data, initializes a CLVP processor and a CLVP model for conditional generation, generates processor output, and retrieves text embeddings using the model.",
            "code": "from transformers import ClvpProcessor, ClvpModelForConditionalGeneration\n\n# Define the Text\ntext = \"This is an example text.\"\n\n# Define processor and model\nprocessor = ClvpProcessor.from_pretrained(\"susnato/clvp_dev\")\nmodel = ClvpModelForConditionalGeneration.from_pretrained(\"susnato/clvp_dev\")\n\n# Generate processor output and text embeds\nprocessor_output = processor(text=text, return_tensors=\"pt\")\ntext_embeds = model.get_text_features(input_ids=processor_output[\"input_ids\"])\n",
            "masked_code": "from transformers import ClvpProcessor, ClvpModelForConditionalGeneration\n\n# Define the Text\ntext = \"This is an example text.\"\n\n# Define processor and model\nprocessor = ClvpProcessor.from_pretrained(\"susnato/clvp_dev\")\nmodel = ClvpModelForConditionalGeneration.from_pretrained(\"susnato/clvp_dev\")\n\n# Generate processor output and text embeds\nprocessor_output = processor(text=text, return_tensors=\"pt\")\n<line_mask>\n",
            "masked_line": "text_embeds = model.get_text_features(input_ids=processor_output[\"input_ids\"])",
            "answer": "get_text_features",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1058"
        },
        {
            "dependency": "transformers",
            "version": "==4.36.0",
            "time": "2023-12-11",
            "description": "The code initializes a ClvpTokenizer object and then uses it to tokenize the input text \"Hello world\" and \" Hello world\", returning the input ids as lists of integers.",
            "code": "from transformers import ClvpTokenizer\n\ntokenizer = ClvpTokenizer.from_pretrained(\"susnato/clvp_dev\")\ntokenizer(\"Hello world\")[\"input_ids\"]\n[62, 84, 28, 2, 179, 79]\n\ntokenizer(\" Hello world\")[\"input_ids\"]\n[2, 62, 84, 28, 2, 179, 79]\n",
            "masked_code": "from transformers import ClvpTokenizer\n\n<line_mask>\ntokenizer(\"Hello world\")[\"input_ids\"]\n[62, 84, 28, 2, 179, 79]\n\ntokenizer(\" Hello world\")[\"input_ids\"]\n[2, 62, 84, 28, 2, 179, 79]\n",
            "masked_line": "tokenizer = ClvpTokenizer.from_pretrained(\"susnato/clvp_dev\")",
            "answer": "ClvpTokenizer",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1059"
        },
        {
            "dependency": "transformers",
            "version": "==4.36.0",
            "time": "2023-12-11",
            "description": "This code initializes a model configuration with separate configurations for vision and text components using CLIPVisionConfig and LlamaConfig respectively, and then creates a Llava model for conditional generation based on the combined configuration. Finally, it retrieves the configuration from the created model.",
            "code": "from transformers import LlavaForConditionalGeneration, LlavaConfig, CLIPVisionConfig, LlamaConfig\nvision_config = CLIPVisionConfig()\ntext_config = LlamaConfig()\nconfiguration = LlavaConfig(vision_config, text_config)\nmodel = LlavaForConditionalGeneration(configuration)\nconfiguration = model.config\n",
            "masked_code": "<line_mask>\nvision_config = CLIPVisionConfig()\ntext_config = LlamaConfig()\nconfiguration = LlavaConfig(vision_config, text_config)\nmodel = LlavaForConditionalGeneration(configuration)\nconfiguration = model.config\n",
            "masked_line": "from transformers import LlavaForConditionalGeneration, LlavaConfig, CLIPVisionConfig, LlamaConfig",
            "answer": "LlavaConfig",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1060"
        },
        {
            "dependency": "transformers",
            "version": "==4.37.0",
            "time": "2024-01-22",
            "description": "This code initializes a FastSpeech2Conformer model with a HifiGan vocoder and accesses the configuration of the model.",
            "code": "from transformers import (\n    FastSpeech2ConformerConfig,\n    FastSpeech2ConformerHifiGanConfig,\n    FastSpeech2ConformerWithHifiGanConfig,\n    FastSpeech2ConformerWithHifiGan,\n)\n\n# Initializing FastSpeech2ConformerWithHifiGan sub-modules configurations.\nmodel_config = FastSpeech2ConformerConfig()\nvocoder_config = FastSpeech2ConformerHifiGanConfig()\n\n# Initializing a FastSpeech2ConformerWithHifiGan module style configuration\nconfiguration = FastSpeech2ConformerWithHifiGanConfig(model_config.to_dict(), vocoder_config.to_dict())\n\n# Initializing a model (with random weights)\nmodel = FastSpeech2ConformerWithHifiGan(configuration)\n\n# Accessing the model configuration\nconfiguration = model.config\n",
            "masked_code": "from transformers import (\n    FastSpeech2ConformerConfig,\n    FastSpeech2ConformerHifiGanConfig,\n    <line_mask>\n    FastSpeech2ConformerWithHifiGan,\n)\n\n# Initializing FastSpeech2ConformerWithHifiGan sub-modules configurations.\nmodel_config = FastSpeech2ConformerConfig()\nvocoder_config = FastSpeech2ConformerHifiGanConfig()\n\n# Initializing a FastSpeech2ConformerWithHifiGan module style configuration\nconfiguration = FastSpeech2ConformerWithHifiGanConfig(model_config.to_dict(), vocoder_config.to_dict())\n\n# Initializing a model (with random weights)\nmodel = FastSpeech2ConformerWithHifiGan(configuration)\n\n# Accessing the model configuration\nconfiguration = model.config\n",
            "masked_line": "FastSpeech2ConformerWithHifiGanConfig,",
            "answer": "FastSpeech2ConformerWithHifiGanConfig",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1061"
        },
        {
            "dependency": "transformers",
            "version": "==4.37.0",
            "time": "2024-01-22",
            "description": "This code snippet creates a Qwen2Tokenizer object from the pretrained \"Qwen/Qwen-tokenizer\" model and then uses it to tokenize the input text \"Hello world\" and \" Hello world\", returning the input ids for each tokenized text.",
            "code": "from transformers import Qwen2Tokenizer\n\ntokenizer = Qwen2Tokenizer.from_pretrained(\"Qwen/Qwen-tokenizer\")\ntokenizer(\"Hello world\")[\"input_ids\"]\n[9707, 1879]\n\ntokenizer(\" Hello world\")[\"input_ids\"]\n[21927, 1879]\n",
            "masked_code": "from transformers import Qwen2Tokenizer\n\n<line_mask>\ntokenizer(\"Hello world\")[\"input_ids\"]\n[9707, 1879]\n\ntokenizer(\" Hello world\")[\"input_ids\"]\n[21927, 1879]\n",
            "masked_line": "tokenizer = Qwen2Tokenizer.from_pretrained(\"Qwen/Qwen-tokenizer\")",
            "answer": "Qwen2Tokenizer",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1062"
        },
        {
            "dependency": "transformers",
            "version": "==4.37.0",
            "time": "2024-01-22",
            "description": "The code uses a tokenizer from the Qwen2TokenizerFast class to convert input text into tokenized input_ids for \"Hello world\" and \" Hello world\".",
            "code": "from transformers import Qwen2TokenizerFast\n\ntokenizer = Qwen2TokenizerFast.from_pretrained(\"Qwen/Qwen-tokenizer\")\ntokenizer(\"Hello world\")[\"input_ids\"]\n[9707, 1879]\n\ntokenizer(\" Hello world\")[\"input_ids\"]\n[21927, 1879]\n",
            "masked_code": "from transformers import Qwen2TokenizerFast\n\n<line_mask>\ntokenizer(\"Hello world\")[\"input_ids\"]\n[9707, 1879]\n\ntokenizer(\" Hello world\")[\"input_ids\"]\n[21927, 1879]\n",
            "masked_line": "tokenizer = Qwen2TokenizerFast.from_pretrained(\"Qwen/Qwen-tokenizer\")",
            "answer": "Qwen2TokenizerFast",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1063"
        },
        {
            "dependency": "transformers",
            "version": "==4.37.0",
            "time": "2024-01-22",
            "description": "The code initializes a SiglipConfig object with a google/siglip-base-patch16-224 style configuration, followed by initializing a SiglipModel object with random weights based on the previously defined configuration. It then accesses the configuration of the model. Additionally, the code demonstrates initializing a SiglipConfig object from separate SiglipTextConfig and SiglipVisionConfig objects.",
            "code": "from transformers import SiglipConfig, SiglipModel\n\n# Initializing a SiglipConfig with google/siglip-base-patch16-224 style configuration\nconfiguration = SiglipConfig()\n\n# Initializing a SiglipModel (with random weights) from the google/siglip-base-patch16-224 style configuration\nmodel = SiglipModel(configuration)\n\n# Accessing the model configuration\nconfiguration = model.config\n\n# We can also initialize a SiglipConfig from a SiglipTextConfig and a SiglipVisionConfig\nfrom transformers import SiglipTextConfig, SiglipVisionConfig\n\n# Initializing a SiglipText and SiglipVision configuration\nconfig_text = SiglipTextConfig()\nconfig_vision = SiglipVisionConfig()\n\nconfig = SiglipConfig.from_text_vision_configs(config_text, config_vision)\n",
            "masked_code": "from transformers import SiglipConfig, SiglipModel\n\n# Initializing a SiglipConfig with google/siglip-base-patch16-224 style configuration\n<line_mask>\n\n# Initializing a SiglipModel (with random weights) from the google/siglip-base-patch16-224 style configuration\nmodel = SiglipModel(configuration)\n\n# Accessing the model configuration\nconfiguration = model.config\n\n# We can also initialize a SiglipConfig from a SiglipTextConfig and a SiglipVisionConfig\nfrom transformers import SiglipTextConfig, SiglipVisionConfig\n\n# Initializing a SiglipText and SiglipVision configuration\nconfig_text = SiglipTextConfig()\nconfig_vision = SiglipVisionConfig()\n\nconfig = SiglipConfig.from_text_vision_configs(config_text, config_vision)\n",
            "masked_line": "configuration = SiglipConfig()",
            "answer": "SiglipConfig",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1064"
        },
        {
            "dependency": "transformers",
            "version": "==4.8.0",
            "time": "2021-06-23",
            "description": "The code snippet encodes the input text using the FlaxBart model to generate encoder outputs.",
            "code": "from transformers import BartTokenizer, FlaxBartForConditionalGeneration\nmodel = FlaxBartForConditionalGeneration.from_pretrained('facebook/bart-large-cnn')\ntokenizer = BartTokenizer.from_pretrained('facebook/bart-large-cnn')\ntext = \"My friends are cool but they eat too many carbs.\"\ninputs = tokenizer(text, max_length=1024, return_tensors='jax')\nencoder_outputs = model.encode(**inputs)",
            "masked_code": "from transformers import BartTokenizer, FlaxBartForConditionalGeneration\nmodel = FlaxBartForConditionalGeneration.from_pretrained('facebook/bart-large-cnn')\ntokenizer = BartTokenizer.from_pretrained('facebook/bart-large-cnn')\ntext = \"My friends are cool but they eat too many carbs.\"\ninputs = tokenizer(text, max_length=1024, return_tensors='jax')\n<line_mask>",
            "masked_line": "encoder_outputs = model.encode(**inputs)",
            "answer": "encode",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1065"
        },
        {
            "dependency": "transformers",
            "version": "==4.8.0",
            "time": "2021-06-23",
            "description": "The code initializes a FlaxBart model for conditional generation and a tokenizer for the model. It encodes the input text using the tokenizer and the model, then decodes the input to generate an output. Lastly, it retrieves the last hidden states of the decoder.",
            "code": "model = FlaxBartForConditionalGeneration.from_pretrained('facebook/bart-large-cnn')\ntokenizer = BartTokenizer.from_pretrained('facebook/bart-large-cnn')\ntext = \"My friends are cool but they eat too many carbs.\"\ninputs = tokenizer(text, max_length=1024, return_tensors='jax')\nencoder_outputs = model.encode(**inputs)\ndecoder_start_token_id = model.config.decoder_start_token_id\ndecoder_input_ids = jnp.ones((inputs.input_ids.shape[0], 1), dtype=\"i4\") * decoder_start_token_id\noutputs = model.decode(decoder_input_ids, encoder_outputs)\nlast_decoder_hidden_states = outputs.last_hidden_state",
            "masked_code": "model = FlaxBartForConditionalGeneration.from_pretrained('facebook/bart-large-cnn')\ntokenizer = BartTokenizer.from_pretrained('facebook/bart-large-cnn')\ntext = \"My friends are cool but they eat too many carbs.\"\ninputs = tokenizer(text, max_length=1024, return_tensors='jax')\nencoder_outputs = model.encode(**inputs)\ndecoder_start_token_id = model.config.decoder_start_token_id\ndecoder_input_ids = jnp.ones((inputs.input_ids.shape[0], 1), dtype=\"i4\") * decoder_start_token_id\n<line_mask>\nlast_decoder_hidden_states = outputs.last_hidden_state",
            "masked_line": "outputs = model.decode(decoder_input_ids, encoder_outputs)",
            "answer": "decode",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1066"
        },
        {
            "dependency": "transformers",
            "version": "==4.9.0",
            "time": "2021-07-22",
            "description": "The code defines configurations for a hybrid model that combines text and vision inputs. It then initializes an encoder-decoder model using these configurations, saves the model to a file named 'my-model', and reloads the model using the saved configuration.",
            "code": "from transformers import BertConfig, CLIPConfig, HybridCLIPConfig, FlaxHybridCLIP\n\nconfig_text = BertConfig()\nconfig_vision = CLIPConfig()\n\nconfig = HybridCLIPConfig.from_text_vision_configs(config_text, config_vision, projection_dim=512)\n\nmodel = EncoderDecoderModel(config=config)\n\nconfig_text = model.config.text_config\nconfig_vision = model.config.vision_config\n\nmodel.save_pretrained('my-model')\n\nencoder_decoder_config = HybridCLIPConfig.from_pretrained('my-model')\nmodel = FlaxHybridCLIP.from_pretrained('my-model', config=encoder_decoder_config)\n",
            "masked_code": "from transformers import BertConfig, CLIPConfig, HybridCLIPConfig, FlaxHybridCLIP\n\nconfig_text = BertConfig()\nconfig_vision = CLIPConfig()\n\n<line_mask>\n\nmodel = EncoderDecoderModel(config=config)\n\nconfig_text = model.config.text_config\nconfig_vision = model.config.vision_config\n\nmodel.save_pretrained('my-model')\n\nencoder_decoder_config = HybridCLIPConfig.from_pretrained('my-model')\nmodel = FlaxHybridCLIP.from_pretrained('my-model', config=encoder_decoder_config)\n",
            "masked_line": "config = HybridCLIPConfig.from_text_vision_configs(config_text, config_vision, projection_dim=512)",
            "answer": "HybridCLIPConfig",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1067"
        },
        {
            "dependency": "transformers",
            "version": "==4.9.0",
            "time": "2021-07-22",
            "description": "This code segment encodes a given text input using a pre-trained FlaxMarianMTModel model that translates English to German.",
            "code": "from transformers import MarianTokenizer, FlaxMarianMTModel\ntokenizer = MarianTokenizer.from_pretrained('facebook/marian-large-cnn')\nmodel = FlaxMarianMTModel.from_pretrained('Helsinki-NLP/opus-mt-en-de')\ntext = \"My friends are cool but they eat too many carbs.\"\ninputs = tokenizer(text, max_length=64, return_tensors='jax')\nencoder_outputs = model.encode(**inputs)",
            "masked_code": "from transformers import MarianTokenizer, FlaxMarianMTModel\ntokenizer = MarianTokenizer.from_pretrained('facebook/marian-large-cnn')\nmodel = FlaxMarianMTModel.from_pretrained('Helsinki-NLP/opus-mt-en-de')\ntext = \"My friends are cool but they eat too many carbs.\"\ninputs = tokenizer(text, max_length=64, return_tensors='jax')\n<line_mask>",
            "masked_line": "encoder_outputs = model.encode(**inputs)",
            "answer": "encode",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1068"
        },
        {
            "dependency": "urllib3",
            "version": "==1.9",
            "time": "2014-07-07",
            "description": "The code establishes an HTTP connection to 'http://example.com' with different retry settings for each request. The first request has custom retry settings, the second request has increased retries, and the third request has retries set to False.",
            "code": "retries = Retry(connect=5, read=2, redirect=5)\nhttp = PoolManager(retries=retries)\nresponse = http.request('GET', 'http://example.com/')\n\nresponse = http.request('GET', 'http://example.com/', retries=Retry(10))\n\nresponse = http.request('GET', 'http://example.com/', retries=False)\n",
            "masked_code": "retries = Retry(connect=5, read=2, redirect=5)\nhttp = PoolManager(retries=retries)\nresponse = http.request('GET', 'http://example.com/')\n\n<line_mask>\n\nresponse = http.request('GET', 'http://example.com/', retries=False)\n",
            "masked_line": "response = http.request('GET', 'http://example.com/', retries=Retry(10))",
            "answer": "Retry",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1069"
        },
        {
            "dependency": "wandb",
            "version": "==0.11.0",
            "time": "2021-07-15",
            "description": "The given code defines a function called coerce_odd that takes a value as input and checks if the value is odd. If the value is odd, the function returns the value, otherwise it returns None. It also creates a scalar type named 'Odd' in a GraphQL schema with the serialization function set to coerce_odd.",
            "code": "def coerce_odd(value):\n    if value % 2 == 1:\n        return value\n    return None\n\nOddType = GraphQLScalarType(name='Odd', serialize=coerce_odd)",
            "masked_code": "def coerce_odd(value):\n    if value % 2 == 1:\n        return value\n    return None\n\n<line_mask>",
            "masked_line": "OddType = GraphQLScalarType(name='Odd', serialize=coerce_odd)",
            "answer": "GraphQLScalarType",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1070"
        },
        {
            "dependency": "wandb",
            "version": "==0.11.0",
            "time": "2021-07-15",
            "description": "This Python code defines a GraphQL union type called PetType with two types: DogType and CatType. It includes a method resolve_type that determines the appropriate type based on the input value, returning either DogType or CatType.",
            "code": "class PetType(GraphQLUnionType):\n    name = 'Pet'\n    types = [DogType, CatType]\n\n    def resolve_type(self, value):\n        if isinstance(value, Dog):\n            return DogType()\n        if isinstance(value, Cat):\n            return CatType()",
            "masked_code": "<line_mask>\n    name = 'Pet'\n    types = [DogType, CatType]\n\n    def resolve_type(self, value):\n        if isinstance(value, Dog):\n            return DogType()\n        if isinstance(value, Cat):\n            return CatType()",
            "masked_line": "class PetType(GraphQLUnionType):",
            "answer": "GraphQLUnionType",
            "type": "delete",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1071"
        },
        {
            "dependency": "wandb",
            "version": "==0.11.2",
            "time": "2021-08-02",
            "description": "The code defines a function coerce_odd() that takes a value as input and checks if the value is odd. If the value is odd, it returns the value. Otherwise, it returns None. Additionally, it creates a GraphQLScalarType named 'Odd' with the serialize function set to coerce_odd.",
            "code": "def coerce_odd(value):\n    if value % 2 == 1:\n        return value\n    return None\n\nOddType = GraphQLScalarType(name='Odd', serialize=coerce_odd)",
            "masked_code": "def coerce_odd(value):\n    if value % 2 == 1:\n        return value\n    return None\n\n<line_mask>",
            "masked_line": "OddType = GraphQLScalarType(name='Odd', serialize=coerce_odd)",
            "answer": "GraphQLScalarType",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1072"
        },
        {
            "dependency": "wandb",
            "version": "==0.12.12",
            "time": "2022-04-05",
            "description": "This code segment initializes WandB for tracking experiment metrics and adds WandB visualizations to the ML pipeline UI metadata.",
            "code": "import wandb\nfrom wandb.integration.kfp.helpers import add_wandb_visualization\n\nwith wandb.init() as run:\n    add_wandb_visualization(run, mlpipeline_ui_metadata_path)\n\n    ... # the rest of your code here",
            "masked_code": "import wandb\n<line_mask>\n\nwith wandb.init() as run:\n    add_wandb_visualization(run, mlpipeline_ui_metadata_path)\n\n    ... # the rest of your code here",
            "masked_line": "from wandb.integration.kfp.helpers import add_wandb_visualization",
            "answer": "add_wandb_visualization",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1073"
        },
        {
            "dependency": "wandb",
            "version": "==0.12.3",
            "time": "2021-09-30",
            "description": "The code profiles the training process using PyTorch profiler and records the shapes of tensors, along with stack information. It runs profiling for a specified number of wait, warmup, and active iterations, then repeats the profiling process. The code also uses Weights & Biases profiling tool to handle tracing.",
            "code": "with torch.profiler.profile(\n    schedule=torch.profiler.schedule(wait=1, warmup=1, active=3, repeat=1),\n    on_trace_ready=wandb.profiler.torch_trace_handler(),\n    record_shapes=True,\n    with_stack=True,\n) as prof:\n    for i, batch in enumerate(dataloader):\n        if step >= 5:\n            break\n        train(batch)\n        prof.step()\n",
            "masked_code": "with torch.profiler.profile(\n    schedule=torch.profiler.schedule(wait=1, warmup=1, active=3, repeat=1),\n    <line_mask>\n    record_shapes=True,\n    with_stack=True,\n) as prof:\n    for i, batch in enumerate(dataloader):\n        if step >= 5:\n            break\n        train(batch)\n        prof.step()\n",
            "masked_line": "on_trace_ready=wandb.profiler.torch_trace_handler(),",
            "answer": "torch_trace_handler",
            "type": "add",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1074"
        },
        {
            "dependency": "librosa",
            "version": "==0.6.2",
            "time": "2018-08-09",
            "description": "Calculate the root mean square energy of the audio signal y.",
            "code": "y, sr = librosa.load(librosa.util.example_audio_file())\nlibrosa.feature.rmse(y=y)\n\nS, phase = librosa.magphase(librosa.stft(y))\nrms = librosa.feature.rmse(S=S)\n\nS = librosa.magphase(librosa.stft(y, window=np.ones, center=False))[0]\nlibrosa.feature.rmse(S=S)",
            "masked_code": "y, sr = librosa.load(librosa.util.example_audio_file())\nlibrosa.feature.rmse(y=y)\n\nS, phase = librosa.magphase(librosa.stft(y))\n<line_mask>\n\nS = librosa.magphase(librosa.stft(y, window=np.ones, center=False))[0]\nlibrosa.feature.rmse(S=S)",
            "masked_line": "rms = librosa.feature.rmse(S=S)",
            "answer": "rmse",
            "type": "name_change_old",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1075"
        },
        {
            "dependency": "MarkupSafe",
            "version": "==2.0.0",
            "time": "2021-05-11",
            "description": "The code is escaping special characters in a given string to their corresponding HTML entities.",
            "code": "value = escape(\"<User 1>\")\nvalue\nMarkup('&lt;User 1&gt;')\nescape(str(value))\nMarkup('&amp;lt;User 1&amp;gt;')\nescape(soft_str(value))\nMarkup('&lt;User 1&gt;')",
            "masked_code": "value = escape(\"<User 1>\")\nvalue\nMarkup('&lt;User 1&gt;')\nescape(str(value))\nMarkup('&amp;lt;User 1&amp;gt;')\n<line_mask>\nMarkup('&lt;User 1&gt;')",
            "masked_line": "escape(soft_str(value))",
            "answer": "soft_str",
            "type": "name_change_new",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1076"
        },
        {
            "dependency": "MarkupSafe",
            "version": "==1.1.1",
            "time": "2019-02-23",
            "description": "The code is escaping special characters in a given string to their corresponding HTML entities.",
            "code": "value = escape('<User 1>')\nvalue\nMarkup('&lt;User 1&gt;')\nescape(str(value))\nMarkup('&amp;lt;User 1&amp;gt;')\nescape(soft_unicode(value))\nMarkup('&lt;User 1&gt;')",
            "masked_code": "value = escape('<User 1>')\nvalue\nMarkup('&lt;User 1&gt;')\nescape(str(value))\nMarkup('&amp;lt;User 1&amp;gt;')\n<line_mask>\nMarkup('&lt;User 1&gt;')",
            "masked_line": "escape(soft_unicode(value))",
            "answer": "soft_unicode",
            "type": "name_change_old",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1077"
        },
        {
            "dependency": "paddlepaddle-gpu",
            "version": "==2.6.0",
            "time": "2023-12-21",
            "description": "The code creates a dataset object using the PaddlePaddle framework and sets the variables 'data' and 'label' for the dataset.",
            "code": "import paddle.base as base\npaddle.enable_static()\ndataset = base.DatasetFactory().create_dataset()\ndata = paddle.static.data(name=\"data\", shape=[None, 10, 10], dtype=\"int64\")\nlabel = paddle.static.data(name=\"label\", shape=[None, 1], dtype=\"int64\", lod_level=1)\ndataset.set_use_var([data, label])",
            "masked_code": "import paddle.base as base\npaddle.enable_static()\ndataset = base.DatasetFactory().create_dataset()\ndata = paddle.static.data(name=\"data\", shape=[None, 10, 10], dtype=\"int64\")\nlabel = paddle.static.data(name=\"label\", shape=[None, 1], dtype=\"int64\", lod_level=1)\n<line_mask>",
            "masked_line": "dataset.set_use_var([data, label])",
            "answer": "set_use_var",
            "type": "name_change_new",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1078"
        },
        {
            "dependency": "pandas",
            "version": "==0.24.0",
            "time": "2019-01-25",
            "description": "The code creates an index object based on the input provided, which can be a list of single values, tuples, or lists.",
            "code": "ensure_index(['a', 'b'])\nIndex(['a', 'b'], dtype='object')\n\nensure_index([('a', 'a'),  ('b', 'c')])\nIndex([('a', 'a'), ('b', 'c')], dtype='object')\n\nensure_index([['a', 'a'], ['b', 'c']])\nMultiIndex(levels=[['a'], ['b', 'c']],\n           labels=[[0, 0], [0, 1]])",
            "masked_code": "<line_mask>\nIndex(['a', 'b'], dtype='object')\n\nensure_index([('a', 'a'),  ('b', 'c')])\nIndex([('a', 'a'), ('b', 'c')], dtype='object')\n\nensure_index([['a', 'a'], ['b', 'c']])\nMultiIndex(levels=[['a'], ['b', 'c']],\n           labels=[[0, 0], [0, 1]])",
            "masked_line": "ensure_index(['a', 'b'])",
            "answer": "ensure_index",
            "type": "name_change_new",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1080"
        },
        {
            "dependency": "pandas",
            "version": "==0.23.4",
            "time": "2018-08-03",
            "description": "The code creates an index object based on the input provided, which can be a list of single values, tuples, or lists.",
            "code": "_ensure_index(['a', 'b'])\nIndex(['a', 'b'], dtype='object')\n\n_ensure_index([('a', 'a'),  ('b', 'c')])\nIndex([('a', 'a'), ('b', 'c')], dtype='object')\n\n_ensure_index([['a', 'a'], ['b', 'c']])\nMultiIndex(levels=[['a'], ['b', 'c']],\n           labels=[[0, 0], [0, 1]])",
            "masked_code": "_ensure_index(['a', 'b'])\nIndex(['a', 'b'], dtype='object')\n\n<line_mask>\nIndex([('a', 'a'), ('b', 'c')], dtype='object')\n\n_ensure_index([['a', 'a'], ['b', 'c']])\nMultiIndex(levels=[['a'], ['b', 'c']],\n           labels=[[0, 0], [0, 1]])",
            "masked_line": "_ensure_index([('a', 'a'),  ('b', 'c')])",
            "answer": "_ensure_index",
            "type": "name_change_old",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1081"
        },
        {
            "dependency": "pandas",
            "version": "==1.0.0",
            "time": "2020-01-29",
            "description": "The code creates a DataFrame using pandas with values and column names specified. It then creates an index object and retrieves its values. Next, it creates a MultiIndex object with two levels of indexes and retrieves its values. Finally, it checks the number of dimensions of the values in the MultiIndex object.",
            "code": "df = pd.DataFrame([[1, 2, 3], [4, 5, 6], [7, 8, 9]],\n                   index=['a', 'b', 'c'], columns=['A', 'B', 'C'])\ndf.index._internal_get_values()\nidx = pd.Index(['1', '2', '3'])\nidx._internal_get_values()\nmidx = pd.MultiIndex.from_arrays([[1, 2, 3], ['a', 'b', 'c']],\n                                  names=('number', 'letter'))\nmidx._internal_get_values()\nmidx._internal_get_values().ndim",
            "masked_code": "df = pd.DataFrame([[1, 2, 3], [4, 5, 6], [7, 8, 9]],\n                   index=['a', 'b', 'c'], columns=['A', 'B', 'C'])\ndf.index._internal_get_values()\nidx = pd.Index(['1', '2', '3'])\n<line_mask>\nmidx = pd.MultiIndex.from_arrays([[1, 2, 3], ['a', 'b', 'c']],\n                                  names=('number', 'letter'))\nmidx._internal_get_values()\nmidx._internal_get_values().ndim",
            "masked_line": "idx._internal_get_values()",
            "answer": "_internal_get_values",
            "type": "name_change_new",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1082"
        },
        {
            "dependency": "pandas",
            "version": "==0.25.3",
            "time": "2019-10-31",
            "description": "The code creates a DataFrame using pandas with values and column names specified. It then creates an index object and retrieves its values. Next, it creates a MultiIndex object with two levels of indexes and retrieves its values. Finally, it checks the number of dimensions of the values in the MultiIndex object.",
            "code": "df = pd.DataFrame([[1, 2, 3], [4, 5, 6], [7, 8, 9]],\n                   index=['a', 'b', 'c'], columns=['A', 'B', 'C'])\ndf.index.get_values()\nidx = pd.Index(['1', '2', '3'])\nidx.get_values()\nmidx = pd.MultiIndex.from_arrays([[1, 2, 3], ['a', 'b', 'c']],\n                                 names=('number', 'letter'))\nmidx.get_values()\nmidx.get_values().ndim",
            "masked_code": "df = pd.DataFrame([[1, 2, 3], [4, 5, 6], [7, 8, 9]],\n                   index=['a', 'b', 'c'], columns=['A', 'B', 'C'])\n<line_mask>\nidx = pd.Index(['1', '2', '3'])\nidx.get_values()\nmidx = pd.MultiIndex.from_arrays([[1, 2, 3], ['a', 'b', 'c']],\n                                 names=('number', 'letter'))\nmidx.get_values()\nmidx.get_values().ndim",
            "masked_line": "df.index.get_values()",
            "answer": "get_values",
            "type": "name_change_old",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1083"
        },
        {
            "dependency": "pandas",
            "version": "==0.25.3",
            "time": "2019-10-31",
            "description": "The code creates a DataFrame using pandas with values and column names specified. It then creates an index object and retrieves its values. Next, it creates a MultiIndex object with specified arrays and names. Finally, it retrieves the values of the MultiIndex object and checks the number of dimensions.",
            "code": "df = pd.DataFrame([[1, 2, 3], [4, 5, 6], [7, 8, 9]],\n                   index=['a', 'b', 'c'], columns=['A', 'B', 'C'])\ndf.index.get_values()\nidx = pd.Index(['1', '2', '3'])\nidx.get_values()\nmidx = pd.MultiIndex.from_arrays([[1, 2, 3], ['a', 'b', 'c']],\n                                 names=('number', 'letter'))\nmidx.get_values()\nmidx.get_values().ndim",
            "masked_code": "df = pd.DataFrame([[1, 2, 3], [4, 5, 6], [7, 8, 9]],\n                   index=['a', 'b', 'c'], columns=['A', 'B', 'C'])\ndf.index.get_values()\nidx = pd.Index(['1', '2', '3'])\nidx.get_values()\nmidx = pd.MultiIndex.from_arrays([[1, 2, 3], ['a', 'b', 'c']],\n                                 names=('number', 'letter'))\nmidx.get_values()\n<line_mask>",
            "masked_line": "midx.get_values().ndim",
            "answer": "get_values",
            "type": "name_change_old",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1085"
        },
        {
            "dependency": "pandas",
            "version": "==1.0.0",
            "time": "2020-01-29",
            "description": "The code creates a DataFrame with values and indexes, then creates an Index and a MultiIndex. It retrieves the values of the indexes and multi-index, and checks the number of dimensions of the values of the multi-index.",
            "code": "df = pd.DataFrame([[1, 2, 3], [4, 5, 6], [7, 8, 9]],\n                   index=['a', 'b', 'c'], columns=['A', 'B', 'C'])\ndf.index._internal_get_values()\nidx = pd.Index(['1', '2', '3'])\nidx._internal_get_values()\nmidx = pd.MultiIndex.from_arrays([[1, 2, 3], ['a', 'b', 'c']],\n                                  names=('number', 'letter'))\nmidx._internal_get_values()\nmidx._internal_get_values().ndim",
            "masked_code": "df = pd.DataFrame([[1, 2, 3], [4, 5, 6], [7, 8, 9]],\n                   index=['a', 'b', 'c'], columns=['A', 'B', 'C'])\ndf.index._internal_get_values()\nidx = pd.Index(['1', '2', '3'])\nidx._internal_get_values()\nmidx = pd.MultiIndex.from_arrays([[1, 2, 3], ['a', 'b', 'c']],\n                                  names=('number', 'letter'))\nmidx._internal_get_values()\n<line_mask>",
            "masked_line": "midx._internal_get_values().ndim",
            "answer": "_internal_get_values",
            "type": "name_change_new",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1086"
        },
        {
            "dependency": "pandas",
            "version": "==1.0.0",
            "time": "2020-01-29",
            "description": "The code creates a DataFrame with values and column names, then retrieves the index values. It also creates an Index object with values and retrieves the values. Finally, it creates a MultiIndex object with arrays and names, retrieves the values, and checks the number of dimensions of the values.",
            "code": "df = pd.DataFrame([[1, 2, 3], [4, 5, 6], [7, 8, 9]],\n                   index=['a', 'b', 'c'], columns=['A', 'B', 'C'])\ndf.index._internal_get_values()\nidx = pd.Index(['1', '2', '3'])\nidx._internal_get_values()\nmidx = pd.MultiIndex.from_arrays([[1, 2, 3], ['a', 'b', 'c']],\n                                  names=('number', 'letter'))\nmidx._internal_get_values()\nmidx._internal_get_values().ndim",
            "masked_code": "df = pd.DataFrame([[1, 2, 3], [4, 5, 6], [7, 8, 9]],\n                   index=['a', 'b', 'c'], columns=['A', 'B', 'C'])\n<line_mask>\nidx = pd.Index(['1', '2', '3'])\nidx._internal_get_values()\nmidx = pd.MultiIndex.from_arrays([[1, 2, 3], ['a', 'b', 'c']],\n                                  names=('number', 'letter'))\nmidx._internal_get_values()\nmidx._internal_get_values().ndim",
            "masked_line": "df.index._internal_get_values()",
            "answer": "_internal_get_values",
            "type": "name_change_new",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1088"
        },
        {
            "dependency": "pandas",
            "version": "==0.25.3",
            "time": "2019-10-31",
            "description": "The code creates a DataFrame with values and column names, then retrieves the index values. It also creates an Index object with values and retrieves the values. Finally, it creates a MultiIndex object with arrays and names, retrieves the values, and checks the number of dimensions of the values.",
            "code": "df = pd.DataFrame([[1, 2, 3], [4, 5, 6], [7, 8, 9]],\n                   index=['a', 'b', 'c'], columns=['A', 'B', 'C'])\ndf.index.get_values()\nidx = pd.Index(['1', '2', '3'])\nidx.get_values()\nmidx = pd.MultiIndex.from_arrays([[1, 2, 3], ['a', 'b', 'c']],\n                                 names=('number', 'letter'))\nmidx.get_values()\nmidx.get_values().ndim",
            "masked_code": "df = pd.DataFrame([[1, 2, 3], [4, 5, 6], [7, 8, 9]],\n                   index=['a', 'b', 'c'], columns=['A', 'B', 'C'])\ndf.index.get_values()\nidx = pd.Index(['1', '2', '3'])\n<line_mask>\nmidx = pd.MultiIndex.from_arrays([[1, 2, 3], ['a', 'b', 'c']],\n                                 names=('number', 'letter'))\nmidx.get_values()\nmidx.get_values().ndim",
            "masked_line": "idx.get_values()",
            "answer": "get_values",
            "type": "name_change_old",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1089"
        },
        {
            "dependency": "pandas",
            "version": "==1.1.0",
            "time": "2020-07-28",
            "description": "The code reassigns values in the 'codes' array based on the mapping between the 'old_cat' and 'new_cat' Index objects.",
            "code": "old_cat = pd.Index(['b', 'a', 'c'])\nnew_cat = pd.Index(['a', 'b'])\ncodes = np.array([0, 1, 1, 2])\nrecode_for_categories(codes, old_cat, new_cat)\narray([ 1,  0,  0, -1], dtype=int8)",
            "masked_code": "old_cat = pd.Index(['b', 'a', 'c'])\nnew_cat = pd.Index(['a', 'b'])\ncodes = np.array([0, 1, 1, 2])\n<line_mask>\narray([ 1,  0,  0, -1], dtype=int8)",
            "masked_line": "recode_for_categories(codes, old_cat, new_cat)",
            "answer": "recode_for_categories",
            "type": "name_change_new",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1090"
        },
        {
            "dependency": "pandas",
            "version": "==1.0.5",
            "time": "2020-06-17",
            "description": "The code reassigns values in the 'codes' array based on the mapping between the 'old_cat' and 'new_cat' Index objects.",
            "code": "old_cat = pd.Index(['b', 'a', 'c'])\nnew_cat = pd.Index(['a', 'b'])\ncodes = np.array([0, 1, 1, 2])\n_recode_for_categories(codes, old_cat, new_cat)\narray([ 1,  0,  0, -1], dtype=int8)",
            "masked_code": "old_cat = pd.Index(['b', 'a', 'c'])\nnew_cat = pd.Index(['a', 'b'])\ncodes = np.array([0, 1, 1, 2])\n<line_mask>\narray([ 1,  0,  0, -1], dtype=int8)",
            "masked_line": "_recode_for_categories(codes, old_cat, new_cat)",
            "answer": "_recode_for_categories",
            "type": "name_change_old",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1091"
        },
        {
            "dependency": "pandas",
            "version": "==1.2.0",
            "time": "2020-12-26",
            "description": "This code checks if the input is an iterable object that is not a string.",
            "code": "iterable_not_string([1, 2, 3])\nTrue\niterable_not_string(\"foo\")\nFalse\niterable_not_string(1)\nFalse",
            "masked_code": "<line_mask>\nTrue\niterable_not_string(\"foo\")\nFalse\niterable_not_string(1)\nFalse",
            "masked_line": "iterable_not_string([1, 2, 3])",
            "answer": "iterable_not_string",
            "type": "name_change_new",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1092"
        },
        {
            "dependency": "pandas",
            "version": "==2.0.0",
            "time": "2023-04-03",
            "description": "The code normalizes the JSON data into a flat table format using pandas, with different levels of normalization specified by the \"max_level\" parameter.",
            "code": "pd.json_normalize(data)\npd.json_normalize(data, max_level=0)\npd.json_normalize(data, max_level=1)\nresult = pd.json_normalize(data, \"counties\", [\"state\", \"shortname\", [\"info\", \"governor\"]])\npd.json_normalize(data, \"A\", record_prefix=\"Prefix.\")",
            "masked_code": "pd.json_normalize(data)\npd.json_normalize(data, max_level=0)\npd.json_normalize(data, max_level=1)\nresult = pd.json_normalize(data, \"counties\", [\"state\", \"shortname\", [\"info\", \"governor\"]])\n<line_mask>",
            "masked_line": "pd.json_normalize(data, \"A\", record_prefix=\"Prefix.\")",
            "answer": "json_normalize",
            "type": "name_change_new",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1093"
        },
        {
            "dependency": "pyrsistent",
            "version": "==0.6.1",
            "time": "2014-10-31",
            "description": "The code defines an immutable data structure called Point with attributes x, y, and id_. It creates instances of Point with specified attribute values and allows for updating the attribute values using the set method.",
            "code": "Point = pclass('x, y', name='Point')\n\np = Point(1, 2)\n\np2 = p.set(x=3)\n\nPoint = pclass('x, y, id_', name='Point')\n\np = Point(1, 2, id_=17)\n\np.set(x=3)\n\np.set(id_=18)",
            "masked_code": "Point = pclass('x, y', name='Point')\n\np = Point(1, 2)\n\np2 = p.set(x=3)\n\n<line_mask>\n\np = Point(1, 2, id_=17)\n\np.set(x=3)\n\np.set(id_=18)",
            "masked_line": "Point = pclass('x, y, id_', name='Point')",
            "answer": "pclass",
            "type": "name_change_new",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1094"
        },
        {
            "dependency": "pyrsistent",
            "version": "==0.6.0",
            "time": "2014-10-26",
            "description": "The code defines an immutable data structure called Point with attributes x, y, and id_. It creates instances of Point with specified attribute values and allows for updating the attribute values using the set method.",
            "code": "Point = immutable('x, y', name='Point')\n\np = Point(1, 2)\n\np2 = p.set(x=3)\n\nPoint(x=1, y=2)\n\nPoint(x=3, y=2)\n\nPoint = immutable('x, y, id_', name='Point')\n\np = Point(1, 2, id_=17)\n\np.set(x=3)\n\nPoint(x=3, y=2, id_=17)\n\np.set(id_=18)",
            "masked_code": "<line_mask>\n\np = Point(1, 2)\n\np2 = p.set(x=3)\n\nPoint(x=1, y=2)\n\nPoint(x=3, y=2)\n\nPoint = immutable('x, y, id_', name='Point')\n\np = Point(1, 2, id_=17)\n\np.set(x=3)\n\nPoint(x=3, y=2, id_=17)\n\np.set(id_=18)",
            "masked_line": "Point = immutable('x, y', name='Point')",
            "answer": "immutable",
            "type": "name_change_old",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1095"
        },
        {
            "dependency": "pyrsistent",
            "version": "==0.9.3",
            "time": "2015-04-06",
            "description": "The code defines a class named Point with attributes x, y, and id_. It creates an instance p of Point with x=1, y=2. It then updates the x attribute of p to 3. Another instance p is created with x=1, y=2, and id_=17. The id_ attribute of p is then updated to 18.",
            "code": "Point = immutable('x, y', name='Point')\n\np = Point(1, 2)\n\np2 = p.set(x=3)\n\nPoint = immutable('x, y, id_', name='Point')\n\np = Point(1, 2, id_=17)\n\np.set(x=3)\n\np.set(id_=18)",
            "masked_code": "Point = immutable('x, y', name='Point')\n\np = Point(1, 2)\n\np2 = p.set(x=3)\n\n<line_mask>\n\np = Point(1, 2, id_=17)\n\np.set(x=3)\n\np.set(id_=18)",
            "masked_line": "Point = immutable('x, y, id_', name='Point')",
            "answer": "immutable",
            "type": "name_change_new",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1096"
        },
        {
            "dependency": "pyrsistent",
            "version": "==0.9.2",
            "time": "2015-04-03",
            "description": "The code defines a class named Point with attributes x, y, and id_. It creates an instance p of Point with x=1, y=2. It then updates the x attribute of p to 3. Another instance p is created with x=1, y=2, and id_=17. The id_ attribute of p is then updated to 18.",
            "code": "Point = pclass('x, y', name='Point')\n\np = Point(1, 2)\n\np2 = p.set(x=3)\n\nPoint = pclass('x, y, id_', name='Point')\n\np = Point(1, 2, id_=17)\n\np.set(x=3)\n\np.set(id_=18)",
            "masked_code": "<line_mask>\n\np = Point(1, 2)\n\np2 = p.set(x=3)\n\nPoint = pclass('x, y, id_', name='Point')\n\np = Point(1, 2, id_=17)\n\np.set(x=3)\n\np.set(id_=18)",
            "masked_line": "Point = pclass('x, y', name='Point')",
            "answer": "pclass",
            "type": "name_change_old",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1097"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==1.0.3",
            "time": "2020-10-20",
            "description": "Calculate the mean absolute error (MAE) between two tensors x and y.",
            "code": "mae = nn.L1Loss(reduction='mean')\nx = torch.tensor([0., 1, 2, 3])\ny = torch.tensor([0., 1, 2, 2])\nmae_value = mae(x, y)\nprint(mae_value)",
            "masked_code": "mae = nn.L1Loss(reduction='mean')\nx = torch.tensor([0., 1, 2, 3])\ny = torch.tensor([0., 1, 2, 2])\n<line_mask>\nprint(mae_value)",
            "masked_line": "mae_value = mae(x, y)",
            "answer": "mae",
            "type": "name_change_old",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1098"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==1.1.0",
            "time": "2020-12-10",
            "description": "The code calculates the Receiver Operating Characteristic (ROC) curve using the input tensors x and y, and returns the false positive rate (fpr), true positive rate (tpr), and thresholds.",
            "code": "x = torch.tensor([0, 1, 2, 3])\ny = torch.tensor([0, 1, 1, 1])\nfpr, tpr, thresholds = __roc(x, y)\nfpr\ntensor([0., 0., 0., 0., 1.])\ntpr\ntensor([0.0000, 0.3333, 0.6667, 1.0000, 1.0000])\nthresholds\ntensor([4, 3, 2, 1, 0])\n",
            "masked_code": "x = torch.tensor([0, 1, 2, 3])\ny = torch.tensor([0, 1, 1, 1])\n<line_mask>\nfpr\ntensor([0., 0., 0., 0., 1.])\ntpr\ntensor([0.0000, 0.3333, 0.6667, 1.0000, 1.0000])\nthresholds\ntensor([4, 3, 2, 1, 0])\n",
            "masked_line": "fpr, tpr, thresholds = __roc(x, y)",
            "answer": "__roc",
            "type": "name_change_old",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1099"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==2.0.0",
            "time": "2023-03-15",
            "description": "The code sets environment variables for the PL Trainer with the number of GPUs as 42 and a specific value for another variable. It then parses the environment variables for the Trainer and returns a Namespace object with the specified GPU value.",
            "code": "import os\nos.environ[\"PL_TRAINER_DEVICES\"] = '42'\nos.environ[\"PL_TRAINER_BLABLABLA\"] = '1.23'\n_parse_env_variables(Trainer)\nNamespace(devices=42)",
            "masked_code": "import os\nos.environ[\"PL_TRAINER_DEVICES\"] = '42'\nos.environ[\"PL_TRAINER_BLABLABLA\"] = '1.23'\n<line_mask>\nNamespace(devices=42)",
            "masked_line": "_parse_env_variables(Trainer)",
            "answer": "_parse_env_variables",
            "type": "name_change_new",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1100"
        },
        {
            "dependency": "pytorch-lightning",
            "version": "==1.9.5",
            "time": "2023-04-12",
            "description": "The code sets environment variables for the PL Trainer with the number of GPUs as 42 and a specific value for another variable. It then parses the environment variables for the Trainer and returns a Namespace object with the specified GPU value.",
            "code": "import os\nos.environ[\"PL_TRAINER_GPUS\"] = '42'\nos.environ[\"PL_TRAINER_BLABLABLA\"] = '1.23'\nparse_env_variables(Trainer)\nNamespace(gpus=42)",
            "masked_code": "import os\nos.environ[\"PL_TRAINER_GPUS\"] = '42'\nos.environ[\"PL_TRAINER_BLABLABLA\"] = '1.23'\n<line_mask>\nNamespace(gpus=42)",
            "masked_line": "parse_env_variables(Trainer)",
            "answer": "parse_env_variables",
            "type": "name_change_old",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1101"
        },
        {
            "dependency": "ray",
            "version": "==0.8.6",
            "time": "2020-06-22",
            "description": "The code runs a function `run_me` for 100 iterations, where it sleeps for 1 second in each iteration and logs the values \"hello\" as \"world\" and \"ray\" as \"tune\" using the `track.log` function. The function is executed using Ray Tune for analysis.",
            "code": "import time\nfrom ray import tune\n\ndef run_me(config):\n    for iter in range(100):\n        time.sleep(1)\n        tune.report(hello=\"world\", ray=\"tune\")\n\nanalysis = tune.run(run_me)",
            "masked_code": "import time\nfrom ray import tune\n\ndef run_me(config):\n    for iter in range(100):\n        time.sleep(1)\n        <line_mask>\n\nanalysis = tune.run(run_me)",
            "masked_line": "tune.report(hello=\"world\", ray=\"tune\")",
            "answer": "report",
            "type": "name_change_new",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1102"
        },
        {
            "dependency": "ray",
            "version": "==0.8.5",
            "time": "2020-05-06",
            "description": "The code runs a function `run_me` for 100 iterations, where it sleeps for 1 second in each iteration and logs the values \"hello\" as \"world\" and \"ray\" as \"tune\" using the `track.log` function. The function is executed using Ray Tune for analysis.",
            "code": "import time\nfrom ray import tune\nfrom ray.tune import track\n\ndef run_me(config):\n    for iter in range(100):\n        time.sleep(1)\n        track.log(hello=\"world\", ray=\"tune\")\n\nanalysis = tune.run(run_me)",
            "masked_code": "import time\nfrom ray import tune\nfrom ray.tune import track\n\ndef run_me(config):\n    for iter in range(100):\n        time.sleep(1)\n        <line_mask>\n\nanalysis = tune.run(run_me)",
            "masked_line": "track.log(hello=\"world\", ray=\"tune\")",
            "answer": "log",
            "type": "name_change_old",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1103"
        },
        {
            "dependency": "ray",
            "version": "==1.11.1",
            "time": "2022-04-11",
            "description": "The code asynchronously runs a remote function on multiple workers in parallel using Ray, with a timeout of 0.1 seconds. The function sleeps for 1 second on each worker. It then checks if the batches returned from the workers are None after the timeout, which is expected.",
            "code": "asynchronous_parallel_sample(\n    trainer,\n    actors=trainer.workers.remote_workers(),\n    ray_wait_timeout_s=0.1,\n    remote_fn=lambda w: time.sleep(1)  # sleep 1sec\n)\nprint(len(batches))\n2\n# Expect a timeout to have happened.\nbatches[0] is None and batches[1] is None\nTrue",
            "masked_code": "<line_mask>\n    trainer,\n    actors=trainer.workers.remote_workers(),\n    ray_wait_timeout_s=0.1,\n    remote_fn=lambda w: time.sleep(1)  # sleep 1sec\n)\nprint(len(batches))\n2\n# Expect a timeout to have happened.\nbatches[0] is None and batches[1] is None\nTrue",
            "masked_line": "asynchronous_parallel_sample(",
            "answer": "asynchronous_parallel_sample",
            "type": "name_change_old",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1104"
        },
        {
            "dependency": "streamlit",
            "version": "==0.85.0",
            "time": "2021-07-22",
            "description": "The code creates two DataFrames, df1 and df2, with random values and 20 columns each. It then displays df1 in a table using Streamlit's st.table function and adds the rows of df2 to the table. Next, it creates a line chart using df1 and adds the rows of df2 to the chart. Finally, it creates a Vega-Lite chart with a line mark, x and y encoding, and a named dataset 'some_fancy_name' using df1. It then adds the rows of df2 to the Vega-Lite chart using the named dataset.",
            "code": "df1 = pd.DataFrame(\n    np.random.randn(50, 20),\n    columns=('col %d' % i for i in range(20)))\n\nmy_table = st._legacy_table(df1)\n\ndf2 = pd.DataFrame(\n    np.random.randn(50, 20),\n    columns=('col %d' % i for i in range(20)))\n\nmy_table._legacy_add_rows(df2)\n\nmy_chart = st._legacy_line_chart(df1)\nmy_chart._legacy_add_rows(df2)\n\nmy_chart = st._legacy_vega_lite_chart({\n    'mark': 'line',\n    'encoding': {'x': 'a', 'y': 'b'},\n    'datasets': {\n        'some_fancy_name': df1,  # <-- named dataset\n    },\n    'data': {'name': 'some_fancy_name'},\n}),\nmy_chart._legacy_add_rows(some_fancy_name=df2)  # <-- name used as keyword\n",
            "masked_code": "df1 = pd.DataFrame(\n    np.random.randn(50, 20),\n    columns=('col %d' % i for i in range(20)))\n\nmy_table = st._legacy_table(df1)\n\ndf2 = pd.DataFrame(\n    np.random.randn(50, 20),\n    columns=('col %d' % i for i in range(20)))\n\nmy_table._legacy_add_rows(df2)\n\nmy_chart = st._legacy_line_chart(df1)\nmy_chart._legacy_add_rows(df2)\n\nmy_chart = st._legacy_vega_lite_chart({\n    'mark': 'line',\n    'encoding': {'x': 'a', 'y': 'b'},\n    'datasets': {\n        'some_fancy_name': df1,  # <-- named dataset\n    },\n    'data': {'name': 'some_fancy_name'},\n}),\n<line_mask>\n",
            "masked_line": "my_chart._legacy_add_rows(some_fancy_name=df2)  # <-- name used as keyword",
            "answer": "_legacy_add_rows",
            "type": "name_change_new",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1105"
        },
        {
            "dependency": "streamlit",
            "version": "==0.84.2",
            "time": "2021-07-19",
            "description": "The code creates two DataFrames, df1 and df2, with random values and 20 columns each. It then displays df1 in a table using Streamlit's st.table function and adds the rows of df2 to the table. Next, it creates a line chart using df1 and adds the rows of df2 to the chart. Finally, it creates a Vega-Lite chart with a line mark, x and y encoding, and a named dataset 'some_fancy_name' using df1. It then adds the rows of df2 to the Vega-Lite chart using the named dataset.",
            "code": "df1 = pd.DataFrame(\n   np.random.randn(50, 20),\n   columns=('col %d' % i for i in range(20)))\n\nmy_table = st.table(df1)\n\ndf2 = pd.DataFrame(\n   np.random.randn(50, 20),\n   columns=('col %d' % i for i in range(20)))\n\nmy_table.add_rows(df2)\n\nmy_chart = st.line_chart(df1)\nmy_chart.add_rows(df2)\n\nmy_chart = st.vega_lite_chart({\n    'mark': 'line',\n    'encoding': {'x': 'a', 'y': 'b'},\n    'datasets': {\n      'some_fancy_name': df1,  # <-- named dataset\n     },\n    'data': {'name': 'some_fancy_name'},\n}),\nmy_chart.add_rows(some_fancy_name=df2)  # <-- name used as keyword\n",
            "masked_code": "df1 = pd.DataFrame(\n   np.random.randn(50, 20),\n   columns=('col %d' % i for i in range(20)))\n\nmy_table = st.table(df1)\n\ndf2 = pd.DataFrame(\n   np.random.randn(50, 20),\n   columns=('col %d' % i for i in range(20)))\n\n<line_mask>\n\nmy_chart = st.line_chart(df1)\nmy_chart.add_rows(df2)\n\nmy_chart = st.vega_lite_chart({\n    'mark': 'line',\n    'encoding': {'x': 'a', 'y': 'b'},\n    'datasets': {\n      'some_fancy_name': df1,  # <-- named dataset\n     },\n    'data': {'name': 'some_fancy_name'},\n}),\nmy_chart.add_rows(some_fancy_name=df2)  # <-- name used as keyword\n",
            "masked_line": "my_table.add_rows(df2)",
            "answer": "add_rows",
            "type": "name_change_old",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1106"
        },
        {
            "dependency": "streamlit",
            "version": "==0.85.0",
            "time": "2021-07-22",
            "description": "The code creates two DataFrames with random values, displays the first DataFrame in a table, and adds rows from the second DataFrame to the table. It also creates a line chart with the first DataFrame and adds rows from the second DataFrame to the chart. Additionally, it creates a Vega-Lite line chart with specific encoding and datasets, and adds rows from the second DataFrame to the chart using a named dataset.",
            "code": "df1 = pd.DataFrame(\n   np.random.randn(50, 20),\n   columns=('col %d' % i for i in range(20)))\n\nmy_table = st._arrow_table(df1)\n\ndf2 = pd.DataFrame(\n   np.random.randn(50, 20),\n   columns=('col %d' % i for i in range(20)))\n\nmy_table._arrow_add_rows(df2)\n\nmy_chart = st._arrow_line_chart(df1)\nmy_chart._arrow_add_rows(df2)\n\nmy_chart = st._arrow_vega_lite_chart({\n    'mark': 'line',\n    'encoding': {'x': 'a', 'y': 'b'},\n    'datasets': {\n        'some_fancy_name': df1,  # <-- named dataset\n    },\n    'data': {'name': 'some_fancy_name'},\n}),\nmy_chart._arrow_add_rows(some_fancy_name=df2)  # <-- name used as keyword\n",
            "masked_code": "df1 = pd.DataFrame(\n   np.random.randn(50, 20),\n   columns=('col %d' % i for i in range(20)))\n\nmy_table = st._arrow_table(df1)\n\ndf2 = pd.DataFrame(\n   np.random.randn(50, 20),\n   columns=('col %d' % i for i in range(20)))\n\nmy_table._arrow_add_rows(df2)\n\nmy_chart = st._arrow_line_chart(df1)\n<line_mask>\n\nmy_chart = st._arrow_vega_lite_chart({\n    'mark': 'line',\n    'encoding': {'x': 'a', 'y': 'b'},\n    'datasets': {\n        'some_fancy_name': df1,  # <-- named dataset\n    },\n    'data': {'name': 'some_fancy_name'},\n}),\nmy_chart._arrow_add_rows(some_fancy_name=df2)  # <-- name used as keyword\n",
            "masked_line": "my_chart._arrow_add_rows(df2)",
            "answer": "_arrow_add_rows",
            "type": "name_change_new",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1107"
        },
        {
            "dependency": "streamlit",
            "version": "==0.84.2",
            "time": "2021-07-19",
            "description": "The code creates two DataFrames with random values, displays the first DataFrame in a table, and adds rows from the second DataFrame to the table. It also creates a line chart with the first DataFrame and adds rows from the second DataFrame to the chart. Additionally, it creates a Vega-Lite line chart with specific encoding and datasets, and adds rows from the second DataFrame to the chart using a named dataset.",
            "code": "df1 = pd.DataFrame(\n    np.random.randn(50, 20),\n    columns=('col %d' % i for i in range(20)))\n\nmy_table = st.table(df1)\n\ndf2 = pd.DataFrame(\n    np.random.randn(50, 20),\n    columns=('col %d' % i for i in range(20)))\n\nmy_table.add_rows(df2)\n\nmy_chart = st.line_chart(df1)\nmy_chart.add_rows(df2)\n\nmy_chart = st.vega_lite_chart({\n    'mark': 'line',\n    'encoding': {'x': 'a', 'y': 'b'},\n    'datasets': {\n        'some_fancy_name': df1,  # <-- named dataset\n    },\n    'data': {'name': 'some_fancy_name'},\n}),\nmy_chart.add_rows(some_fancy_name=df2)  # <-- name used as keyword\n",
            "masked_code": "df1 = pd.DataFrame(\n    np.random.randn(50, 20),\n    columns=('col %d' % i for i in range(20)))\n\nmy_table = st.table(df1)\n\ndf2 = pd.DataFrame(\n    np.random.randn(50, 20),\n    columns=('col %d' % i for i in range(20)))\n\nmy_table.add_rows(df2)\n\nmy_chart = st.line_chart(df1)\n<line_mask>\n\nmy_chart = st.vega_lite_chart({\n    'mark': 'line',\n    'encoding': {'x': 'a', 'y': 'b'},\n    'datasets': {\n        'some_fancy_name': df1,  # <-- named dataset\n    },\n    'data': {'name': 'some_fancy_name'},\n}),\nmy_chart.add_rows(some_fancy_name=df2)  # <-- name used as keyword\n",
            "masked_line": "my_chart.add_rows(df2)",
            "answer": "add_rows",
            "type": "name_change_old",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1108"
        },
        {
            "dependency": "streamlit",
            "version": "==0.85.0",
            "time": "2021-07-22",
            "description": "The code creates two DataFrames with random values, displays the first DataFrame in a table, and adds rows from the second DataFrame to the table. It also creates a line chart with the first DataFrame and adds rows from the second DataFrame to the chart. Additionally, it creates a Vega-Lite line chart with specific encoding and datasets, and adds rows from the second DataFrame to the chart using a named dataset.",
            "code": "df1 = pd.DataFrame(\n   np.random.randn(50, 20),\n   columns=('col %d' % i for i in range(20)))\n\nmy_table = st._arrow_table(df1)\n\ndf2 = pd.DataFrame(\n   np.random.randn(50, 20),\n   columns=('col %d' % i for i in range(20)))\n\nmy_table._arrow_add_rows(df2)\n\nmy_chart = st._arrow_line_chart(df1)\nmy_chart._arrow_add_rows(df2)\n\nmy_chart = st._arrow_vega_lite_chart({\n    'mark': 'line',\n    'encoding': {'x': 'a', 'y': 'b'},\n    'datasets': {\n        'some_fancy_name': df1,  # <-- named dataset\n    },\n    'data': {'name': 'some_fancy_name'},\n}),\nmy_chart._arrow_add_rows(some_fancy_name=df2)  # <-- name used as keyword\n",
            "masked_code": "df1 = pd.DataFrame(\n   np.random.randn(50, 20),\n   columns=('col %d' % i for i in range(20)))\n\nmy_table = st._arrow_table(df1)\n\ndf2 = pd.DataFrame(\n   np.random.randn(50, 20),\n   columns=('col %d' % i for i in range(20)))\n\n<line_mask>\n\nmy_chart = st._arrow_line_chart(df1)\nmy_chart._arrow_add_rows(df2)\n\nmy_chart = st._arrow_vega_lite_chart({\n    'mark': 'line',\n    'encoding': {'x': 'a', 'y': 'b'},\n    'datasets': {\n        'some_fancy_name': df1,  # <-- named dataset\n    },\n    'data': {'name': 'some_fancy_name'},\n}),\nmy_chart._arrow_add_rows(some_fancy_name=df2)  # <-- name used as keyword\n",
            "masked_line": "my_table._arrow_add_rows(df2)",
            "answer": "_arrow_add_rows",
            "type": "name_change_new",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1109"
        },
        {
            "dependency": "streamlit",
            "version": "==0.84.2",
            "time": "2021-07-19",
            "description": "The code creates two DataFrames with random values, displays the first DataFrame in a table, and adds rows from the second DataFrame to the table. It also creates a line chart with the first DataFrame and adds rows from the second DataFrame to the chart. Additionally, it creates a Vega-Lite line chart with specific encoding and datasets, and adds rows from the second DataFrame to the chart using a named dataset.",
            "code": "df1 = pd.DataFrame(\n    np.random.randn(50, 20),\n    columns=('col %d' % i for i in range(20)))\n\nmy_table = st.table(df1)\n\ndf2 = pd.DataFrame(\n    np.random.randn(50, 20),\n    columns=('col %d' % i for i in range(20)))\n\nmy_table.add_rows(df2)\n\nmy_chart = st.line_chart(df1)\nmy_chart.add_rows(df2)\n\nmy_chart = st.vega_lite_chart({\n    'mark': 'line',\n    'encoding': {'x': 'a', 'y': 'b'},\n    'datasets': {\n        'some_fancy_name': df1,  # <-- named dataset\n    },\n    'data': {'name': 'some_fancy_name'},\n}),\nmy_chart.add_rows(some_fancy_name=df2)  # <-- name used as keyword\n",
            "masked_code": "df1 = pd.DataFrame(\n    np.random.randn(50, 20),\n    columns=('col %d' % i for i in range(20)))\n\nmy_table = st.table(df1)\n\ndf2 = pd.DataFrame(\n    np.random.randn(50, 20),\n    columns=('col %d' % i for i in range(20)))\n\n<line_mask>\n\nmy_chart = st.line_chart(df1)\nmy_chart.add_rows(df2)\n\nmy_chart = st.vega_lite_chart({\n    'mark': 'line',\n    'encoding': {'x': 'a', 'y': 'b'},\n    'datasets': {\n        'some_fancy_name': df1,  # <-- named dataset\n    },\n    'data': {'name': 'some_fancy_name'},\n}),\nmy_chart.add_rows(some_fancy_name=df2)  # <-- name used as keyword\n",
            "masked_line": "my_table.add_rows(df2)",
            "answer": "add_rows",
            "type": "name_change_old",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1110"
        },
        {
            "dependency": "streamlit",
            "version": "==1.28.0",
            "time": "2023-10-25",
            "description": "The code generates a DataFrame with random values and displays it using the Streamlit library. It also allows for customization of the DataFrame's style using a Pandas Styler object.",
            "code": "import streamlit as st\nimport pandas as pd\nimport numpy as np\n\ndf = pd.DataFrame(np.random.randn(50, 20), columns=(\"col %d\" % i for i in range(20)))\n\nst.dataframe(df)  # Same as st.write(df)\n\ndf = pd.DataFrame(np.random.randn(10, 20), columns=(\"col %d\" % i for i in range(20)))\n\nst.dataframe(df.style.highlight_max(axis=0))\n\ndf = pd.DataFrame(\n    {\n        \"name\": [\"Roadmap\", \"Extras\", \"Issues\"],\n        \"url\": [\"https://roadmap.streamlit.app\", \"https://extras.streamlit.app\", \"https://issues.streamlit.app\"],\n        \"stars\": [random.randint(0, 1000) for _ in range(3)],\n        \"views_history\": [[random.randint(0, 5000) for _ in range(30)] for _ in range(3)],\n    }\n)\nst.dataframe(\n    df,\n    column_config={\n        \"name\": \"App name\",\n        \"stars\": st.column_config.NumberColumn(\n            \"Github Stars\",\n            help=\"Number of stars on GitHub\",\n            format=\"%d \",\n        ),\n        \"url\": st.column_config.LinkColumn(\"App URL\"),\n        \"views_history\": st.column_config.LineChartColumn(\n            \"Views (past 30 days)\", y_min=0, y_max=5000\n        ),\n    },\n    hide_index=True,\n)",
            "masked_code": "import streamlit as st\nimport pandas as pd\nimport numpy as np\n\ndf = pd.DataFrame(np.random.randn(50, 20), columns=(\"col %d\" % i for i in range(20)))\n\nst.dataframe(df)  # Same as st.write(df)\n\ndf = pd.DataFrame(np.random.randn(10, 20), columns=(\"col %d\" % i for i in range(20)))\n\n<line_mask>\n\ndf = pd.DataFrame(\n    {\n        \"name\": [\"Roadmap\", \"Extras\", \"Issues\"],\n        \"url\": [\"https://roadmap.streamlit.app\", \"https://extras.streamlit.app\", \"https://issues.streamlit.app\"],\n        \"stars\": [random.randint(0, 1000) for _ in range(3)],\n        \"views_history\": [[random.randint(0, 5000) for _ in range(30)] for _ in range(3)],\n    }\n)\nst.dataframe(\n    df,\n    column_config={\n        \"name\": \"App name\",\n        \"stars\": st.column_config.NumberColumn(\n            \"Github Stars\",\n            help=\"Number of stars on GitHub\",\n            format=\"%d \",\n        ),\n        \"url\": st.column_config.LinkColumn(\"App URL\"),\n        \"views_history\": st.column_config.LineChartColumn(\n            \"Views (past 30 days)\", y_min=0, y_max=5000\n        ),\n    },\n    hide_index=True,\n)",
            "masked_line": "st.dataframe(df.style.highlight_max(axis=0))",
            "answer": "dataframe",
            "type": "name_change_new",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1111"
        },
        {
            "dependency": "streamlit",
            "version": "==1.28.0",
            "time": "2023-10-25",
            "description": "This code generates a random 10x5 DataFrame using NumPy and Pandas, and then displays it as an arrow table using Streamlit.",
            "code": "import streamlit as st\nimport pandas as pd\nimport numpy as np\n\ndf = pd.DataFrame(np.random.randn(10, 5), columns=(\"col %d\" % i for i in range(5)))\n\nst.table(df)",
            "masked_code": "import streamlit as st\nimport pandas as pd\nimport numpy as np\n\ndf = pd.DataFrame(np.random.randn(10, 5), columns=(\"col %d\" % i for i in range(5)))\n\n<line_mask>",
            "masked_line": "st.table(df)",
            "answer": "table",
            "type": "name_change_new",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1112"
        },
        {
            "dependency": "streamlit",
            "version": "==1.27.2",
            "time": "2023-10-03",
            "description": "This code generates a random 10x5 DataFrame using NumPy and Pandas, and then displays it as an arrow table using Streamlit.",
            "code": "import streamlit as st\nimport pandas as pd\nimport numpy as np\n\ndf = pd.DataFrame(\n   np.random.randn(10, 5),\n   columns=(\"col %d\" % i for i in range(5)))\n\nst._arrow_table(df)",
            "masked_code": "import streamlit as st\nimport pandas as pd\nimport numpy as np\n\ndf = pd.DataFrame(\n   np.random.randn(10, 5),\n   columns=(\"col %d\" % i for i in range(5)))\n\n<line_mask>",
            "masked_line": "st._arrow_table(df)",
            "answer": "_arrow_table",
            "type": "name_change_old",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1113"
        },
        {
            "dependency": "streamlit",
            "version": "==1.28.0",
            "time": "2023-10-25",
            "description": "The code generates a scatter plot using Altair library based on a randomly generated DataFrame with 3 columns. The scatter plot displays the values of columns 'a' and 'b' as x and y coordinates, the size and color of the circles represent the values in column 'c'. The plot is displayed using Streamlit library.",
            "code": "import streamlit as st\nimport pandas as pd\nimport numpy as np\nimport altair as alt\n\nchart_data = pd.DataFrame(np.random.randn(20, 3), columns=[\"a\", \"b\", \"c\"])\n\nc = (\n   alt.Chart(chart_data)\n   .mark_circle()\n   .encode(x=\"a\", y=\"b\", size=\"c\", color=\"c\", tooltip=[\"a\", \"b\", \"c\"])\n)\n\nst.altair_chart(c, use_container_width=True)",
            "masked_code": "import streamlit as st\nimport pandas as pd\nimport numpy as np\nimport altair as alt\n\nchart_data = pd.DataFrame(np.random.randn(20, 3), columns=[\"a\", \"b\", \"c\"])\n\nc = (\n   alt.Chart(chart_data)\n   .mark_circle()\n   .encode(x=\"a\", y=\"b\", size=\"c\", color=\"c\", tooltip=[\"a\", \"b\", \"c\"])\n)\n\n<line_mask>",
            "masked_line": "st.altair_chart(c, use_container_width=True)",
            "answer": "altair_chart",
            "type": "name_change_new",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1114"
        },
        {
            "dependency": "streamlit",
            "version": "==1.27.2",
            "time": "2023-10-03",
            "description": "The code generates a scatter plot using Altair library based on a randomly generated DataFrame with 3 columns. The scatter plot displays the values of columns 'a' and 'b' as x and y coordinates, the size and color of the circles represent the values in column 'c'. The plot is displayed using Streamlit library.",
            "code": "import streamlit as st\nimport pandas as pd\nimport numpy as np\nimport altair as alt\n\ndf = pd.DataFrame(\n    np.random.randn(200, 3),\n    columns=['a', 'b', 'c'])\n\nc = alt.Chart(df).mark_circle().encode(\n    x='a', y='b', size='c', color='c', tooltip=['a', 'b', 'c'])\n\nst._arrow_altair_chart(c, use_container_width=True)",
            "masked_code": "import streamlit as st\nimport pandas as pd\nimport numpy as np\nimport altair as alt\n\ndf = pd.DataFrame(\n    np.random.randn(200, 3),\n    columns=['a', 'b', 'c'])\n\nc = alt.Chart(df).mark_circle().encode(\n    x='a', y='b', size='c', color='c', tooltip=['a', 'b', 'c'])\n\n<line_mask>",
            "masked_line": "st._arrow_altair_chart(c, use_container_width=True)",
            "answer": "_arrow_altair_chart",
            "type": "name_change_old",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1115"
        },
        {
            "dependency": "streamlit",
            "version": "==1.28.0",
            "time": "2023-10-25",
            "description": "The code generates a scatter plot chart using Streamlit and displays it using the Arrow Vega-Lite chart. The chart visualizes random data points with three variables 'a', 'b', and 'c', where 'a' and 'b' are plotted on the x and y axes as quantitative values, and 'c' is used for both the size and color of the data points.",
            "code": "import streamlit as st\nimport pandas as pd\nimport numpy as np\n\nchart_data = pd.DataFrame(np.random.randn(200, 3), columns=[\"a\", \"b\", \"c\"])\n\nst.vega_lite_chart(\n    chart_data,\n    {\n        \"mark\": {\"type\": \"circle\", \"tooltip\": True},\n        \"encoding\": {\n            \"x\": {\"field\": \"a\", \"type\": \"quantitative\"},\n            \"y\": {\"field\": \"b\", \"type\": \"quantitative\"},\n            \"size\": {\"field\": \"c\", \"type\": \"quantitative\"},\n            \"color\": {\"field\": \"c\", \"type\": \"quantitative\"},\n        },\n    },\n)",
            "masked_code": "import streamlit as st\nimport pandas as pd\nimport numpy as np\n\nchart_data = pd.DataFrame(np.random.randn(200, 3), columns=[\"a\", \"b\", \"c\"])\n\n<line_mask>\n    chart_data,\n    {\n        \"mark\": {\"type\": \"circle\", \"tooltip\": True},\n        \"encoding\": {\n            \"x\": {\"field\": \"a\", \"type\": \"quantitative\"},\n            \"y\": {\"field\": \"b\", \"type\": \"quantitative\"},\n            \"size\": {\"field\": \"c\", \"type\": \"quantitative\"},\n            \"color\": {\"field\": \"c\", \"type\": \"quantitative\"},\n        },\n    },\n)",
            "masked_line": "st.vega_lite_chart(",
            "answer": "vega_lite_chart",
            "type": "name_change_new",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1116"
        },
        {
            "dependency": "streamlit",
            "version": "==1.27.2",
            "time": "2023-10-03",
            "description": "The code generates a scatter plot chart using Streamlit and displays it using the Arrow Vega-Lite chart. The chart visualizes random data points with three variables 'a', 'b', and 'c', where 'a' and 'b' are plotted on the x and y axes as quantitative values, and 'c' is used for both the size and color of the data points.",
            "code": "import streamlit as st\nimport pandas as pd\nimport numpy as np\n\ndf = pd.DataFrame(\n    np.random.randn(200, 3),\n    columns=['a', 'b', 'c'])\n\nst._arrow_vega_lite_chart(df, {\n    'mark': {'type': 'circle', 'tooltip': True},\n    'encoding': {\n        'x': {'field': 'a', 'type': 'quantitative'},\n        'y': {'field': 'b', 'type': 'quantitative'},\n        'size': {'field': 'c', 'type': 'quantitative'},\n        'color': {'field': 'c', 'type': 'quantitative'},\n    },\n})",
            "masked_code": "import streamlit as st\nimport pandas as pd\nimport numpy as np\n\ndf = pd.DataFrame(\n    np.random.randn(200, 3),\n    columns=['a', 'b', 'c'])\n\n<line_mask>\n    'mark': {'type': 'circle', 'tooltip': True},\n    'encoding': {\n        'x': {'field': 'a', 'type': 'quantitative'},\n        'y': {'field': 'b', 'type': 'quantitative'},\n        'size': {'field': 'c', 'type': 'quantitative'},\n        'color': {'field': 'c', 'type': 'quantitative'},\n    },\n})",
            "masked_line": "st._arrow_vega_lite_chart(df, {",
            "answer": "_arrow_vega_lite_chart",
            "type": "name_change_old",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1117"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.0.1",
            "time": "2017-03-07",
            "description": "The code initializes a string to index table from a vocabulary file, maps the strings in the 'features' constant to their corresponding indices using the table, and then initializes the table.",
            "code": "features = tf.constant([\"emerson\", \"lake\", \"and\", \"palmer\"])\ntable = tf.contrib.lookup.string_to_index_table_from_file(\n    vocabulary_file=\"test.txt\", num_oov_buckets=1)\nids = table.lookup(features)\n...\ntf.tables_initializer().run()\n",
            "masked_code": "features = tf.constant([\"emerson\", \"lake\", \"and\", \"palmer\"])\n<line_mask>\n    vocabulary_file=\"test.txt\", num_oov_buckets=1)\nids = table.lookup(features)\n...\ntf.tables_initializer().run()\n",
            "masked_line": "table = tf.contrib.lookup.string_to_index_table_from_file(",
            "answer": "string_to_index_table_from_file",
            "type": "name_change_old",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1118"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.14.0",
            "time": "2019-06-18",
            "description": "The code creates a simple TensorFlow Keras model with one dense layer and input shape of 10. It then saves the model in the SavedModel format and loads the saved model back for inspection.",
            "code": "import tensorflow as tf\n\n# Create a tf.keras model.\nmodel = tf.keras.Sequential()\nmodel.add(tf.keras.layers.Dense(1, input_shape=[10]))\nmodel.summary()\n\n# Save the tf.keras model in the SavedModel format.\npath = '/tmp/simple_keras_model'\ntf.keras.experimental.export_saved_model(model, path)\n\n# Load the saved keras model back.\nnew_model = tf.keras.experimental.load_from_saved_model(path)\nnew_model.summary()\n",
            "masked_code": "import tensorflow as tf\n\n# Create a tf.keras model.\nmodel = tf.keras.Sequential()\nmodel.add(tf.keras.layers.Dense(1, input_shape=[10]))\nmodel.summary()\n\n# Save the tf.keras model in the SavedModel format.\npath = '/tmp/simple_keras_model'\ntf.keras.experimental.export_saved_model(model, path)\n\n# Load the saved keras model back.\n<line_mask>\nnew_model.summary()\n",
            "masked_line": "new_model = tf.keras.experimental.load_from_saved_model(path)",
            "answer": "load_from_saved_model",
            "type": "name_change_new",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1119"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.13.2",
            "time": "2019-07-15",
            "description": "The code creates a simple TensorFlow Keras model with one dense layer and input shape of 10. It then saves the model in the SavedModel format and loads the saved model back for inspection.",
            "code": "import tensorflow as tf\n\n# Create a tf.keras model.\nmodel = tf.keras.Sequential()\nmodel.add(tf.keras.layers.Dense(1, input_shape=[10]))\nmodel.summary()\n\n# Save the tf.keras model in the SavedModel format.\nsaved_to_path = tf.contrib.saved_model.save_keras_model(\n      model, '/tmp/my_simple_tf_keras_saved_model')\n\n# Load the saved keras model back.\nmodel_prime = tf.contrib.saved_model.load_keras_model(saved_to_path)\nmodel_prime.summary()\n",
            "masked_code": "import tensorflow as tf\n\n# Create a tf.keras model.\nmodel = tf.keras.Sequential()\nmodel.add(tf.keras.layers.Dense(1, input_shape=[10]))\nmodel.summary()\n\n# Save the tf.keras model in the SavedModel format.\nsaved_to_path = tf.contrib.saved_model.save_keras_model(\n      model, '/tmp/my_simple_tf_keras_saved_model')\n\n# Load the saved keras model back.\n<line_mask>\nmodel_prime.summary()\n",
            "masked_line": "model_prime = tf.contrib.saved_model.load_keras_model(saved_to_path)",
            "answer": "load_keras_model",
            "type": "name_change_old",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1120"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.6.0",
            "time": "2018-02-28",
            "description": "This code defines a neural network with dense reparameterization layers using TensorFlow Probability. It then calculates the negative log likelihood and Kullback-Leibler divergence, and combines them to form the loss function. Finally, it uses the Adam optimizer to minimize the loss function during training.",
            "code": "tfp = tf.contrib.bayesflow\n\nnet = tfp.layers.dense_reparameterization(\n    features, 512, activation=tf.nn.relu)\nlogits = tfp.layers.dense_reparameterization(net, 10)\nneg_log_likelihood = tf.nn.softmax_cross_entropy_with_logits(\n    labels=labels, logits=logits)\nkl = sum(tf.get_collection(tf.GraphKeys.REGULARIZATION_LOSSES))\nloss = neg_log_likelihood + kl\ntrain_op = tf.train.AdamOptimizer().minimize(loss)\n",
            "masked_code": "tfp = tf.contrib.bayesflow\n\n<line_mask>\n    features, 512, activation=tf.nn.relu)\nlogits = tfp.layers.dense_reparameterization(net, 10)\nneg_log_likelihood = tf.nn.softmax_cross_entropy_with_logits(\n    labels=labels, logits=logits)\nkl = sum(tf.get_collection(tf.GraphKeys.REGULARIZATION_LOSSES))\nloss = neg_log_likelihood + kl\ntrain_op = tf.train.AdamOptimizer().minimize(loss)\n",
            "masked_line": "net = tfp.layers.dense_reparameterization(",
            "answer": "dense_reparameterization",
            "type": "name_change_new",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1121"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.6.0",
            "time": "2018-02-28",
            "description": "The code performs a neural network training using local reparameterization for dense layers, softmax cross entropy loss function, and Adam optimizer.",
            "code": "tfp = tf.contrib.bayesflow\n\nnet = tfp.layers.dense_local_reparameterization(\n    features, 512, activation=tf.nn.relu)\nlogits = tfp.layers.dense_local_reparameterization(net, 10)\nneg_log_likelihood = tf.nn.softmax_cross_entropy_with_logits(\n    labels=labels, logits=logits)\nkl = sum(tf.get_collection(tf.GraphKeys.REGULARIZATION_LOSSES))\nloss = neg_log_likelihood + kl\ntrain_op = tf.train.AdamOptimizer().minimize(loss)\n",
            "masked_code": "tfp = tf.contrib.bayesflow\n\n<line_mask>\n    features, 512, activation=tf.nn.relu)\nlogits = tfp.layers.dense_local_reparameterization(net, 10)\nneg_log_likelihood = tf.nn.softmax_cross_entropy_with_logits(\n    labels=labels, logits=logits)\nkl = sum(tf.get_collection(tf.GraphKeys.REGULARIZATION_LOSSES))\nloss = neg_log_likelihood + kl\ntrain_op = tf.train.AdamOptimizer().minimize(loss)\n",
            "masked_line": "net = tfp.layers.dense_local_reparameterization(",
            "answer": "dense_local_reparameterization",
            "type": "name_change_new",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1122"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.6.0",
            "time": "2018-02-28",
            "description": "This code defines a neural network with two dense layers using the Flipout estimator for Bayesian neural networks. It calculates the negative log likelihood using softmax cross entropy with logits, adds the Kullback-Leibler divergence regularization term, and defines a training operation to minimize the loss using the Adam optimizer.",
            "code": "tfp = tf.contrib.bayesflow\n\nnet = tfp.layers.dense_flipout(\n    features, 512, activation=tf.nn.relu)\nlogits = tfp.layers.dense_flipout(net, 10)\nneg_log_likelihood = tf.nn.softmax_cross_entropy_with_logits(\n    labels=labels, logits=logits)\nkl = sum(tf.get_collection(tf.GraphKeys.REGULARIZATION_LOSSES))\nloss = neg_log_likelihood + kl\ntrain_op = tf.train.AdamOptimizer().minimize(loss)\n",
            "masked_code": "tfp = tf.contrib.bayesflow\n\n<line_mask>\n    features, 512, activation=tf.nn.relu)\nlogits = tfp.layers.dense_flipout(net, 10)\nneg_log_likelihood = tf.nn.softmax_cross_entropy_with_logits(\n    labels=labels, logits=logits)\nkl = sum(tf.get_collection(tf.GraphKeys.REGULARIZATION_LOSSES))\nloss = neg_log_likelihood + kl\ntrain_op = tf.train.AdamOptimizer().minimize(loss)\n",
            "masked_line": "net = tfp.layers.dense_flipout(",
            "answer": "dense_flipout",
            "type": "name_change_new",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1123"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.12.0",
            "time": "2023-03-20",
            "description": "The code defines a class FruitTraceType with a method _placeholder_value that returns an instance of the Fruit class. The code also includes a function foo(x) that can take the placeholder value as an argument.",
            "code": "class FruitTraceType:\n  def placeholder_value(self, placeholder_context=None):\n    return Fruit()\n\n\n@tf.function\ndef foo(x):\n  # Here `x` is be the placeholder value\n  ...\n",
            "masked_code": "class FruitTraceType:\n  <line_mask>\n    return Fruit()\n\n\n@tf.function\ndef foo(x):\n  # Here `x` is be the placeholder value\n  ...\n",
            "masked_line": "def placeholder_value(self, placeholder_context=None):",
            "answer": "placeholder_value",
            "type": "name_change_new",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1124"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.11.1",
            "time": "2023-03-16",
            "description": "The code defines a class FruitTraceType with a method _placeholder_value that returns an instance of the Fruit class. The code also includes a function foo(x) that can take the placeholder value as an argument.",
            "code": "class FruitTraceType:\n  def _placeholder_value():\n    return Fruit()\n\n\n@tf.function\ndef foo(x):\n  # Here `x` can be the placeholder value\n  ...\n",
            "masked_code": "class FruitTraceType:\n  <line_mask>\n    return Fruit()\n\n\n@tf.function\ndef foo(x):\n  # Here `x` can be the placeholder value\n  ...\n",
            "masked_line": "def _placeholder_value():",
            "answer": "_placeholder_value",
            "type": "name_change_old",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1125"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.13.0",
            "time": "2023-06-28",
            "description": "The code initializes a TPUStrategy and creates a checkpoint manager to save checkpoints during training. It also defines a preemption handler to save checkpoints if preemption occurs. The training loop runs a multi-step training function until the trained step reaches a specified number of steps.",
            "code": "strategy = tf.distribute.TPUStrategy(tpu_cluster_resolver)\n# initialization omitted\n\nwith strategy.scope():\n  # Save in the checkpoint.\n  trained_step = tf.Variable(initial_value=tf.constant(0, dtype=tf.dtypes.int64), name='trained_step', aggregation=tf.VariableAggregation.ONLY_FIRST_REPLICA)\n\n  checkpoint_manager = tf.train.CheckpointManager(checkpoint, directory, max_to_keep=1)\n  preemption_handler = tf.distribute.experimental.PreemptionCheckpointHandler(cluster_resolver, checkpoint_manager)\n\nwhile trained_step.numpy() < NUM_STEPS:\n  # Train STEPS_IN_FUNCTION steps at once.\n  train_multi_step_function()\n  trained_step.assign_add(STEPS_IN_FUNCTION)\n  preemption_handler.save_checkpoint_if_preempted()",
            "masked_code": "strategy = tf.distribute.TPUStrategy(tpu_cluster_resolver)\n# initialization omitted\n\nwith strategy.scope():\n  # Save in the checkpoint.\n  trained_step = tf.Variable(initial_value=tf.constant(0, dtype=tf.dtypes.int64), name='trained_step', aggregation=tf.VariableAggregation.ONLY_FIRST_REPLICA)\n\n  checkpoint_manager = tf.train.CheckpointManager(checkpoint, directory, max_to_keep=1)\n  preemption_handler = tf.distribute.experimental.PreemptionCheckpointHandler(cluster_resolver, checkpoint_manager)\n\nwhile trained_step.numpy() < NUM_STEPS:\n  # Train STEPS_IN_FUNCTION steps at once.\n  train_multi_step_function()\n  trained_step.assign_add(STEPS_IN_FUNCTION)\n  <line_mask>",
            "masked_line": "preemption_handler.save_checkpoint_if_preempted()",
            "answer": "save_checkpoint_if_preempted",
            "type": "name_change_new",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1126"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.4.0",
            "time": "2020-12-12",
            "description": "The code creates a dataset with a batch size determined by the input context, repeats the dataset indefinitely, batches the data, and then shards the dataset based on the input context's number of input pipelines and input pipeline ID. The code then distributes the dataset across replicas using the provided strategy and runs a function on each batch using the strategy.",
            "code": "def dataset_fn(input_context):\n  batch_size = input_context.get_per_replica_batch_size(global_batch_size)\n  d = tf.data.Dataset.from_tensors([[1.]]).repeat().batch(batch_size)\n  return d.shard(\n      input_context.num_input_pipelines, input_context.input_pipeline_id)\n\ninputs = strategy.distribute_datasets_from_function(dataset_fn)\n\nfor batch in inputs:\n  replica_results = strategy.run(replica_fn, args=(batch,))",
            "masked_code": "def dataset_fn(input_context):\n  batch_size = input_context.get_per_replica_batch_size(global_batch_size)\n  d = tf.data.Dataset.from_tensors([[1.]]).repeat().batch(batch_size)\n  return d.shard(\n      input_context.num_input_pipelines, input_context.input_pipeline_id)\n\n<line_mask>\n\nfor batch in inputs:\n  replica_results = strategy.run(replica_fn, args=(batch,))",
            "masked_line": "inputs = strategy.distribute_datasets_from_function(dataset_fn)",
            "answer": "distribute_datasets_from_function",
            "type": "name_change_new",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1127"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.3.4",
            "time": "2021-08-11",
            "description": "The code creates a dataset with a batch size determined by the input context, repeats the dataset indefinitely, batches the data, and then shards the dataset based on the input context's number of input pipelines and input pipeline ID. The code then distributes the dataset across replicas using the provided strategy and runs a function on each batch using the strategy.",
            "code": "def dataset_fn(input_context):\n  batch_size = input_context.get_per_replica_batch_size(global_batch_size)\n  d = tf.data.Dataset.from_tensors([[1.]]).repeat().batch(batch_size)\n  return d.shard(\n      input_context.num_input_pipelines, input_context.input_pipeline_id)\n\ninputs = strategy.experimental_distribute_datasets_from_function(dataset_fn)\n\nfor batch in inputs:\n  replica_results = strategy.run(replica_fn, args=(batch,))",
            "masked_code": "def dataset_fn(input_context):\n  batch_size = input_context.get_per_replica_batch_size(global_batch_size)\n  d = tf.data.Dataset.from_tensors([[1.]]).repeat().batch(batch_size)\n  return d.shard(\n      input_context.num_input_pipelines, input_context.input_pipeline_id)\n\n<line_mask>\n\nfor batch in inputs:\n  replica_results = strategy.run(replica_fn, args=(batch,))",
            "masked_line": "inputs = strategy.experimental_distribute_datasets_from_function(dataset_fn)",
            "answer": "experimental_distribute_datasets_from_function",
            "type": "name_change_old",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1128"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.7.0",
            "time": "2021-11-01",
            "description": "The code sets the global policy for mixed precision to 'mixed_float16', then retrieves the global policy. It creates a Dense layer with a default dtype policy. It creates another Dense layer with dtype 'float64' policy. Finally, it changes the global policy to 'float32'.",
            "code": "tf.keras.mixed_precision.set_global_policy('mixed_float16')\ntf.keras.mixed_precision.global_policy()\ntf.keras.layers.Dense(10).dtype_policy\ntf.keras.layers.Dense(10, dtype='float64').dtype_policy\ntf.keras.mixed_precision.set_global_policy('float32')\n",
            "masked_code": "<line_mask>\ntf.keras.mixed_precision.global_policy()\ntf.keras.layers.Dense(10).dtype_policy\ntf.keras.layers.Dense(10, dtype='float64').dtype_policy\ntf.keras.mixed_precision.set_global_policy('float32')\n",
            "masked_line": "tf.keras.mixed_precision.set_global_policy('mixed_float16')",
            "answer": "set_global_policy",
            "type": "name_change_new",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1133"
        },
        {
            "dependency": "torch",
            "version": "==1.4.0",
            "time": "2020-01-14",
            "description": "This code defines a function `bar` that creates a resolution callback with a parameter of 1 and then prints the result of calling the callback with the argument \"foo\". The function `baz` sets a variable `foo` to 2 and then calls the function `bar`. Finally, the code executes the function `baz`.",
            "code": "def bar():\n    cb = createResolutionCallbackFromFrame(1)\n    print(cb(\"foo\"))\n\ndef baz():\n    foo = 2\n    bar()\n\nbaz()",
            "masked_code": "def bar():\n    <line_mask>\n    print(cb(\"foo\"))\n\ndef baz():\n    foo = 2\n    bar()\n\nbaz()",
            "masked_line": "cb = createResolutionCallbackFromFrame(1)",
            "answer": "createResolutionCallbackFromFrame",
            "type": "name_change_new",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1134"
        },
        {
            "dependency": "torch",
            "version": "==1.3.1",
            "time": "2019-11-04",
            "description": "This code defines a function `bar` that creates a resolution callback with a parameter of 1 and then prints the result of calling the callback with the argument \"foo\". The function `baz` sets a variable `foo` to 2 and then calls the function `bar`. Finally, the code executes the function `baz`.",
            "code": "def bar():\n    cb = createResolutionCallback(1)\n    print(cb(\"foo\"))\n\ndef baz():\n    foo = 2\n    bar()\n\nbaz()",
            "masked_code": "def bar():\n    <line_mask>\n    print(cb(\"foo\"))\n\ndef baz():\n    foo = 2\n    bar()\n\nbaz()",
            "masked_line": "cb = createResolutionCallback(1)",
            "answer": "createResolutionCallback",
            "type": "name_change_old",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "library_source_code",
            "id": "library_source_code_block_1135"
        },
        {
            "dependency": "numpy",
            "version": "==1.14.3",
            "time": "2022-08-01",
            "description": "This function generates a one-hot encoded array based on the input label within the provided dimension.",
            "code": "import numpy as np\n\ndef oneHotLabel(label, dim):\n    \"\"\"\n\n    :param label:\n    :return: np.array((BATCH_SIZE, OUTPUT_DIM))\n    \"\"\"\n    oneHot = np.zeros(dim)\n    if label < 0 or label > dim:\n        return oneHot\n\n    oneHot[label] = 1\n\n    return oneHot",
            "masked_code": "import numpy as np\n\ndef oneHotLabel(label, dim):\n    \"\"\"\n\n    :param label:\n    :return: np.array((BATCH_SIZE, OUTPUT_DIM))\n    \"\"\"\n    <line_mask>\n    if label < 0 or label > dim:\n        return oneHot\n\n    oneHot[label] = 1\n\n    return oneHot",
            "masked_line": "oneHot = np.zeros(dim)",
            "answer": "zeros",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "downstream_application_code",
            "id": "downstream_application_code_block_1"
        },
        {
            "dependency": "spacy",
            "version": "==2.2.3",
            "time": "2019-02-20",
            "description": "This Python code reads input from stdin, tokenizes the text using the English language model from the spaCy library, and prints the tokenized words to stdout.",
            "code": "# Simple English tokenizer from stdin to stdout\n\nimport spacy\nimport fileinput\n\nnlp = spacy.load(\"en\", disable = [\"parser\", \"ner\"])\nfor line in fileinput.input():\n    print(\" \".join([word.text for word in nlp(line.strip())]))\n",
            "masked_code": "# Simple English tokenizer from stdin to stdout\n\nimport spacy\nimport fileinput\n\nnlp = spacy.load(\"en\", disable = [\"parser\", \"ner\"])\nfor line in fileinput.input():\n    <line_mask>\n",
            "masked_line": "print(\" \".join([word.text for word in nlp(line.strip())]))",
            "answer": "nlp",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "downstream_application_code",
            "id": "downstream_application_code_block_2"
        },
        {
            "dependency": "openai",
            "version": "==0.20.0",
            "time": "2023-05-12",
            "description": "This code defines two functions to interact with the OpenAI GPT-3 API. The first function, get_gpt3_response, takes in a text prompt and generates a response using the GPT-3 model with specified parameters. The function returns the generated text response. \nThe second function, get_gpt3_response_logprobs, also takes in a text prompt and generates a response using the GPT-3 model with specified parameters, but it also returns the log probabilities of each token in the generated response.",
            "code": "import openai\n\nAPI_KEY = \"ENTER YOUR OPENAI TOKEN HERE\"\nopenai.api_key  = API_KEY\n\n\ndef get_gpt3_response(text:str, temperature = 0.6, max_tokens = 50, top_p = 1, frequency_penalty=0.0,\n                      presence_penalty=0.0) -> str:\n\n    response = openai.Completion.create(\n        engine=\"text-davinci-002\",\n        prompt=text,\n        temperature=temperature,\n        max_tokens=max_tokens,\n        top_p=top_p,\n        frequency_penalty=frequency_penalty,\n        presence_penalty=presence_penalty,\n    )\n\n    return (response['choices'][0]['text'].strip())\n\n\ndef get_gpt3_response_logprobs(input:list, temperature = 0.6, max_tokens = 50, top_p = 1, frequency_penalty=0.0,\n                      presence_penalty=0.0):\n\n\n    response = openai.Completion.create(\n        echo = True,\n        logprobs = 5,\n        engine=\"text-davinci-002\",\n        prompt=input,\n        temperature=temperature,\n        max_tokens=max_tokens,\n        top_p=top_p,\n        frequency_penalty=frequency_penalty,\n        presence_penalty=presence_penalty,\n    )\n\n\n    logprobs = [(response['choices'][i]['logprobs']['tokens'],response['choices'][i]['logprobs']['token_logprobs'] )\n                for i in range(len(input))]\n    return logprobs\n",
            "masked_code": "import openai\n\nAPI_KEY = \"ENTER YOUR OPENAI TOKEN HERE\"\nopenai.api_key  = API_KEY\n\n\ndef get_gpt3_response(text:str, temperature = 0.6, max_tokens = 50, top_p = 1, frequency_penalty=0.0,\n                      presence_penalty=0.0) -> str:\n\n    response = openai.Completion.create(\n        engine=\"text-davinci-002\",\n        prompt=text,\n        temperature=temperature,\n        max_tokens=max_tokens,\n        top_p=top_p,\n        frequency_penalty=frequency_penalty,\n        presence_penalty=presence_penalty,\n    )\n\n    <line_mask>\n\n\ndef get_gpt3_response_logprobs(input:list, temperature = 0.6, max_tokens = 50, top_p = 1, frequency_penalty=0.0,\n                      presence_penalty=0.0):\n\n\n    response = openai.Completion.create(\n        echo = True,\n        logprobs = 5,\n        engine=\"text-davinci-002\",\n        prompt=input,\n        temperature=temperature,\n        max_tokens=max_tokens,\n        top_p=top_p,\n        frequency_penalty=frequency_penalty,\n        presence_penalty=presence_penalty,\n    )\n\n\n    logprobs = [(response['choices'][i]['logprobs']['tokens'],response['choices'][i]['logprobs']['token_logprobs'] )\n                for i in range(len(input))]\n    return logprobs\n",
            "masked_line": "return (response['choices'][0]['text'].strip())",
            "answer": "strip",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "downstream_application_code",
            "id": "downstream_application_code_block_3"
        },
        {
            "dependency": "spacy_stanza",
            "version": "==1.0.2",
            "time": "2022-09-19",
            "description": "This code defines a class called TaiwaneseTagger that extends Tagger and initializes a pipeline for processing Chinese (Traditional) text using spaCy and Stanza. It also loads a list of Chinese stop words.",
            "code": "from typing import Any\nimport spacy_stanza  # type: ignore\n\nfrom muda import Tagger\n\nfrom . import register_tagger\n\n\n@register_tagger(\"zh_tw_tagger\")\nclass TaiwaneseTagger(Tagger):\n    def __init__(self, **kwargs: Any) -> None:\n        super().__init__(**kwargs)\n\n        from spacy.lang.zh.stop_words import STOP_WORDS\n\n        self.stop_words = STOP_WORDS\n        self.tgt_pipeline = spacy_stanza.load_pipeline(\n            \"zh\", processors=\"tokenize,pos,lemma,depparse\"\n        )\n",
            "masked_code": "from typing import Any\nimport spacy_stanza  # type: ignore\n\nfrom muda import Tagger\n\nfrom . import register_tagger\n\n\n@register_tagger(\"zh_tw_tagger\")\nclass TaiwaneseTagger(Tagger):\n    def __init__(self, **kwargs: Any) -> None:\n        super().__init__(**kwargs)\n\n        from spacy.lang.zh.stop_words import STOP_WORDS\n\n        self.stop_words = STOP_WORDS\n        <line_mask>\n            \"zh\", processors=\"tokenize,pos,lemma,depparse\"\n        )\n",
            "masked_line": "self.tgt_pipeline = spacy_stanza.load_pipeline(",
            "answer": "load_pipeline",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "downstream_application_code",
            "id": "downstream_application_code_block_4"
        },
        {
            "dependency": "spacy",
            "version": "==3.3.0",
            "time": "2022-09-19",
            "description": "This code defines a class called TaiwaneseTagger that extends Tagger and initializes a pipeline for processing Chinese (Traditional) text using spaCy and Stanza. It also loads a list of Chinese stop words.",
            "code": "from typing import Any\nimport spacy_stanza  # type: ignore\n\nfrom muda import Tagger\n\nfrom . import register_tagger\n\n\n@register_tagger(\"zh_tw_tagger\")\nclass TaiwaneseTagger(Tagger):\n    def __init__(self, **kwargs: Any) -> None:\n        super().__init__(**kwargs)\n\n        from spacy.lang.zh.stop_words import STOP_WORDS\n\n        self.stop_words = STOP_WORDS\n        self.tgt_pipeline = spacy_stanza.load_pipeline(\n            \"zh\", processors=\"tokenize,pos,lemma,depparse\"\n        )\n",
            "masked_code": "from typing import Any\nimport spacy_stanza  # type: ignore\n\nfrom muda import Tagger\n\nfrom . import register_tagger\n\n\n@register_tagger(\"zh_tw_tagger\")\nclass TaiwaneseTagger(Tagger):\n    def __init__(self, **kwargs: Any) -> None:\n        super().__init__(**kwargs)\n\n        from spacy.lang.zh.stop_words import STOP_WORDS\n\n        self.stop_words = STOP_WORDS\n        <line_mask>\n            \"zh\", processors=\"tokenize,pos,lemma,depparse\"\n        )\n",
            "masked_line": "self.tgt_pipeline = spacy_stanza.load_pipeline(",
            "answer": "load_pipeline",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "downstream_application_code",
            "id": "downstream_application_code_block_5"
        },
        {
            "dependency": "numpy",
            "version": "==1.24.3",
            "time": "2023-05-25",
            "description": "This code is a function that takes a binary mask as input, checks if the total length of the mask is equal to the sum of its values, and if so, flips a randomly chosen value in the mask. Finally, it returns the modified mask.",
            "code": "import numpy as np\n\ndef mask_safe(mask):\n    tot_len = mask.shape[0]\n    mask_cnt = np.sum(mask.astype(np.int32))\n    range_i = np.arange(tot_len)\n    \n    if tot_len == mask_cnt or mask_cnt == 0:\n        idx = np.random.choice(range_i)\n        mask[idx] = 1 - mask[idx]\n    \n    return mask",
            "masked_code": "import numpy as np\n\ndef mask_safe(mask):\n    tot_len = mask.shape[0]\n    mask_cnt = np.sum(mask.astype(np.int32))\n    <line_mask>\n    \n    if tot_len == mask_cnt or mask_cnt == 0:\n        idx = np.random.choice(range_i)\n        mask[idx] = 1 - mask[idx]\n    \n    return mask",
            "masked_line": "range_i = np.arange(tot_len)",
            "answer": "arange",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "downstream_application_code",
            "id": "downstream_application_code_block_6"
        },
        {
            "dependency": "torch",
            "version": "==2.0.1",
            "time": "2023-05-25",
            "description": "The function `delete_noisy_char` removes noisy characters from a string and returns the cleaned string. The function `extend_vocab` extends a pretrained vocabulary by adding a new token and its corresponding vector to the vocabulary.",
            "code": "import torch\n\ndef delete_noisy_char(s):\n    s = (\n        s.replace(\",\", \" \")\n        .replace(\"/\", \" \")\n        .replace('\"', \" \")\n        .replace(\"-\", \" \")\n        .replace(\";\", \" \")\n        .replace(\".\", \" \")\n        .replace(\"&\", \" \")\n        .replace(\"?\", \" \")\n        .replace(\"!\", \" \")\n        .replace(\"(\", \" \")\n        .replace(\")\", \" \")\n    )\n    s = s.strip()\n    return s\n\ndef extend_vocab(pretrained_vocab, token, vector):\n    pretrained_vocab.itos.extend([token])\n    pretrained_vocab.stoi[token] = pretrained_vocab.vectors.shape[0]\n    pretrained_vocab.vectors = torch.cat([pretrained_vocab.vectors, vector], dim=0)\n\n\n",
            "masked_code": "import torch\n\ndef delete_noisy_char(s):\n    s = (\n        s.replace(\",\", \" \")\n        .replace(\"/\", \" \")\n        .replace('\"', \" \")\n        .replace(\"-\", \" \")\n        .replace(\";\", \" \")\n        .replace(\".\", \" \")\n        .replace(\"&\", \" \")\n        .replace(\"?\", \" \")\n        .replace(\"!\", \" \")\n        .replace(\"(\", \" \")\n        .replace(\")\", \" \")\n    )\n    s = s.strip()\n    return s\n\ndef extend_vocab(pretrained_vocab, token, vector):\n    <line_mask>\n    pretrained_vocab.stoi[token] = pretrained_vocab.vectors.shape[0]\n    pretrained_vocab.vectors = torch.cat([pretrained_vocab.vectors, vector], dim=0)\n\n\n",
            "masked_line": "pretrained_vocab.itos.extend([token])",
            "answer": "itos",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "downstream_application_code",
            "id": "downstream_application_code_block_7"
        },
        {
            "dependency": "psutil",
            "version": "==5.9.5",
            "time": "2023-05-25",
            "description": "This code returns the command line arguments of the current process as a single string.",
            "code": "import psutil\nimport os\n\ndef get_command():\n    my_process = psutil.Process( os.getpid() )\n    return \" \".join(my_process.cmdline())",
            "masked_code": "import psutil\nimport os\n\ndef get_command():\n    my_process = psutil.Process( os.getpid() )\n    <line_mask>",
            "masked_line": "return \" \".join(my_process.cmdline())",
            "answer": "cmdline",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "downstream_application_code",
            "id": "downstream_application_code_block_8"
        },
        {
            "dependency": "pybind11",
            "version": ">=2.6.0",
            "time": "2020-10-20",
            "description": "This Python code sets up the configuration for a package called 'submodlib', which is an efficient and scalable library for submodular optimization. The setup includes defining extension modules for C++ code, reading a long description from a README file, and specifying various package details like the name, version, description, author, email, URL, license, and dependencies.",
            "code": "#from glob import glob\nfrom setuptools import find_packages, setup\n\n# try:\n#     from pybind11.setup_helpers import Pybind11Extension, build_ext\n# except ImportError:\n#     from setuptools import Extension as Pybind11Extension\n# The above\n# is not eeded any more because it is available at setup time due to pyproject.toml\n# this is why setup_requires is also not needed\n\nfrom pybind11.setup_helpers import Pybind11Extension, build_ext\n\nimport sys\n\nwith open(\"README.md\", \"r\") as fh:\n    long_description = fh.read()\n\nexec(open('submodlib/version.py').read())\n\n#ParallelCompile(\"NPY_NUM_BUILD_JOBS\").install()\n\next_modules = [\n    Pybind11Extension(name=\"submodlib_cpp\",\n    sources=\n        [\"cpp/SetFunction.cpp\",\n        \"cpp/utils/helper.cpp\", \"cpp/wrappers/wr_helper.cpp\",\n        \"cpp/utils/sparse_utils.cpp\", \"cpp/wrappers/wr_sparse_utils.cpp\",\n        \"cpp/optimizers/NaiveGreedyOptimizer.cpp\", \n        \"cpp/optimizers/LazyGreedyOptimizer.cpp\", \n        \"cpp/optimizers/StochasticGreedyOptimizer.cpp\", \n        \"cpp/optimizers/LazierThanLazyGreedyOptimizer.cpp\", \n        \"cpp/wrappers/wrapper.cpp\", \n        \"cpp/submod/FacilityLocation.cpp\", \"cpp/wrappers/wr_FacilityLocation.cpp\", \n        \"cpp/submod/FacilityLocation2.cpp\", \"cpp/wrappers/wr_FacilityLocation2.cpp\", \n        \"cpp/submod/DisparitySum.cpp\", \"cpp/wrappers/wr_DisparitySum.cpp\", \n        \"cpp/submod/FeatureBased.cpp\", \"cpp/wrappers/wr_FeatureBased.cpp\", \n        \"cpp/submod/GraphCut.cpp\", \"cpp/wrappers/wr_GraphCut.cpp\", \n        \"cpp/submod/SetCover.cpp\", \"cpp/wrappers/wr_SetCover.cpp\", \n        \"cpp/submod/ProbabilisticSetCover.cpp\", \"cpp/wrappers/wr_ProbabilisticSetCover.cpp\", \n        \"cpp/submod/DisparityMin.cpp\", \"cpp/wrappers/wr_DisparityMin.cpp\", \n        \"cpp/submod/LogDeterminant.cpp\", \"cpp/wrappers/wr_LogDeterminant.cpp\", \n        \"cpp/smi/FacilityLocationMutualInformation.cpp\", \"cpp/wrappers/wr_FacilityLocationMutualInformation.cpp\", \n        \"cpp/smi/FacilityLocationVariantMutualInformation.cpp\", \"cpp/wrappers/wr_FacilityLocationVariantMutualInformation.cpp\", \n        \"cpp/smi/ConcaveOverModular.cpp\", \"cpp/wrappers/wr_ConcaveOverModular.cpp\", \n        \"cpp/smi/GraphCutMutualInformation.cpp\", \"cpp/wrappers/wr_GraphCutMutualInformation.cpp\", \n        \"cpp/condgain/GraphCutConditionalGain.cpp\", \"cpp/wrappers/wr_GraphCutConditionalGain.cpp\", \n        \"cpp/condgain/ConditionalGain.cpp\", \n        \"cpp/condgain/FacilityLocationConditionalGain.cpp\", \"cpp/wrappers/wr_FacilityLocationConditionalGain.cpp\", \n        \"cpp/condgain/LogDeterminantConditionalGain.cpp\", \"cpp/wrappers/wr_LogDeterminantConditionalGain.cpp\", \n        \"cpp/condgain/ProbabilisticSetCoverConditionalGain.cpp\", \"cpp/wrappers/wr_ProbabilisticSetCoverConditionalGain.cpp\", \n        \"cpp/smi/ProbabilisticSetCoverMutualInformation.cpp\", \"cpp/wrappers/wr_ProbabilisticSetCoverMutualInformation.cpp\", \n        \"cpp/smi/MutualInformation.cpp\", \n        \"cpp/smi/LogDeterminantMutualInformation.cpp\", \"cpp/wrappers/wr_LogDeterminantMutualInformation.cpp\", \n        \"cpp/smi/SetCoverMutualInformation.cpp\", \"cpp/wrappers/wr_SetCoverMutualInformation.cpp\", \n        \"cpp/condgain/SetCoverConditionalGain.cpp\", \"cpp/wrappers/wr_SetCoverConditionalGain.cpp\", \n        \"cpp/cmi/FacilityLocationConditionalMutualInformation.cpp\", \"cpp/wrappers/wr_FacilityLocationConditionalMutualInformation.cpp\", \n        \"cpp/cmi/LogDeterminantConditionalMutualInformation.cpp\", \"cpp/wrappers/wr_LogDeterminantConditionalMutualInformation.cpp\", \n        \"cpp/cmi/SetCoverConditionalMutualInformation.cpp\", \"cpp/wrappers/wr_SetCoverConditionalMutualInformation.cpp\", \n        \"cpp/cmi/ProbabilisticSetCoverConditionalMutualInformation.cpp\", \"cpp/wrappers/wr_ProbabilisticSetCoverConditionalMutualInformation.cpp\", \n        \"cpp/Clustered.cpp\", \"cpp/wrappers/wr_Clustered.cpp\"],\n        extra_compile_args=['-O3'],\n        #include_dirs=[\"cpp/\"],\n        # Example: passing in the version to the compiled code\n        #sorted(glob(\"cpp/submod/*.cpp\")),\n        define_macros = [('VERSION_INFO', __version__)],\n        ),\n]\n\nsetup(\n    name='submodlib',\n    #packages=find_packages(include=['submodlib']),\n    packages=['submodlib', 'submodlib/functions'],\n    #packages=find_packages('submodlib'),\n    #package_dir={'':'submodlib'},\n    #version='0.0.2',\n    version=__version__,\n    description='submodlib is an efficient and scalable library for submodular optimization which finds its application in summarization, data subset selection, hyper parameter tuning etc.',\n    long_description=long_description,\n    long_description_content_type=\"text/markdown\",\n    author='Vishal Kaushal',\n    cmdclass={\"build_ext\": build_ext},\n    ext_modules=ext_modules,\n    author_email='vishal.kaushal@gmail.com',\n    url=\"https://github.com/vishkaush/submodlib\",\n    #url='http://pypi.python.org/pypi/submodlib/',\n    #url=\"https://github.com/pypa/sampleproject\",\n    license='MIT',\n    # install_requires=[\n    #     \"numpy >= 1.14.2\",\n    #     \"scipy >= 1.0.0\",\n    #     \"numba >= 0.43.0\",\n    #     \"tqdm >= 4.24.0\",\n    #     \"nose\"\n    # ],\n    install_requires=[\"numpy==1.22.0\", \"scipy\", \"scikit-learn\", \"numba\"],\n    #setup_requires=['pybind11','pytest-runner'],\n    tests_require=['pytest'],\n    #extras_require={\"test\": \"pytest\"},\n    test_suite='tests',\n    #classifiers=[\n    #    \"Programming Language :: Python :: 3\",\n    #    \"License :: OSI Approved :: MIT License\",\n    #    \"Operating System :: OS Independent\",\n    #],\n    zip_safe=False \n)\n",
            "masked_code": "#from glob import glob\nfrom setuptools import find_packages, setup\n\n# try:\n#     from pybind11.setup_helpers import Pybind11Extension, build_ext\n# except ImportError:\n#     from setuptools import Extension as Pybind11Extension\n# The above\n# is not eeded any more because it is available at setup time due to pyproject.toml\n# this is why setup_requires is also not needed\n\n<line_mask>\n\nimport sys\n\nwith open(\"README.md\", \"r\") as fh:\n    long_description = fh.read()\n\nexec(open('submodlib/version.py').read())\n\n#ParallelCompile(\"NPY_NUM_BUILD_JOBS\").install()\n\next_modules = [\n    Pybind11Extension(name=\"submodlib_cpp\",\n    sources=\n        [\"cpp/SetFunction.cpp\",\n        \"cpp/utils/helper.cpp\", \"cpp/wrappers/wr_helper.cpp\",\n        \"cpp/utils/sparse_utils.cpp\", \"cpp/wrappers/wr_sparse_utils.cpp\",\n        \"cpp/optimizers/NaiveGreedyOptimizer.cpp\", \n        \"cpp/optimizers/LazyGreedyOptimizer.cpp\", \n        \"cpp/optimizers/StochasticGreedyOptimizer.cpp\", \n        \"cpp/optimizers/LazierThanLazyGreedyOptimizer.cpp\", \n        \"cpp/wrappers/wrapper.cpp\", \n        \"cpp/submod/FacilityLocation.cpp\", \"cpp/wrappers/wr_FacilityLocation.cpp\", \n        \"cpp/submod/FacilityLocation2.cpp\", \"cpp/wrappers/wr_FacilityLocation2.cpp\", \n        \"cpp/submod/DisparitySum.cpp\", \"cpp/wrappers/wr_DisparitySum.cpp\", \n        \"cpp/submod/FeatureBased.cpp\", \"cpp/wrappers/wr_FeatureBased.cpp\", \n        \"cpp/submod/GraphCut.cpp\", \"cpp/wrappers/wr_GraphCut.cpp\", \n        \"cpp/submod/SetCover.cpp\", \"cpp/wrappers/wr_SetCover.cpp\", \n        \"cpp/submod/ProbabilisticSetCover.cpp\", \"cpp/wrappers/wr_ProbabilisticSetCover.cpp\", \n        \"cpp/submod/DisparityMin.cpp\", \"cpp/wrappers/wr_DisparityMin.cpp\", \n        \"cpp/submod/LogDeterminant.cpp\", \"cpp/wrappers/wr_LogDeterminant.cpp\", \n        \"cpp/smi/FacilityLocationMutualInformation.cpp\", \"cpp/wrappers/wr_FacilityLocationMutualInformation.cpp\", \n        \"cpp/smi/FacilityLocationVariantMutualInformation.cpp\", \"cpp/wrappers/wr_FacilityLocationVariantMutualInformation.cpp\", \n        \"cpp/smi/ConcaveOverModular.cpp\", \"cpp/wrappers/wr_ConcaveOverModular.cpp\", \n        \"cpp/smi/GraphCutMutualInformation.cpp\", \"cpp/wrappers/wr_GraphCutMutualInformation.cpp\", \n        \"cpp/condgain/GraphCutConditionalGain.cpp\", \"cpp/wrappers/wr_GraphCutConditionalGain.cpp\", \n        \"cpp/condgain/ConditionalGain.cpp\", \n        \"cpp/condgain/FacilityLocationConditionalGain.cpp\", \"cpp/wrappers/wr_FacilityLocationConditionalGain.cpp\", \n        \"cpp/condgain/LogDeterminantConditionalGain.cpp\", \"cpp/wrappers/wr_LogDeterminantConditionalGain.cpp\", \n        \"cpp/condgain/ProbabilisticSetCoverConditionalGain.cpp\", \"cpp/wrappers/wr_ProbabilisticSetCoverConditionalGain.cpp\", \n        \"cpp/smi/ProbabilisticSetCoverMutualInformation.cpp\", \"cpp/wrappers/wr_ProbabilisticSetCoverMutualInformation.cpp\", \n        \"cpp/smi/MutualInformation.cpp\", \n        \"cpp/smi/LogDeterminantMutualInformation.cpp\", \"cpp/wrappers/wr_LogDeterminantMutualInformation.cpp\", \n        \"cpp/smi/SetCoverMutualInformation.cpp\", \"cpp/wrappers/wr_SetCoverMutualInformation.cpp\", \n        \"cpp/condgain/SetCoverConditionalGain.cpp\", \"cpp/wrappers/wr_SetCoverConditionalGain.cpp\", \n        \"cpp/cmi/FacilityLocationConditionalMutualInformation.cpp\", \"cpp/wrappers/wr_FacilityLocationConditionalMutualInformation.cpp\", \n        \"cpp/cmi/LogDeterminantConditionalMutualInformation.cpp\", \"cpp/wrappers/wr_LogDeterminantConditionalMutualInformation.cpp\", \n        \"cpp/cmi/SetCoverConditionalMutualInformation.cpp\", \"cpp/wrappers/wr_SetCoverConditionalMutualInformation.cpp\", \n        \"cpp/cmi/ProbabilisticSetCoverConditionalMutualInformation.cpp\", \"cpp/wrappers/wr_ProbabilisticSetCoverConditionalMutualInformation.cpp\", \n        \"cpp/Clustered.cpp\", \"cpp/wrappers/wr_Clustered.cpp\"],\n        extra_compile_args=['-O3'],\n        #include_dirs=[\"cpp/\"],\n        # Example: passing in the version to the compiled code\n        #sorted(glob(\"cpp/submod/*.cpp\")),\n        define_macros = [('VERSION_INFO', __version__)],\n        ),\n]\n\nsetup(\n    name='submodlib',\n    #packages=find_packages(include=['submodlib']),\n    packages=['submodlib', 'submodlib/functions'],\n    #packages=find_packages('submodlib'),\n    #package_dir={'':'submodlib'},\n    #version='0.0.2',\n    version=__version__,\n    description='submodlib is an efficient and scalable library for submodular optimization which finds its application in summarization, data subset selection, hyper parameter tuning etc.',\n    long_description=long_description,\n    long_description_content_type=\"text/markdown\",\n    author='Vishal Kaushal',\n    cmdclass={\"build_ext\": build_ext},\n    ext_modules=ext_modules,\n    author_email='vishal.kaushal@gmail.com',\n    url=\"https://github.com/vishkaush/submodlib\",\n    #url='http://pypi.python.org/pypi/submodlib/',\n    #url=\"https://github.com/pypa/sampleproject\",\n    license='MIT',\n    # install_requires=[\n    #     \"numpy >= 1.14.2\",\n    #     \"scipy >= 1.0.0\",\n    #     \"numba >= 0.43.0\",\n    #     \"tqdm >= 4.24.0\",\n    #     \"nose\"\n    # ],\n    install_requires=[\"numpy==1.22.0\", \"scipy\", \"scikit-learn\", \"numba\"],\n    #setup_requires=['pybind11','pytest-runner'],\n    tests_require=['pytest'],\n    #extras_require={\"test\": \"pytest\"},\n    test_suite='tests',\n    #classifiers=[\n    #    \"Programming Language :: Python :: 3\",\n    #    \"License :: OSI Approved :: MIT License\",\n    #    \"Operating System :: OS Independent\",\n    #],\n    zip_safe=False \n)\n",
            "masked_line": "from pybind11.setup_helpers import Pybind11Extension, build_ext",
            "answer": "Pybind11Extension",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "downstream_application_code",
            "id": "downstream_application_code_block_9"
        },
        {
            "dependency": "numpy",
            "version": "==1.22.0",
            "time": "2020-10-20",
            "description": "This code generates kernel matrices using different methods for similarity calculation, based on the groundData array. The methods used are \"sklearn\", \"rowwise\", and \"np\". The create_kernel function from the helper module is called with the specified method and metric (\"dot\" or \"cosine\"), and the resulting kernel matrix is printed.",
            "code": "import numpy as np\n#import submodlib_cpp as subcp\nimport submodlib.helper as helper\n\ngroundData =np.array( [(4.5,13.5), (5,13.5), (5.5,13.5)] )\n\n#methods = [\"sklearn\", \"fastdist\", \"scipy\", \"rowwise\", \"np\", \"np_numba\", \"other\"]\nmethods = [\"sklearn\", \"rowwise\", \"np\"]\n\nfor method in methods:\n    print(\"\\n***Kernel from \", method)\n    kernel = helper.create_kernel(groundData, metric=\"dot\", method=method)\n    print(kernel)\n\n# for method in methods:\n#     print(\"\\n***Kernel from \", method)\n#     kernel = helper.create_kernel(groundData, metric=\"cosine\", method=method)\n#     print(kernel)",
            "masked_code": "import numpy as np\n#import submodlib_cpp as subcp\nimport submodlib.helper as helper\n\n<line_mask>\n\n#methods = [\"sklearn\", \"fastdist\", \"scipy\", \"rowwise\", \"np\", \"np_numba\", \"other\"]\nmethods = [\"sklearn\", \"rowwise\", \"np\"]\n\nfor method in methods:\n    print(\"\\n***Kernel from \", method)\n    kernel = helper.create_kernel(groundData, metric=\"dot\", method=method)\n    print(kernel)\n\n# for method in methods:\n#     print(\"\\n***Kernel from \", method)\n#     kernel = helper.create_kernel(groundData, metric=\"cosine\", method=method)\n#     print(kernel)",
            "masked_line": "groundData =np.array( [(4.5,13.5), (5,13.5), (5.5,13.5)] )",
            "answer": "array",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "downstream_application_code",
            "id": "downstream_application_code_block_10"
        },
        {
            "dependency": "transformers",
            "version": ">=4.29.2",
            "time": "2022-03-28",
            "description": "This code uses a pre-trained transformer model to generate code based on the input text \"# this function prints hello world\". The generated code is then decoded using the model's tokenizer and printed as output.",
            "code": "from transformers import AutoTokenizer, AutoModelForCausalLM\n\ntokenizer = AutoTokenizer.from_pretrained(\"checkpoints/codegen2-6B\")\nmodel = CodeGenForCausalLM.from_pretrained(\"checkpoints/codegen2-6B\", torch_dtype=torch.float16, revision=\"sharded\")\ninputs = tokenizer(\"# this function prints hello world\", return_tensors=\"pt\")\nsample = model.generate(**inputs, max_length=128)\nprint(tokenizer.decode(sample[0], truncate_before_pattern=[r\"\\n\\n^#\", \"^'''\", \"\\n\\n\\n\"]))\n",
            "masked_code": "from transformers import AutoTokenizer, AutoModelForCausalLM\n\n<line_mask>\nmodel = CodeGenForCausalLM.from_pretrained(\"checkpoints/codegen2-6B\", torch_dtype=torch.float16, revision=\"sharded\")\ninputs = tokenizer(\"# this function prints hello world\", return_tensors=\"pt\")\nsample = model.generate(**inputs, max_length=128)\nprint(tokenizer.decode(sample[0], truncate_before_pattern=[r\"\\n\\n^#\", \"^'''\", \"\\n\\n\\n\"]))\n",
            "masked_line": "tokenizer = AutoTokenizer.from_pretrained(\"checkpoints/codegen2-6B\")",
            "answer": "from_pretrained",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "downstream_application_code",
            "id": "downstream_application_code_block_11"
        },
        {
            "dependency": "transformers",
            "version": ">=4.29.2",
            "time": "2022-03-28",
            "description": "The code generates a sequence of text based on a provided partial code snippet using a pretrained language model.",
            "code": "from transformers import AutoTokenizer, AutoModelForCausalLM\n\ntokenizer = AutoTokenizer.from_pretrained(\"checkpoints/codegen25-7b-multi\", trust_remote_code=True)\nmodel = AutoModelForCausalLM.from_pretrained(\"checkpoints/codegen25-7b-multi\")\ninputs = tokenizer(\"def hello_world():\", return_tensors=\"pt\")\nsample = model.generate(**inputs, max_length=128)\nprint(tokenizer.decode(sample[0], truncate_before_pattern=[r\"\\n\\n^#\", \"^'''\", \"\\n\\n\\n\"]))\n",
            "masked_code": "from transformers import AutoTokenizer, AutoModelForCausalLM\n\ntokenizer = AutoTokenizer.from_pretrained(\"checkpoints/codegen25-7b-multi\", trust_remote_code=True)\n<line_mask>\ninputs = tokenizer(\"def hello_world():\", return_tensors=\"pt\")\nsample = model.generate(**inputs, max_length=128)\nprint(tokenizer.decode(sample[0], truncate_before_pattern=[r\"\\n\\n^#\", \"^'''\", \"\\n\\n\\n\"]))\n",
            "masked_line": "model = AutoModelForCausalLM.from_pretrained(\"checkpoints/codegen25-7b-multi\")",
            "answer": "from_pretrained",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "downstream_application_code",
            "id": "downstream_application_code_block_12"
        },
        {
            "dependency": "torch",
            "version": ">=1.8.1",
            "time": "2018-06-18",
            "description": "This code ensures that only the first process performs a barrier synchronization using PyTorch's distributed communication library.",
            "code": "from contextlib import contextmanager\nimport torch\n\n\n@contextmanager\ndef only_first_process(local_rank):\n    if local_rank not in [-1, 0]:\n        # noinspection PyUnresolvedReferences\n        torch.distributed.barrier()\n\n    try:\n        yield\n    finally:\n        if local_rank == 0:\n            # noinspection PyUnresolvedReferences\n            torch.distributed.barrier()\n",
            "masked_code": "from contextlib import contextmanager\nimport torch\n\n\n@contextmanager\ndef only_first_process(local_rank):\n    if local_rank not in [-1, 0]:\n        # noinspection PyUnresolvedReferences\n        torch.distributed.barrier()\n\n    try:\n        yield\n    finally:\n        if local_rank == 0:\n            # noinspection PyUnresolvedReferences\n            <line_mask>\n",
            "masked_line": "torch.distributed.barrier()",
            "answer": "distributed",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "downstream_application_code",
            "id": "downstream_application_code_block_13"
        },
        {
            "dependency": "torch",
            "version": ">=1.7",
            "time": "2019-07-23",
            "description": "This code defines a custom dataset class called IdDataset that inherits from FairseqDataset. The __getitem__ method returns the index passed to it. The __len__ method returns the length of the dataset as 0. The collater method returns a PyTorch tensor containing the samples passed to it.",
            "code": "# Copyright (c) Facebook, Inc. and its affiliates.\n#\n# This source code is licensed under the MIT license found in the\n# LICENSE file in the root directory of this source tree.\n\nimport torch\n\nfrom . import FairseqDataset\n\n\nclass IdDataset(FairseqDataset):\n    def __getitem__(self, index):\n        return index\n\n    def __len__(self):\n        return 0\n\n    def collater(self, samples):\n        return torch.tensor(samples)\n",
            "masked_code": "# Copyright (c) Facebook, Inc. and its affiliates.\n#\n# This source code is licensed under the MIT license found in the\n# LICENSE file in the root directory of this source tree.\n\nimport torch\n\nfrom . import FairseqDataset\n\n\nclass IdDataset(FairseqDataset):\n    def __getitem__(self, index):\n        return index\n\n    def __len__(self):\n        return 0\n\n    def collater(self, samples):\n        <line_mask>\n",
            "masked_line": "return torch.tensor(samples)",
            "answer": "tensor",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "downstream_application_code",
            "id": "downstream_application_code_block_14"
        },
        {
            "dependency": "torch",
            "version": ">=1.7",
            "time": "2019-07-23",
            "description": "This code defines a class called RollDataset that inherits from BaseWrapperDataset. It takes a dataset and shifts as input parameters and rolls the items in the dataset by the specified shifts.",
            "code": "# Copyright (c) Facebook, Inc. and its affiliates.\n#\n# This source code is licensed under the MIT license found in the\n# LICENSE file in the root directory of this source tree.\n\nimport torch\n\nfrom . import BaseWrapperDataset\n\n\nclass RollDataset(BaseWrapperDataset):\n    def __init__(self, dataset, shifts):\n        super().__init__(dataset)\n        self.shifts = shifts\n\n    def __getitem__(self, index):\n        item = self.dataset[index]\n        return torch.roll(item, self.shifts)\n",
            "masked_code": "# Copyright (c) Facebook, Inc. and its affiliates.\n#\n# This source code is licensed under the MIT license found in the\n# LICENSE file in the root directory of this source tree.\n\nimport torch\n\nfrom . import BaseWrapperDataset\n\n\nclass RollDataset(BaseWrapperDataset):\n    def __init__(self, dataset, shifts):\n        super().__init__(dataset)\n        self.shifts = shifts\n\n    def __getitem__(self, index):\n        item = self.dataset[index]\n        <line_mask>\n",
            "masked_line": "return torch.roll(item, self.shifts)",
            "answer": "roll",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "downstream_application_code",
            "id": "downstream_application_code_block_15"
        },
        {
            "dependency": "torch",
            "version": ">=1.7",
            "time": "2019-07-23",
            "description": "This code defines a custom GroupNorm layer implemented in fp32 to be used during fp16 training. The forward method applies Group Normalization to the input tensor in fp32 format and returns the output tensor in the same data type as the input.",
            "code": "# Copyright (c) Facebook, Inc. and its affiliates.\n#\n# This source code is licensed under the MIT license found in the\n# LICENSE file in the root directory of this source tree.\n\"\"\"\nLayer norm done in fp32 (for fp16 training)\n\"\"\"\n\nimport torch.nn as nn\nimport torch.nn.functional as F\n\n\nclass Fp32GroupNorm(nn.GroupNorm):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n    def forward(self, input):\n        output = F.group_norm(\n            input.float(),\n            self.num_groups,\n            self.weight.float() if self.weight is not None else None,\n            self.bias.float() if self.bias is not None else None,\n            self.eps,\n        )\n        return output.type_as(input)\n",
            "masked_code": "# Copyright (c) Facebook, Inc. and its affiliates.\n#\n# This source code is licensed under the MIT license found in the\n# LICENSE file in the root directory of this source tree.\n\"\"\"\nLayer norm done in fp32 (for fp16 training)\n\"\"\"\n\nimport torch.nn as nn\nimport torch.nn.functional as F\n\n\nclass Fp32GroupNorm(nn.GroupNorm):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n    def forward(self, input):\n        output = F.group_norm(\n            input.float(),\n            self.num_groups,\n            self.weight.float() if self.weight is not None else None,\n            self.bias.float() if self.bias is not None else None,\n            self.eps,\n        )\n        <line_mask>\n",
            "masked_line": "return output.type_as(input)",
            "answer": "type_as",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "downstream_application_code",
            "id": "downstream_application_code_block_16"
        },
        {
            "dependency": "torch",
            "version": ">=1.7",
            "time": "2019-07-23",
            "description": "This code defines two functions for implementing the Gaussian Error Linear Units (GELUs) activation function in PyTorch: gelu_accurate and gelu. The gelu_accurate function calculates the GELU activation using a mathematical formula, while the gelu function uses the built-in PyTorch function nn.functional.gelu to compute the activation.",
            "code": "# Copyright (c) Facebook, Inc. and its affiliates.\n#\n# This source code is licensed under the MIT license found in the\n# LICENSE file in the root directory of this source tree.\n\"\"\"\nSee \"Gaussian Error Linear Units (GELUs)\" by Dan Hendrycks and Kevin Gimpel with\nthe corresponding GitHub repo: https://github.com/hendrycks/GELUs\n\"\"\"\n\nimport math\n\nimport torch\nimport torch.nn as nn\n\n\ndef gelu_accurate(x):\n    if not hasattr(gelu_accurate, \"_a\"):\n        gelu_accurate._a = math.sqrt(2 / math.pi)\n    return (\n        0.5 * x * (1 + torch.tanh(gelu_accurate._a * (x + 0.044715 * torch.pow(x, 3))))\n    )\n\n\ndef gelu(x: torch.Tensor) -> torch.Tensor:\n    return torch.nn.functional.gelu(x.float()).type_as(x)\n",
            "masked_code": "# Copyright (c) Facebook, Inc. and its affiliates.\n#\n# This source code is licensed under the MIT license found in the\n# LICENSE file in the root directory of this source tree.\n\"\"\"\nSee \"Gaussian Error Linear Units (GELUs)\" by Dan Hendrycks and Kevin Gimpel with\nthe corresponding GitHub repo: https://github.com/hendrycks/GELUs\n\"\"\"\n\nimport math\n\nimport torch\nimport torch.nn as nn\n\n\ndef gelu_accurate(x):\n    if not hasattr(gelu_accurate, \"_a\"):\n        gelu_accurate._a = math.sqrt(2 / math.pi)\n    return (\n        0.5 * x * (1 + torch.tanh(gelu_accurate._a * (x + 0.044715 * torch.pow(x, 3))))\n    )\n\n\ndef gelu(x: torch.Tensor) -> torch.Tensor:\n    <line_mask>\n",
            "masked_line": "return torch.nn.functional.gelu(x.float()).type_as(x)",
            "answer": "type_as",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "downstream_application_code",
            "id": "downstream_application_code_block_17"
        },
        {
            "dependency": "torch",
            "version": ">=1.7",
            "time": "2019-07-23",
            "description": "This function unfolds a 1-dimensional tensor along the time dimension, adding padding and creating a 4-dimensional output tensor.",
            "code": "# Copyright (c) Facebook, Inc. and its affiliates.\n#\n# This source code is licensed under the MIT license found in the\n# LICENSE file in the root directory of this source tree.\n\nimport torch.nn.functional as F\n\n\ndef unfold1d(x, kernel_size, padding_l, pad_value=0):\n    \"\"\"unfold T x B x C to T x B x C x K\"\"\"\n    if kernel_size > 1:\n        T, B, C = x.size()\n        x = F.pad(\n            x, (0, 0, 0, 0, padding_l, kernel_size - 1 - padding_l), value=pad_value\n        )\n        x = x.as_strided((T, B, C, kernel_size), (B * C, C, 1, B * C))\n    else:\n        x = x.unsqueeze(3)\n    return x\n",
            "masked_code": "# Copyright (c) Facebook, Inc. and its affiliates.\n#\n# This source code is licensed under the MIT license found in the\n# LICENSE file in the root directory of this source tree.\n\nimport torch.nn.functional as F\n\n\ndef unfold1d(x, kernel_size, padding_l, pad_value=0):\n    \"\"\"unfold T x B x C to T x B x C x K\"\"\"\n    if kernel_size > 1:\n        T, B, C = x.size()\n        x = F.pad(\n            x, (0, 0, 0, 0, padding_l, kernel_size - 1 - padding_l), value=pad_value\n        )\n        <line_mask>\n    else:\n        x = x.unsqueeze(3)\n    return x\n",
            "masked_line": "x = x.as_strided((T, B, C, kernel_size), (B * C, C, 1, B * C))",
            "answer": "as_strided",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "downstream_application_code",
            "id": "downstream_application_code_block_18"
        },
        {
            "dependency": "torch",
            "version": ">=1.7",
            "time": "2019-07-23",
            "description": "This code defines two functions, gelu_accurate and gelu, that implement the Gaussian Error Linear Units (GELUs) activation function. The gelu_accurate function calculates the GELU activation function using a mathematical formula, while the gelu function uses a built-in PyTorch function to compute the GELU activation function.",
            "code": "# Copyright (c) Facebook, Inc. and its affiliates.\n#\n# This source code is licensed under the MIT license found in the\n# LICENSE file in the root directory of this source tree.\n\"\"\"\nSee \"Gaussian Error Linear Units (GELUs)\" by Dan Hendrycks and Kevin Gimpel with\nthe corresponding GitHub repo: https://github.com/hendrycks/GELUs\n\"\"\"\n\nimport math\n\nimport torch\nimport torch.nn as nn\n\n\ndef gelu_accurate(x):\n    if not hasattr(gelu_accurate, \"_a\"):\n        gelu_accurate._a = math.sqrt(2 / math.pi)\n    return (\n        0.5 * x * (1 + torch.tanh(gelu_accurate._a * (x + 0.044715 * torch.pow(x, 3))))\n    )\n\n\ndef gelu(x: torch.Tensor) -> torch.Tensor:\n    return torch.nn.functional.gelu(x.float()).type_as(x)\n",
            "masked_code": "# Copyright (c) Facebook, Inc. and its affiliates.\n#\n# This source code is licensed under the MIT license found in the\n# LICENSE file in the root directory of this source tree.\n\"\"\"\nSee \"Gaussian Error Linear Units (GELUs)\" by Dan Hendrycks and Kevin Gimpel with\nthe corresponding GitHub repo: https://github.com/hendrycks/GELUs\n\"\"\"\n\nimport math\n\nimport torch\nimport torch.nn as nn\n\n\ndef gelu_accurate(x):\n    if not hasattr(gelu_accurate, \"_a\"):\n        gelu_accurate._a = math.sqrt(2 / math.pi)\n    return (\n        0.5 * x * (1 + torch.tanh(gelu_accurate._a * (x + 0.044715 * torch.pow(x, 3))))\n    )\n\n\ndef gelu(x: torch.Tensor) -> torch.Tensor:\n    <line_mask>\n",
            "masked_line": "return torch.nn.functional.gelu(x.float()).type_as(x)",
            "answer": "gelu",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "downstream_application_code",
            "id": "downstream_application_code_block_22"
        },
        {
            "dependency": "torch",
            "version": ">=1.7",
            "time": "2019-07-23",
            "description": "This function unfolds a 1-dimensional tensor along the time dimension to include a specified kernel size, padding, and pad value.",
            "code": "# Copyright (c) Facebook, Inc. and its affiliates.\n#\n# This source code is licensed under the MIT license found in the\n# LICENSE file in the root directory of this source tree.\n\nimport torch.nn.functional as F\n\n\ndef unfold1d(x, kernel_size, padding_l, pad_value=0):\n    \"\"\"unfold T x B x C to T x B x C x K\"\"\"\n    if kernel_size > 1:\n        T, B, C = x.size()\n        x = F.pad(\n            x, (0, 0, 0, 0, padding_l, kernel_size - 1 - padding_l), value=pad_value\n        )\n        x = x.as_strided((T, B, C, kernel_size), (B * C, C, 1, B * C))\n    else:\n        x = x.unsqueeze(3)\n    return x\n",
            "masked_code": "# Copyright (c) Facebook, Inc. and its affiliates.\n#\n# This source code is licensed under the MIT license found in the\n# LICENSE file in the root directory of this source tree.\n\nimport torch.nn.functional as F\n\n\ndef unfold1d(x, kernel_size, padding_l, pad_value=0):\n    \"\"\"unfold T x B x C to T x B x C x K\"\"\"\n    if kernel_size > 1:\n        <line_mask>\n        x = F.pad(\n            x, (0, 0, 0, 0, padding_l, kernel_size - 1 - padding_l), value=pad_value\n        )\n        x = x.as_strided((T, B, C, kernel_size), (B * C, C, 1, B * C))\n    else:\n        x = x.unsqueeze(3)\n    return x\n",
            "masked_line": "T, B, C = x.size()",
            "answer": "size",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "downstream_application_code",
            "id": "downstream_application_code_block_23"
        },
        {
            "dependency": "torch",
            "version": ">=1.7",
            "time": "2019-07-23",
            "description": "This code defines a unit test case for a normalization function in a speech recognition data utility module. The test input is a tensor of values, and the code applies a mean-variance normalization operation on the input tensor. The code then checks if there are no NaN values in the output tensor and if the output tensor is equal to the input tensor.",
            "code": "#!/usr/bin/env python3\n# Copyright (c) Facebook, Inc. and its affiliates.\n#\n# This source code is licensed under the MIT license found in the\n# LICENSE file in the root directory of this source tree.\nimport unittest\n\nimport torch\nfrom examples.speech_recognition.data import data_utils\n\n\nclass DataUtilsTest(unittest.TestCase):\n    def test_normalization(self):\n        sample_len1 = torch.tensor(\n            [\n                [\n                    -0.7661,\n                    -1.3889,\n                    -2.0972,\n                    -0.9134,\n                    -0.7071,\n                    -0.9765,\n                    -0.8700,\n                    -0.8283,\n                    0.7512,\n                    1.3211,\n                    2.1532,\n                    2.1174,\n                    1.2800,\n                    1.2633,\n                    1.6147,\n                    1.6322,\n                    2.0723,\n                    3.1522,\n                    3.2852,\n                    2.2309,\n                    2.5569,\n                    2.2183,\n                    2.2862,\n                    1.5886,\n                    0.8773,\n                    0.8725,\n                    1.2662,\n                    0.9899,\n                    1.1069,\n                    1.3926,\n                    1.2795,\n                    1.1199,\n                    1.1477,\n                    1.2687,\n                    1.3843,\n                    1.1903,\n                    0.8355,\n                    1.1367,\n                    1.2639,\n                    1.4707,\n                ]\n            ]\n        )\n        out = data_utils.apply_mv_norm(sample_len1)\n        assert not torch.isnan(out).any()\n        assert (out == sample_len1).all()\n",
            "masked_code": "#!/usr/bin/env python3\n# Copyright (c) Facebook, Inc. and its affiliates.\n#\n# This source code is licensed under the MIT license found in the\n# LICENSE file in the root directory of this source tree.\nimport unittest\n\nimport torch\nfrom examples.speech_recognition.data import data_utils\n\n\nclass DataUtilsTest(unittest.TestCase):\n    def test_normalization(self):\n        sample_len1 = torch.tensor(\n            [\n                [\n                    -0.7661,\n                    -1.3889,\n                    -2.0972,\n                    -0.9134,\n                    -0.7071,\n                    -0.9765,\n                    -0.8700,\n                    -0.8283,\n                    0.7512,\n                    1.3211,\n                    2.1532,\n                    2.1174,\n                    1.2800,\n                    1.2633,\n                    1.6147,\n                    1.6322,\n                    2.0723,\n                    3.1522,\n                    3.2852,\n                    2.2309,\n                    2.5569,\n                    2.2183,\n                    2.2862,\n                    1.5886,\n                    0.8773,\n                    0.8725,\n                    1.2662,\n                    0.9899,\n                    1.1069,\n                    1.3926,\n                    1.2795,\n                    1.1199,\n                    1.1477,\n                    1.2687,\n                    1.3843,\n                    1.1903,\n                    0.8355,\n                    1.1367,\n                    1.2639,\n                    1.4707,\n                ]\n            ]\n        )\n        out = data_utils.apply_mv_norm(sample_len1)\n        <line_mask>\n        assert (out == sample_len1).all()\n",
            "masked_line": "assert not torch.isnan(out).any()",
            "answer": "any",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "downstream_application_code",
            "id": "downstream_application_code_block_24"
        },
        {
            "dependency": "torch",
            "version": ">=1.7",
            "time": "2019-07-23",
            "description": "This code defines two functions for computing the Gaussian Error Linear Unit (GELU) activation function: gelu_accurate and gelu. The gelu_accurate function calculates the GELU activation function using a more accurate formula, while the gelu function uses the gelu implementation from the torch.nn.functional module.",
            "code": "# Copyright (c) Facebook, Inc. and its affiliates.\n#\n# This source code is licensed under the MIT license found in the\n# LICENSE file in the root directory of this source tree.\n\"\"\"\nSee \"Gaussian Error Linear Units (GELUs)\" by Dan Hendrycks and Kevin Gimpel with\nthe corresponding GitHub repo: https://github.com/hendrycks/GELUs\n\"\"\"\n\nimport math\n\nimport torch\nimport torch.nn as nn\n\n\ndef gelu_accurate(x):\n    if not hasattr(gelu_accurate, \"_a\"):\n        gelu_accurate._a = math.sqrt(2 / math.pi)\n    return (\n        0.5 * x * (1 + torch.tanh(gelu_accurate._a * (x + 0.044715 * torch.pow(x, 3))))\n    )\n\n\ndef gelu(x: torch.Tensor) -> torch.Tensor:\n    return torch.nn.functional.gelu(x.float()).type_as(x)\n",
            "masked_code": "# Copyright (c) Facebook, Inc. and its affiliates.\n#\n# This source code is licensed under the MIT license found in the\n# LICENSE file in the root directory of this source tree.\n\"\"\"\nSee \"Gaussian Error Linear Units (GELUs)\" by Dan Hendrycks and Kevin Gimpel with\nthe corresponding GitHub repo: https://github.com/hendrycks/GELUs\n\"\"\"\n\nimport math\n\nimport torch\nimport torch.nn as nn\n\n\ndef gelu_accurate(x):\n    if not hasattr(gelu_accurate, \"_a\"):\n        gelu_accurate._a = math.sqrt(2 / math.pi)\n    return (\n        0.5 * x * (1 + torch.tanh(gelu_accurate._a * (x + 0.044715 * torch.pow(x, 3))))\n    )\n\n\ndef gelu(x: torch.Tensor) -> torch.Tensor:\n    <line_mask>\n",
            "masked_line": "return torch.nn.functional.gelu(x.float()).type_as(x)",
            "answer": "functional",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "downstream_application_code",
            "id": "downstream_application_code_block_28"
        },
        {
            "dependency": "torch",
            "version": ">=1.7",
            "time": "2019-07-23",
            "description": "The code performs a unit test for normalization function in the data_utils module for speech recognition. It tests whether the output tensor after applying the mean-variance normalization to a sample tensor is not NaN and is equal to the original sample tensor.",
            "code": "#!/usr/bin/env python3\n# Copyright (c) Facebook, Inc. and its affiliates.\n#\n# This source code is licensed under the MIT license found in the\n# LICENSE file in the root directory of this source tree.\nimport unittest\n\nimport torch\nfrom examples.speech_recognition.data import data_utils\n\n\nclass DataUtilsTest(unittest.TestCase):\n    def test_normalization(self):\n        sample_len1 = torch.tensor(\n            [\n                [\n                    -0.7661,\n                    -1.3889,\n                    -2.0972,\n                    -0.9134,\n                    -0.7071,\n                    -0.9765,\n                    -0.8700,\n                    -0.8283,\n                    0.7512,\n                    1.3211,\n                    2.1532,\n                    2.1174,\n                    1.2800,\n                    1.2633,\n                    1.6147,\n                    1.6322,\n                    2.0723,\n                    3.1522,\n                    3.2852,\n                    2.2309,\n                    2.5569,\n                    2.2183,\n                    2.2862,\n                    1.5886,\n                    0.8773,\n                    0.8725,\n                    1.2662,\n                    0.9899,\n                    1.1069,\n                    1.3926,\n                    1.2795,\n                    1.1199,\n                    1.1477,\n                    1.2687,\n                    1.3843,\n                    1.1903,\n                    0.8355,\n                    1.1367,\n                    1.2639,\n                    1.4707,\n                ]\n            ]\n        )\n        out = data_utils.apply_mv_norm(sample_len1)\n        assert not torch.isnan(out).any()\n        assert (out == sample_len1).all()\n",
            "masked_code": "#!/usr/bin/env python3\n# Copyright (c) Facebook, Inc. and its affiliates.\n#\n# This source code is licensed under the MIT license found in the\n# LICENSE file in the root directory of this source tree.\nimport unittest\n\nimport torch\nfrom examples.speech_recognition.data import data_utils\n\n\nclass DataUtilsTest(unittest.TestCase):\n    def test_normalization(self):\n        sample_len1 = torch.tensor(\n            [\n                [\n                    -0.7661,\n                    -1.3889,\n                    -2.0972,\n                    -0.9134,\n                    -0.7071,\n                    -0.9765,\n                    -0.8700,\n                    -0.8283,\n                    0.7512,\n                    1.3211,\n                    2.1532,\n                    2.1174,\n                    1.2800,\n                    1.2633,\n                    1.6147,\n                    1.6322,\n                    2.0723,\n                    3.1522,\n                    3.2852,\n                    2.2309,\n                    2.5569,\n                    2.2183,\n                    2.2862,\n                    1.5886,\n                    0.8773,\n                    0.8725,\n                    1.2662,\n                    0.9899,\n                    1.1069,\n                    1.3926,\n                    1.2795,\n                    1.1199,\n                    1.1477,\n                    1.2687,\n                    1.3843,\n                    1.1903,\n                    0.8355,\n                    1.1367,\n                    1.2639,\n                    1.4707,\n                ]\n            ]\n        )\n        out = data_utils.apply_mv_norm(sample_len1)\n        <line_mask>\n        assert (out == sample_len1).all()\n",
            "masked_line": "assert not torch.isnan(out).any()",
            "answer": "isnan",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "downstream_application_code",
            "id": "downstream_application_code_block_30"
        },
        {
            "dependency": "torch",
            "version": ">=1.7",
            "time": "2019-07-23",
            "description": "This code defines a custom dataset class called IdDataset that inherits from FairseqDataset. It implements the __getitem__ method to return the index of the element in the dataset, the __len__ method to return the length of the dataset (which is always 0), and the collater method to convert a list of samples into a tensor using torch.",
            "code": "# Copyright (c) Facebook, Inc. and its affiliates.\n#\n# This source code is licensed under the MIT license found in the\n# LICENSE file in the root directory of this source tree.\n\nimport torch\n\nfrom . import FairseqDataset\n\n\nclass IdDataset(FairseqDataset):\n\n    def __getitem__(self, index):\n        return index\n\n    def __len__(self):\n        return 0\n\n    def collater(self, samples):\n        return torch.tensor(samples)\n",
            "masked_code": "# Copyright (c) Facebook, Inc. and its affiliates.\n#\n# This source code is licensed under the MIT license found in the\n# LICENSE file in the root directory of this source tree.\n\nimport torch\n\nfrom . import FairseqDataset\n\n\nclass IdDataset(FairseqDataset):\n\n    def __getitem__(self, index):\n        return index\n\n    def __len__(self):\n        return 0\n\n    def collater(self, samples):\n        <line_mask>\n",
            "masked_line": "return torch.tensor(samples)",
            "answer": "tensor",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "downstream_application_code",
            "id": "downstream_application_code_block_31"
        },
        {
            "dependency": "torch",
            "version": ">=1.7",
            "time": "2019-07-23",
            "description": "This code defines a class RollDataset that is a subclass of BaseWrapperDataset. It takes a dataset and shifts as input and rolls each item in the dataset by the specified shifts using torch.roll function.",
            "code": "# Copyright (c) Facebook, Inc. and its affiliates.\n#\n# This source code is licensed under the MIT license found in the\n# LICENSE file in the root directory of this source tree.\n\nimport torch\n\nfrom . import BaseWrapperDataset\n\n\nclass RollDataset(BaseWrapperDataset):\n\n    def __init__(self, dataset, shifts):\n        super().__init__(dataset)\n        self.shifts = shifts\n\n    def __getitem__(self, index):\n        item = self.dataset[index]\n        return torch.roll(item, self.shifts)\n",
            "masked_code": "# Copyright (c) Facebook, Inc. and its affiliates.\n#\n# This source code is licensed under the MIT license found in the\n# LICENSE file in the root directory of this source tree.\n\nimport torch\n\nfrom . import BaseWrapperDataset\n\n\nclass RollDataset(BaseWrapperDataset):\n\n    def __init__(self, dataset, shifts):\n        super().__init__(dataset)\n        self.shifts = shifts\n\n    def __getitem__(self, index):\n        item = self.dataset[index]\n        <line_mask>\n",
            "masked_line": "return torch.roll(item, self.shifts)",
            "answer": "roll",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "downstream_application_code",
            "id": "downstream_application_code_block_32"
        },
        {
            "dependency": "torch",
            "version": ">=1.7",
            "time": "2019-07-23",
            "description": "The function `LayerNorm` implements Layer Normalization, which normalizes the input tensor across a specified normalized shape, with options for setting epsilon, elementwise affine parameters, and whether to use CUDA if available. If CUDA is available and the `apex` package is installed, it uses the FusedLayerNorm implementation; otherwise, it falls back to the PyTorch `LayerNorm` implementation.",
            "code": "# Copyright (c) Facebook, Inc. and its affiliates.\n#\n# This source code is licensed under the MIT license found in the\n# LICENSE file in the root directory of this source tree.\n\nimport torch\n\n\ndef LayerNorm(normalized_shape, eps=1e-5, elementwise_affine=True, export=False):\n    if not export and torch.cuda.is_available():\n        try:\n            from apex.normalization import FusedLayerNorm\n            return FusedLayerNorm(normalized_shape, eps, elementwise_affine)\n        except ImportError:\n            pass\n    return torch.nn.LayerNorm(normalized_shape, eps, elementwise_affine)\n",
            "masked_code": "# Copyright (c) Facebook, Inc. and its affiliates.\n#\n# This source code is licensed under the MIT license found in the\n# LICENSE file in the root directory of this source tree.\n\nimport torch\n\n\ndef LayerNorm(normalized_shape, eps=1e-5, elementwise_affine=True, export=False):\n    <line_mask>\n        try:\n            from apex.normalization import FusedLayerNorm\n            return FusedLayerNorm(normalized_shape, eps, elementwise_affine)\n        except ImportError:\n            pass\n    return torch.nn.LayerNorm(normalized_shape, eps, elementwise_affine)\n",
            "masked_line": "if not export and torch.cuda.is_available():",
            "answer": "cuda",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "downstream_application_code",
            "id": "downstream_application_code_block_33"
        },
        {
            "dependency": "torch",
            "version": ">=1.7",
            "time": "2019-07-23",
            "description": "This function unfolds a 1-dimensional tensor along the third dimension, by padding and striding the input tensor based on the specified kernel size and padding parameters.",
            "code": "# Copyright (c) Facebook, Inc. and its affiliates.\n#\n# This source code is licensed under the MIT license found in the\n# LICENSE file in the root directory of this source tree.\n\nimport torch.nn.functional as F\n\n\ndef unfold1d(x, kernel_size, padding_l, pad_value=0):\n    '''unfold T x B x C to T x B x C x K'''\n    if kernel_size > 1:\n        T, B, C = x.size()\n        x = F.pad(x, (0, 0, 0, 0, padding_l, kernel_size - 1 - padding_l), value=pad_value)\n        x = x.as_strided((T, B, C, kernel_size), (B*C, C, 1, B*C))\n    else:\n        x = x.unsqueeze(3)\n    return x\n",
            "masked_code": "# Copyright (c) Facebook, Inc. and its affiliates.\n#\n# This source code is licensed under the MIT license found in the\n# LICENSE file in the root directory of this source tree.\n\nimport torch.nn.functional as F\n\n\ndef unfold1d(x, kernel_size, padding_l, pad_value=0):\n    '''unfold T x B x C to T x B x C x K'''\n    if kernel_size > 1:\n        T, B, C = x.size()\n        x = F.pad(x, (0, 0, 0, 0, padding_l, kernel_size - 1 - padding_l), value=pad_value)\n        <line_mask>\n    else:\n        x = x.unsqueeze(3)\n    return x\n",
            "masked_line": "x = x.as_strided((T, B, C, kernel_size), (B*C, C, 1, B*C))",
            "answer": "as_strided",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "downstream_application_code",
            "id": "downstream_application_code_block_34"
        },
        {
            "dependency": "torch",
            "version": ">=1.7",
            "time": "2019-07-23",
            "description": "The function defined in the provided Python code calculates the Gaussian Error Linear Unit (GELU) activation function. The function implements an accurate version of GELU using a mathematical formula that involves basic arithmetic operations and hyperbolic tangent function. The code also includes a more efficient version of GELU using the PyTorch library's built-in functionality.",
            "code": "# Copyright (c) Facebook, Inc. and its affiliates.\n#\n# This source code is licensed under the MIT license found in the\n# LICENSE file in the root directory of this source tree.\n\"\"\"\nSee \"Gaussian Error Linear Units (GELUs)\" by Dan Hendrycks and Kevin Gimpel with\nthe corresponding GitHub repo: https://github.com/hendrycks/GELUs\n\"\"\"\n\nimport math\n\nimport torch\nimport torch.nn as nn\n\n\ndef gelu_accurate(x):\n    if not hasattr(gelu_accurate, \"_a\"):\n        gelu_accurate._a = math.sqrt(2 / math.pi)\n    return (\n        0.5 * x * (1 + torch.tanh(gelu_accurate._a * (x + 0.044715 * torch.pow(x, 3))))\n    )\n\n\ndef gelu(x: torch.Tensor) -> torch.Tensor:\n    return torch.nn.functional.gelu(x.float()).type_as(x)\n",
            "masked_code": "# Copyright (c) Facebook, Inc. and its affiliates.\n#\n# This source code is licensed under the MIT license found in the\n# LICENSE file in the root directory of this source tree.\n\"\"\"\nSee \"Gaussian Error Linear Units (GELUs)\" by Dan Hendrycks and Kevin Gimpel with\nthe corresponding GitHub repo: https://github.com/hendrycks/GELUs\n\"\"\"\n\nimport math\n\nimport torch\nimport torch.nn as nn\n\n\ndef gelu_accurate(x):\n    if not hasattr(gelu_accurate, \"_a\"):\n        gelu_accurate._a = math.sqrt(2 / math.pi)\n    return (\n        0.5 * x * (1 + torch.tanh(gelu_accurate._a * (x + 0.044715 * torch.pow(x, 3))))\n    )\n\n\ndef gelu(x: torch.Tensor) -> torch.Tensor:\n    <line_mask>\n",
            "masked_line": "return torch.nn.functional.gelu(x.float()).type_as(x)",
            "answer": "nn",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "downstream_application_code",
            "id": "downstream_application_code_block_38"
        },
        {
            "dependency": "torch",
            "version": ">=1.7",
            "time": "2019-07-23",
            "description": "This code defines a function named `unfold1d` that takes input x of shape T x B x C and unfolds it to shape T x B x C x K where K is the kernel size. The function pads the input x with pad_value if the kernel size is greater than 1 and then reshapes it using the strided view. If the kernel size is 1, it simply adds a dimension to the input x.",
            "code": "# Copyright (c) Facebook, Inc. and its affiliates.\n#\n# This source code is licensed under the MIT license found in the\n# LICENSE file in the root directory of this source tree.\n\nimport torch.nn.functional as F\n\n\ndef unfold1d(x, kernel_size, padding_l, pad_value=0):\n    \"\"\"unfold T x B x C to T x B x C x K\"\"\"\n    if kernel_size > 1:\n        T, B, C = x.size()\n        x = F.pad(\n            x, (0, 0, 0, 0, padding_l, kernel_size - 1 - padding_l), value=pad_value\n        )\n        x = x.as_strided((T, B, C, kernel_size), (B * C, C, 1, B * C))\n    else:\n        x = x.unsqueeze(3)\n    return x\n",
            "masked_code": "# Copyright (c) Facebook, Inc. and its affiliates.\n#\n# This source code is licensed under the MIT license found in the\n# LICENSE file in the root directory of this source tree.\n\nimport torch.nn.functional as F\n\n\ndef unfold1d(x, kernel_size, padding_l, pad_value=0):\n    \"\"\"unfold T x B x C to T x B x C x K\"\"\"\n    if kernel_size > 1:\n        T, B, C = x.size()\n        <line_mask>\n            x, (0, 0, 0, 0, padding_l, kernel_size - 1 - padding_l), value=pad_value\n        )\n        x = x.as_strided((T, B, C, kernel_size), (B * C, C, 1, B * C))\n    else:\n        x = x.unsqueeze(3)\n    return x\n",
            "masked_line": "x = F.pad(",
            "answer": "pad",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "downstream_application_code",
            "id": "downstream_application_code_block_39"
        },
        {
            "dependency": "torch",
            "version": ">=1.7",
            "time": "2019-07-23",
            "description": "This function unfolds a 3D tensor along the last dimension, adding an extra dimension based on the specified kernel size and padding.",
            "code": "# Copyright (c) Facebook, Inc. and its affiliates.\n#\n# This source code is licensed under the MIT license found in the\n# LICENSE file in the root directory of this source tree.\n\nimport torch.nn.functional as F\n\n\ndef unfold1d(x, kernel_size, padding_l, pad_value=0):\n    \"\"\"unfold T x B x C to T x B x C x K\"\"\"\n    if kernel_size > 1:\n        T, B, C = x.size()\n        x = F.pad(\n            x, (0, 0, 0, 0, padding_l, kernel_size - 1 - padding_l), value=pad_value\n        )\n        x = x.as_strided((T, B, C, kernel_size), (B * C, C, 1, B * C))\n    else:\n        x = x.unsqueeze(3)\n    return x\n",
            "masked_code": "# Copyright (c) Facebook, Inc. and its affiliates.\n#\n# This source code is licensed under the MIT license found in the\n# LICENSE file in the root directory of this source tree.\n\nimport torch.nn.functional as F\n\n\ndef unfold1d(x, kernel_size, padding_l, pad_value=0):\n    \"\"\"unfold T x B x C to T x B x C x K\"\"\"\n    if kernel_size > 1:\n        T, B, C = x.size()\n        x = F.pad(\n            x, (0, 0, 0, 0, padding_l, kernel_size - 1 - padding_l), value=pad_value\n        )\n        x = x.as_strided((T, B, C, kernel_size), (B * C, C, 1, B * C))\n    else:\n        <line_mask>\n    return x\n",
            "masked_line": "x = x.unsqueeze(3)",
            "answer": "unsqueeze",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "downstream_application_code",
            "id": "downstream_application_code_block_44"
        },
        {
            "dependency": "torch",
            "version": ">=1.7",
            "time": "2019-07-23",
            "description": "This code sets up the configuration and dependencies for the LayoutLM project, including specifying the project name, version, author, URL, description, required packages, and optional development dependencies.",
            "code": "#!/usr/bin/env python3\nimport torch\nfrom setuptools import find_packages, setup\n\ntorch_ver = [int(x) for x in torch.__version__.split(\".\")[:2]]\nassert torch_ver >= [1, 4], \"Requires PyTorch >= 1.4\"\n\nsetup(\n    name=\"layoutlm\",\n    version=\"0.0\",\n    author=\"Yiheng Xu\",\n    url=\"https://github.com/microsoft/unilm/tree/master/layoutlm\",\n    description=\"LayoutLM\",\n    packages=find_packages(exclude=(\"configs\", \"tests\")),\n    python_requires=\">=3.6\",\n    install_requires=[\n        \"transformers==2.9.0\",\n        \"tensorboardX==2.0\",\n        \"lxml==4.9.1\",\n        \"seqeval==0.0.12\",\n        \"Pillow==9.3.0\",\n    ],\n    extras_require={\n        \"dev\": [\"flake8==3.8.2\", \"isort==4.3.21\", \"black==19.10b0\", \"pre-commit==2.4.0\"]\n    },\n)\n",
            "masked_code": "#!/usr/bin/env python3\nimport torch\nfrom setuptools import find_packages, setup\n\n<line_mask>\nassert torch_ver >= [1, 4], \"Requires PyTorch >= 1.4\"\n\nsetup(\n    name=\"layoutlm\",\n    version=\"0.0\",\n    author=\"Yiheng Xu\",\n    url=\"https://github.com/microsoft/unilm/tree/master/layoutlm\",\n    description=\"LayoutLM\",\n    packages=find_packages(exclude=(\"configs\", \"tests\")),\n    python_requires=\">=3.6\",\n    install_requires=[\n        \"transformers==2.9.0\",\n        \"tensorboardX==2.0\",\n        \"lxml==4.9.1\",\n        \"seqeval==0.0.12\",\n        \"Pillow==9.3.0\",\n    ],\n    extras_require={\n        \"dev\": [\"flake8==3.8.2\", \"isort==4.3.21\", \"black==19.10b0\", \"pre-commit==2.4.0\"]\n    },\n)\n",
            "masked_line": "torch_ver = [int(x) for x in torch.__version__.split(\".\")[:2]]",
            "answer": "__version__",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "downstream_application_code",
            "id": "downstream_application_code_block_45"
        },
        {
            "dependency": "transformers",
            "version": ">=4.15.0",
            "time": "2019-07-23",
            "description": "This code defines a custom configuration class named LayoutXLMConfig that inherits from LayoutLMv2Config and sets the model_type attribute to \"layoutxlm\". It also provides a mapping of pre-trained model configurations for LayoutXLM models.",
            "code": "# coding=utf-8\nfrom transformers.utils import logging\n\nfrom ..layoutlmv2 import LayoutLMv2Config\n\n\nlogger = logging.get_logger(__name__)\n\nLAYOUTXLM_PRETRAINED_CONFIG_ARCHIVE_MAP = {\n    \"layoutxlm-base\": \"https://huggingface.co/layoutxlm-base/resolve/main/config.json\",\n    \"layoutxlm-large\": \"https://huggingface.co/layoutxlm-large/resolve/main/config.json\",\n}\n\n\nclass LayoutXLMConfig(LayoutLMv2Config):\n    model_type = \"layoutxlm\"\n",
            "masked_code": "# coding=utf-8\nfrom transformers.utils import logging\n\nfrom ..layoutlmv2 import LayoutLMv2Config\n\n\n<line_mask>\n\nLAYOUTXLM_PRETRAINED_CONFIG_ARCHIVE_MAP = {\n    \"layoutxlm-base\": \"https://huggingface.co/layoutxlm-base/resolve/main/config.json\",\n    \"layoutxlm-large\": \"https://huggingface.co/layoutxlm-large/resolve/main/config.json\",\n}\n\n\nclass LayoutXLMConfig(LayoutLMv2Config):\n    model_type = \"layoutxlm\"\n",
            "masked_line": "logger = logging.get_logger(__name__)",
            "answer": "get_logger",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "downstream_application_code",
            "id": "downstream_application_code_block_46"
        },
        {
            "dependency": "transformers",
            "version": ">=4.15.0",
            "time": "2019-07-23",
            "description": "This code defines a tokenization class for LayoutLMv3 model, which is based on RoBERTa. The class extends the RobertaTokenizer class and specifies the vocabulary files names for the tokenizer.",
            "code": "# coding=utf-8\n# Copyright 2018 The Open AI Team Authors and The HuggingFace Inc. team.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\"\"\"Tokenization classes for LayoutLMv3, refer to RoBERTa.\"\"\"\n\nfrom transformers.models.roberta import RobertaTokenizer\nfrom transformers.utils import logging\n\n\nlogger = logging.get_logger(__name__)\n\nVOCAB_FILES_NAMES = {\n    \"vocab_file\": \"vocab.json\",\n    \"merges_file\": \"merges.txt\",\n}\n\nclass LayoutLMv3Tokenizer(RobertaTokenizer):\n    vocab_files_names = VOCAB_FILES_NAMES\n    # pretrained_vocab_files_map = PRETRAINED_VOCAB_FILES_MAP\n    # max_model_input_sizes = PRETRAINED_POSITIONAL_EMBEDDINGS_SIZES\n    model_input_names = [\"input_ids\", \"attention_mask\"]\n",
            "masked_code": "# coding=utf-8\n# Copyright 2018 The Open AI Team Authors and The HuggingFace Inc. team.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\"\"\"Tokenization classes for LayoutLMv3, refer to RoBERTa.\"\"\"\n\nfrom transformers.models.roberta import RobertaTokenizer\nfrom transformers.utils import logging\n\n\n<line_mask>\n\nVOCAB_FILES_NAMES = {\n    \"vocab_file\": \"vocab.json\",\n    \"merges_file\": \"merges.txt\",\n}\n\nclass LayoutLMv3Tokenizer(RobertaTokenizer):\n    vocab_files_names = VOCAB_FILES_NAMES\n    # pretrained_vocab_files_map = PRETRAINED_VOCAB_FILES_MAP\n    # max_model_input_sizes = PRETRAINED_POSITIONAL_EMBEDDINGS_SIZES\n    model_input_names = [\"input_ids\", \"attention_mask\"]\n",
            "masked_line": "logger = logging.get_logger(__name__)",
            "answer": "get_logger",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "downstream_application_code",
            "id": "downstream_application_code_block_47"
        },
        {
            "dependency": "transformers",
            "version": ">=4.15.0",
            "time": "2019-07-23",
            "description": "This code defines a fast tokenization class for LayoutLMv3 model, which is based on RoBERTa.",
            "code": "# coding=utf-8\n# Copyright 2018 The Open AI Team Authors and The HuggingFace Inc. team.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\"\"\"Fast Tokenization classes for LayoutLMv3, refer to RoBERTa.\"\"\"\n\n\nfrom transformers.models.roberta.tokenization_roberta_fast import RobertaTokenizerFast\nfrom transformers.utils import logging\n\nfrom .tokenization_layoutlmv3 import LayoutLMv3Tokenizer\n\n\nlogger = logging.get_logger(__name__)\n\nVOCAB_FILES_NAMES = {\"vocab_file\": \"vocab.json\", \"merges_file\": \"merges.txt\", \"tokenizer_file\": \"tokenizer.json\"}\n\n\nclass LayoutLMv3TokenizerFast(RobertaTokenizerFast):\n    vocab_files_names = VOCAB_FILES_NAMES\n    # pretrained_vocab_files_map = PRETRAINED_VOCAB_FILES_MAP\n    # max_model_input_sizes = PRETRAINED_POSITIONAL_EMBEDDINGS_SIZES\n    model_input_names = [\"input_ids\", \"attention_mask\"]\n    slow_tokenizer_class = LayoutLMv3Tokenizer\n",
            "masked_code": "# coding=utf-8\n# Copyright 2018 The Open AI Team Authors and The HuggingFace Inc. team.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\"\"\"Fast Tokenization classes for LayoutLMv3, refer to RoBERTa.\"\"\"\n\n\nfrom transformers.models.roberta.tokenization_roberta_fast import RobertaTokenizerFast\nfrom transformers.utils import logging\n\nfrom .tokenization_layoutlmv3 import LayoutLMv3Tokenizer\n\n\n<line_mask>\n\nVOCAB_FILES_NAMES = {\"vocab_file\": \"vocab.json\", \"merges_file\": \"merges.txt\", \"tokenizer_file\": \"tokenizer.json\"}\n\n\nclass LayoutLMv3TokenizerFast(RobertaTokenizerFast):\n    vocab_files_names = VOCAB_FILES_NAMES\n    # pretrained_vocab_files_map = PRETRAINED_VOCAB_FILES_MAP\n    # max_model_input_sizes = PRETRAINED_POSITIONAL_EMBEDDINGS_SIZES\n    model_input_names = [\"input_ids\", \"attention_mask\"]\n    slow_tokenizer_class = LayoutLMv3Tokenizer\n",
            "masked_line": "logger = logging.get_logger(__name__)",
            "answer": "get_logger",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "downstream_application_code",
            "id": "downstream_application_code_block_48"
        },
        {
            "dependency": "transformers",
            "version": ">=4.15.0",
            "time": "2019-07-23",
            "description": "This code snippet updates various mapping dictionaries to include MarkupLM related configurations, tokenizers, converters, and models for question answering and token classification.",
            "code": "from transformers import CONFIG_MAPPING, MODEL_FOR_QUESTION_ANSWERING_MAPPING, \\\n    MODEL_FOR_TOKEN_CLASSIFICATION_MAPPING, MODEL_NAMES_MAPPING, TOKENIZER_MAPPING\nfrom transformers.convert_slow_tokenizer import SLOW_TO_FAST_CONVERTERS, RobertaConverter\nfrom transformers.file_utils import PRESET_MIRROR_DICT\n\nfrom .models.markuplm import (\n    MarkupLMConfig,\n    MarkupLMTokenizer,\n    MarkupLMForQuestionAnswering,\n    MarkupLMForTokenClassification,\n    MarkupLMTokenizerFast,\n)\n\nCONFIG_MAPPING.update(\n    [\n        (\"markuplm\", MarkupLMConfig),\n    ]\n)\nMODEL_NAMES_MAPPING.update([(\"markuplm\", \"MarkupLM\")])\n\nTOKENIZER_MAPPING.update(\n    [\n        (MarkupLMConfig, (MarkupLMTokenizer, MarkupLMTokenizerFast)),\n    ]\n)\n\nSLOW_TO_FAST_CONVERTERS.update(\n    {\"MarkupLMTokenizer\": RobertaConverter}\n)\n\nMODEL_FOR_QUESTION_ANSWERING_MAPPING.update(\n    [(MarkupLMConfig, MarkupLMForQuestionAnswering)]\n)\n\nMODEL_FOR_TOKEN_CLASSIFICATION_MAPPING.update(\n    [(MarkupLMConfig, MarkupLMForTokenClassification)]\n)\n",
            "masked_code": "from transformers import CONFIG_MAPPING, MODEL_FOR_QUESTION_ANSWERING_MAPPING, \\\n    MODEL_FOR_TOKEN_CLASSIFICATION_MAPPING, MODEL_NAMES_MAPPING, TOKENIZER_MAPPING\nfrom transformers.convert_slow_tokenizer import SLOW_TO_FAST_CONVERTERS, RobertaConverter\nfrom transformers.file_utils import PRESET_MIRROR_DICT\n\nfrom .models.markuplm import (\n    MarkupLMConfig,\n    MarkupLMTokenizer,\n    MarkupLMForQuestionAnswering,\n    MarkupLMForTokenClassification,\n    MarkupLMTokenizerFast,\n)\n\nCONFIG_MAPPING.update(\n    [\n        (\"markuplm\", MarkupLMConfig),\n    ]\n)\nMODEL_NAMES_MAPPING.update([(\"markuplm\", \"MarkupLM\")])\n\nTOKENIZER_MAPPING.update(\n    [\n        (MarkupLMConfig, (MarkupLMTokenizer, MarkupLMTokenizerFast)),\n    ]\n)\n\nSLOW_TO_FAST_CONVERTERS.update(\n    {\"MarkupLMTokenizer\": RobertaConverter}\n)\n\nMODEL_FOR_QUESTION_ANSWERING_MAPPING.update(\n    [(MarkupLMConfig, MarkupLMForQuestionAnswering)]\n)\n\n<line_mask>\n    [(MarkupLMConfig, MarkupLMForTokenClassification)]\n)\n",
            "masked_line": "MODEL_FOR_TOKEN_CLASSIFICATION_MAPPING.update(",
            "answer": "update",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "downstream_application_code",
            "id": "downstream_application_code_block_49"
        },
        {
            "dependency": "transformers",
            "version": ">=4.9.2",
            "time": "2022-05-25",
            "description": "The code initializes a model for Python code tokenization, loads a tokenizer, configures model settings for Mistral stability tweaks, loads a GPT-2 large model configuration, initializes a new model with the configuration, and saves the model to the hub.",
            "code": "from arguments import InitializationArguments\nfrom transformers import AutoConfig, AutoModelForCausalLM, AutoTokenizer, HfArgumentParser\n\n\n# Configuration\nparser = HfArgumentParser(InitializationArguments)\nargs = parser.parse_args()\n\n# Load codeparrot tokenizer trained for Python code tokenization\ntokenizer = AutoTokenizer.from_pretrained(args.tokenizer_name)\n\n# Config: \"scale_attn_by_layer_idx\" and \"reorder_and_upcast_attn\" are Mistral stability tweaks\nconfig_kwargs = {\"vocab_size\": len(tokenizer), \"scale_attn_by_layer_idx\": True, \"reorder_and_upcast_attn\": True}\n\n# Load model config (GPT-2 large in this case)\nconfig = AutoConfig.from_pretrained(args.config_name, **config_kwargs)\n\n# Initialize new model with config\nmodel = AutoModelForCausalLM(config)\n\n# Save model to the hub\nmodel.save_pretrained(args.model_name, push_to_hub=args.push_to_hub)\n",
            "masked_code": "from arguments import InitializationArguments\nfrom transformers import AutoConfig, AutoModelForCausalLM, AutoTokenizer, HfArgumentParser\n\n\n# Configuration\nparser = HfArgumentParser(InitializationArguments)\n<line_mask>\n\n# Load codeparrot tokenizer trained for Python code tokenization\ntokenizer = AutoTokenizer.from_pretrained(args.tokenizer_name)\n\n# Config: \"scale_attn_by_layer_idx\" and \"reorder_and_upcast_attn\" are Mistral stability tweaks\nconfig_kwargs = {\"vocab_size\": len(tokenizer), \"scale_attn_by_layer_idx\": True, \"reorder_and_upcast_attn\": True}\n\n# Load model config (GPT-2 large in this case)\nconfig = AutoConfig.from_pretrained(args.config_name, **config_kwargs)\n\n# Initialize new model with config\nmodel = AutoModelForCausalLM(config)\n\n# Save model to the hub\nmodel.save_pretrained(args.model_name, push_to_hub=args.push_to_hub)\n",
            "masked_line": "args = parser.parse_args()",
            "answer": "parse_args",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "downstream_application_code",
            "id": "downstream_application_code_block_51"
        },
        {
            "dependency": "torch",
            "version": ">=1.5.0",
            "time": "2022-05-25",
            "description": "This script outputs information about the environment, such as the Torch version, CUDA availability, CUDA version, CuDNN version, number of GPUs available, and NCCL version.",
            "code": "#!/usr/bin/env python3\n\n# coding=utf-8\n# Copyright 2020 The HuggingFace Inc. team.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# this script dumps information about the environment\n\nimport torch\n\n\nprint(\"Torch version:\", torch.__version__)\nprint(\"Cuda available:\", torch.cuda.is_available())\nprint(\"Cuda version:\", torch.version.cuda)\nprint(\"CuDNN version:\", torch.backends.cudnn.version())\nprint(\"Number of GPUs available:\", torch.cuda.device_count())\nprint(\"NCCL version:\", torch.cuda.nccl.version())\n",
            "masked_code": "#!/usr/bin/env python3\n\n# coding=utf-8\n# Copyright 2020 The HuggingFace Inc. team.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# this script dumps information about the environment\n\nimport torch\n\n\nprint(\"Torch version:\", torch.__version__)\nprint(\"Cuda available:\", torch.cuda.is_available())\nprint(\"Cuda version:\", torch.version.cuda)\nprint(\"CuDNN version:\", torch.backends.cudnn.version())\n<line_mask>\nprint(\"NCCL version:\", torch.cuda.nccl.version())\n",
            "masked_line": "print(\"Number of GPUs available:\", torch.cuda.device_count())",
            "answer": "device_count",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "downstream_application_code",
            "id": "downstream_application_code_block_52"
        },
        {
            "dependency": "torch",
            "version": ">=1.7.0",
            "time": "2022-08-07",
            "description": "The function get_optimizer(config, parameters) returns an optimizer based on the provided configuration (config) and model parameters (parameters). The optimizer can be selected from Adam, RMSProp, or SGD, with specific parameters such as learning rate (lr), weight decay, momentum, beta values, and AMSGrad. If the optimizer type is not one of the specified options, it raises a NotImplementedError.",
            "code": "import torch.optim as optim\n\n\ndef get_optimizer(config, parameters):\n    if config.optim.optimizer == 'Adam':\n        return optim.Adam(parameters, lr=config.optim.lr, weight_decay=config.optim.weight_decay,\n                          betas=(config.optim.beta1, 0.999), amsgrad=config.optim.amsgrad,\n                          eps=config.optim.eps)\n    elif config.optim.optimizer == 'RMSProp':\n        return optim.RMSprop(parameters, lr=config.optim.lr, weight_decay=config.optim.weight_decay)\n    elif config.optim.optimizer == 'SGD':\n        return optim.SGD(parameters, lr=config.optim.lr, momentum=0.9)\n    else:\n        raise NotImplementedError(\n            'Optimizer {} not understood.'.format(config.optim.optimizer))\n",
            "masked_code": "import torch.optim as optim\n\n\ndef get_optimizer(config, parameters):\n    <line_mask>\n        return optim.Adam(parameters, lr=config.optim.lr, weight_decay=config.optim.weight_decay,\n                          betas=(config.optim.beta1, 0.999), amsgrad=config.optim.amsgrad,\n                          eps=config.optim.eps)\n    elif config.optim.optimizer == 'RMSProp':\n        return optim.RMSprop(parameters, lr=config.optim.lr, weight_decay=config.optim.weight_decay)\n    elif config.optim.optimizer == 'SGD':\n        return optim.SGD(parameters, lr=config.optim.lr, momentum=0.9)\n    else:\n        raise NotImplementedError(\n            'Optimizer {} not understood.'.format(config.optim.optimizer))\n",
            "masked_line": "if config.optim.optimizer == 'Adam':",
            "answer": "Adam",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "downstream_application_code",
            "id": "downstream_application_code_block_53"
        },
        {
            "dependency": "torch",
            "version": ">=1.9.0",
            "time": "2021-07-28",
            "description": "This code returns the appropriate autocast function based on the precision parameter provided.",
            "code": "import torch\nfrom contextlib import suppress\n\n\ndef get_autocast(precision):\n    if precision == 'amp':\n        return torch.cuda.amp.autocast\n    elif precision == 'amp_bfloat16' or precision == 'amp_bf16':\n        # amp_bfloat16 is more stable than amp float16 for clip training\n        return lambda: torch.cuda.amp.autocast(dtype=torch.bfloat16)\n    else:\n        return suppress\n",
            "masked_code": "import torch\nfrom contextlib import suppress\n\n\ndef get_autocast(precision):\n    if precision == 'amp':\n        <line_mask>\n    elif precision == 'amp_bfloat16' or precision == 'amp_bf16':\n        # amp_bfloat16 is more stable than amp float16 for clip training\n        return lambda: torch.cuda.amp.autocast(dtype=torch.bfloat16)\n    else:\n        return suppress\n",
            "masked_line": "return torch.cuda.amp.autocast",
            "answer": "autocast",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "downstream_application_code",
            "id": "downstream_application_code_block_54"
        },
        {
            "dependency": "gym",
            "version": ">=0.15.4",
            "time": "2023-02-22",
            "description": "This function creates a gym environment for the RTFM (Read the F***ing Manual) task, with customizable parameters such as environment name, height, width, observation type, maximum placement, featurizer function, shuffling wiki, and time penalty.",
            "code": "\"\"\"Implements environment getter for RTFM.\"\"\"\nimport gym\nfrom rtfm import featurizer as X\nimport rtfm.tasks\n\n\ndef create_env(env=\"rtfm:groups_simple_stationary-v0\", height=6, width=6, partially_observable=False, max_placement=1, featurizer=None, shuffle_wiki=False, time_penalty=-0.02):\n    \"\"\"Create RTFM environment.\n\n    Args:\n        env (str, optional): RTFM environment name.. Defaults to \"rtfm:groups_simple_stationary-v0\".\n        height (int, optional): Height of environment. Defaults to 6.\n        width (int, optional): Width of environment. Defaults to 6.\n        partially_observable (bool, optional): Whether to only give partial observations or priviledged observations. Defaults to False.\n        max_placement (int, optional): Max placement. Defaults to 1.\n        featurizer (_type_, optional): Function for featurizing inputs. Defaults to None.\n        shuffle_wiki (bool, optional): Whether to shuffle wiki. Defaults to False.\n        time_penalty (float, optional): Time penalty. Defaults to -0.02.\n\n    Returns:\n        env: gym environment\n    \"\"\"\n    f = featurizer or X.Concat([X.Text(), X.ValidMoves()])\n    env = gym.make(env, room_shape=(height, width), partially_observable=partially_observable,\n                   max_placement=max_placement, featurizer=f, shuffle_wiki=shuffle_wiki, time_penalty=time_penalty)\n    return env\n",
            "masked_code": "\"\"\"Implements environment getter for RTFM.\"\"\"\nimport gym\nfrom rtfm import featurizer as X\nimport rtfm.tasks\n\n\ndef create_env(env=\"rtfm:groups_simple_stationary-v0\", height=6, width=6, partially_observable=False, max_placement=1, featurizer=None, shuffle_wiki=False, time_penalty=-0.02):\n    \"\"\"Create RTFM environment.\n\n    Args:\n        env (str, optional): RTFM environment name.. Defaults to \"rtfm:groups_simple_stationary-v0\".\n        height (int, optional): Height of environment. Defaults to 6.\n        width (int, optional): Width of environment. Defaults to 6.\n        partially_observable (bool, optional): Whether to only give partial observations or priviledged observations. Defaults to False.\n        max_placement (int, optional): Max placement. Defaults to 1.\n        featurizer (_type_, optional): Function for featurizing inputs. Defaults to None.\n        shuffle_wiki (bool, optional): Whether to shuffle wiki. Defaults to False.\n        time_penalty (float, optional): Time penalty. Defaults to -0.02.\n\n    Returns:\n        env: gym environment\n    \"\"\"\n    f = featurizer or X.Concat([X.Text(), X.ValidMoves()])\n    <line_mask>\n                   max_placement=max_placement, featurizer=f, shuffle_wiki=shuffle_wiki, time_penalty=time_penalty)\n    return env\n",
            "masked_line": "env = gym.make(env, room_shape=(height, width), partially_observable=partially_observable,",
            "answer": "make",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "downstream_application_code",
            "id": "downstream_application_code_block_55"
        },
        {
            "dependency": "revtok",
            "version": ">=0.0.3",
            "time": "2023-02-22",
            "description": "This code defines a function to tokenize a sentence by converting it to lowercase and splitting it into words, and another function to recursively get all subclasses of a given class.",
            "code": "# Copyright (c) Facebook, Inc. and its affiliates.\n# All rights reserved.\n#\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\nimport argparse\nimport revtok\n\n\ndef tokenize(sent):\n    return [w.strip() for w in revtok.tokenize(sent.lower())]\n\n\ndef get_all_subclasses(c):\n    ret = []\n    sub = c.__subclasses__()\n    for cc in sub:\n        ret += get_all_subclasses(cc)\n    return ret + sub\n",
            "masked_code": "# Copyright (c) Facebook, Inc. and its affiliates.\n# All rights reserved.\n#\n# This source code is licensed under the license found in the\n# LICENSE file in the root directory of this source tree.\n\nimport argparse\nimport revtok\n\n\ndef tokenize(sent):\n    <line_mask>\n\n\ndef get_all_subclasses(c):\n    ret = []\n    sub = c.__subclasses__()\n    for cc in sub:\n        ret += get_all_subclasses(cc)\n    return ret + sub\n",
            "masked_line": "return [w.strip() for w in revtok.tokenize(sent.lower())]",
            "answer": "tokenize",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "downstream_application_code",
            "id": "downstream_application_code_block_56"
        },
        {
            "dependency": "torch",
            "version": ">=1.10.0",
            "time": "2022-08-24",
            "description": "The code defines a class called BaseModel that extends torch.nn.Module and has a method load() which loads a model from a file specified by a given file path. The method first loads the model's parameters from the file using torch.load(), then checks if there is an \"optimizer\" key in the parameters dictionary. If it exists, the method updates the parameters to only contain the \"model\" key. Finally, the method loads the state dictionary of the model with the modified parameters.",
            "code": "import torch\n\n\nclass BaseModel(torch.nn.Module):\n    def load(self, path):\n        \"\"\"Load model from file.\n\n        Args:\n            path (str): file path\n        \"\"\"\n        parameters = torch.load(path, map_location=torch.device('cpu'))\n\n        if \"optimizer\" in parameters:\n            parameters = parameters[\"model\"]\n\n        self.load_state_dict(parameters)\n",
            "masked_code": "import torch\n\n\nclass BaseModel(torch.nn.Module):\n    def load(self, path):\n        \"\"\"Load model from file.\n\n        Args:\n            path (str): file path\n        \"\"\"\n        <line_mask>\n\n        if \"optimizer\" in parameters:\n            parameters = parameters[\"model\"]\n\n        self.load_state_dict(parameters)\n",
            "masked_line": "parameters = torch.load(path, map_location=torch.device('cpu'))",
            "answer": "load",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "downstream_application_code",
            "id": "downstream_application_code_block_57"
        },
        {
            "dependency": "torch",
            "version": ">=1.10.0",
            "time": "2022-08-24",
            "description": "This code defines a class called HSwish that implements the hard Swish activation function, which is defined as Hswish(x) = x * ReLU6(x + 3) / 6. It takes an input tensor x and applies the hard Swish function to it, returning the output tensor.",
            "code": "# Copyright (c) OpenMMLab. All rights reserved.\nimport torch.nn as nn\n\nfrom .registry import ACTIVATION_LAYERS\n\n\n@ACTIVATION_LAYERS.register_module()\nclass HSwish(nn.Module):\n    \"\"\"Hard Swish Module.\n\n    This module applies the hard swish function:\n\n    .. math::\n        Hswish(x) = x * ReLU6(x + 3) / 6\n\n    Args:\n        inplace (bool): can optionally do the operation in-place.\n            Default: False.\n\n    Returns:\n        Tensor: The output tensor.\n    \"\"\"\n\n    def __init__(self, inplace=False):\n        super(HSwish, self).__init__()\n        self.act = nn.ReLU6(inplace)\n\n    def forward(self, x):\n        return x * self.act(x + 3) / 6\n",
            "masked_code": "# Copyright (c) OpenMMLab. All rights reserved.\nimport torch.nn as nn\n\nfrom .registry import ACTIVATION_LAYERS\n\n\n@ACTIVATION_LAYERS.register_module()\nclass HSwish(nn.Module):\n    \"\"\"Hard Swish Module.\n\n    This module applies the hard swish function:\n\n    .. math::\n        Hswish(x) = x * ReLU6(x + 3) / 6\n\n    Args:\n        inplace (bool): can optionally do the operation in-place.\n            Default: False.\n\n    Returns:\n        Tensor: The output tensor.\n    \"\"\"\n\n    def __init__(self, inplace=False):\n        super(HSwish, self).__init__()\n        self.act = nn.ReLU6(inplace)\n\n    def forward(self, x):\n        <line_mask>\n",
            "masked_line": "return x * self.act(x + 3) / 6",
            "answer": "act",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "downstream_application_code",
            "id": "downstream_application_code_block_58"
        },
        {
            "dependency": "torch",
            "version": ">=1.10.0",
            "time": "2022-08-24",
            "description": "This code defines a Scale class in Python using PyTorch, which is a learnable scale parameter. The Scale layer scales the input by a learnable factor, multiplying a learnable scale parameter with the input of any shape.",
            "code": "# Copyright (c) OpenMMLab. All rights reserved.\nimport torch\nimport torch.nn as nn\n\n\nclass Scale(nn.Module):\n    \"\"\"A learnable scale parameter.\n\n    This layer scales the input by a learnable factor. It multiplies a\n    learnable scale parameter of shape (1,) with input of any shape.\n\n    Args:\n        scale (float): Initial value of scale factor. Default: 1.0\n    \"\"\"\n\n    def __init__(self, scale=1.0):\n        super(Scale, self).__init__()\n        self.scale = nn.Parameter(torch.tensor(scale, dtype=torch.float))\n\n    def forward(self, x):\n        return x * self.scale\n",
            "masked_code": "# Copyright (c) OpenMMLab. All rights reserved.\nimport torch\nimport torch.nn as nn\n\n\nclass Scale(nn.Module):\n    \"\"\"A learnable scale parameter.\n\n    This layer scales the input by a learnable factor. It multiplies a\n    learnable scale parameter of shape (1,) with input of any shape.\n\n    Args:\n        scale (float): Initial value of scale factor. Default: 1.0\n    \"\"\"\n\n    def __init__(self, scale=1.0):\n        super(Scale, self).__init__()\n        <line_mask>\n\n    def forward(self, x):\n        return x * self.scale\n",
            "masked_line": "self.scale = nn.Parameter(torch.tensor(scale, dtype=torch.float))",
            "answer": "tensor",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "downstream_application_code",
            "id": "downstream_application_code_block_59"
        },
        {
            "dependency": "torch",
            "version": ">=1.10.0",
            "time": "2022-08-24",
            "description": "This code defines a custom activation function called Swish, which applies the Swish function to an input tensor x. The Swish function is defined as Swish(x) = x * Sigmoid(x), where Sigmoid is the sigmoid function. The module returns the output tensor after applying the Swish function.",
            "code": "# Copyright (c) OpenMMLab. All rights reserved.\nimport torch\nimport torch.nn as nn\n\nfrom .registry import ACTIVATION_LAYERS\n\n\n@ACTIVATION_LAYERS.register_module()\nclass Swish(nn.Module):\n    \"\"\"Swish Module.\n\n    This module applies the swish function:\n\n    .. math::\n        Swish(x) = x * Sigmoid(x)\n\n    Returns:\n        Tensor: The output tensor.\n    \"\"\"\n\n    def __init__(self):\n        super(Swish, self).__init__()\n\n    def forward(self, x):\n        return x * torch.sigmoid(x)\n",
            "masked_code": "# Copyright (c) OpenMMLab. All rights reserved.\nimport torch\nimport torch.nn as nn\n\nfrom .registry import ACTIVATION_LAYERS\n\n\n@ACTIVATION_LAYERS.register_module()\nclass Swish(nn.Module):\n    \"\"\"Swish Module.\n\n    This module applies the swish function:\n\n    .. math::\n        Swish(x) = x * Sigmoid(x)\n\n    Returns:\n        Tensor: The output tensor.\n    \"\"\"\n\n    def __init__(self):\n        super(Swish, self).__init__()\n\n    def forward(self, x):\n        <line_mask>\n",
            "masked_line": "return x * torch.sigmoid(x)",
            "answer": "sigmoid",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "downstream_application_code",
            "id": "downstream_application_code_block_60"
        },
        {
            "dependency": "transformers",
            "version": ">=4.29.2",
            "time": "2021-03-13",
            "description": "This code uses a transformer model to generate code based on the input text \"# this function prints hello world\". It loads a pre-trained model and tokenizer, generates the code using the model, and then decodes the generated code.",
            "code": "from transformers import AutoTokenizer, AutoModelForCausalLM\n\ntokenizer = AutoTokenizer.from_pretrained(\"checkpoints/codegen2-6B\")\nmodel = CodeGenForCausalLM.from_pretrained(\"checkpoints/codegen2-6B\", torch_dtype=torch.float16, revision=\"sharded\")\ninputs = tokenizer(\"# this function prints hello world\", return_tensors=\"pt\")\nsample = model.generate(**inputs, max_length=128)\nprint(tokenizer.decode(sample[0], truncate_before_pattern=[r\"\\n\\n^#\", \"^'''\", \"\\n\\n\\n\"]))\n",
            "masked_code": "from transformers import AutoTokenizer, AutoModelForCausalLM\n\ntokenizer = AutoTokenizer.from_pretrained(\"checkpoints/codegen2-6B\")\nmodel = CodeGenForCausalLM.from_pretrained(\"checkpoints/codegen2-6B\", torch_dtype=torch.float16, revision=\"sharded\")\n<line_mask>\nsample = model.generate(**inputs, max_length=128)\nprint(tokenizer.decode(sample[0], truncate_before_pattern=[r\"\\n\\n^#\", \"^'''\", \"\\n\\n\\n\"]))\n",
            "masked_line": "inputs = tokenizer(\"# this function prints hello world\", return_tensors=\"pt\")",
            "answer": "tokenizer",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "downstream_application_code",
            "id": "downstream_application_code_block_61"
        },
        {
            "dependency": "transformers",
            "version": ">=4.29.2",
            "time": "2021-03-13",
            "description": "The code generates text using a pretrained language model to continue the Python function \"def hello_world():\", with a maximum length of 128 characters.",
            "code": "from transformers import AutoTokenizer, AutoModelForCausalLM\n\ntokenizer = AutoTokenizer.from_pretrained(\"checkpoints/codegen25-7b-multi\", trust_remote_code=True)\nmodel = AutoModelForCausalLM.from_pretrained(\"checkpoints/codegen25-7b-multi\")\ninputs = tokenizer(\"def hello_world():\", return_tensors=\"pt\")\nsample = model.generate(**inputs, max_length=128)\nprint(tokenizer.decode(sample[0], truncate_before_pattern=[r\"\\n\\n^#\", \"^'''\", \"\\n\\n\\n\"]))\n",
            "masked_code": "from transformers import AutoTokenizer, AutoModelForCausalLM\n\ntokenizer = AutoTokenizer.from_pretrained(\"checkpoints/codegen25-7b-multi\", trust_remote_code=True)\n<line_mask>\ninputs = tokenizer(\"def hello_world():\", return_tensors=\"pt\")\nsample = model.generate(**inputs, max_length=128)\nprint(tokenizer.decode(sample[0], truncate_before_pattern=[r\"\\n\\n^#\", \"^'''\", \"\\n\\n\\n\"]))\n",
            "masked_line": "model = AutoModelForCausalLM.from_pretrained(\"checkpoints/codegen25-7b-multi\")",
            "answer": "from_pretrained",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "downstream_application_code",
            "id": "downstream_application_code_block_62"
        },
        {
            "dependency": "setuptools",
            "version": ">=41.0.0",
            "time": "2019-01-15",
            "description": "This Python code sets up a pip package named \"box_arrangement\" with a version of 0.1. It includes sparse reward tasks involving moving and pushing boxes to targets. The package has required dependencies such as 'absl-py', 'dm_control', 'numpy', and 'dm_env'. It is licensed under the Apache License 2.0 and is authored by DeepMind.",
            "code": "# Copyright 2020 DeepMind Technologies Limited\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Setup for pip package.\"\"\"\n\nfrom setuptools import find_packages\nfrom setuptools import setup\n\n\nREQUIRED_PACKAGES = ['absl-py', 'dm_control', 'numpy', 'dm_env']\n\nsetup(\n    name='box_arrangement',\n    version='0.1',\n    description=('Sparse reward tasks involving moving and pushing boxes to'\n                 ' targets.'),\n    url='https://github.com/deepmind/deepmind-research/box_arrangement',\n    author='DeepMind',\n    author_email='dhruvat@google.com',\n    # Contained modules and scripts.\n    packages=find_packages(),\n    install_requires=REQUIRED_PACKAGES,\n    platforms=['any'],\n    license='Apache 2.0',\n)\n",
            "masked_code": "# Copyright 2020 DeepMind Technologies Limited\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Setup for pip package.\"\"\"\n\nfrom setuptools import find_packages\nfrom setuptools import setup\n\n\nREQUIRED_PACKAGES = ['absl-py', 'dm_control', 'numpy', 'dm_env']\n\nsetup(\n    name='box_arrangement',\n    version='0.1',\n    description=('Sparse reward tasks involving moving and pushing boxes to'\n                 ' targets.'),\n    url='https://github.com/deepmind/deepmind-research/box_arrangement',\n    author='DeepMind',\n    author_email='dhruvat@google.com',\n    # Contained modules and scripts.\n    <line_mask>\n    install_requires=REQUIRED_PACKAGES,\n    platforms=['any'],\n    license='Apache 2.0',\n)\n",
            "masked_line": "packages=find_packages(),",
            "answer": "find_packages",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "downstream_application_code",
            "id": "downstream_application_code_block_63"
        },
        {
            "dependency": "setuptools",
            "version": ">=41.0.0",
            "time": "2019-01-15",
            "description": "This code sets up a pip package named 'catch_carry' that includes whole-body object manipulation tasks and motion capture data. It specifies the required packages, author information, package version, description, and license information for the package.",
            "code": "# Copyright 2020 DeepMind Technologies Limited\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Setup for pip package.\"\"\"\n\nfrom setuptools import find_packages\nfrom setuptools import setup\n\n\nREQUIRED_PACKAGES = ['absl-py', 'dm_control', 'numpy']\n\nsetup(\n    name='catch_carry',\n    version='0.1',\n    description='Whole-body object manipulation tasks and motion capture data.',\n    url='https://github.com/deepmind/deepmind-research/catch_carry',\n    author='DeepMind',\n    author_email='stunya@google.com',\n    # Contained modules and scripts.\n    packages=find_packages(),\n    install_requires=REQUIRED_PACKAGES,\n    platforms=['any'],\n    license='Apache 2.0',\n)\n",
            "masked_code": "# Copyright 2020 DeepMind Technologies Limited\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Setup for pip package.\"\"\"\n\nfrom setuptools import find_packages\nfrom setuptools import setup\n\n\nREQUIRED_PACKAGES = ['absl-py', 'dm_control', 'numpy']\n\nsetup(\n    name='catch_carry',\n    version='0.1',\n    description='Whole-body object manipulation tasks and motion capture data.',\n    url='https://github.com/deepmind/deepmind-research/catch_carry',\n    author='DeepMind',\n    author_email='stunya@google.com',\n    # Contained modules and scripts.\n    <line_mask>\n    install_requires=REQUIRED_PACKAGES,\n    platforms=['any'],\n    license='Apache 2.0',\n)\n",
            "masked_line": "packages=find_packages(),",
            "answer": "find_packages",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "downstream_application_code",
            "id": "downstream_application_code_block_64"
        },
        {
            "dependency": "setuptools",
            "version": ">=41.0.0",
            "time": "2019-01-15",
            "description": "This code sets up a Python package for the DM21 functionals interface to PySCF. It includes required packages, checkpoints data, package description, author information, package modules and scripts, installation requirements, and license information.",
            "code": "# Copyright 2021 DeepMind Technologies Limited\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Setup for DM21 functionals interface to PySCF.\"\"\"\n\nfrom setuptools import setup\n\nREQUIRED_PACKAGES = [\n    'absl-py',\n    'attrs',\n    # Note PySCF 1.7.6 and older do not support h5py 3.3.0:\n    # https://github.com/pyscf/pyscf/issues/1016\n    'h5py',\n    'numpy',\n    # Note DM21 functionals are compatible with PySCF 1.7.6 if an older version\n    # of h5py is used.\n    'pyscf>=2.0',\n    'tensorflow',\n    'tensorflow_hub',\n]\nCHECKPOINT_DATA = ['checkpoints/DM21*/*.pb', 'checkpoints/DM21*/variables/*']\n\nsetup(\n    name='density_functional_approximation_dm21',\n    version='0.1',\n    description='An interface to PySCF for the DM21 functionals.',\n    url='https://github.com/deepmind/deepmind-research/density_functional_approximation_dm21',\n    author='DeepMind',\n    author_email='no-reply@google.com',\n    # Contained modules and scripts.\n    packages=['density_functional_approximation_dm21'],\n    package_data={\n        'density_functional_approximation_dm21': CHECKPOINT_DATA,\n    },\n    scripts=['density_functional_approximation_dm21/export_saved_model.py'],\n    install_requires=REQUIRED_PACKAGES,\n    platforms=['any'],\n    license='Apache 2.0',\n    extras_require={'testing': ['pytest', 'scipy']},\n)\n",
            "masked_code": "# Copyright 2021 DeepMind Technologies Limited\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Setup for DM21 functionals interface to PySCF.\"\"\"\n\nfrom setuptools import setup\n\nREQUIRED_PACKAGES = [\n    'absl-py',\n    'attrs',\n    # Note PySCF 1.7.6 and older do not support h5py 3.3.0:\n    # https://github.com/pyscf/pyscf/issues/1016\n    'h5py',\n    'numpy',\n    # Note DM21 functionals are compatible with PySCF 1.7.6 if an older version\n    # of h5py is used.\n    'pyscf>=2.0',\n    'tensorflow',\n    'tensorflow_hub',\n]\nCHECKPOINT_DATA = ['checkpoints/DM21*/*.pb', 'checkpoints/DM21*/variables/*']\n\n<line_mask>\n    name='density_functional_approximation_dm21',\n    version='0.1',\n    description='An interface to PySCF for the DM21 functionals.',\n    url='https://github.com/deepmind/deepmind-research/density_functional_approximation_dm21',\n    author='DeepMind',\n    author_email='no-reply@google.com',\n    # Contained modules and scripts.\n    packages=['density_functional_approximation_dm21'],\n    package_data={\n        'density_functional_approximation_dm21': CHECKPOINT_DATA,\n    },\n    scripts=['density_functional_approximation_dm21/export_saved_model.py'],\n    install_requires=REQUIRED_PACKAGES,\n    platforms=['any'],\n    license='Apache 2.0',\n    extras_require={'testing': ['pytest', 'scipy']},\n)\n",
            "masked_line": "setup(",
            "answer": "setup",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "downstream_application_code",
            "id": "downstream_application_code_block_65"
        },
        {
            "dependency": "ml_collections",
            "version": ">=0.1",
            "time": "2019-01-15",
            "description": "This code defines a default configuration for model evaluation, including strategies for ResNet training, optimizer settings, data preprocessing, data augmentation, evaluation criteria, loss function, model uncertainty handling, time filtering intervals, and other experimental parameters for training the neural network model.",
            "code": "# Copyright 2021 DeepMind Technologies Limited.\n#\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Default config, focused on model evaluation.\"\"\"\n\nfrom ml_collections import config_dict\n\n\ndef get_config(filter_time_intervals=None):\n  \"\"\"Return config object for training.\"\"\"\n  config = config_dict.ConfigDict()\n  config.eval_strategy = config_dict.ConfigDict()\n  config.eval_strategy.class_name = 'OneDeviceConfig'\n  config.eval_strategy.kwargs = config_dict.ConfigDict(\n      dict(device_type='v100'))\n\n  ## Experiment config.\n  config.experiment_kwargs = config_dict.ConfigDict(dict(\n      resnet_kwargs=dict(\n          blocks_per_group_list=[3, 4, 6, 3],  # This choice is ResNet50.\n          bn_config=dict(\n              decay_rate=0.9,\n              eps=1e-5),\n          resnet_v2=False,\n          additional_features_mode='mlp',\n      ),\n      optimizer_config=dict(\n          class_name='Momentum',\n          kwargs={'momentum': 0.9},\n          # Set up the learning rate schedule.\n          lr_init=0.025,\n          lr_factor=0.1,\n          lr_schedule=(50e3, 100e3, 150e3),\n          gradient_clip=5.,\n      ),\n      l2_regularization=1e-4,\n      total_train_batch_size=128,\n      train_net_args={'is_training': True},\n      eval_batch_size=128,\n      eval_net_args={'is_training': True},\n      data_config=dict(\n          # dataset loading\n          dataset_path=None,\n          num_val_splits=10,\n          val_split=0,\n\n          # image cropping\n          image_size=(80, 80, 7),\n          train_crop_type='crop_fixed',\n          test_crop_type='crop_fixed',\n          n_crop_repeat=1,\n\n          train_augmentations=dict(\n              rotation_and_flip=True,\n              rescaling=True,\n              translation=True,\n          ),\n\n          test_augmentations=dict(\n              rotation_and_flip=False,\n              rescaling=False,\n              translation=False,\n          ),\n          test_time_ensembling='sum',\n\n          num_eval_buckets=5,\n          eval_confidence_interval=95,\n\n          task='grounded_unnormalized_regression',\n          loss_config=dict(\n              loss='mse',\n              mse_normalize=False,\n          ),\n          model_uncertainty=True,\n          additional_features='',\n          time_filter_intervals=filter_time_intervals,\n          class_boundaries={\n              '0': [[-1., 0]],\n              '1': [[0, 1.]]\n          },\n          frequencies_to_use='all',\n      ),\n      n_train_epochs=100\n      ))\n\n  return config\n",
            "masked_code": "# Copyright 2021 DeepMind Technologies Limited.\n#\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Default config, focused on model evaluation.\"\"\"\n\nfrom ml_collections import config_dict\n\n\ndef get_config(filter_time_intervals=None):\n  \"\"\"Return config object for training.\"\"\"\n  <line_mask>\n  config.eval_strategy = config_dict.ConfigDict()\n  config.eval_strategy.class_name = 'OneDeviceConfig'\n  config.eval_strategy.kwargs = config_dict.ConfigDict(\n      dict(device_type='v100'))\n\n  ## Experiment config.\n  config.experiment_kwargs = config_dict.ConfigDict(dict(\n      resnet_kwargs=dict(\n          blocks_per_group_list=[3, 4, 6, 3],  # This choice is ResNet50.\n          bn_config=dict(\n              decay_rate=0.9,\n              eps=1e-5),\n          resnet_v2=False,\n          additional_features_mode='mlp',\n      ),\n      optimizer_config=dict(\n          class_name='Momentum',\n          kwargs={'momentum': 0.9},\n          # Set up the learning rate schedule.\n          lr_init=0.025,\n          lr_factor=0.1,\n          lr_schedule=(50e3, 100e3, 150e3),\n          gradient_clip=5.,\n      ),\n      l2_regularization=1e-4,\n      total_train_batch_size=128,\n      train_net_args={'is_training': True},\n      eval_batch_size=128,\n      eval_net_args={'is_training': True},\n      data_config=dict(\n          # dataset loading\n          dataset_path=None,\n          num_val_splits=10,\n          val_split=0,\n\n          # image cropping\n          image_size=(80, 80, 7),\n          train_crop_type='crop_fixed',\n          test_crop_type='crop_fixed',\n          n_crop_repeat=1,\n\n          train_augmentations=dict(\n              rotation_and_flip=True,\n              rescaling=True,\n              translation=True,\n          ),\n\n          test_augmentations=dict(\n              rotation_and_flip=False,\n              rescaling=False,\n              translation=False,\n          ),\n          test_time_ensembling='sum',\n\n          num_eval_buckets=5,\n          eval_confidence_interval=95,\n\n          task='grounded_unnormalized_regression',\n          loss_config=dict(\n              loss='mse',\n              mse_normalize=False,\n          ),\n          model_uncertainty=True,\n          additional_features='',\n          time_filter_intervals=filter_time_intervals,\n          class_boundaries={\n              '0': [[-1., 0]],\n              '1': [[0, 1.]]\n          },\n          frequencies_to_use='all',\n      ),\n      n_train_epochs=100\n      ))\n\n  return config\n",
            "masked_line": "config = config_dict.ConfigDict()",
            "answer": "ConfigDict",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "downstream_application_code",
            "id": "downstream_application_code_block_66"
        },
        {
            "dependency": "setuptools",
            "version": ">=41.0.0",
            "time": "2019-01-15",
            "description": "This code sets up a pip package named \"geomancer\" that includes a library for the Geometric Manifold Component Estimator. It specifies required packages, author information, and license details.",
            "code": "# Copyright 2020 DeepMind Technologies Limited\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Setup for pip package.\"\"\"\n\nfrom setuptools import find_packages\nfrom setuptools import setup\n\n\nREQUIRED_PACKAGES = ['numpy', 'scipy', 'matplotlib', 'absl-py', 'tqdm']\n\nsetup(\n    name='geomancer',\n    version='0.1',\n    description='A library for the Geometric Manifold Component Estimator.',\n    url='https://github.com/deepmind/deepmind-research/geomancer',\n    author='DeepMind',\n    author_email='pfau@google.com',\n    # Contained modules and scripts.\n    packages=find_packages(),\n    install_requires=REQUIRED_PACKAGES,\n    platforms=['any'],\n    license='Apache 2.0',\n)\n",
            "masked_code": "# Copyright 2020 DeepMind Technologies Limited\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Setup for pip package.\"\"\"\n\nfrom setuptools import find_packages\n<line_mask>\n\n\nREQUIRED_PACKAGES = ['numpy', 'scipy', 'matplotlib', 'absl-py', 'tqdm']\n\nsetup(\n    name='geomancer',\n    version='0.1',\n    description='A library for the Geometric Manifold Component Estimator.',\n    url='https://github.com/deepmind/deepmind-research/geomancer',\n    author='DeepMind',\n    author_email='pfau@google.com',\n    # Contained modules and scripts.\n    packages=find_packages(),\n    install_requires=REQUIRED_PACKAGES,\n    platforms=['any'],\n    license='Apache 2.0',\n)\n",
            "masked_line": "from setuptools import setup",
            "answer": "setup",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "downstream_application_code",
            "id": "downstream_application_code_block_67"
        },
        {
            "dependency": "setuptools",
            "version": ">=41.0.0",
            "time": "2019-01-15",
            "description": "This code sets up a pip package for a library called \"hpu_net\" which contains the Hierarchical Probabilistic U-Net model. It includes the necessary packages, modules, and scripts for the package, specifies the version, description, URL, author, and license, and defines the required packages for installation.",
            "code": "# Copyright 2019 DeepMind Technologies Limited\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Setup for pip package.\"\"\"\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nfrom setuptools import find_packages\nfrom setuptools import setup\n\n\nREQUIRED_PACKAGES = ['numpy', 'dm-sonnet==1.35', 'tensorflow==1.14',\n                     'tensorflow-probability==0.7.0']\n\nsetup(\n    name='hpu_net',\n    version='0.1',\n    description='A library for the Hierarchical Probabilistic U-Net model.',\n    url='https://github.com/deepmind/deepmind-research/hierarchical_probabilistic_unet',\n    author='DeepMind',\n    author_email='no-reply@google.com',\n    # Contained modules and scripts.\n    packages=find_packages(),\n    install_requires=REQUIRED_PACKAGES,\n    platforms=['any'],\n    license='Apache 2.0',\n)\n",
            "masked_code": "# Copyright 2019 DeepMind Technologies Limited\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Setup for pip package.\"\"\"\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nfrom setuptools import find_packages\nfrom setuptools import setup\n\n\nREQUIRED_PACKAGES = ['numpy', 'dm-sonnet==1.35', 'tensorflow==1.14',\n                     'tensorflow-probability==0.7.0']\n\nsetup(\n    name='hpu_net',\n    version='0.1',\n    description='A library for the Hierarchical Probabilistic U-Net model.',\n    url='https://github.com/deepmind/deepmind-research/hierarchical_probabilistic_unet',\n    author='DeepMind',\n    author_email='no-reply@google.com',\n    # Contained modules and scripts.\n    <line_mask>\n    install_requires=REQUIRED_PACKAGES,\n    platforms=['any'],\n    license='Apache 2.0',\n)\n",
            "masked_line": "packages=find_packages(),",
            "answer": "find_packages",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "downstream_application_code",
            "id": "downstream_application_code_block_68"
        },
        {
            "dependency": "setuptools",
            "version": ">=41.0.0",
            "time": "2019-01-15",
            "description": "This code sets up a pip package for a K-FAC optimizer implemented in JAX, accompanying code for 'Better, Faster Fermionic Neural Networks'. It includes the required packages for installation and provides a long description of the optimizer.",
            "code": "# Copyright 2020 DeepMind Technologies Limited.\n#\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\"\"\"Setup for pip package.\"\"\"\n\nfrom setuptools import setup\n\n\nREQUIRED_PACKAGES = (\n    \"absl-py\",\n    \"dataclasses\",\n    \"jax\",\n    \"networkx\",\n    \"numpy\",\n    \"ordered-set\",\n    \"typing\",\n)\n\nLONG_DESCRIPTION = \"\\n\".join([\n    \"Kronecker-Factored Approximate Curvature (K-FAC) optimizer implemented in \"\n    \"JAX.\",\n    \"\",\n    \"Accompanying code for 'Better, Faster Fermionic Neural Networks'\",\n    \"James S. Spencer, David Pfau, Aleksandar Botev, and W. M. C. Foulkes.\",\n    \"https://arxiv.org/abs/2011.07125.\",\n])\n\n\nsetup(\n    name=\"kfac_ferminet_alpha\",\n    version=\"0.0.1\",\n    description=\"A K-FAC optimizer implemented in JAX\",\n    long_description=LONG_DESCRIPTION,\n    url=\"https://github.com/deepmind/deepmind-research/kfac_ferminet_alpha\",\n    author=\"DeepMind\",\n    package_dir={\"kfac_ferminet_alpha\": \".\"},\n    packages=[\"kfac_ferminet_alpha\"],\n    install_requires=REQUIRED_PACKAGES,\n    platforms=[\"any\"],\n    license=\"Apache License, Version 2.0\",\n)\n",
            "masked_code": "# Copyright 2020 DeepMind Technologies Limited.\n#\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\"\"\"Setup for pip package.\"\"\"\n\n<line_mask>\n\n\nREQUIRED_PACKAGES = (\n    \"absl-py\",\n    \"dataclasses\",\n    \"jax\",\n    \"networkx\",\n    \"numpy\",\n    \"ordered-set\",\n    \"typing\",\n)\n\nLONG_DESCRIPTION = \"\\n\".join([\n    \"Kronecker-Factored Approximate Curvature (K-FAC) optimizer implemented in \"\n    \"JAX.\",\n    \"\",\n    \"Accompanying code for 'Better, Faster Fermionic Neural Networks'\",\n    \"James S. Spencer, David Pfau, Aleksandar Botev, and W. M. C. Foulkes.\",\n    \"https://arxiv.org/abs/2011.07125.\",\n])\n\n\nsetup(\n    name=\"kfac_ferminet_alpha\",\n    version=\"0.0.1\",\n    description=\"A K-FAC optimizer implemented in JAX\",\n    long_description=LONG_DESCRIPTION,\n    url=\"https://github.com/deepmind/deepmind-research/kfac_ferminet_alpha\",\n    author=\"DeepMind\",\n    package_dir={\"kfac_ferminet_alpha\": \".\"},\n    packages=[\"kfac_ferminet_alpha\"],\n    install_requires=REQUIRED_PACKAGES,\n    platforms=[\"any\"],\n    license=\"Apache License, Version 2.0\",\n)\n",
            "masked_line": "from setuptools import setup",
            "answer": "setup",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "downstream_application_code",
            "id": "downstream_application_code_block_69"
        },
        {
            "dependency": "dill",
            "version": "==0.3.4",
            "time": "2019-01-15",
            "description": "This code defines a function called load_checkpoint that loads a checkpoint from a given file path using dill library and returns the loaded data. If the file is not found, it returns None. It also logs a message indicating the checkpoint loading process.",
            "code": "# Copyright 2020 DeepMind Technologies Limited.\n#\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Checkpoint restoring utilities.\"\"\"\n\nfrom absl import logging\nimport dill\n\n\ndef load_checkpoint(checkpoint_path):\n  try:\n    with open(checkpoint_path, 'rb') as checkpoint_file:\n      checkpoint_data = dill.load(checkpoint_file)\n      logging.info('Loading checkpoint from %s', checkpoint_path)\n      return checkpoint_data\n  except FileNotFoundError:\n    return None\n",
            "masked_code": "# Copyright 2020 DeepMind Technologies Limited.\n#\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Checkpoint restoring utilities.\"\"\"\n\nfrom absl import logging\nimport dill\n\n\ndef load_checkpoint(checkpoint_path):\n  try:\n    with open(checkpoint_path, 'rb') as checkpoint_file:\n      <line_mask>\n      logging.info('Loading checkpoint from %s', checkpoint_path)\n      return checkpoint_data\n  except FileNotFoundError:\n    return None\n",
            "masked_line": "checkpoint_data = dill.load(checkpoint_file)",
            "answer": "load",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "downstream_application_code",
            "id": "downstream_application_code_block_70"
        },
        {
            "dependency": "setuptools",
            "version": ">=41.0.0",
            "time": "2019-01-15",
            "description": "This Python code sets up a pip package called \"physics_inspired_models\" that implements multiple physically inspired models including Hamiltonian Generative Network, Lagrangian Generative Network, Neural ODE, Recurrent Generative Network, RNN, LSTM, and GRU. The package contains the required dependencies and is associated with a publication by DeepMind.",
            "code": "# Copyright 2020 DeepMind Technologies Limited.\n#\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\"\"\"Setup for pip package.\"\"\"\nfrom setuptools import setup\n\nREQUIRED_PACKAGES = (\n    \"dm_hamiltonian_dynamics_suite@git+https://github.com/deepmind/dm_hamiltonian_dynamics_suite\",  # pylint: disable=line-too-long.\n    \"absl-py>=0.12.0\",\n    \"numpy>=1.16.4\",\n    \"scikit-learn>=1.0\",\n    \"typing>=3.7.4.3\",\n    \"jax==0.2.20\",\n    \"jaxline==0.0.3\",\n    \"distrax==0.0.2\",\n    \"optax==0.0.6\",\n    \"dm-haiku==0.0.3\",\n)\n\nLONG_DESCRIPTION = \"\\n\".join([\n    \"A codebase containing the implementation of the following models:\",\n    \"Hamiltonian Generative Network (HGN)\",\n    \"Lagrangian Generative Network (LGN)\",\n    \"Neural ODE\",\n    \"Recurrent Generative Network (RGN)\",\n    \"and RNN, LSTM and GRU.\",\n    \"This is code accompanying the publication of:\"\n])\n\n\nsetup(\n    name=\"physics_inspired_models\",\n    version=\"0.0.1\",\n    description=\"Implementation of multiple physically inspired models.\",\n    long_description=LONG_DESCRIPTION,\n    url=\"https://github.com/deepmind/deepmind-research/physics_inspired_models\",\n    author=\"DeepMind\",\n    package_dir={\"physics_inspired_models\": \".\"},\n    packages=[\"physics_inspired_models\", \"physics_inspired_models.models\"],\n    install_requires=REQUIRED_PACKAGES,\n    platforms=[\"any\"],\n    license=\"Apache License, Version 2.0\",\n)\n",
            "masked_code": "# Copyright 2020 DeepMind Technologies Limited.\n#\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\"\"\"Setup for pip package.\"\"\"\n<line_mask>\n\nREQUIRED_PACKAGES = (\n    \"dm_hamiltonian_dynamics_suite@git+https://github.com/deepmind/dm_hamiltonian_dynamics_suite\",  # pylint: disable=line-too-long.\n    \"absl-py>=0.12.0\",\n    \"numpy>=1.16.4\",\n    \"scikit-learn>=1.0\",\n    \"typing>=3.7.4.3\",\n    \"jax==0.2.20\",\n    \"jaxline==0.0.3\",\n    \"distrax==0.0.2\",\n    \"optax==0.0.6\",\n    \"dm-haiku==0.0.3\",\n)\n\nLONG_DESCRIPTION = \"\\n\".join([\n    \"A codebase containing the implementation of the following models:\",\n    \"Hamiltonian Generative Network (HGN)\",\n    \"Lagrangian Generative Network (LGN)\",\n    \"Neural ODE\",\n    \"Recurrent Generative Network (RGN)\",\n    \"and RNN, LSTM and GRU.\",\n    \"This is code accompanying the publication of:\"\n])\n\n\nsetup(\n    name=\"physics_inspired_models\",\n    version=\"0.0.1\",\n    description=\"Implementation of multiple physically inspired models.\",\n    long_description=LONG_DESCRIPTION,\n    url=\"https://github.com/deepmind/deepmind-research/physics_inspired_models\",\n    author=\"DeepMind\",\n    package_dir={\"physics_inspired_models\": \".\"},\n    packages=[\"physics_inspired_models\", \"physics_inspired_models.models\"],\n    install_requires=REQUIRED_PACKAGES,\n    platforms=[\"any\"],\n    license=\"Apache License, Version 2.0\",\n)\n",
            "masked_line": "from setuptools import setup",
            "answer": "setup",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "downstream_application_code",
            "id": "downstream_application_code_block_71"
        },
        {
            "dependency": "setuptools",
            "version": ">=41.0.0",
            "time": "2019-01-15",
            "description": "This code sets up a pip package for a library called PolyGen, which is an Autoregressive Generative Model of 3D Meshes. The setup includes specifying the package name, version, description, URL, author information, required packages, and license.",
            "code": "# Copyright 2020 DeepMind Technologies Limited\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Setup for pip package.\"\"\"\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nfrom setuptools import find_packages\nfrom setuptools import setup\n\n\nREQUIRED_PACKAGES = ['numpy', 'dm-sonnet==1.36', 'tensorflow==1.14',\n                     'tensor2tensor==1.15', 'networkx', 'matplotlib', 'six']\n\nsetup(\n    name='polygen',\n    version='0.1',\n    description='A library for PolyGen: An Autoregressive Generative Model of 3D Meshes.',\n    url='https://github.com/deepmind/deepmind-research/polygen',\n    author='DeepMind',\n    author_email='no-reply@google.com',\n    # Contained modules and scripts.\n    packages=find_packages(),\n    install_requires=REQUIRED_PACKAGES,\n    platforms=['any'],\n    license='Apache 2.0',\n)\n",
            "masked_code": "# Copyright 2020 DeepMind Technologies Limited\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Setup for pip package.\"\"\"\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nfrom setuptools import find_packages\n<line_mask>\n\n\nREQUIRED_PACKAGES = ['numpy', 'dm-sonnet==1.36', 'tensorflow==1.14',\n                     'tensor2tensor==1.15', 'networkx', 'matplotlib', 'six']\n\nsetup(\n    name='polygen',\n    version='0.1',\n    description='A library for PolyGen: An Autoregressive Generative Model of 3D Meshes.',\n    url='https://github.com/deepmind/deepmind-research/polygen',\n    author='DeepMind',\n    author_email='no-reply@google.com',\n    # Contained modules and scripts.\n    packages=find_packages(),\n    install_requires=REQUIRED_PACKAGES,\n    platforms=['any'],\n    license='Apache 2.0',\n)\n",
            "masked_line": "from setuptools import setup",
            "answer": "setup",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "downstream_application_code",
            "id": "downstream_application_code_block_72"
        },
        {
            "dependency": "torch",
            "version": ">=2.1",
            "time": "2020-05-20",
            "description": "This code defines and tests a random window discriminator model that takes input signals and condition features to generate scores. The model has multiple window sizes and different downsample factors for the conditional discriminator layers. The test function generates random input signals and condition features, passes them through the model, and checks the output scores for correctness.",
            "code": "import numpy as np\nimport torch\n\nfrom TTS.vocoder.models.random_window_discriminator import RandomWindowDiscriminator\n\n\ndef test_rwd():\n    layer = RandomWindowDiscriminator(\n        cond_channels=80,\n        window_sizes=(512, 1024, 2048, 4096, 8192),\n        cond_disc_downsample_factors=[(8, 4, 2, 2, 2), (8, 4, 2, 2), (8, 4, 2), (8, 4), (4, 2, 2)],\n        hop_length=256,\n    )\n    x = torch.rand([4, 1, 22050])\n    c = torch.rand([4, 80, 22050 // 256])\n\n    scores, _ = layer(x, c)\n    assert len(scores) == 10\n    assert np.all(scores[0].shape == (4, 1, 1))\n",
            "masked_code": "import numpy as np\nimport torch\n\nfrom TTS.vocoder.models.random_window_discriminator import RandomWindowDiscriminator\n\n\ndef test_rwd():\n    layer = RandomWindowDiscriminator(\n        cond_channels=80,\n        window_sizes=(512, 1024, 2048, 4096, 8192),\n        cond_disc_downsample_factors=[(8, 4, 2, 2, 2), (8, 4, 2, 2), (8, 4, 2), (8, 4), (4, 2, 2)],\n        hop_length=256,\n    )\n    <line_mask>\n    c = torch.rand([4, 80, 22050 // 256])\n\n    scores, _ = layer(x, c)\n    assert len(scores) == 10\n    assert np.all(scores[0].shape == (4, 1, 1))\n",
            "masked_line": "x = torch.rand([4, 1, 22050])",
            "answer": "rand",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "downstream_application_code",
            "id": "downstream_application_code_block_73"
        },
        {
            "dependency": "numpy",
            "version": ">=1.17.0",
            "time": "2020-05-20",
            "description": "This code defines and tests a random window discriminator model that takes input signals and condition features to generate scores. The model has multiple window sizes and different downsample factors for the conditional discriminator layers. The test function generates random input signals and condition features, passes them through the model, and checks the output scores for correctness.",
            "code": "import numpy as np\nimport torch\n\nfrom TTS.vocoder.models.random_window_discriminator import RandomWindowDiscriminator\n\n\ndef test_rwd():\n    layer = RandomWindowDiscriminator(\n        cond_channels=80,\n        window_sizes=(512, 1024, 2048, 4096, 8192),\n        cond_disc_downsample_factors=[(8, 4, 2, 2, 2), (8, 4, 2, 2), (8, 4, 2), (8, 4), (4, 2, 2)],\n        hop_length=256,\n    )\n    x = torch.rand([4, 1, 22050])\n    c = torch.rand([4, 80, 22050 // 256])\n\n    scores, _ = layer(x, c)\n    assert len(scores) == 10\n    assert np.all(scores[0].shape == (4, 1, 1))\n",
            "masked_code": "import numpy as np\nimport torch\n\nfrom TTS.vocoder.models.random_window_discriminator import RandomWindowDiscriminator\n\n\ndef test_rwd():\n    layer = RandomWindowDiscriminator(\n        cond_channels=80,\n        window_sizes=(512, 1024, 2048, 4096, 8192),\n        cond_disc_downsample_factors=[(8, 4, 2, 2, 2), (8, 4, 2, 2), (8, 4, 2), (8, 4), (4, 2, 2)],\n        hop_length=256,\n    )\n    x = torch.rand([4, 1, 22050])\n    c = torch.rand([4, 80, 22050 // 256])\n\n    scores, _ = layer(x, c)\n    assert len(scores) == 10\n    <line_mask>\n",
            "masked_line": "assert np.all(scores[0].shape == (4, 1, 1))",
            "answer": "all",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "downstream_application_code",
            "id": "downstream_application_code_block_74"
        },
        {
            "dependency": "torch",
            "version": ">=2.1",
            "time": "2020-05-20",
            "description": "This code defines a subclass called FullbandMelganGenerator that inherits from the MelganGenerator class. It initializes the subclass with certain parameters such as input and output channels, kernel sizes, and number of residual blocks. The class also includes an inference method that takes conditional features as input, pads the features, and returns the output using the layers of the generator.",
            "code": "import torch\n\nfrom TTS.vocoder.models.melgan_generator import MelganGenerator\n\n\nclass FullbandMelganGenerator(MelganGenerator):\n    def __init__(\n        self,\n        in_channels=80,\n        out_channels=1,\n        proj_kernel=7,\n        base_channels=512,\n        upsample_factors=(2, 8, 2, 2),\n        res_kernel=3,\n        num_res_blocks=4,\n    ):\n        super().__init__(\n            in_channels=in_channels,\n            out_channels=out_channels,\n            proj_kernel=proj_kernel,\n            base_channels=base_channels,\n            upsample_factors=upsample_factors,\n            res_kernel=res_kernel,\n            num_res_blocks=num_res_blocks,\n        )\n\n    @torch.no_grad()\n    def inference(self, cond_features):\n        cond_features = cond_features.to(self.layers[1].weight.device)\n        cond_features = torch.nn.functional.pad(\n            cond_features, (self.inference_padding, self.inference_padding), \"replicate\"\n        )\n        return self.layers(cond_features)\n",
            "masked_code": "import torch\n\nfrom TTS.vocoder.models.melgan_generator import MelganGenerator\n\n\nclass FullbandMelganGenerator(MelganGenerator):\n    def __init__(\n        self,\n        in_channels=80,\n        out_channels=1,\n        proj_kernel=7,\n        base_channels=512,\n        upsample_factors=(2, 8, 2, 2),\n        res_kernel=3,\n        num_res_blocks=4,\n    ):\n        super().__init__(\n            in_channels=in_channels,\n            out_channels=out_channels,\n            proj_kernel=proj_kernel,\n            base_channels=base_channels,\n            upsample_factors=upsample_factors,\n            res_kernel=res_kernel,\n            num_res_blocks=num_res_blocks,\n        )\n\n    @torch.no_grad()\n    def inference(self, cond_features):\n        cond_features = cond_features.to(self.layers[1].weight.device)\n        <line_mask>\n            cond_features, (self.inference_padding, self.inference_padding), \"replicate\"\n        )\n        return self.layers(cond_features)\n",
            "masked_line": "cond_features = torch.nn.functional.pad(",
            "answer": "nn",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "downstream_application_code",
            "id": "downstream_application_code_block_75"
        },
        {
            "dependency": "torch",
            "version": ">=1.7.1",
            "time": "2020-06-19",
            "description": "This code defines a dummy neural network model using PyTorch's nn.Module class. The model includes a sequential neural network that flattens the input tensor and applies a linear transformation to output a tensor of size 10. The forward method defines how the input tensor is passed through the model and returns the output tensor.",
            "code": "from torch import nn\n\n\nclass DummyModel(nn.Module):\n    def __init__(self):\n        super().__init__()\n        self.main = nn.Sequential(nn.Flatten(), nn.Linear(3072, 10))\n\n    def forward(self, x):\n        return self.main(x)\n",
            "masked_code": "from torch import nn\n\n\nclass DummyModel(nn.Module):\n    def __init__(self):\n        super().__init__()\n        <line_mask>\n\n    def forward(self, x):\n        return self.main(x)\n",
            "masked_line": "self.main = nn.Sequential(nn.Flatten(), nn.Linear(3072, 10))",
            "answer": "Sequential",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "downstream_application_code",
            "id": "downstream_application_code_block_76"
        },
        {
            "dependency": "torch",
            "version": ">=1.10.0",
            "time": "2022-08-24",
            "description": "This code defines a Hard Swish Module in PyTorch, which applies the hard swish function to input tensors. The hard swish function is defined as Hswish(x) = x * ReLU6(x + 3) / 6. The module takes an optional parameter inplace to specify whether the operation should be performed in-place or not. The forward function of the module applies the hard swish function to the input tensor x and returns the output tensor.",
            "code": "# Copyright (c) OpenMMLab. All rights reserved.\nimport torch.nn as nn\n\nfrom .registry import ACTIVATION_LAYERS\n\n\n@ACTIVATION_LAYERS.register_module()\nclass HSwish(nn.Module):\n    \"\"\"Hard Swish Module.\n\n    This module applies the hard swish function:\n\n    .. math::\n        Hswish(x) = x * ReLU6(x + 3) / 6\n\n    Args:\n        inplace (bool): can optionally do the operation in-place.\n            Default: False.\n\n    Returns:\n        Tensor: The output tensor.\n    \"\"\"\n\n    def __init__(self, inplace=False):\n        super(HSwish, self).__init__()\n        self.act = nn.ReLU6(inplace)\n\n    def forward(self, x):\n        return x * self.act(x + 3) / 6\n",
            "masked_code": "# Copyright (c) OpenMMLab. All rights reserved.\nimport torch.nn as nn\n\nfrom .registry import ACTIVATION_LAYERS\n\n\n@ACTIVATION_LAYERS.register_module()\nclass HSwish(nn.Module):\n    \"\"\"Hard Swish Module.\n\n    This module applies the hard swish function:\n\n    .. math::\n        Hswish(x) = x * ReLU6(x + 3) / 6\n\n    Args:\n        inplace (bool): can optionally do the operation in-place.\n            Default: False.\n\n    Returns:\n        Tensor: The output tensor.\n    \"\"\"\n\n    def __init__(self, inplace=False):\n        super(HSwish, self).__init__()\n        <line_mask>\n\n    def forward(self, x):\n        return x * self.act(x + 3) / 6\n",
            "masked_line": "self.act = nn.ReLU6(inplace)",
            "answer": "ReLU6",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "downstream_application_code",
            "id": "downstream_application_code_block_78"
        },
        {
            "dependency": "torch",
            "version": ">=1.10.0",
            "time": "2022-08-24",
            "description": "This code defines a Scale class in Python using PyTorch, which implements a learnable scale parameter. The Scale class scales the input tensor by a learnable factor specified by a scale parameter. The scale factor is initialized with a default value of 1.0 and can be adjusted during training. The forward method of the Scale class multiplies the input tensor by the learnable scale parameter to scale the input tensor.",
            "code": "# Copyright (c) OpenMMLab. All rights reserved.\nimport torch\nimport torch.nn as nn\n\n\nclass Scale(nn.Module):\n    \"\"\"A learnable scale parameter.\n\n    This layer scales the input by a learnable factor. It multiplies a\n    learnable scale parameter of shape (1,) with input of any shape.\n\n    Args:\n        scale (float): Initial value of scale factor. Default: 1.0\n    \"\"\"\n\n    def __init__(self, scale=1.0):\n        super(Scale, self).__init__()\n        self.scale = nn.Parameter(torch.tensor(scale, dtype=torch.float))\n\n    def forward(self, x):\n        return x * self.scale\n",
            "masked_code": "# Copyright (c) OpenMMLab. All rights reserved.\nimport torch\nimport torch.nn as nn\n\n\nclass Scale(nn.Module):\n    \"\"\"A learnable scale parameter.\n\n    This layer scales the input by a learnable factor. It multiplies a\n    learnable scale parameter of shape (1,) with input of any shape.\n\n    Args:\n        scale (float): Initial value of scale factor. Default: 1.0\n    \"\"\"\n\n    def __init__(self, scale=1.0):\n        super(Scale, self).__init__()\n        <line_mask>\n\n    def forward(self, x):\n        return x * self.scale\n",
            "masked_line": "self.scale = nn.Parameter(torch.tensor(scale, dtype=torch.float))",
            "answer": "Parameter",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "downstream_application_code",
            "id": "downstream_application_code_block_79"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.1.0",
            "time": "2021-08-26",
            "description": "The code creates a sparse tensor with negative infinity values at specified indices and then converts it to a dense tensor.",
            "code": "import tensorflow as tf\n\n#there are same values in the tensor\nskip_ids = tf.constant([[0], [0]], dtype=tf.int64)\n\nsparse_mask = tf.SparseTensor(\n    # Put a -inf at each bad index.\n    values=[-float('inf')] * len(skip_ids),\n    indices=skip_ids,\n    # Match the shape to the vocabulary\n    dense_shape=[76])\nprint(sparse_mask)\n\nprediction_mask = tf.sparse.to_dense(sparse_mask)",
            "masked_code": "import tensorflow as tf\n\n#there are same values in the tensor\nskip_ids = tf.constant([[0], [0]], dtype=tf.int64)\n\nsparse_mask = tf.SparseTensor(\n    # Put a -inf at each bad index.\n    values=[-float('inf')] * len(skip_ids),\n    indices=skip_ids,\n    # Match the shape to the vocabulary\n    dense_shape=[76])\nprint(sparse_mask)\n\n<line_mask>",
            "masked_line": "prediction_mask = tf.sparse.to_dense(sparse_mask)",
            "answer": "sparse",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_1"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.1.0",
            "time": "2021-08-26",
            "description": "The code creates a sparse mask for a given set of unique indices by putting -inf at each index and then converts the sparse mask into a dense prediction mask.",
            "code": "import tensorflow as tf\n\nskip_ids = tf.constant([[0], [0]], dtype=tf.int64)\n\n# get unique indices\ntmp1 = tf.reshape(skip_ids, shape=(-1,))\nuniques, idx, counts = tf.unique_with_counts(tmp1)\nuniques_ids = tf.expand_dims(uniques, axis=1)\n\n\nsparse_mask = tf.SparseTensor(\n    # Put a -inf at each bad index.\n    values=[-float('inf')] * len(uniques_ids),\n    indices=uniques_ids,\n    # Match the shape to the vocabulary\n    dense_shape=[76])\nprint(sparse_mask)\n\nprediction_mask = tf.sparse.to_dense(sparse_mask)\n\nprint(prediction_mask)",
            "masked_code": "import tensorflow as tf\n\nskip_ids = tf.constant([[0], [0]], dtype=tf.int64)\n\n# get unique indices\ntmp1 = tf.reshape(skip_ids, shape=(-1,))\nuniques, idx, counts = tf.unique_with_counts(tmp1)\n<line_mask>\n\n\nsparse_mask = tf.SparseTensor(\n    # Put a -inf at each bad index.\n    values=[-float('inf')] * len(uniques_ids),\n    indices=uniques_ids,\n    # Match the shape to the vocabulary\n    dense_shape=[76])\nprint(sparse_mask)\n\nprediction_mask = tf.sparse.to_dense(sparse_mask)\n\nprint(prediction_mask)",
            "masked_line": "uniques_ids = tf.expand_dims(uniques, axis=1)",
            "answer": "expand_dims",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_2"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-01-12",
            "description": "The code creates a boolean array 'y' with the same shape as 'all_bools', then finds the index of the maximum value along axis 1 for each row in array 'x', and assigns these values from 'x' to the corresponding indices in 'y'.",
            "code": "y = np.zeros_like(all_bools, dtype=bool)\nidx = np.arange(len(x)), x.argmax(axis=1)\ny[idx] = x[idx]\n\ny\narray([[False,  True, False],\n       [ True, False, False],\n       [False, False,  True],\n       [False, False, False]])",
            "masked_code": "y = np.zeros_like(all_bools, dtype=bool)\n<line_mask>\ny[idx] = x[idx]\n\ny\narray([[False,  True, False],\n       [ True, False, False],\n       [False, False,  True],\n       [False, False, False]])",
            "masked_line": "idx = np.arange(len(x)), x.argmax(axis=1)",
            "answer": "arange",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_3"
        },
        {
            "dependency": "pyarrow",
            "version": "==4.0.1",
            "time": "2021-07-16",
            "description": "The code reads a pandas DataFrame, converts it to a PyArrow Table, and then writes the Table to an ORC file format at the specified location '/tmp/your_df.orc'.",
            "code": "import pandas as pd\nimport pyarrow as pa\nimport pyarrow.orc as orc\n\n# Here prepare your pandas df.\n\ntable = pa.Table.from_pandas(df, preserve_index=False)\norc.write_table(table, '/tmp/your_df.orc')",
            "masked_code": "import pandas as pd\nimport pyarrow as pa\nimport pyarrow.orc as orc\n\n# Here prepare your pandas df.\n\n<line_mask>\norc.write_table(table, '/tmp/your_df.orc')",
            "masked_line": "table = pa.Table.from_pandas(df, preserve_index=False)",
            "answer": "Table",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_4"
        },
        {
            "dependency": "pytest",
            "version": "==4.1.1",
            "time": "2019-01-29",
            "description": "The code defines two fixture functions, input1 and input2, that retrieve the values of command-line options input1 and input2 for pytest tests.",
            "code": "import pytest\n\n\ndef pytest_addoption(parser):\n    parser.addoption(\"--input1\", action=\"store\", default=\"default input1\")\n    parser.addoption(\"--input2\", action=\"store\", default=\"default input2\")\n\n\n\n@pytest.fixture\ndef input1(request):\n    return request.config.getoption(\"--input1\")\n\n\n@pytest.fixture\ndef input2(request):\n    return request.config.getoption(\"--input2\")",
            "masked_code": "import pytest\n\n\ndef pytest_addoption(parser):\n    parser.addoption(\"--input1\", action=\"store\", default=\"default input1\")\n    parser.addoption(\"--input2\", action=\"store\", default=\"default input2\")\n\n\n\n<line_mask>\ndef input1(request):\n    return request.config.getoption(\"--input1\")\n\n\n@pytest.fixture\ndef input2(request):\n    return request.config.getoption(\"--input2\")",
            "masked_line": "@pytest.fixture",
            "answer": "fixture",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_5"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.0",
            "time": "2019-11-07",
            "description": "The code loads an image from a specified file path, encodes the image as a JPEG, prepares the image bytes for inference, loads a TensorFlow saved model from a directory, performs inference using the loaded model on the prepared image bytes, and returns the output.",
            "code": "import cv2\ncv2.imread(filepath)\nflag, bts = cv.imencode('.jpg', img)\ninp = [bts[:,0].tobytes()]\nsaved_model_dir = '.'\nloaded = tf.saved_model.load(export_dir=saved_model_dir)\ninfer = loaded.signatures[\"serving_default\"]\nout = infer(key=tf.constant('something_unique'), image_bytes=tf.constant(inp))",
            "masked_code": "import cv2\ncv2.imread(filepath)\nflag, bts = cv.imencode('.jpg', img)\ninp = [bts[:,0].tobytes()]\nsaved_model_dir = '.'\n<line_mask>\ninfer = loaded.signatures[\"serving_default\"]\nout = infer(key=tf.constant('something_unique'), image_bytes=tf.constant(inp))",
            "masked_line": "loaded = tf.saved_model.load(export_dir=saved_model_dir)",
            "answer": "saved_model",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_6"
        },
        {
            "dependency": "numpy",
            "version": "==1.16.2",
            "time": "2019-07-09",
            "description": "This code calculates the sum of elements in 'a' array for every 'interval' number of elements.",
            "code": "import numpy as np\n\ninterval = 3\na = [1, 7, 4, 7, 4, 8, 5, 2, 17, 8, 3, 12, 9, 6, 28]\nl = max(a) // interval + 1\nb = np.bincount(a, minlength=l*interval).reshape((l,interval)).sum(axis=1)",
            "masked_code": "import numpy as np\n\ninterval = 3\na = [1, 7, 4, 7, 4, 8, 5, 2, 17, 8, 3, 12, 9, 6, 28]\nl = max(a) // interval + 1\n<line_mask>",
            "masked_line": "b = np.bincount(a, minlength=l*interval).reshape((l,interval)).sum(axis=1)",
            "answer": "reshape",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_7"
        },
        {
            "dependency": "django",
            "version": ">=3.0",
            "time": "2020-09-04",
            "description": "This code defines a Django model called SomeModel with a field named enum_field, which is a CharField with choices specified by the SomeEnum TextChoices class. The enum_field field defaults to Option A (represented by \"A\") from the SomeEnum choices.",
            "code": "from django.db import models\n\nclass SomeModel(models.Model):\n\n    class SomeEnum(models.TextChoices):\n\n        A = \"A\", _(\"Option A\")\n        B = \"B\", _(\"Option B\")\n\n    enum_field = models.CharField(\n        max_length=1,\n        choices=SomeEnum.choices,\n        default=SomeEnum.A,\n    )",
            "masked_code": "from django.db import models\n\nclass SomeModel(models.Model):\n\n    class SomeEnum(models.TextChoices):\n\n        A = \"A\", _(\"Option A\")\n        B = \"B\", _(\"Option B\")\n\n    <line_mask>\n        max_length=1,\n        choices=SomeEnum.choices,\n        default=SomeEnum.A,\n    )",
            "masked_line": "enum_field = models.CharField(",
            "answer": "CharField",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_8"
        },
        {
            "dependency": "pandas",
            "version": "==1.4.1",
            "time": "2022-02-25",
            "description": "The code creates a pandas DataFrame with columns 'A' and 'B' containing the values [1, 2] and [3, 4] respectively. It then uses a generator function to iterate over the records of the DataFrame and print each record. Additionally, it compares the output of the generator function with the to_dict method of the DataFrame when 'orient' parameter is set to 'records'.",
            "code": "import pandas as pd\n\ndf = pd.DataFrame({\n    'A': [1, 2],\n    'B': [3, 4]\n})\n\n# Using Generator\nfor row in dataframe_records_gen(df):\n    print(row)\n\n# For Comparison with to_dict function\nprint(\"to_dict\", df.to_dict(orient='records'))",
            "masked_code": "import pandas as pd\n\ndf = pd.DataFrame({\n    'A': [1, 2],\n    'B': [3, 4]\n})\n\n# Using Generator\nfor row in dataframe_records_gen(df):\n    print(row)\n\n# For Comparison with to_dict function\n<line_mask>",
            "masked_line": "print(\"to_dict\", df.to_dict(orient='records'))",
            "answer": "to_dict",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_9"
        },
        {
            "dependency": "selenium",
            "version": "==4.1.0",
            "time": "2022-01-17",
            "description": "The code initializes a Selenium Edge webdriver with logging capabilities and retrieves and prints the browser logs.",
            "code": "from selenium import webdriver\nfrom selenium.webdriver.common.desired_capabilities import DesiredCapabilities\n\nd = DesiredCapabilities.EDGE\nd['ms:loggingPrefs'] = { 'browser':'ALL' }\n\ndriver = webdriver.Edge(capabilities=d,executable_path = r\"C:\\Users\\Administrator\\Desktop\\msedgedriver.exe\")\ndriver.get('')\n\nentry = driver.get_log(\"browser\")\nprint(entry)",
            "masked_code": "from selenium import webdriver\nfrom selenium.webdriver.common.desired_capabilities import DesiredCapabilities\n\nd = DesiredCapabilities.EDGE\nd['ms:loggingPrefs'] = { 'browser':'ALL' }\n\n<line_mask>\ndriver.get('')\n\nentry = driver.get_log(\"browser\")\nprint(entry)",
            "masked_line": "driver = webdriver.Edge(capabilities=d,executable_path = r\"C:\\Users\\Administrator\\Desktop\\msedgedriver.exe\")",
            "answer": "Edge",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_10"
        },
        {
            "dependency": "elasticsearch",
            "version": "==8.1.2",
            "time": "2022-04-15",
            "description": "This code generates random values for the field 'my_field' and adds them to a list. Every 1000 documents, it sends a bulk request to Elasticsearch to index these documents.",
            "code": "from elasticsearch import Elasticsearch, helpers\nfrom random import getrandbits\n\nes_client = Elasticsearch('https://elastic.host:9200')\n\ndocument_list = []\nfor i in range(1,10000000):\n    document = {'my_field': getrandbits(64)}\n    document_list.append(document)\n    if i % 1000 == 0:\n        helpers.bulk(es_client, document_list, index='my_index')\n        document_list = []",
            "masked_code": "from elasticsearch import Elasticsearch, helpers\nfrom random import getrandbits\n\n<line_mask>\n\ndocument_list = []\nfor i in range(1,10000000):\n    document = {'my_field': getrandbits(64)}\n    document_list.append(document)\n    if i % 1000 == 0:\n        helpers.bulk(es_client, document_list, index='my_index')\n        document_list = []",
            "masked_line": "es_client = Elasticsearch('https://elastic.host:9200')",
            "answer": "Elasticsearch",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_11"
        },
        {
            "dependency": "elasticsearch",
            "version": "==8.1.2",
            "time": "2022-04-15",
            "description": "The code generates random 64-bit integer values and inserts them into an Elasticsearch index in batches of 1000 documents.",
            "code": "from elasticsearch import Elasticsearch\nfrom random import getrandbits\n\nes_client = Elasticsearch('https://elastic.host:9200')\n\nactions_list = []\nfor i in range(1,10000000):\n    document = {'my_field': getrandbits(64)}\n    actions_list.append({\"index\": {}, \"doc\": document})\n    if i % 1000 == 0:\n        es_client.bulk(operations=actions_list, index='my_index')\n        actions_list = []",
            "masked_code": "<line_mask>\nfrom random import getrandbits\n\nes_client = Elasticsearch('https://elastic.host:9200')\n\nactions_list = []\nfor i in range(1,10000000):\n    document = {'my_field': getrandbits(64)}\n    actions_list.append({\"index\": {}, \"doc\": document})\n    if i % 1000 == 0:\n        es_client.bulk(operations=actions_list, index='my_index')\n        actions_list = []",
            "masked_line": "from elasticsearch import Elasticsearch",
            "answer": "Elasticsearch",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_12"
        },
        {
            "dependency": "numpy",
            "version": "==1.26.0",
            "time": "2023-12-06",
            "description": "The code generates a matrix `c` of size N x 2N, where the even columns contain the identity matrix of size N and the odd columns contain a diagonal matrix created from a given vector.",
            "code": "a = np.eye(N)\nb = np.diag(some_vector)\n\nc = np.empty((N, 2*N))\nc[:, 0::2] = a\nc[:, 1::2] = b",
            "masked_code": "<line_mask>\nb = np.diag(some_vector)\n\nc = np.empty((N, 2*N))\nc[:, 0::2] = a\nc[:, 1::2] = b",
            "masked_line": "a = np.eye(N)",
            "answer": "eye",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_13"
        },
        {
            "dependency": "numpy",
            "version": "==1.26.0",
            "time": "2023-12-06",
            "description": "The code initializes a matrix of zeros with a size of 2n^2, sets specific elements of the matrix to 1 and some values from a vector, and then reshapes the matrix to a 2D array of size n by 2n.",
            "code": "some_matrix = np.zeros(2 * n**2)\n\nstep = 2 * (n + 1)\n\nsome_matrix[::step] = 1\nsome_matrix[1::step] = some_vector\nsome_matrix = some_matrix.reshape(n, 2 * n)",
            "masked_code": "some_matrix = np.zeros(2 * n**2)\n\nstep = 2 * (n + 1)\n\nsome_matrix[::step] = 1\nsome_matrix[1::step] = some_vector\n<line_mask>",
            "masked_line": "some_matrix = some_matrix.reshape(n, 2 * n)",
            "answer": "reshape",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_14"
        },
        {
            "dependency": "openai",
            "version": ">=1.0.0",
            "time": "2023-05-31",
            "description": "The code makes an API request to OpenAI to generate completions using the GPT-3.5 model with the prompt \"Say this is a test\". If successful, it prints the response, otherwise it handles any OpenAI API errors.",
            "code": "import os\nfrom openai import OpenAI, OpenAIError\nclient = OpenAI()\nOpenAI.api_key = os.getenv('OPENAI_API_KEY')\n\ntry:\n  # Make your OpenAI API request here\n  response = client.completions.create(\n    model=\"gpt-3.5-turbo-instruct\",\n    prompt=\"Say this is a test\"\n  )\n  print(response)\nexcept OpenAIError as e:\n  # Handle all OpenAI API errors\n  print(f\"Error: {e}\")",
            "masked_code": "import os\nfrom openai import OpenAI, OpenAIError\nclient = OpenAI()\nOpenAI.api_key = os.getenv('OPENAI_API_KEY')\n\ntry:\n  # Make your OpenAI API request here\n  <line_mask>\n    model=\"gpt-3.5-turbo-instruct\",\n    prompt=\"Say this is a test\"\n  )\n  print(response)\nexcept OpenAIError as e:\n  # Handle all OpenAI API errors\n  print(f\"Error: {e}\")",
            "masked_line": "response = client.completions.create(",
            "answer": "create",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_15"
        },
        {
            "dependency": "pandas",
            "version": ">=1.3.0",
            "time": "2023-07-11",
            "description": "The code calculates whether each element in the column 'd_max' is a peak by checking if the values in a rolling window of size 12 are all the same.",
            "code": "import pandas as pd\nimport numpy as np\ndata = {'d_max': [2, 3] + [6] * 12 + [1, 5, 5, 5]}\ndf = pd.DataFrame(data)\ndf['is_peak'] = df['d_max'][::-1].rolling(12, closed='left').apply(lambda x:len(set(x))==1)[::-1]\ndf",
            "masked_code": "import pandas as pd\nimport numpy as np\ndata = {'d_max': [2, 3] + [6] * 12 + [1, 5, 5, 5]}\ndf = pd.DataFrame(data)\n<line_mask>\ndf",
            "masked_line": "df['is_peak'] = df['d_max'][::-1].rolling(12, closed='left').apply(lambda x:len(set(x))==1)[::-1]",
            "answer": "apply",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_16"
        },
        {
            "dependency": "pytest",
            "version": "==7.4.0",
            "time": "2023-07-07",
            "description": "The code defines fixtures for creating an app and a test client for testing a FastAPI application. The 'app' fixture returns the created FastAPI app using the 'create_app' function, while the 'client' fixture returns a TestClient object for testing the app.",
            "code": "import pytest\n\nfrom fastapi.testclient import TestClient\nfrom main import create_app\n\n\n@pytest.fixture\ndef app():\n    return create_app()\n\n\n@pytest.fixture\ndef client(app):\n    return TestClient(app)",
            "masked_code": "import pytest\n\nfrom fastapi.testclient import TestClient\nfrom main import create_app\n\n\n@pytest.fixture\ndef app():\n    return create_app()\n\n\n<line_mask>\ndef client(app):\n    return TestClient(app)",
            "masked_line": "@pytest.fixture",
            "answer": "fixture",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_17"
        },
        {
            "dependency": "customtkinter",
            "version": "==5.1.2",
            "time": "2023-03-13",
            "description": "The code creates a custom tkinter window with a button containing the text 'aaa bbb ccc ddd'. The button's text label is configured to wrap at 50 pixels and then the button is displayed on the window. Finally, the window enters the main event loop.",
            "code": "import customtkinter as ctk\n\nroot = ctk.CTk()\n\nbutton = ctk.CTkButton(root, text='aaa bbb ccc ddd')\nbutton._text_label.configure(wraplength=50)\nbutton.pack()\n\nroot.mainloop()",
            "masked_code": "import customtkinter as ctk\n\nroot = ctk.CTk()\n\n<line_mask>\nbutton._text_label.configure(wraplength=50)\nbutton.pack()\n\nroot.mainloop()",
            "masked_line": "button = ctk.CTkButton(root, text='aaa bbb ccc ddd')",
            "answer": "CTkButton",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_18"
        },
        {
            "dependency": "pandas",
            "version": "==2.0.3",
            "time": "2023-07-27",
            "description": "The code reads an existing Excel file, adds a new row to the dataframe, and then writes the updated dataframe back to the existing Excel file.",
            "code": "import pandas as pd\n# Read the existing Excel file\ndf = pd.read_excel('existing_file.xlsx')\n\n# Create a new dataframe with the new row\nnew_row = pd.DataFrame({'key': ['black'], 'value': ['2']})\ndf = pd.concat([df, new_row], ignore_index=True)\n\n# Write the dataframe to the existing Excel file using ExcelWriter\nwith pd.ExcelWriter('existing_file.xlsx', mode='a', if_sheet_exists='overlay') as writer:\n    df.to_excel(writer, sheet_name='Sheet1', index=False)",
            "masked_code": "import pandas as pd\n# Read the existing Excel file\ndf = pd.read_excel('existing_file.xlsx')\n\n# Create a new dataframe with the new row\nnew_row = pd.DataFrame({'key': ['black'], 'value': ['2']})\n<line_mask>\n\n# Write the dataframe to the existing Excel file using ExcelWriter\nwith pd.ExcelWriter('existing_file.xlsx', mode='a', if_sheet_exists='overlay') as writer:\n    df.to_excel(writer, sheet_name='Sheet1', index=False)",
            "masked_line": "df = pd.concat([df, new_row], ignore_index=True)",
            "answer": "concat",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_19"
        },
        {
            "dependency": "boto3",
            "version": "==1.9.134",
            "time": "2019-04-25",
            "description": "The code uploads a 100mb file named '100mb.txt' to an S3 bucket named 'test-threads' using boto3 library.",
            "code": "import io\nimport pdb\n\nimport boto3\n\n# From dd if=/dev/zero of=100mb.txt  bs=50M  count=1\nbuf = io.BytesIO(open('100mb.txt', 'rb').read())\nbucket = boto3.resource('s3').Bucket('test-threads')\npdb.run(\"bucket.upload_fileobj(buf, '100mb')\")",
            "masked_code": "import io\nimport pdb\n\nimport boto3\n\n# From dd if=/dev/zero of=100mb.txt  bs=50M  count=1\nbuf = io.BytesIO(open('100mb.txt', 'rb').read())\n<line_mask>\npdb.run(\"bucket.upload_fileobj(buf, '100mb')\")",
            "masked_line": "bucket = boto3.resource('s3').Bucket('test-threads')",
            "answer": "Bucket",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_20"
        },
        {
            "dependency": "pandas",
            "version": "==0.23.4",
            "time": "2019-03-09",
            "description": "The code generates a DataFrame containing financial data for two symbols, 'AA' and 'BB', with columns for open, high, low, close prices, volume, and adjusted close price. The data is generated randomly with 1000 rows and dates ranging from January 2, 1962.",
            "code": "import pandas as pd # version 0.23.4\nimport numpy as np # version 1.15.4\n\nnp.random.seed(1)\n\ndf1 = pd.DataFrame(index=[\n    pd.date_range(start='1962-01-02', periods=1000, freq='D'),\n    ['AA']*500 + ['BB']*500\n], columns=[\n    'price_open',\n    'price_high',\n    'price_low',\n    'price_close',\n    'volume',\n    'price_adj_close'\n], data=np.random.random(size=(1000, 6)))\n\ndf1.index.names = ['date', 'symbol']",
            "masked_code": "import pandas as pd # version 0.23.4\nimport numpy as np # version 1.15.4\n\nnp.random.seed(1)\n\n<line_mask>\n    pd.date_range(start='1962-01-02', periods=1000, freq='D'),\n    ['AA']*500 + ['BB']*500\n], columns=[\n    'price_open',\n    'price_high',\n    'price_low',\n    'price_close',\n    'volume',\n    'price_adj_close'\n], data=np.random.random(size=(1000, 6)))\n\ndf1.index.names = ['date', 'symbol']",
            "masked_line": "df1 = pd.DataFrame(index=[",
            "answer": "DataFrame",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_21"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.4",
            "time": "2019-03-09",
            "description": "The code generates a DataFrame 'df1' with 1000 rows and 6 columns containing random numerical values. The index of the DataFrame consists of dates ranging from '1962-01-02' with a frequency of 1 day, and symbols 'AA' and 'BB'. The columns of the DataFrame represent stock market data such as open price, high price, low price, close price, volume, and adjusted close price.",
            "code": "import pandas as pd # version 0.23.4\nimport numpy as np # version 1.15.4\n\nnp.random.seed(1)\n\ndf1 = pd.DataFrame(index=[\n    pd.date_range(start='1962-01-02', periods=1000, freq='D'),\n    ['AA']*500 + ['BB']*500\n], columns=[\n    'price_open',\n    'price_high',\n    'price_low',\n    'price_close',\n    'volume',\n    'price_adj_close'\n], data=np.random.random(size=(1000, 6)))\n\ndf1.index.names = ['date', 'symbol']",
            "masked_code": "import pandas as pd # version 0.23.4\nimport numpy as np # version 1.15.4\n\n<line_mask>\n\ndf1 = pd.DataFrame(index=[\n    pd.date_range(start='1962-01-02', periods=1000, freq='D'),\n    ['AA']*500 + ['BB']*500\n], columns=[\n    'price_open',\n    'price_high',\n    'price_low',\n    'price_close',\n    'volume',\n    'price_adj_close'\n], data=np.random.random(size=(1000, 6)))\n\ndf1.index.names = ['date', 'symbol']",
            "masked_line": "np.random.seed(1)",
            "answer": "seed",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_22"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.14.0",
            "time": "2019-11-07",
            "description": "The code loads a saved TensorFlow model and uses it to make detections on an image after encoding it. It retrieves the number of detections, detection scores, detection boxes, and detection classes for objects in the image.",
            "code": "import cv2\nimport tensorflow as tf\ncv2.imread(filepath)\nflag, bts = cv.imencode('.jpg', img)\ninp = [bts[:,0].tobytes()]\nwith tf.Session(graph=tf.Graph()) as sess:\n    tf.saved_model.loader.load(sess, ['serve'], 'directory_of_saved_model')\n    graph = tf.get_default_graph()\n    out = sess.run([sess.graph.get_tensor_by_name('num_detections:0'),\n            sess.graph.get_tensor_by_name('detection_scores:0'),\n            sess.graph.get_tensor_by_name('detection_boxes:0'),\n            sess.graph.get_tensor_by_name('detection_classes:0')],\n           feed_dict={'encoded_image_string_tensor:0': inp})",
            "masked_code": "import cv2\nimport tensorflow as tf\ncv2.imread(filepath)\nflag, bts = cv.imencode('.jpg', img)\ninp = [bts[:,0].tobytes()]\nwith tf.Session(graph=tf.Graph()) as sess:\n    <line_mask>\n    graph = tf.get_default_graph()\n    out = sess.run([sess.graph.get_tensor_by_name('num_detections:0'),\n            sess.graph.get_tensor_by_name('detection_scores:0'),\n            sess.graph.get_tensor_by_name('detection_boxes:0'),\n            sess.graph.get_tensor_by_name('detection_classes:0')],\n           feed_dict={'encoded_image_string_tensor:0': inp})",
            "masked_line": "tf.saved_model.loader.load(sess, ['serve'], 'directory_of_saved_model')",
            "answer": "saved_model",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_23"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.14.0",
            "time": "2019-11-07",
            "description": "This code loads a pre-trained TensorFlow model from a saved directory and uses OpenCV to read and preprocess an image. It then runs the model on the image to detect objects and returns the number of detections, detection scores, detection boxes, and detection classes for the objects in the image.",
            "code": "import cv2\nimport tensorflow as tf\nimport numpy as np\nwith tf.Session(graph=tf.Graph()) as sess:\n    tf.saved_model.loader.load(sess, ['serve'], 'directory_of_saved_model')\n    graph = tf.get_default_graph()\n    # Read and preprocess an image.\n    img = cv2.imread(filepath)\n    # Run the model\n    out = sess.run([sess.graph.get_tensor_by_name('num_detections:0'),\n                    sess.graph.get_tensor_by_name('detection_scores:0'),\n                    sess.graph.get_tensor_by_name('detection_boxes:0'),\n                    sess.graph.get_tensor_by_name('detection_classes:0')],\n                   feed_dict={'map/TensorArrayStack/TensorArrayGatherV3:0': img[np.newaxis, :, :, :]})",
            "masked_code": "import cv2\nimport tensorflow as tf\nimport numpy as np\nwith tf.Session(graph=tf.Graph()) as sess:\n    <line_mask>\n    graph = tf.get_default_graph()\n    # Read and preprocess an image.\n    img = cv2.imread(filepath)\n    # Run the model\n    out = sess.run([sess.graph.get_tensor_by_name('num_detections:0'),\n                    sess.graph.get_tensor_by_name('detection_scores:0'),\n                    sess.graph.get_tensor_by_name('detection_boxes:0'),\n                    sess.graph.get_tensor_by_name('detection_classes:0')],\n                   feed_dict={'map/TensorArrayStack/TensorArrayGatherV3:0': img[np.newaxis, :, :, :]})",
            "masked_line": "tf.saved_model.loader.load(sess, ['serve'], 'directory_of_saved_model')",
            "answer": "loader",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_24"
        },
        {
            "dependency": "scipy",
            "version": "==0.16.0",
            "time": "2019-05-20",
            "description": "This function calculates a 1-dimensional maximum filter with the specified window size on an input array, replacing the values at the edges with a fill value if necessary.",
            "code": "from scipy.ndimage.filters import maximum_filter1d\n\ndef max_filter1d_same(a, W, fillna=np.nan):\n    out_dtype = np.full(0,fillna).dtype\n    hW = (W-1)//2 # Half window size\n    out = maximum_filter1d(a,size=W, origin=hW)\n    if out.dtype is out_dtype:\n        out[:W-1] = fillna\n    else:\n        out = np.concatenate((np.full(W-1,fillna), out[W-1:]))\n    return out",
            "masked_code": "<line_mask>\n\ndef max_filter1d_same(a, W, fillna=np.nan):\n    out_dtype = np.full(0,fillna).dtype\n    hW = (W-1)//2 # Half window size\n    out = maximum_filter1d(a,size=W, origin=hW)\n    if out.dtype is out_dtype:\n        out[:W-1] = fillna\n    else:\n        out = np.concatenate((np.full(W-1,fillna), out[W-1:]))\n    return out",
            "masked_line": "from scipy.ndimage.filters import maximum_filter1d",
            "answer": "maximum_filter1d",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_25"
        },
        {
            "dependency": "numpy",
            "version": "==1.19.2",
            "time": "2020-12-17",
            "description": "The code generates a random integer-valued variable using numpy, calculates the probabilities and values from the variable, and then plots the probability distribution of the variable as a line graph.",
            "code": "import numpy as np                 # v 1.19.2\nimport pandas as pd                # v 1.1.3\nimport matplotlib.pyplot as plt    # v 3.3.2\n\n# Create an integer-valued random variable using numpy\nrng = np.random.default_rng(123)\nvariable = rng.laplace(loc=0, scale=5, size=1000).round()\n\n# Create dataframe with values and probabilities\nvar_range = variable.max()-variable.min()\nprobabilities, values = np.histogram(variable, bins=int(var_range), density=True)\n\n# Plot probability distribution like in your example\ndf = pd.DataFrame(dict(value=values[:-1], prob=probabilities))\ndf.plot.line(x='value', y='prob')",
            "masked_code": "import numpy as np                 # v 1.19.2\nimport pandas as pd                # v 1.1.3\nimport matplotlib.pyplot as plt    # v 3.3.2\n\n# Create an integer-valued random variable using numpy\nrng = np.random.default_rng(123)\nvariable = rng.laplace(loc=0, scale=5, size=1000).round()\n\n# Create dataframe with values and probabilities\n<line_mask>\nprobabilities, values = np.histogram(variable, bins=int(var_range), density=True)\n\n# Plot probability distribution like in your example\ndf = pd.DataFrame(dict(value=values[:-1], prob=probabilities))\ndf.plot.line(x='value', y='prob')",
            "masked_line": "var_range = variable.max()-variable.min()",
            "answer": "min",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_26"
        },
        {
            "dependency": "pandas",
            "version": "==1.1.3",
            "time": "2020-12-17",
            "description": "The code generates a random variable with Laplace distribution using numpy, creates a dataframe with values and probabilities, and then plots the probability distribution as a line graph using pandas and matplotlib.",
            "code": "import numpy as np                 # v 1.19.2\nimport pandas as pd                # v 1.1.3\nimport matplotlib.pyplot as plt    # v 3.3.2\n\n# Create an integer-valued random variable using numpy\nrng = np.random.default_rng(123)\nvariable = rng.laplace(loc=0, scale=5, size=1000).round()\n\n# Create dataframe with values and probabilities\nvar_range = variable.max()-variable.min()\nprobabilities, values = np.histogram(variable, bins=int(var_range), density=True)\n\n# Plot probability distribution like in your example\ndf = pd.DataFrame(dict(value=values[:-1], prob=probabilities))\ndf.plot.line(x='value', y='prob')",
            "masked_code": "import numpy as np                 # v 1.19.2\nimport pandas as pd                # v 1.1.3\nimport matplotlib.pyplot as plt    # v 3.3.2\n\n# Create an integer-valued random variable using numpy\nrng = np.random.default_rng(123)\nvariable = rng.laplace(loc=0, scale=5, size=1000).round()\n\n# Create dataframe with values and probabilities\nvar_range = variable.max()-variable.min()\nprobabilities, values = np.histogram(variable, bins=int(var_range), density=True)\n\n# Plot probability distribution like in your example\ndf = pd.DataFrame(dict(value=values[:-1], prob=probabilities))\n<line_mask>",
            "masked_line": "df.plot.line(x='value', y='prob')",
            "answer": "line",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_27"
        },
        {
            "dependency": "pandas",
            "version": "==1.1.3",
            "time": "2020-12-17",
            "description": "The code generates a probability distribution plot for measured data using both a histogram and a kernel density estimate (KDE). The histogram is plotted with specified bins and color settings, while the KDE is plotted in black with some transparency. Additionally, the x-axis limits are saved and then reset to improve the readability of the final plot, and a legend is added to differentiate the KDE plot.",
            "code": "# Better way to plot the probability distribution of measured data,\n# with a kernel density estimate\n\ns = pd.Series(variable)\n\n# Plot pandas histogram\ns.plot.hist(bins=20, density=True, edgecolor='w', linewidth=0.5)\n\n# Save default x-axis limits for final formatting because the pandas kde\n# plot uses much wider limits which decreases readability\nax = plt.gca()\nxlim = ax.get_xlim()\n\n# Plot pandas KDE\ns.plot.density(color='black', alpha=0.5) # identical to s.plot.kde(...)\n\n# Reset hist x-axis limits and add legend\nax.set_xlim(xlim)\nax.legend(labels=['KDE'], frameon=False)",
            "masked_code": "# Better way to plot the probability distribution of measured data,\n# with a kernel density estimate\n\ns = pd.Series(variable)\n\n# Plot pandas histogram\ns.plot.hist(bins=20, density=True, edgecolor='w', linewidth=0.5)\n\n# Save default x-axis limits for final formatting because the pandas kde\n# plot uses much wider limits which decreases readability\nax = plt.gca()\nxlim = ax.get_xlim()\n\n# Plot pandas KDE\n<line_mask>\n\n# Reset hist x-axis limits and add legend\nax.set_xlim(xlim)\nax.legend(labels=['KDE'], frameon=False)",
            "masked_line": "s.plot.density(color='black', alpha=0.5) # identical to s.plot.kde(...)",
            "answer": "plot",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_28"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.3.2",
            "time": "2020-12-17",
            "description": "The code plots the probability distribution of measured data by first creating a pandas Series from the data, then plotting a histogram with 20 bins and density normalized. It saves the default x-axis limits for final formatting, plots a kernel density estimate (KDE) for the data, resets the x-axis limits to the default values, and adds a legend labeling the KDE plot.",
            "code": "# Better way to plot the probability distribution of measured data,\n# with a kernel density estimate\n\ns = pd.Series(variable)\n\n# Plot pandas histogram\ns.plot.hist(bins=20, density=True, edgecolor='w', linewidth=0.5)\n\n# Save default x-axis limits for final formatting because the pandas kde\n# plot uses much wider limits which decreases readability\nax = plt.gca()\nxlim = ax.get_xlim()\n\n# Plot pandas KDE\ns.plot.density(color='black', alpha=0.5) # identical to s.plot.kde(...)\n\n# Reset hist x-axis limits and add legend\nax.set_xlim(xlim)\nax.legend(labels=['KDE'], frameon=False)",
            "masked_code": "# Better way to plot the probability distribution of measured data,\n# with a kernel density estimate\n\ns = pd.Series(variable)\n\n# Plot pandas histogram\ns.plot.hist(bins=20, density=True, edgecolor='w', linewidth=0.5)\n\n# Save default x-axis limits for final formatting because the pandas kde\n# plot uses much wider limits which decreases readability\nax = plt.gca()\nxlim = ax.get_xlim()\n\n# Plot pandas KDE\ns.plot.density(color='black', alpha=0.5) # identical to s.plot.kde(...)\n\n# Reset hist x-axis limits and add legend\nax.set_xlim(xlim)\n<line_mask>",
            "masked_line": "ax.legend(labels=['KDE'], frameon=False)",
            "answer": "legend",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_29"
        },
        {
            "dependency": "numpy",
            "version": "==1.19.2",
            "time": "2021-01-05",
            "description": "This code calculates the mean, minimum, and maximum values of a dataset along the specified axis. It then computes the error between the mean and the minimum values, as well as between the maximum and the mean values. Finally, it generates a plot with error bars and an error band to visualize the data.",
            "code": "ymean = yfuncs.mean(axis=0)\nymin = yfuncs.min(axis=0)\nymax = yfuncs.max(axis=0)\nyerror = np.stack((ymean-ymin, ymax-ymean))\n\nfig, ax = plt.subplots(figsize=(10,4))\nplt.fill_between(x, ymin, ymax, alpha=0.2, label='error band')\nplt.errorbar(x, ymean, yerror, color='tab:blue', ecolor='tab:blue',\n             capsize=3, linewidth=1, label='mean with error bars')\nplt.legend()\n\nplt.show()",
            "masked_code": "ymean = yfuncs.mean(axis=0)\nymin = yfuncs.min(axis=0)\nymax = yfuncs.max(axis=0)\n<line_mask>\n\nfig, ax = plt.subplots(figsize=(10,4))\nplt.fill_between(x, ymin, ymax, alpha=0.2, label='error band')\nplt.errorbar(x, ymean, yerror, color='tab:blue', ecolor='tab:blue',\n             capsize=3, linewidth=1, label='mean with error bars')\nplt.legend()\n\nplt.show()",
            "masked_line": "yerror = np.stack((ymean-ymin, ymax-ymean))",
            "answer": "stack",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_30"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.3.2",
            "time": "2021-01-05",
            "description": "The code calculates the mean, minimum, and maximum values along the axis of the yfuncs array. It then computes the error values by subtracting the minimum from the mean and the maximum from the mean. Finally, it creates a plot with error bars representing the error band around the mean values of yfuncs.",
            "code": "ymean = yfuncs.mean(axis=0)\nymin = yfuncs.min(axis=0)\nymax = yfuncs.max(axis=0)\nyerror = np.stack((ymean-ymin, ymax-ymean))\n\nfig, ax = plt.subplots(figsize=(10,4))\nplt.fill_between(x, ymin, ymax, alpha=0.2, label='error band')\nplt.errorbar(x, ymean, yerror, color='tab:blue', ecolor='tab:blue',\n             capsize=3, linewidth=1, label='mean with error bars')\nplt.legend()\n\nplt.show()",
            "masked_code": "ymean = yfuncs.mean(axis=0)\nymin = yfuncs.min(axis=0)\nymax = yfuncs.max(axis=0)\nyerror = np.stack((ymean-ymin, ymax-ymean))\n\nfig, ax = plt.subplots(figsize=(10,4))\nplt.fill_between(x, ymin, ymax, alpha=0.2, label='error band')\nplt.errorbar(x, ymean, yerror, color='tab:blue', ecolor='tab:blue',\n             capsize=3, linewidth=1, label='mean with error bars')\nplt.legend()\n\n<line_mask>",
            "masked_line": "plt.show()",
            "answer": "show",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_31"
        },
        {
            "dependency": "ibm-watson",
            "version": ">=4.0",
            "time": "2019-10-05",
            "description": "The code sets up IBM Watson service authentication using an IAM authenticator and a provided API key, then sets the URL for the Watson service.",
            "code": "from ibm_watson import MyService\nfrom ibm_cloud_sdk_core.authenticators import IAMAuthenticator\n\nauthenticator = IAMAuthenticator('{apikey}')\nservice = MyService(\n   authenticator=authenticator\n)\nservice.set_service_url('{url}')",
            "masked_code": "from ibm_watson import MyService\nfrom ibm_cloud_sdk_core.authenticators import IAMAuthenticator\n\nauthenticator = IAMAuthenticator('{apikey}')\n<line_mask>\n   authenticator=authenticator\n)\nservice.set_service_url('{url}')",
            "masked_line": "service = MyService(",
            "answer": "MyService",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_32"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-01-12",
            "description": "The code reads a csv string with columns 'col_a', 'col_b', and 'col_c', converts it into a numpy array, multiplies the values in 'col_a' by 4, and prints the result.",
            "code": "import numpy as np\nfrom io import StringIO\n\ncsv = '''col_a\\tcol_b\\tcol_c\n5.0\\t19.6\\t22.8\n6.0\\t42.42\\t39.208\n'''\n\narr = np.genfromtxt(StringIO(csv), dtype=np.float64, delimiter='\\t', names=True)\n\nxcol_a = arr['col_a']*4\nprint(xcol_a)\n# output: [20. 24.]",
            "masked_code": "import numpy as np\nfrom io import StringIO\n\ncsv = '''col_a\\tcol_b\\tcol_c\n5.0\\t19.6\\t22.8\n6.0\\t42.42\\t39.208\n'''\n\n<line_mask>\n\nxcol_a = arr['col_a']*4\nprint(xcol_a)\n# output: [20. 24.]",
            "masked_line": "arr = np.genfromtxt(StringIO(csv), dtype=np.float64, delimiter='\\t', names=True)",
            "answer": "genfromtxt",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_33"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2020-01-10",
            "description": "The code calculates the adjusted residual values based on certain conditions. If the residual value falls between 0.0 and 0.5, it will be multiplied by -2*1.2. If it falls between 0.5 and 0.7, it will be multiplied by -2*1.0. If the residual value is greater than 0.7, it will be multiplied by -2*2.0. Any residual values that do not meet these conditions will remain unchanged.",
            "code": "import numpy as np\n\nresidual = np.random.rand(10) -0.3 # -0.3 to get some negative values\ncondlist = [(residual>=0.0)&(residual<=0.5), (residual>=0.5)&(residual<=0.7), residual>0.7]\nchoicelist = [-2*1.2*residual, -2*1.0*residual,-2*2.0*residual]\n\nresidual = np.select(condlist, choicelist, default=residual)",
            "masked_code": "import numpy as np\n\nresidual = np.random.rand(10) -0.3 # -0.3 to get some negative values\ncondlist = [(residual>=0.0)&(residual<=0.5), (residual>=0.5)&(residual<=0.7), residual>0.7]\nchoicelist = [-2*1.2*residual, -2*1.0*residual,-2*2.0*residual]\n\n<line_mask>",
            "masked_line": "residual = np.select(condlist, choicelist, default=residual)",
            "answer": "select",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_34"
        },
        {
            "dependency": "pandas",
            "version": "==1.5.3",
            "time": "2020-11-12",
            "description": "The code sets up a dataframe with columns 'Delay' and 'Time', and creates a dictionary 'error' with maximum and minimum values for different 'Time' values. It does not include any function calls or external dependencies.",
            "code": "import pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# set edgecolor param (this is a global setting, so only set it once)\nplt.rcParams[\"patch.force_edgecolor\"] = True\n\n# setup the dataframe\nDelay = ['S1', 'S2', 'S3', 'S4']\n\nTime = [87, 66, 90, 55]\n\ndf = pd.DataFrame({'Delay':Delay,'Time':Time})\n\n# create a dict for the errors\nerror = {87: {'max': 90,'min': 60}, 66: {'max': 70,'min': 40}, 90: {'max': 93,'min': 80}, 55: {'max': 60,'min': 23}}",
            "masked_code": "import pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# set edgecolor param (this is a global setting, so only set it once)\nplt.rcParams[\"patch.force_edgecolor\"] = True\n\n# setup the dataframe\nDelay = ['S1', 'S2', 'S3', 'S4']\n\nTime = [87, 66, 90, 55]\n\n<line_mask>\n\n# create a dict for the errors\nerror = {87: {'max': 90,'min': 60}, 66: {'max': 70,'min': 40}, 90: {'max': 93,'min': 80}, 55: {'max': 60,'min': 23}}",
            "masked_line": "df = pd.DataFrame({'Delay':Delay,'Time':Time})",
            "answer": "DataFrame",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_35"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.7.0",
            "time": "2020-11-12",
            "description": "The code plots a bar graph using the 'Delay' values as x-axis and 'Time' values as y-axis from a dataframe 'df'. It then adds error lines to each bar in the plot based on the min and max values provided in a dictionary 'error'.",
            "code": "# plot the figure\nfig, ax = plt.subplots(figsize=(8, 6))\nsns.barplot(x='Delay', y='Time', data=df, ax=ax)\n\n# add the lines for the errors \nfor p in ax.patches:\n    x = p.get_x()  # get the bottom left x corner of the bar\n    w = p.get_width()  # get width of bar\n    h = p.get_height()  # get height of bar\n    min_y = error[h]['min']  # use h to get min from dict z\n    max_y = error[h]['max']  # use h to get max from dict z\n    plt.vlines(x+w/2, min_y, max_y, color='k')  # draw a vertical line",
            "masked_code": "# plot the figure\n<line_mask>\nsns.barplot(x='Delay', y='Time', data=df, ax=ax)\n\n# add the lines for the errors \nfor p in ax.patches:\n    x = p.get_x()  # get the bottom left x corner of the bar\n    w = p.get_width()  # get width of bar\n    h = p.get_height()  # get height of bar\n    min_y = error[h]['min']  # use h to get min from dict z\n    max_y = error[h]['max']  # use h to get max from dict z\n    plt.vlines(x+w/2, min_y, max_y, color='k')  # draw a vertical line",
            "masked_line": "fig, ax = plt.subplots(figsize=(8, 6))",
            "answer": "subplots",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_36"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.7.0",
            "time": "2020-11-12",
            "description": "This code creates a bar plot using data from a DataFrame, where the x-axis represents delays and the y-axis represents time. For each bar in the plot, it calculates the bottom left x-coordinate, width, and height of the bar. Then, it retrieves the minimum and maximum values from a dictionary based on the bar's height. Finally, it draws a vertical line within each bar connecting the minimum and maximum values.",
            "code": "fig, ax = plt.subplots(figsize=(8, 6))\n\ndf.plot.bar(x='Delay', y='Time', ax=ax)\n\nfor p in ax.patches:\n    x = p.get_x()  # get the bottom left x corner of the bar\n    w = p.get_width()  # get width of bar\n    h = p.get_height()  # get height of bar\n    min_y = error[h]['min']  # use h to get min from dict z\n    max_y = error[h]['max']  # use h to get max from dict z\n    plt.vlines(x+w/2, min_y, max_y, color='k')  # draw a vertical line",
            "masked_code": "<line_mask>\n\ndf.plot.bar(x='Delay', y='Time', ax=ax)\n\nfor p in ax.patches:\n    x = p.get_x()  # get the bottom left x corner of the bar\n    w = p.get_width()  # get width of bar\n    h = p.get_height()  # get height of bar\n    min_y = error[h]['min']  # use h to get min from dict z\n    max_y = error[h]['max']  # use h to get max from dict z\n    plt.vlines(x+w/2, min_y, max_y, color='k')  # draw a vertical line",
            "masked_line": "fig, ax = plt.subplots(figsize=(8, 6))",
            "answer": "subplots",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_37"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.7.0",
            "time": "2020-11-12",
            "description": "This code generates a bar plot using data from a DataFrame, with the x-axis representing the 'Delay' values and the y-axis representing the 'Time' values. It then adds vertical lines to each bar indicating the minimum and maximum values stored in the 'error' dictionary corresponding to each bar's height.",
            "code": "fig, ax = plt.subplots(figsize=(8, 6))\n\nax.bar(x='Delay', height='Time', data=df)\n\nfor p in ax.patches:\n    x = p.get_x()  # get the bottom left x corner of the bar\n    w = p.get_width()  # get width of bar\n    h = p.get_height()  # get height of bar\n    min_y = error[h]['min']  # use h to get min from dict z\n    max_y = error[h]['max']  # use h to get max from dict z\n    plt.vlines(x+w/2, min_y, max_y, color='k')  # draw a vertical line",
            "masked_code": "<line_mask>\n\nax.bar(x='Delay', height='Time', data=df)\n\nfor p in ax.patches:\n    x = p.get_x()  # get the bottom left x corner of the bar\n    w = p.get_width()  # get width of bar\n    h = p.get_height()  # get height of bar\n    min_y = error[h]['min']  # use h to get min from dict z\n    max_y = error[h]['max']  # use h to get max from dict z\n    plt.vlines(x+w/2, min_y, max_y, color='k')  # draw a vertical line",
            "masked_line": "fig, ax = plt.subplots(figsize=(8, 6))",
            "answer": "subplots",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_38"
        },
        {
            "dependency": "seaborn",
            "version": "==0.12.2",
            "time": "2020-11-12",
            "description": "This code generates a bar plot using the data from the 'Delay' and 'Time' columns in a DataFrame named 'df'. It then adds vertical lines to represent error bars for each bar in the plot. The error bars are defined by minimum and maximum values in a dictionary called 'error'.",
            "code": "# plot the figure\nfig, ax = plt.subplots(figsize=(8, 6))\nsns.barplot(x='Delay', y='Time', data=df, ax=ax)\n\n# add the lines for the errors \nfor p in ax.patches:\n    x = p.get_x()  # get the bottom left x corner of the bar\n    w = p.get_width()  # get width of bar\n    h = p.get_height()  # get height of bar\n    min_y = error[h]['min']  # use h to get min from dict z\n    max_y = error[h]['max']  # use h to get max from dict z\n    plt.vlines(x+w/2, min_y, max_y, color='k')  # draw a vertical line",
            "masked_code": "# plot the figure\nfig, ax = plt.subplots(figsize=(8, 6))\n<line_mask>\n\n# add the lines for the errors \nfor p in ax.patches:\n    x = p.get_x()  # get the bottom left x corner of the bar\n    w = p.get_width()  # get width of bar\n    h = p.get_height()  # get height of bar\n    min_y = error[h]['min']  # use h to get min from dict z\n    max_y = error[h]['max']  # use h to get max from dict z\n    plt.vlines(x+w/2, min_y, max_y, color='k')  # draw a vertical line",
            "masked_line": "sns.barplot(x='Delay', y='Time', data=df, ax=ax)",
            "answer": "barplot",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_39"
        },
        {
            "dependency": "matplotlib",
            "version": "==2.1.1",
            "time": "2020-04-14",
            "description": "This code generates a plot with custom tick labels on both the x and y axes. The x-axis values are sorted and displayed as ticks with corresponding labels, as well as the y-axis values. The plot is then displayed with 'Values' as the x-axis label and 'Indices' as the y-axis label.",
            "code": "import matplotlib.pyplot as plt\n\nx_axis_values = ['(-68.18100000000001, 89.754]', '(89.754, 130.42]', '(130.42, 165.601]', '(165.601, 205.456]',\n                 '(205.456, 371.968]']\n\ny_axis_values = ['(-0.123, 0.749]', '(0.749, 0.922]', '(0.922, 1.068]', '(1.068, 1.253]', '(1.253, 2.14]']\n\n# Try to sort the values, before passing to [xticks, yticks]\n# or in which order, you want them along axes\nplt.xticks(ticks=range(len(x_axis_values)), labels=x_axis_values)\nplt.yticks(ticks=range(len(y_axis_values)), labels=y_axis_values)\n\n# plt.scatter(x_axis_values, y_axis_values)\nplt.xlabel('Values')\nplt.ylabel('Indices')\n\nplt.show()",
            "masked_code": "import matplotlib.pyplot as plt\n\nx_axis_values = ['(-68.18100000000001, 89.754]', '(89.754, 130.42]', '(130.42, 165.601]', '(165.601, 205.456]',\n                 '(205.456, 371.968]']\n\ny_axis_values = ['(-0.123, 0.749]', '(0.749, 0.922]', '(0.922, 1.068]', '(1.068, 1.253]', '(1.253, 2.14]']\n\n# Try to sort the values, before passing to [xticks, yticks]\n# or in which order, you want them along axes\nplt.xticks(ticks=range(len(x_axis_values)), labels=x_axis_values)\n<line_mask>\n\n# plt.scatter(x_axis_values, y_axis_values)\nplt.xlabel('Values')\nplt.ylabel('Indices')\n\nplt.show()",
            "masked_line": "plt.yticks(ticks=range(len(y_axis_values)), labels=y_axis_values)",
            "answer": "yticks",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_40"
        },
        {
            "dependency": "scikit-learn",
            "version": ">=0.21",
            "time": "2020-03-26",
            "description": "The code calculates the multilabel confusion matrix to evaluate the classification performance of a model on a dataset with multiple labels.",
            "code": "import numpy as np\nfrom sklearn.metrics import multilabel_confusion_matrix\ny_true = np.array([[1, 0, 1, 0, 0],\n                   [0, 1, 0, 1, 1],\n                   [1, 1, 1, 0, 1]])\ny_pred = np.array([[1, 0, 0, 0, 1],\n                   [0, 1, 1, 1, 0],\n                   [1, 1, 1, 0, 0]])\n\nmultilabel_confusion_matrix(y_true, y_pred)\n# result:\narray([[[1, 0],\n        [0, 2]],\n\n       [[1, 0],\n        [0, 2]],\n\n       [[0, 1],\n        [1, 1]],\n\n       [[2, 0],\n        [0, 1]],\n\n       [[0, 1],\n        [2, 0]]])",
            "masked_code": "import numpy as np\n<line_mask>\ny_true = np.array([[1, 0, 1, 0, 0],\n                   [0, 1, 0, 1, 1],\n                   [1, 1, 1, 0, 1]])\ny_pred = np.array([[1, 0, 0, 0, 1],\n                   [0, 1, 1, 1, 0],\n                   [1, 1, 1, 0, 0]])\n\nmultilabel_confusion_matrix(y_true, y_pred)\n# result:\narray([[[1, 0],\n        [0, 2]],\n\n       [[1, 0],\n        [0, 2]],\n\n       [[0, 1],\n        [1, 1]],\n\n       [[2, 0],\n        [0, 1]],\n\n       [[0, 1],\n        [2, 0]]])",
            "masked_line": "from sklearn.metrics import multilabel_confusion_matrix",
            "answer": "multilabel_confusion_matrix",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_41"
        },
        {
            "dependency": "networkx",
            "version": "==1.10",
            "time": "2020-04-24",
            "description": "The code creates a directed multigraph and adds multiple edges between nodes '1', '2', '3', and '4'.",
            "code": "G = nx.MultiDiGraph()\n\nG.add_edge('1','2')\nG.add_edge('1','3')\nG.add_edge('3','2')\nG.add_edge('3','4')\nG.add_edge('4','3')",
            "masked_code": "<line_mask>\n\nG.add_edge('1','2')\nG.add_edge('1','3')\nG.add_edge('3','2')\nG.add_edge('3','4')\nG.add_edge('4','3')",
            "masked_line": "G = nx.MultiDiGraph()",
            "answer": "MultiDiGraph",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_42"
        },
        {
            "dependency": "numpy",
            "version": "==1.19.2",
            "time": "2021-01-07",
            "description": "The code generates random daily changes, calculates the total change by cumulatively summing the daily changes starting from -1900, and creates a DataFrame with columns for daily and total changes from a specified start date to end date.",
            "code": "import numpy as np                 # v 1.19.2\nimport pandas as pd                # v 1.1.3\nimport matplotlib.pyplot as plt    # v 3.3.2\n\nrng = np.random.default_rng(seed=1) # random number generator\n\ndti = pd.bdate_range(start='2020-07-22', end='2020-09-03')\ndaily = rng.normal(loc=0, scale=250, size=dti.size)\ntotal = -1900 + np.cumsum(daily)\n\ndf = pd.DataFrame({'Daily Change': daily,\n                   'Total Change': total},\n                  index=dti)\ndf.head()",
            "masked_code": "import numpy as np                 # v 1.19.2\nimport pandas as pd                # v 1.1.3\nimport matplotlib.pyplot as plt    # v 3.3.2\n\nrng = np.random.default_rng(seed=1) # random number generator\n\ndti = pd.bdate_range(start='2020-07-22', end='2020-09-03')\n<line_mask>\ntotal = -1900 + np.cumsum(daily)\n\ndf = pd.DataFrame({'Daily Change': daily,\n                   'Total Change': total},\n                  index=dti)\ndf.head()",
            "masked_line": "daily = rng.normal(loc=0, scale=250, size=dti.size)",
            "answer": "normal",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_43"
        },
        {
            "dependency": "pandas",
            "version": "==1.1.3",
            "time": "2021-01-07",
            "description": "The code generates a DataFrame using Pandas with two columns, 'Daily Change' and 'Total Change'. 'Daily Change' column contains random numbers drawn from a normal distribution with a mean of 0 and a standard deviation of 250. 'Total Change' column is calculated by taking the cumulative sum of the 'Daily Change' column and starting from -1900. The DataFrame is indexed with business days ranging from July 22, 2020, to September 3, 2020.",
            "code": "import numpy as np                 # v 1.19.2\nimport pandas as pd                # v 1.1.3\nimport matplotlib.pyplot as plt    # v 3.3.2\n\nrng = np.random.default_rng(seed=1) # random number generator\n\ndti = pd.bdate_range(start='2020-07-22', end='2020-09-03')\ndaily = rng.normal(loc=0, scale=250, size=dti.size)\ntotal = -1900 + np.cumsum(daily)\n\ndf = pd.DataFrame({'Daily Change': daily,\n                   'Total Change': total},\n                  index=dti)\ndf.head()",
            "masked_code": "import numpy as np                 # v 1.19.2\nimport pandas as pd                # v 1.1.3\nimport matplotlib.pyplot as plt    # v 3.3.2\n\nrng = np.random.default_rng(seed=1) # random number generator\n\ndti = pd.bdate_range(start='2020-07-22', end='2020-09-03')\ndaily = rng.normal(loc=0, scale=250, size=dti.size)\ntotal = -1900 + np.cumsum(daily)\n\n<line_mask>\n                   'Total Change': total},\n                  index=dti)\ndf.head()",
            "masked_line": "df = pd.DataFrame({'Daily Change': daily,",
            "answer": "DataFrame",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_44"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.3.2",
            "time": "2021-01-07",
            "description": "This code creates custom x ticks and tick labels for a plot by setting a fixed major locator for the x-axis at a specified frequency, setting a fixed minor locator for the x-axis, formatting the major ticks with the index values from the data frame in a specific format, and adjusting the appearance of the x tick labels.",
            "code": "import matplotlib.ticker as mticker\n\n# Create custom x ticks and tick labels\nfreq = 4 # business days\nmaj_locator = mticker.FixedLocator(ax.get_xticks()[::freq])\nmin_locator = mticker.FixedLocator(ax.get_xticks())\nax.xaxis.set_major_locator(maj_locator)\nax.xaxis.set_minor_locator(min_locator)\n\nmaj_formatter = mticker.FixedFormatter(df.index[maj_locator.locs].strftime('%b-%d'))\nax.xaxis.set_major_formatter(maj_formatter)\nplt.setp(ax.get_xticklabels(), rotation=0, ha='center')",
            "masked_code": "import matplotlib.ticker as mticker\n\n# Create custom x ticks and tick labels\nfreq = 4 # business days\nmaj_locator = mticker.FixedLocator(ax.get_xticks()[::freq])\nmin_locator = mticker.FixedLocator(ax.get_xticks())\nax.xaxis.set_major_locator(maj_locator)\nax.xaxis.set_minor_locator(min_locator)\n\n<line_mask>\nax.xaxis.set_major_formatter(maj_formatter)\nplt.setp(ax.get_xticklabels(), rotation=0, ha='center')",
            "masked_line": "maj_formatter = mticker.FixedFormatter(df.index[maj_locator.locs].strftime('%b-%d'))",
            "answer": "FixedFormatter",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_45"
        },
        {
            "dependency": "scikit-learn",
            "version": "<0.23",
            "time": "2020-10-24",
            "description": "The code creates an instance of a Logistic Regression model from the scikit-learn library.",
            "code": "import sklearn\nsklearn.__version__\n# 0.22.2\n\nfrom sklearn.linear_model import LogisticRegression\nlr = LogisticRegression()\nlr",
            "masked_code": "import sklearn\nsklearn.__version__\n# 0.22.2\n\nfrom sklearn.linear_model import LogisticRegression\n<line_mask>\nlr",
            "masked_line": "lr = LogisticRegression()",
            "answer": "LogisticRegression",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_46"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.1.0",
            "time": "2020-09-17",
            "description": "This code calculates whether the target values are in the top k predictions.",
            "code": "import tensorflow as tf\nprint(tf.__version__)\nfrom tensorflow import nn\n\ny_true = [[0, 0, 1], [0, 1, 0]]\ny_pred = [[0.1, 0.9, 0.8], [0.05, 0.95, 0]]\n\ny_pred=tf.convert_to_tensor(y_pred, dtype=tf.float32)\ny_true = tf.convert_to_tensor([2,1], dtype=tf.int32)\n\nprint(nn.in_top_k(y_true, y_pred,  k=3))",
            "masked_code": "import tensorflow as tf\nprint(tf.__version__)\nfrom tensorflow import nn\n\ny_true = [[0, 0, 1], [0, 1, 0]]\ny_pred = [[0.1, 0.9, 0.8], [0.05, 0.95, 0]]\n\n<line_mask>\ny_true = tf.convert_to_tensor([2,1], dtype=tf.int32)\n\nprint(nn.in_top_k(y_true, y_pred,  k=3))",
            "masked_line": "y_pred=tf.convert_to_tensor(y_pred, dtype=tf.float32)",
            "answer": "convert_to_tensor",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_47"
        },
        {
            "dependency": "rpy2",
            "version": "==3.x",
            "time": "2020-04-24",
            "description": "The code converts a pandas DataFrame to an R DataFrame using the rpy2 library, and assigns the result to the variable 'rkernel'.",
            "code": "from rpy2.robjects.conversion import localconverter\nfrom rpy2.robjects import pandas2ri\n\n\ndef pandas_to_rpy2(df):\n    with localconverter(ro.default_converter + pandas2ri.converter):\n        return ro.conversion.py2rpy(df)\n\ndef rpy2_to_pandas(r_df):\n    with localconverter(ro.default_converter + pandas2ri.converter):\n        return ro.conversion.rpy2py(r_df)\n\nrkernel = pandas_to_rpy2(df_dism)",
            "masked_code": "from rpy2.robjects.conversion import localconverter\nfrom rpy2.robjects import pandas2ri\n\n\ndef pandas_to_rpy2(df):\n    <line_mask>\n        return ro.conversion.py2rpy(df)\n\ndef rpy2_to_pandas(r_df):\n    with localconverter(ro.default_converter + pandas2ri.converter):\n        return ro.conversion.rpy2py(r_df)\n\nrkernel = pandas_to_rpy2(df_dism)",
            "masked_line": "with localconverter(ro.default_converter + pandas2ri.converter):",
            "answer": "localconverter",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_48"
        },
        {
            "dependency": "numpy",
            "version": ">=1.17",
            "time": "2020-07-11",
            "description": "The code randomly selects 10 data points from the given test_data list, converts them to float values, and adds Gaussian jitter to each data point using a specific bandwidth factor.",
            "code": "import numpy\n\ngen=numpy.random.Generator(npr.PCG64())\ntest_data = [0, 8, 12, 35, 40, 4, 1, 0, 0, 0]\n# Choose 10 data points from `test_data` at random.\nc=gen.integers(0, len(test_data), size=10)\nc=numpy.asarray([float(test_data[d]) for d in c])\n# Add a Gaussian jitter.\n# Use the bandwidth factor in your example.\nc+=gen.normal(0, 0.18)",
            "masked_code": "import numpy\n\ngen=numpy.random.Generator(npr.PCG64())\ntest_data = [0, 8, 12, 35, 40, 4, 1, 0, 0, 0]\n# Choose 10 data points from `test_data` at random.\nc=gen.integers(0, len(test_data), size=10)\nc=numpy.asarray([float(test_data[d]) for d in c])\n# Add a Gaussian jitter.\n# Use the bandwidth factor in your example.\n<line_mask>",
            "masked_line": "c+=gen.normal(0, 0.18)",
            "answer": "normal",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_49"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.x",
            "time": "2020-05-15",
            "description": "The code creates a TensorFlow graph and sets it as the default graph. It defines a placeholder for 1D tensors of text input, loads a pre-trained Universal Sentence Encoder module from TensorFlow Hub, embeds the text input using the module, and initializes global variables and tables. Finally, it creates a TensorFlow session, initializes it, and runs the initialization operation.",
            "code": "# Create graph and finalize (finalizing optional but recommended).\ng = tf.Graph()\nwith g.as_default():\n  # We will be feeding 1D tensors of text into the graph.\n  text_input = tf.placeholder(dtype=tf.string, shape=[None])\n  embed = hub.Module(\"https://tfhub.dev/google/universal-sentence-encoder/2\")\n  embedded_text = embed(text_input)\n  init_op = tf.group([tf.global_variables_initializer(), tf.tables_initializer()])\ng.finalize()\n\n# Create session and initialize.\nsession = tf.Session(graph=g)\nsession.run(init_op)",
            "masked_code": "# Create graph and finalize (finalizing optional but recommended).\ng = tf.Graph()\nwith g.as_default():\n  # We will be feeding 1D tensors of text into the graph.\n  text_input = tf.placeholder(dtype=tf.string, shape=[None])\n  embed = hub.Module(\"https://tfhub.dev/google/universal-sentence-encoder/2\")\n  embedded_text = embed(text_input)\n  <line_mask>\ng.finalize()\n\n# Create session and initialize.\nsession = tf.Session(graph=g)\nsession.run(init_op)",
            "masked_line": "init_op = tf.group([tf.global_variables_initializer(), tf.tables_initializer()])",
            "answer": "group",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_50"
        },
        {
            "dependency": "plotly",
            "version": "==5.5.0",
            "time": "2021-12-29",
            "description": "The code generates a visualization of medal data using Plotly Express and Plotly Graph Objects. It converts numbers to words using the Inflect library and displays the visualization with text annotations.",
            "code": "import plotly.express as px\nimport plotly.graph_objects as go\nimport inflect\n\np = inflect.engine()\ndf = px.data.medals_wide(indexed=True)\nfig = px.imshow(df, text_auto=True)\nfig2 = go.Figure(fig.data, fig.layout)\nfig2 = fig2.update_traces(text=df.applymap(p.number_to_words).values, texttemplate=\"%{text}\", hovertemplate=None)\n\nfig.show()\nfig2.show()",
            "masked_code": "import plotly.express as px\nimport plotly.graph_objects as go\nimport inflect\n\np = inflect.engine()\ndf = px.data.medals_wide(indexed=True)\nfig = px.imshow(df, text_auto=True)\nfig2 = go.Figure(fig.data, fig.layout)\nfig2 = fig2.update_traces(text=df.applymap(p.number_to_words).values, texttemplate=\"%{text}\", hovertemplate=None)\n\nfig.show()\n<line_mask>",
            "masked_line": "fig2.show()",
            "answer": "show",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_51"
        },
        {
            "dependency": "numpy",
            "version": "==1.20",
            "time": "2021-08-18",
            "description": "The code calculates scores based on comparing sliding windows of size 10 to the last element in each window of a given dataframe. The calculated scores are then stored in a new dataframe with columns corresponding to the original dataframe.",
            "code": "from numpy.lib.stride_tricks import sliding_window_view\ndata = df.to_numpy()\nsw = sliding_window_view(data, 10, axis=0)\nscores_np = (sw <= sw[..., -1:]).sum(axis=2) / sw.shape[-1]\nscores_np_df = pd.DataFrame(scores_np, columns=df.columns)",
            "masked_code": "<line_mask>\ndata = df.to_numpy()\nsw = sliding_window_view(data, 10, axis=0)\nscores_np = (sw <= sw[..., -1:]).sum(axis=2) / sw.shape[-1]\nscores_np_df = pd.DataFrame(scores_np, columns=df.columns)",
            "masked_line": "from numpy.lib.stride_tricks import sliding_window_view",
            "answer": "sliding_window_view",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_52"
        },
        {
            "dependency": "scipy",
            "version": "==1.7.3",
            "time": "2021-12-06",
            "description": "This Python code uses the scipy library to calculate the binned statistic of a dataset based on specified bins. It calculates the mean statistic for the values in each bin, handling missing values represented as NaN.",
            "code": "import scipy\nscipy.__version__\n'1.7.3'\nimport scipy.stats, numpy as np\nx = [0.5, 0.5, 1.5, 1.5]\nvalues = [10, 20, np.nan, 40]\nscipy.stats.binned_statistic(x, values, statistic='mean', bins=(0, 1, 2)).statistic\narray([15., nan])\nscipy.stats.binned_statistic(x, values, statistic=np.nanmean, bins=(0, 1, 2)).statistic\narray([15., 40.])",
            "masked_code": "import scipy\nscipy.__version__\n'1.7.3'\nimport scipy.stats, numpy as np\nx = [0.5, 0.5, 1.5, 1.5]\nvalues = [10, 20, np.nan, 40]\n<line_mask>\narray([15., nan])\nscipy.stats.binned_statistic(x, values, statistic=np.nanmean, bins=(0, 1, 2)).statistic\narray([15., 40.])",
            "masked_line": "scipy.stats.binned_statistic(x, values, statistic='mean', bins=(0, 1, 2)).statistic",
            "answer": "stats",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_53"
        },
        {
            "dependency": "plotly",
            "version": "==4.10",
            "time": "2021-09-18",
            "description": "This code creates an image representation using plotly express and displays it with customized x and y axis ranges.",
            "code": "import plotly.express as px\nfig = px.imshow(\n    img,\n    #color_continuous_scale='gray',\n    binary_string=True\n)\n\nfig.update_xaxes(range=[xmin, xmax])\nfig.update_yaxes(range=[ymax, ymin])\nfig.show()",
            "masked_code": "import plotly.express as px\nfig = px.imshow(\n    img,\n    #color_continuous_scale='gray',\n    binary_string=True\n)\n\nfig.update_xaxes(range=[xmin, xmax])\nfig.update_yaxes(range=[ymax, ymin])\n<line_mask>",
            "masked_line": "fig.show()",
            "answer": "show",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_54"
        },
        {
            "dependency": "pandas",
            "version": "==1.3.0",
            "time": "2021-11-14",
            "description": "This code creates a pandas DataFrame with columns 'A' and 'B', prints the initial DataFrame along with the data types of the columns, updates the values in columns 'A' and 'B' with new values, and prints the updated DataFrame along with the updated data types of the columns.",
            "code": "import pandas as pd\n\ndf = pd.DataFrame({'A': [1.2, 2.3], 'B': [3.4, 4.5]})\nprint(df)\nprint(df.dtypes)\ndf.loc[:, 'A':'B'] = pd.DataFrame({'A': [1, 2], 'B': [3, 4]})\nprint(df)\nprint(df.dtypes)",
            "masked_code": "import pandas as pd\n\n<line_mask>\nprint(df)\nprint(df.dtypes)\ndf.loc[:, 'A':'B'] = pd.DataFrame({'A': [1, 2], 'B': [3, 4]})\nprint(df)\nprint(df.dtypes)",
            "masked_line": "df = pd.DataFrame({'A': [1.2, 2.3], 'B': [3.4, 4.5]})",
            "answer": "DataFrame",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_55"
        },
        {
            "dependency": "pandas",
            "version": "==1.3.0",
            "time": "2021-11-14",
            "description": "The code creates a DataFrame with columns 'A' and 'B' containing floats, prints the DataFrame and its data types, then updates the values in columns 'A' and 'B' with integer values, prints the updated DataFrame and its data types.",
            "code": "import pandas as pd\n\ndf = pd.DataFrame({'A': [1.2, 2.3], 'B': [3.4, 4.5]})\nprint(df)\nprint(df.dtypes)\ndf[['A', 'B']] = pd.DataFrame({'A': [1, 2], 'B': [3, 4]})\nprint(df)\nprint(df.dtypes)",
            "masked_code": "import pandas as pd\n\n<line_mask>\nprint(df)\nprint(df.dtypes)\ndf[['A', 'B']] = pd.DataFrame({'A': [1, 2], 'B': [3, 4]})\nprint(df)\nprint(df.dtypes)",
            "masked_line": "df = pd.DataFrame({'A': [1.2, 2.3], 'B': [3.4, 4.5]})",
            "answer": "DataFrame",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_56"
        },
        {
            "dependency": "pandas",
            "version": "==1.4.4",
            "time": "2023-03-17",
            "description": "This code creates a DataFrame using pandas with columns A, B, C, and D. It then adds new columns E, F, and G to the DataFrame with specific values assigned to each row based on the dictionary d.",
            "code": "import pandas as pd\n\ndf = pd.DataFrame({'A': [3, 9, 3, 4], 'B': [7, 1, 6, 0], 'C': [9, 0, 3, 4], 'D': [1, 8, 0, 0]})\n\nd = {0:10,1:20,2:30,3:40}\n\ndf.loc[:,'E'] = pd.Series({0:10,1:20,2:30,3:40})\ndf.loc[:,'F'] = {0:10,1:20,2:30,3:40}\ndf.loc[:,'G'] = {0:10,1:20,2:30,3:40}\ndf.loc[:,'G'] = {0:10,1:20,2:30,3:40}\ndf",
            "masked_code": "import pandas as pd\n\ndf = pd.DataFrame({'A': [3, 9, 3, 4], 'B': [7, 1, 6, 0], 'C': [9, 0, 3, 4], 'D': [1, 8, 0, 0]})\n\nd = {0:10,1:20,2:30,3:40}\n\n<line_mask>\ndf.loc[:,'F'] = {0:10,1:20,2:30,3:40}\ndf.loc[:,'G'] = {0:10,1:20,2:30,3:40}\ndf.loc[:,'G'] = {0:10,1:20,2:30,3:40}\ndf",
            "masked_line": "df.loc[:,'E'] = pd.Series({0:10,1:20,2:30,3:40})",
            "answer": "Series",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_57"
        },
        {
            "dependency": "tqdm",
            "version": "==4.62.2",
            "time": "2022-02-27",
            "description": "The code generates a large dataset with 100,000,000 rows and 4 columns of random numbers and then squares the contents of each element in a column-wise fashion using pandas and numpy.",
            "code": "from tqdm import tqdm # version 4.62.2\nimport pandas as pd # version 1.4.1\nimport numpy as np\n\ntqdm.pandas(desc='My bar!') # lots of cool paramiters you can pass here. \n# the below line generates a very large dataset for us to work with. \ndf = pd.DataFrame(np.random.randn(100000000, 4), columns=['a','b','c','d'])\n# the below line will square the contents of each element in an column-wise \n# fashion \ndf.progress_apply(lambda x: x**2)",
            "masked_code": "from tqdm import tqdm # version 4.62.2\nimport pandas as pd # version 1.4.1\nimport numpy as np\n\n<line_mask>\n# the below line generates a very large dataset for us to work with. \ndf = pd.DataFrame(np.random.randn(100000000, 4), columns=['a','b','c','d'])\n# the below line will square the contents of each element in an column-wise \n# fashion \ndf.progress_apply(lambda x: x**2)",
            "masked_line": "tqdm.pandas(desc='My bar!') # lots of cool paramiters you can pass here.",
            "answer": "pandas",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_58"
        },
        {
            "dependency": "pandas",
            "version": "==1.4.1",
            "time": "2022-02-27",
            "description": "The code generates a large dataset with random numbers in 4 columns and then squares the contents of each element in a column-wise fashion.",
            "code": "from tqdm import tqdm # version 4.62.2\nimport pandas as pd # version 1.4.1\nimport numpy as np\n\ntqdm.pandas(desc='My bar!') # lots of cool paramiters you can pass here. \n# the below line generates a very large dataset for us to work with. \ndf = pd.DataFrame(np.random.randn(100000000, 4), columns=['a','b','c','d'])\n# the below line will square the contents of each element in an column-wise \n# fashion \ndf.progress_apply(lambda x: x**2)",
            "masked_code": "from tqdm import tqdm # version 4.62.2\nimport pandas as pd # version 1.4.1\nimport numpy as np\n\ntqdm.pandas(desc='My bar!') # lots of cool paramiters you can pass here. \n# the below line generates a very large dataset for us to work with. \ndf = pd.DataFrame(np.random.randn(100000000, 4), columns=['a','b','c','d'])\n# the below line will square the contents of each element in an column-wise \n# fashion \n<line_mask>",
            "masked_line": "df.progress_apply(lambda x: x**2)",
            "answer": "progress_apply",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_59"
        },
        {
            "dependency": "pandas",
            "version": "==1.3.5",
            "time": "2022-04-08",
            "description": "The code generates a 200x100 DataFrame filled with random numbers using numpy, then initializes a list res with two elements [0,0].",
            "code": "import pandas as pd\nimport numpy as np\n\ndf = pd.DataFrame(\n    np.random.rand(200,100)\n)\nperiod = 10\nres = [0,0]",
            "masked_code": "import pandas as pd\nimport numpy as np\n\n<line_mask>\n    np.random.rand(200,100)\n)\nperiod = 10\nres = [0,0]",
            "masked_line": "df = pd.DataFrame(",
            "answer": "DataFrame",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_60"
        },
        {
            "dependency": "PyYAML",
            "version": "==6.0",
            "time": "2022-01-22",
            "description": "This code reads a YAML file named \"test.cwl\", loads its content into a dictionary, then modifies the dictionary by adding a new input item, and finally writes the updated dictionary back to a new YAML file named \"test-new.cwl\".",
            "code": "import yaml\n# Read file\nwith open(\"test.cwl\", 'r') as cwl_file:  \n    cwl_dict = yaml.safe_load(cwl_file)\n\n# Write file\nwith open(\"test-new.cwl\", 'w') as cwl_file:\n    cwl_dict[\"inputs\"] = [{\"id\" : 2, \"type\": \"ABC\"}]\n    yaml.dump(cwl_dict, cwl_file)",
            "masked_code": "import yaml\n# Read file\nwith open(\"test.cwl\", 'r') as cwl_file:  \n    cwl_dict = yaml.safe_load(cwl_file)\n\n# Write file\nwith open(\"test-new.cwl\", 'w') as cwl_file:\n    cwl_dict[\"inputs\"] = [{\"id\" : 2, \"type\": \"ABC\"}]\n    <line_mask>",
            "masked_line": "yaml.dump(cwl_dict, cwl_file)",
            "answer": "dump",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_61"
        },
        {
            "dependency": "Flask",
            "version": ">0.11",
            "time": "2022-12-21",
            "description": "This code creates a Flask web application with a socket.io server that serves a webpage with the content of 'index.html' when a user visits the root URL. The server runs on '127.0.0.1:8000' in debug mode.",
            "code": "from flask import Flask, render_template\nfrom flask_socketio import SocketIO\n\napp = Flask(__name__)\napp.config['SECRET_KEY'] = 'blahBlah'\napp.config['SERVER_NAME'] = '127.0.0.1:8000'\nsocket = SocketIO(app)\n\n@app.route('/')\ndef index():\n    return render_template('index.html')\n\nif __name__ == '__main__':\n    socket.run(app, debug=True)",
            "masked_code": "from flask import Flask, render_template\nfrom flask_socketio import SocketIO\n\napp = Flask(__name__)\napp.config['SECRET_KEY'] = 'blahBlah'\napp.config['SERVER_NAME'] = '127.0.0.1:8000'\nsocket = SocketIO(app)\n\n@app.route('/')\ndef index():\n    return render_template('index.html')\n\nif __name__ == '__main__':\n    <line_mask>",
            "masked_line": "socket.run(app, debug=True)",
            "answer": "run",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_62"
        },
        {
            "dependency": "pyspark",
            "version": "==3.2.1",
            "time": "2022-06-13",
            "description": "This code connects to a local Spark session, reads data from a CSV file, removes the file header, and writes the data to a Kafka topic named \"foobar\" with a specified bootstrap server address.",
            "code": "from pyspark.sql import SparkSession\n\nscala_version = '2.12'  # TODO: Ensure this is correct\nspark_version = '3.2.1'\npackages = [\n    f'org.apache.spark:spark-sql-kafka-0-10_{scala_version}:{spark_version}',\n    'org.apache.kafka:kafka-clients:3.2.0'\n]\nspark = SparkSession.builder\\\n   .master(\"local\")\\\n   .appName(\"kafka-example\")\\\n   .config(\"spark.jars.packages\", \",\".join(packages))\\\n   .getOrCreate()\n\n# Read all lines into a single value dataframe  with column 'value'\n# TODO: Replace with real file. \ndf = spark.read.text('file:///tmp/data.csv')\n\n# TODO: Remove the file header, if it exists\n\n# Write\ndf.write.format(\"kafka\")\\\n  .option(\"kafka.bootstrap.servers\", \"localhost:9092\")\\\n  .option(\"topic\", \"foobar\")\\\n  .save()",
            "masked_code": "from pyspark.sql import SparkSession\n\nscala_version = '2.12'  # TODO: Ensure this is correct\nspark_version = '3.2.1'\npackages = [\n    f'org.apache.spark:spark-sql-kafka-0-10_{scala_version}:{spark_version}',\n    'org.apache.kafka:kafka-clients:3.2.0'\n]\nspark = SparkSession.builder\\\n   .master(\"local\")\\\n   .appName(\"kafka-example\")\\\n   .config(\"spark.jars.packages\", \",\".join(packages))\\\n   .getOrCreate()\n\n# Read all lines into a single value dataframe  with column 'value'\n# TODO: Replace with real file. \n<line_mask>\n\n# TODO: Remove the file header, if it exists\n\n# Write\ndf.write.format(\"kafka\")\\\n  .option(\"kafka.bootstrap.servers\", \"localhost:9092\")\\\n  .option(\"topic\", \"foobar\")\\\n  .save()",
            "masked_line": "df = spark.read.text('file:///tmp/data.csv')",
            "answer": "text",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_63"
        },
        {
            "dependency": "pandas",
            "version": ">2.0.x",
            "time": "2023-08-06",
            "description": "The code converts the 'datetime' column in a DataFrame from object type to datetime type.",
            "code": "import pandas as pd\n\nprint(pd.__version__)\n# '2.0.3'\n\ndata = {\n    'id': [1, 2, 3],\n    'testcolumn': ['A', 'B', 'C'],\n    'datetime': ['2023-07-25 10:30:00', '2023-07-26 12:45:00', \n                 '2023-07-27 15:15:00'],\n    'value': ['100', '200', '300']\n    }\n\ndf = pd.DataFrame(data)\n\nprint(df['datetime'].dtypes)\n# object\n\nprint(type(df.loc[0, 'datetime']))\n# \n\ndf.loc[:, 'datetime'] = pd.to_datetime(df['datetime'])\n\nprint(df['datetime'].dtypes)\n# object\n\nprint(type(df.loc[0, 'datetime']))\n#",
            "masked_code": "import pandas as pd\n\nprint(pd.__version__)\n# '2.0.3'\n\ndata = {\n    'id': [1, 2, 3],\n    'testcolumn': ['A', 'B', 'C'],\n    'datetime': ['2023-07-25 10:30:00', '2023-07-26 12:45:00', \n                 '2023-07-27 15:15:00'],\n    'value': ['100', '200', '300']\n    }\n\n<line_mask>\n\nprint(df['datetime'].dtypes)\n# object\n\nprint(type(df.loc[0, 'datetime']))\n# \n\ndf.loc[:, 'datetime'] = pd.to_datetime(df['datetime'])\n\nprint(df['datetime'].dtypes)\n# object\n\nprint(type(df.loc[0, 'datetime']))\n#",
            "masked_line": "df = pd.DataFrame(data)",
            "answer": "DataFrame",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_64"
        },
        {
            "dependency": "pandas",
            "version": ">2.0.x",
            "time": "2023-08-06",
            "description": "The code displays the version of the pandas library being used, creates a DataFrame from the data, converts the 'datetime' column to a string data type, and then converts it to datetime data type.",
            "code": "print(pd.__version__)\n# '2.0.3'\n\ndf = pd.DataFrame(data)\n\ndf['datetime'] = df['datetime'].astype('string')\n\nprint(df['datetime'].dtypes)\n# string\n\ndf.loc[:, 'datetime'] = pd.to_datetime(df['datetime'])\n\nprint(df['datetime'].dtypes)\n# datetime64[ns]",
            "masked_code": "print(pd.__version__)\n# '2.0.3'\n\n<line_mask>\n\ndf['datetime'] = df['datetime'].astype('string')\n\nprint(df['datetime'].dtypes)\n# string\n\ndf.loc[:, 'datetime'] = pd.to_datetime(df['datetime'])\n\nprint(df['datetime'].dtypes)\n# datetime64[ns]",
            "masked_line": "df = pd.DataFrame(data)",
            "answer": "DataFrame",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_65"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.0",
            "time": "2020-05-09",
            "description": "This code sets the random seed values for Python, TensorFlow, NumPy, and the random module to ensure reproducibility of random processes.",
            "code": "def reset_random_seeds():\n   os.environ['PYTHONHASHSEED']=str(2)\n   tf.random.set_seed(2)\n   np.random.seed(2)\n   random.seed(2)",
            "masked_code": "def reset_random_seeds():\n   os.environ['PYTHONHASHSEED']=str(2)\n   <line_mask>\n   np.random.seed(2)\n   random.seed(2)",
            "masked_line": "tf.random.set_seed(2)",
            "answer": "set_seed",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_66"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.0",
            "time": "2020-12-25",
            "description": "This code defines an Adam optimizer with a learning rate of 0.1 and creates two TensorFlow variables, x and y, which are added to a list called var_list.",
            "code": "import tensorflow as tf\nfrom tensorflow import keras \n\nopt = tf.keras.optimizers.Adam(learning_rate=0.1)\n\nx = tf.Variable([3.0, 4.0]) \ny = tf.Variable([1.0, 1.0, 1.0, 1.0])\nvar_list = [x, y]",
            "masked_code": "import tensorflow as tf\nfrom tensorflow import keras \n\n<line_mask>\n\nx = tf.Variable([3.0, 4.0]) \ny = tf.Variable([1.0, 1.0, 1.0, 1.0])\nvar_list = [x, y]",
            "masked_line": "opt = tf.keras.optimizers.Adam(learning_rate=0.1)",
            "answer": "keras",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_67"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.0",
            "time": "2020-12-25",
            "description": "The function clip_grad limits the gradient values to 10 if they exceed 1000. The processed gradients are then used to apply gradients to the variables in var_list using the optimizer opt.",
            "code": "def clip_grad(grad):\n    if grad > 1000:\n        grad = 10\n    return grad\n\nprocessed_grads = [tf.map_fn(clip_grad, g) for g in grads]\n\nopt.apply_gradients(zip(processed_grads, var_list))",
            "masked_code": "def clip_grad(grad):\n    if grad > 1000:\n        grad = 10\n    return grad\n\n<line_mask>\n\nopt.apply_gradients(zip(processed_grads, var_list))",
            "masked_line": "processed_grads = [tf.map_fn(clip_grad, g) for g in grads]",
            "answer": "map_fn",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_68"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.0",
            "time": "2019-10-26",
            "description": "The code creates a convolutional neural network model that consists of a convolutional layer with 64 filters, a 2x2 max pooling layer, and a flattening layer. It then displays a summary of the model architecture.",
            "code": "from tensorflow.keras.models import Sequential\nfrom tensorflow.keras.layers import Conv2D, MaxPooling2D, Flatten\n\nexample_model = Sequential()\nexample_model.add(Conv2D(64, (3, 3), activation='relu', padding='same', input_shape=(100, 100, 1)))\nexample_model.add(MaxPooling2D((2, 2)))\nexample_model.add(Flatten())\nexample_model.summary()",
            "masked_code": "from tensorflow.keras.models import Sequential\nfrom tensorflow.keras.layers import Conv2D, MaxPooling2D, Flatten\n\nexample_model = Sequential()\n<line_mask>\nexample_model.add(MaxPooling2D((2, 2)))\nexample_model.add(Flatten())\nexample_model.summary()",
            "masked_line": "example_model.add(Conv2D(64, (3, 3), activation='relu', padding='same', input_shape=(100, 100, 1)))",
            "answer": "add",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_69"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.x",
            "time": "2020-05-04",
            "description": "The code generates two random matrices A and B, each with the shape [10,000, 10,000], computes their matrix product, and returns the sum of all elements in the resulting matrix.",
            "code": "import tensorflow as tf\n\ndef get_values():\n  A = tf.random.normal([10_000,10_000])\n  B = tf.random.normal([10_000,10_000])\n  return A,B\n\n@tf.function\ndef compute():\n  A,B = get_values()\n  return tf.reduce_sum(tf.matmul(A,B))\n\nprint(compute())",
            "masked_code": "import tensorflow as tf\n\ndef get_values():\n  <line_mask>\n  B = tf.random.normal([10_000,10_000])\n  return A,B\n\n@tf.function\ndef compute():\n  A,B = get_values()\n  return tf.reduce_sum(tf.matmul(A,B))\n\nprint(compute())",
            "masked_line": "A = tf.random.normal([10_000,10_000])",
            "answer": "random",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_70"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.x",
            "time": "2019-10-29",
            "description": "The code optimizes a variable var1 using stochastic gradient descent (SGD) with a learning rate of 0.1 for 1000 iterations. The loss function is calculated based on the current value of var1 and is minimized to update var1. The final value of var1 is printed after each iteration.",
            "code": "import tensorflow as tf\n\nopt = tf.keras.optimizers.SGD(learning_rate=0.1)\nvar1 = tf.Variable(tf.random.normal([1]))\ndef loss():\n    var2 = tf.add(tf.multiply(-2, var1), 1)\n    return var1 * var1 + var2\n\nfor i in range(1000):\n    opt.minimize(loss, var_list=[var1])\n    print('var1: {}'.format(var1.numpy()))\n    # ...\n    # var1: [0.9999999]",
            "masked_code": "import tensorflow as tf\n\nopt = tf.keras.optimizers.SGD(learning_rate=0.1)\nvar1 = tf.Variable(tf.random.normal([1]))\ndef loss():\n    <line_mask>\n    return var1 * var1 + var2\n\nfor i in range(1000):\n    opt.minimize(loss, var_list=[var1])\n    print('var1: {}'.format(var1.numpy()))\n    # ...\n    # var1: [0.9999999]",
            "masked_line": "var2 = tf.add(tf.multiply(-2, var1), 1)",
            "answer": "add",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_71"
        },
        {
            "dependency": "selenium",
            "version": "==4.8",
            "time": "2023-08-21",
            "description": "This code snippet initializes a Selenium webdriver for Chrome browser with specified options and executable path.",
            "code": "# using selenium 4.8 and python 3.9\n\nfrom selenium import webdriver\nfrom selenium.webdriver.chrome.options import Options\n\n\noptions = Options()\noptions.binary_location = 'path to chrome.exe'\n## this is the chromium for testing which can be downloaded from the link given below\n\ndriver = webdriver.Chrome(chrome_options = options, executable_path = 'path to chromedriver.exe')\n## must be the same as the downloaded version of chrome cft.",
            "masked_code": "# using selenium 4.8 and python 3.9\n\nfrom selenium import webdriver\nfrom selenium.webdriver.chrome.options import Options\n\n\noptions = Options()\noptions.binary_location = 'path to chrome.exe'\n## this is the chromium for testing which can be downloaded from the link given below\n\n<line_mask>\n## must be the same as the downloaded version of chrome cft.",
            "masked_line": "driver = webdriver.Chrome(chrome_options = options, executable_path = 'path to chromedriver.exe')",
            "answer": "Chrome",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_72"
        },
        {
            "dependency": "selenium",
            "version": "==4.6",
            "time": "2023-07-29",
            "description": "The code opens a Chrome browser using Selenium, maximizes the window, and navigates to the Google homepage.",
            "code": "from selenium import webdriver\nfrom selenium.webdriver.chrome.options import Options\n\noptions = Options()\noptions.add_argument(\"start-maximized\")\ndriver = webdriver.Chrome(options=options)\ndriver.get(\"https://www.google.com/\")",
            "masked_code": "from selenium import webdriver\nfrom selenium.webdriver.chrome.options import Options\n\n<line_mask>\noptions.add_argument(\"start-maximized\")\ndriver = webdriver.Chrome(options=options)\ndriver.get(\"https://www.google.com/\")",
            "masked_line": "options = Options()",
            "answer": "Options",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_73"
        },
        {
            "dependency": "pandas",
            "version": ">=0.25",
            "time": "2019-10-17",
            "description": "This code generates a scatter plot of random data points with 'x' and 'y' values using the hvplot library as the backend for plotting.",
            "code": "import numpy as np\nimport pandas as pd\n\nimport hvplot\nimport hvplot.pandas\n\npd.options.plotting.backend = 'hvplot'\n\ndata = np.random.normal(size=[50, 2])\n\ndf = pd.DataFrame(data, columns=['x', 'y'])\n\ndf.plot(kind='scatter', x='x', y='y')",
            "masked_code": "import numpy as np\nimport pandas as pd\n\nimport hvplot\nimport hvplot.pandas\n\npd.options.plotting.backend = 'hvplot'\n\ndata = np.random.normal(size=[50, 2])\n\n<line_mask>\n\ndf.plot(kind='scatter', x='x', y='y')",
            "masked_line": "df = pd.DataFrame(data, columns=['x', 'y'])",
            "answer": "DataFrame",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_74"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.4.3",
            "time": "2019-02-22",
            "description": "This code generates a histogram plot using the seaborn library for the given data points. The x-axis of the plot shows the range from 1 to 31 with ticks at each integer value.",
            "code": "import matplotlib.pyplot as plt\nimport seaborn as sns\n\ndata = [5,8,12,18,19,19.9,20.1,21,24,28] \n\nfig, ax = plt.subplots()\nsns.histplot(data, ax=ax)  # distplot is deprecate and replaced by histplot\nax.set_xlim(1,31)\nax.set_xticks(range(1,32))\nplt.show()",
            "masked_code": "import matplotlib.pyplot as plt\nimport seaborn as sns\n\ndata = [5,8,12,18,19,19.9,20.1,21,24,28] \n\nfig, ax = plt.subplots()\nsns.histplot(data, ax=ax)  # distplot is deprecate and replaced by histplot\nax.set_xlim(1,31)\nax.set_xticks(range(1,32))\n<line_mask>",
            "masked_line": "plt.show()",
            "answer": "show",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_75"
        },
        {
            "dependency": "seaborn",
            "version": "==0.11.2",
            "time": "2019-02-22",
            "description": "This code generates a histogram plot of the data values in the variable 'data' using seaborn library and matplotlib. It sets the x-axis limits from 1 to 31 and displays the plot.",
            "code": "import matplotlib.pyplot as plt\nimport seaborn as sns\n\ndata = [5,8,12,18,19,19.9,20.1,21,24,28] \n\nfig, ax = plt.subplots()\nsns.histplot(data, ax=ax)  # distplot is deprecate and replaced by histplot\nax.set_xlim(1,31)\nax.set_xticks(range(1,32))\nplt.show()",
            "masked_code": "import matplotlib.pyplot as plt\nimport seaborn as sns\n\ndata = [5,8,12,18,19,19.9,20.1,21,24,28] \n\nfig, ax = plt.subplots()\n<line_mask>\nax.set_xlim(1,31)\nax.set_xticks(range(1,32))\nplt.show()",
            "masked_line": "sns.histplot(data, ax=ax)  # distplot is deprecate and replaced by histplot",
            "answer": "histplot",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_76"
        },
        {
            "dependency": "scipy",
            "version": "==0.16.1",
            "time": "2019-06-27",
            "description": "This function calculates the p-value for a given correlation coefficient using the beta distribution.",
            "code": "import pandas as pd\nfrom scipy.special import betainc\n\ndef pvalue(corr, n=50):\n    df = n - 2\n    t_squared = corr**2 * (df / ((1.0 - corr) * (1.0 + corr)))\n    prob = betainc(0.5*df, 0.5, df/(df+t_squared))\n    return prob",
            "masked_code": "import pandas as pd\nfrom scipy.special import betainc\n\ndef pvalue(corr, n=50):\n    df = n - 2\n    t_squared = corr**2 * (df / ((1.0 - corr) * (1.0 + corr)))\n    <line_mask>\n    return prob",
            "masked_line": "prob = betainc(0.5*df, 0.5, df/(df+t_squared))",
            "answer": "betainc",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_77"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.0.0",
            "time": "2019-12-14",
            "description": "The code splits the input TFRecord dataset into 10 different TFRecord files, with each file containing a portion of the original dataset based on the specified shard index.",
            "code": "import tensorflow as tf\n\nraw_dataset = tf.data.TFRecordDataset(\"input_file.tfrecord\")\n\nshards = 10\n\nfor i in range(shards):\n    writer = tf.data.experimental.TFRecordWriter(f\"output_file-part-{i}.tfrecord\")\n    writer.write(raw_dataset.shard(shards, i))",
            "masked_code": "import tensorflow as tf\n\n<line_mask>\n\nshards = 10\n\nfor i in range(shards):\n    writer = tf.data.experimental.TFRecordWriter(f\"output_file-part-{i}.tfrecord\")\n    writer.write(raw_dataset.shard(shards, i))",
            "masked_line": "raw_dataset = tf.data.TFRecordDataset(\"input_file.tfrecord\")",
            "answer": "TFRecordDataset",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_78"
        },
        {
            "dependency": "networkx",
            "version": "==1.9",
            "time": "2019-10-16",
            "description": "The code creates a directed graph from a pandas DataFrame where each row represents a parent-child relationship with respective levels. It then identifies the roots of the graph (nodes with parent level 0) and lists their descendants in a new DataFrame.",
            "code": "import networkx as nx\nimport pandas as pd\n\ndata = [['A', 'B', 0, 1],\n        ['B', 'C', 1, 2],\n        ['B', 'D', 1, 2],\n        ['X', 'Y', 0, 2],\n        ['X', 'D', 0, 2],\n        ['Y', 'Z', 2, 3]]\n\ndf = pd.DataFrame(data=data, columns=['parent', 'child', 'parent_level', 'child_level'])\n\nroots = df.parent[df.parent_level.eq(0)].unique()\ndg = nx.from_pandas_edgelist(df, source='parent', target='child', create_using=nx.DiGraph)\n\nresult = pd.DataFrame(data=[[root, nx.descendants(dg, root)] for root in roots], columns=['root', 'children'])\nprint(result)",
            "masked_code": "import networkx as nx\nimport pandas as pd\n\ndata = [['A', 'B', 0, 1],\n        ['B', 'C', 1, 2],\n        ['B', 'D', 1, 2],\n        ['X', 'Y', 0, 2],\n        ['X', 'D', 0, 2],\n        ['Y', 'Z', 2, 3]]\n\ndf = pd.DataFrame(data=data, columns=['parent', 'child', 'parent_level', 'child_level'])\n\nroots = df.parent[df.parent_level.eq(0)].unique()\n<line_mask>\n\nresult = pd.DataFrame(data=[[root, nx.descendants(dg, root)] for root in roots], columns=['root', 'children'])\nprint(result)",
            "masked_line": "dg = nx.from_pandas_edgelist(df, source='parent', target='child', create_using=nx.DiGraph)",
            "answer": "from_pandas_edgelist",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_79"
        },
        {
            "dependency": "pytest",
            "version": "==4.6.3",
            "time": "2019-06-28",
            "description": "This code tests the execution of Python scripts in a specified directory using the runpy module.",
            "code": "# test_spam.py\n\nimport pathlib\nimport runpy\nimport pytest\n\nscripts = pathlib.Path(__file__, '..', 'scripts').resolve().glob('*.py')\n\n\n@pytest.mark.parametrize('script', scripts)\ndef test_script_execution(script):\n    runpy.run_path(script)",
            "masked_code": "# test_spam.py\n\nimport pathlib\nimport runpy\nimport pytest\n\nscripts = pathlib.Path(__file__, '..', 'scripts').resolve().glob('*.py')\n\n\n<line_mask>\ndef test_script_execution(script):\n    runpy.run_path(script)",
            "masked_line": "@pytest.mark.parametrize('script', scripts)",
            "answer": "mark",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_80"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-01-11",
            "description": "This code converts a list of integers into a categorical format using one-hot encoding, then decodes the one-hot encoded values back into the original integers.",
            "code": "import numpy as np\ny = [0, 1, 2, 0, 4, 5]\nY = to_categorical(y, num_classes=len(y))\nprint(Y)\ny = np.argmax(Y, axis=-1)\nprint(y)\n# [0, 1, 2, 0, 4, 5]",
            "masked_code": "import numpy as np\ny = [0, 1, 2, 0, 4, 5]\nY = to_categorical(y, num_classes=len(y))\nprint(Y)\n<line_mask>\nprint(y)\n# [0, 1, 2, 0, 4, 5]",
            "masked_line": "y = np.argmax(Y, axis=-1)",
            "answer": "argmax",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_81"
        },
        {
            "dependency": "numba",
            "version": "==0.44",
            "time": "2019-06-05",
            "description": "This code defines a numba jit compiled function named 'func' that takes in a numpy array 'x' and a string 'y'. The function prints the value of 'y' and then returns the input numpy array 'x'.",
            "code": "import numpy as np\nimport numba as nb\n\nfrom numba import types\n\n@nb.jit(nb.float64[:](nb.float64[:], types.unicode_type), nopython=True, cache=True)\ndef func(x, y='cont'):\n    \"\"\"\n    :param x: is np.array, x.shape=(n,)\n    :param y: is a string, \n    :return: a np.array of same shape as x\n    \"\"\"\n    print(y)\n    return x",
            "masked_code": "import numpy as np\nimport numba as nb\n\nfrom numba import types\n\n<line_mask>\ndef func(x, y='cont'):\n    \"\"\"\n    :param x: is np.array, x.shape=(n,)\n    :param y: is a string, \n    :return: a np.array of same shape as x\n    \"\"\"\n    print(y)\n    return x",
            "masked_line": "@nb.jit(nb.float64[:](nb.float64[:], types.unicode_type), nopython=True, cache=True)",
            "answer": "jit",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_82"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.1",
            "time": "2019-07-25",
            "description": "This code calculates the number of business days between two given dates.",
            "code": "import pandas as pd\nimport numpy as np\n\ndate1 = \"01/07/2019\"\ndate2 = \"08/07/2019\"\n\ndate1 = pd.to_datetime(date1,format=\"%d/%m/%Y\").date()\ndate2 = pd.to_datetime(date2,format=\"%d/%m/%Y\").date()\n\ndays = np.busday_count( date1 , date2)\nprint(days)",
            "masked_code": "import pandas as pd\nimport numpy as np\n\ndate1 = \"01/07/2019\"\ndate2 = \"08/07/2019\"\n\ndate1 = pd.to_datetime(date1,format=\"%d/%m/%Y\").date()\ndate2 = pd.to_datetime(date2,format=\"%d/%m/%Y\").date()\n\n<line_mask>\nprint(days)",
            "masked_line": "days = np.busday_count( date1 , date2)",
            "answer": "busday_count",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_83"
        },
        {
            "dependency": "matplotlib",
            "version": ">=3.3",
            "time": "2021-03-24",
            "description": "This code creates a figure with 3 subplots arranged horizontally, each subplot contains a line plot with x-axis values [1, 2, 3] and a title indicating its index. The figure has an overall title 'suptitle' and the subplots are arranged neatly with tight layout.",
            "code": "import matplotlib.pyplot as plt\n\nfig, axs = plt.subplots(1, 3)\nfor i, ax in enumerate(axs):\n    ax.plot([1, 2, 3])\n    ax.set_title(f'Axes {i}')\n\nfig.suptitle('suptitle')\nfig.tight_layout()",
            "masked_code": "import matplotlib.pyplot as plt\n\nfig, axs = plt.subplots(1, 3)\nfor i, ax in enumerate(axs):\n    ax.plot([1, 2, 3])\n    ax.set_title(f'Axes {i}')\n\n<line_mask>\nfig.tight_layout()",
            "masked_line": "fig.suptitle('suptitle')",
            "answer": "suptitle",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_84"
        },
        {
            "dependency": "scipy",
            "version": "==0.16.0",
            "time": "2019-05-26",
            "description": "This code performs flood fill algorithm in a numpy array 'a' starting from the coordinates 'xy' with a new value 'newval'.",
            "code": "from scipy.ndimage.measurements import label\n\ndef floodfill_by_xy_scipy(a,xy,newval):\n    x,y = xy\n    l = label(a==a[x,y])[0]\n    a[l==l[x,y]] = newval\n    return a",
            "masked_code": "<line_mask>\n\ndef floodfill_by_xy_scipy(a,xy,newval):\n    x,y = xy\n    l = label(a==a[x,y])[0]\n    a[l==l[x,y]] = newval\n    return a",
            "masked_line": "from scipy.ndimage.measurements import label",
            "answer": "label",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_85"
        },
        {
            "dependency": "matplotlib",
            "version": "==2.0.2",
            "time": "2019-01-24",
            "description": "The code generates a plot of y = x^2 from x = 0 to x = 1000, and formats the y-axis ticks in scientific notation with matplotlib.",
            "code": "import numpy as np\nimport matplotlib.pyplot as plt\nplt.figure()\nx = np.linspace(0,1000)\ny = x**2\nplt.plot(x,y)\nplt.gca().yaxis.set_major_formatter(plt.ScalarFormatter(useMathText=True))\nplt.ticklabel_format(style='sci', axis='y', scilimits=(0,0))\nplt.show()",
            "masked_code": "import numpy as np\nimport matplotlib.pyplot as plt\nplt.figure()\nx = np.linspace(0,1000)\ny = x**2\nplt.plot(x,y)\n<line_mask>\nplt.ticklabel_format(style='sci', axis='y', scilimits=(0,0))\nplt.show()",
            "masked_line": "plt.gca().yaxis.set_major_formatter(plt.ScalarFormatter(useMathText=True))",
            "answer": "ScalarFormatter",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_86"
        },
        {
            "dependency": "requests",
            "version": "==2.21.0",
            "time": "2019-02-14",
            "description": "The code retrieves all the href links of products listed on Amazon under a specific category.",
            "code": "import requests\nimport lxml, lxml.html\n\nurl = 'https://www.amazon.com/s/ref=lp_266162_nr_n_0?fst=as%3Aoff&rh=n%3A283155%2Cn%3A%211000%2Cn%3A1%2Cn%3A173508%2Cn%3A266162%2Cn%3A3564986011&bbn=266162&ie=UTF8&qid=1550120216&rnid=266162'\nr = requests.get(url)\nhtml = lxml.html.fromstring(r.content)\nlinks = html.cssselect('.a-fixed-left-grid-col .a-col-left a')\nfor link in links:\n    print(link.attrib['href'])",
            "masked_code": "import requests\nimport lxml, lxml.html\n\nurl = 'https://www.amazon.com/s/ref=lp_266162_nr_n_0?fst=as%3Aoff&rh=n%3A283155%2Cn%3A%211000%2Cn%3A1%2Cn%3A173508%2Cn%3A266162%2Cn%3A3564986011&bbn=266162&ie=UTF8&qid=1550120216&rnid=266162'\n<line_mask>\nhtml = lxml.html.fromstring(r.content)\nlinks = html.cssselect('.a-fixed-left-grid-col .a-col-left a')\nfor link in links:\n    print(link.attrib['href'])",
            "masked_line": "r = requests.get(url)",
            "answer": "get",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_87"
        },
        {
            "dependency": "lxml",
            "version": "==4.3.1",
            "time": "2019-02-14",
            "description": "The code is fetching a webpage from Amazon and extracting all the links from the specified CSS selectors in the HTML content of the webpage. Finally, it prints out the href attribute value of each extracted link.",
            "code": "import requests\nimport lxml, lxml.html\n\nurl = 'https://www.amazon.com/s/ref=lp_266162_nr_n_0?fst=as%3Aoff&rh=n%3A283155%2Cn%3A%211000%2Cn%3A1%2Cn%3A173508%2Cn%3A266162%2Cn%3A3564986011&bbn=266162&ie=UTF8&qid=1550120216&rnid=266162'\nr = requests.get(url)\nhtml = lxml.html.fromstring(r.content)\nlinks = html.cssselect('.a-fixed-left-grid-col .a-col-left a')\nfor link in links:\n    print(link.attrib['href'])",
            "masked_code": "import requests\nimport lxml, lxml.html\n\nurl = 'https://www.amazon.com/s/ref=lp_266162_nr_n_0?fst=as%3Aoff&rh=n%3A283155%2Cn%3A%211000%2Cn%3A1%2Cn%3A173508%2Cn%3A266162%2Cn%3A3564986011&bbn=266162&ie=UTF8&qid=1550120216&rnid=266162'\nr = requests.get(url)\n<line_mask>\nlinks = html.cssselect('.a-fixed-left-grid-col .a-col-left a')\nfor link in links:\n    print(link.attrib['href'])",
            "masked_line": "html = lxml.html.fromstring(r.content)",
            "answer": "fromstring",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_88"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.1",
            "time": "2019-01-03",
            "description": "This code returns the n nearest points to a given point (x, y) from a list of points.",
            "code": "import numpy as np\n\ndef get_nearest_point(x, y, n):\n\n    dist = [Distance(point[0], point[1], x, y) for point in points]\n    indices = np.argsort(dist)\n    return [points[i] for i in indices[:n]]",
            "masked_code": "import numpy as np\n\ndef get_nearest_point(x, y, n):\n\n    dist = [Distance(point[0], point[1], x, y) for point in points]\n    <line_mask>\n    return [points[i] for i in indices[:n]]",
            "masked_line": "indices = np.argsort(dist)",
            "answer": "argsort",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_89"
        },
        {
            "dependency": "pandas",
            "version": ">=0.25.1",
            "time": "2019-10-23",
            "description": "The code splits the values in the 'Column in question' column by ';' and expands the DataFrame to have one row for each split value. It then calculates the adjusted 'Quantity' by dividing the original quantity by the number of split values for each row.",
            "code": "import pandas as pd\nimport numpy as np\n\n\ndf = pd.DataFrame({'Quantity':[6,50,25,4]\n                  ,'Column in question':['1;2;3;4;5;6','','','7;8;9;10']\n                  ,'Price':['$1.00','$10.00','$0.10','$25.00']\n                  ,'Invoice Close Date':['9/3/2019','9/27/2019','9/18/2019','9/30/2019']})\n\ndf_out = df.assign(ciq=df['Column in question'].str.split(';')).explode('ciq')\\\n           .drop('Column in question', axis=1)\\\n           .rename(columns={'ciq':'Column in question'})\n\ndf_out['Quantity'] = (df_out['Quantity'] / df_out.groupby(level=0)['Quantity'].transform('size'))\n\ndf_out",
            "masked_code": "import pandas as pd\nimport numpy as np\n\n\ndf = pd.DataFrame({'Quantity':[6,50,25,4]\n                  ,'Column in question':['1;2;3;4;5;6','','','7;8;9;10']\n                  ,'Price':['$1.00','$10.00','$0.10','$25.00']\n                  ,'Invoice Close Date':['9/3/2019','9/27/2019','9/18/2019','9/30/2019']})\n\n<line_mask>\n           .drop('Column in question', axis=1)\\\n           .rename(columns={'ciq':'Column in question'})\n\ndf_out['Quantity'] = (df_out['Quantity'] / df_out.groupby(level=0)['Quantity'].transform('size'))\n\ndf_out",
            "masked_line": "df_out = df.assign(ciq=df['Column in question'].str.split(';')).explode('ciq')\\",
            "answer": "explode",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_90"
        },
        {
            "dependency": "Flask",
            "version": "==0.10.1",
            "time": "2019-12-12",
            "description": "This code sets up a Flask web application with two routes: '/ping' returns an empty string and '/invocations' returns the message \"should do inference with your model here\". When the code is executed, the Flask application runs in debug mode on host '0.0.0.0' and port 8080.",
            "code": "from flask import Flask, request\napp = Flask(__name__)\n\n@app.route('/ping')\ndef ping():\n    return ''\n\n@app.route('/invocations')\ndef invoke():\n    return 'should do inference with your model here'\n\n\nif __name__ == '__main__':\n    app.run(debug=True, host='0.0.0.0', port=8080)",
            "masked_code": "<line_mask>\napp = Flask(__name__)\n\n@app.route('/ping')\ndef ping():\n    return ''\n\n@app.route('/invocations')\ndef invoke():\n    return 'should do inference with your model here'\n\n\nif __name__ == '__main__':\n    app.run(debug=True, host='0.0.0.0', port=8080)",
            "masked_line": "from flask import Flask, request",
            "answer": "Flask",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_91"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.4",
            "time": "2019-05-28",
            "description": "This code performs polynomial multiplication of two real-valued polynomials using Fast Fourier Transform (FFT).",
            "code": "from numpy.fft import rfft, irfft\ndef fftrealpolymul(arr_a, arr_b):  #fft based real-valued polynomial multiplication\n    L = len(arr_a) + len(arr_b)\n    a_f = rfft(arr_a, L)\n    b_f = rfft(arr_b, L)\n    return irfft(a_f * b_f)",
            "masked_code": "from numpy.fft import rfft, irfft\ndef fftrealpolymul(arr_a, arr_b):  #fft based real-valued polynomial multiplication\n    L = len(arr_a) + len(arr_b)\n    <line_mask>\n    b_f = rfft(arr_b, L)\n    return irfft(a_f * b_f)",
            "masked_line": "a_f = rfft(arr_a, L)",
            "answer": "rfft",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_92"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.0",
            "time": "2019-03-01",
            "description": "The code defines a neural network model using a pretrained ResNet50 model as a base, with additional layers for flattening and dense classification. The model is configured with specific input shape and number of classes for classification. The code also includes the option to freeze some layers and customize the top layers for specific tasks. The summary of the model architecture is printed using the \"summary()\" method.",
            "code": "import tensorflow\n\nin_width, in_height, in_channels = 224, 224, 3\n\npretrained_resnet = tensorflow.keras.applications.ResNet50(\n    weights=\"imagenet\",\n    include_top=False,\n    input_shape=(in_width, in_height, in_channels),\n)\n\n# You can freeze some layers if you want, depends on your task\n# Make \"top\" (last 3 layers below) whatever fits your task as well\n\nmodel = tensorflow.keras.models.Sequential(\n    [\n        pretrained_resnet,\n        tensorflow.keras.layers.Flatten(),\n        tensorflow.keras.layers.Dense(1024, activation=\"relu\"),\n        tensorflow.keras.layers.Dense(10, activation=\"softmax\"),\n    ]\n)\n\nprint(model.summary())",
            "masked_code": "import tensorflow\n\nin_width, in_height, in_channels = 224, 224, 3\n\npretrained_resnet = tensorflow.keras.applications.ResNet50(\n    weights=\"imagenet\",\n    include_top=False,\n    input_shape=(in_width, in_height, in_channels),\n)\n\n# You can freeze some layers if you want, depends on your task\n# Make \"top\" (last 3 layers below) whatever fits your task as well\n\nmodel = tensorflow.keras.models.Sequential(\n    [\n        pretrained_resnet,\n        tensorflow.keras.layers.Flatten(),\n        <line_mask>\n        tensorflow.keras.layers.Dense(10, activation=\"softmax\"),\n    ]\n)\n\nprint(model.summary())",
            "masked_line": "tensorflow.keras.layers.Dense(1024, activation=\"relu\"),",
            "answer": "Dense",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_93"
        },
        {
            "dependency": "scipy",
            "version": "==0.14.0",
            "time": "2019-10-25",
            "description": "This code generates a square matrix with random values, then inverts the values below the main diagonal by multiplying them by -1.",
            "code": "from scipy.spatial.distance import squareform\n\ndef diag_inverted(n):\n    l = n*(n-1)//2\n    out = squareform(np.random.randn(l))\n    out[np.tri(len(out),k=-1,dtype=bool)] *= -1\n    return out",
            "masked_code": "from scipy.spatial.distance import squareform\n\ndef diag_inverted(n):\n    l = n*(n-1)//2\n    <line_mask>\n    out[np.tri(len(out),k=-1,dtype=bool)] *= -1\n    return out",
            "masked_line": "out = squareform(np.random.randn(l))",
            "answer": "squareform",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_94"
        },
        {
            "dependency": "rq",
            "version": "==0.10.0",
            "time": "2022-01-06",
            "description": "The code retrieves and prints the name of the first worker in a specific queue.",
            "code": "from redis import Redis\nfrom rq import Queue, Worker\n\n# Returns all workers registered in this connection\nredis = Redis(host='myredis.example.com', port=6379)\nworkers = Worker.all(connection=redis)\n\n# Returns all workers in this queue (new in version 0.10.0)\nqueue = Queue('queue_name')\nworkers = Worker.all(queue=queue)\nworker = workers[0]\nprint(worker.name)",
            "masked_code": "from redis import Redis\nfrom rq import Queue, Worker\n\n# Returns all workers registered in this connection\nredis = Redis(host='myredis.example.com', port=6379)\nworkers = Worker.all(connection=redis)\n\n# Returns all workers in this queue (new in version 0.10.0)\nqueue = Queue('queue_name')\n<line_mask>\nworker = workers[0]\nprint(worker.name)",
            "masked_line": "workers = Worker.all(queue=queue)",
            "answer": "all",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_95"
        },
        {
            "dependency": "pyspark",
            "version": "==2.2",
            "time": "2019-11-07",
            "description": "The code selects the second part of the path from the viewed_page column in a DataFrame using HiveContext, but it will not work with SQLContext.",
            "code": "from pyspark import SparkContext\nfrom pyspark.sql import HiveContext, SQLContext\n\nsc = SparkContext()\n\nsqlContext = SQLContext(sc)\nhivContext = HiveContext(sc)\n\nquery = 'SELECT split(parse_url(page.viewed_page, \"PATH\"), \"/\")[1] as path FROM df'\n\nhivContext.sql(query) # this will work\nsqlContext.sql(query) # this will not work",
            "masked_code": "from pyspark import SparkContext\nfrom pyspark.sql import HiveContext, SQLContext\n\n<line_mask>\n\nsqlContext = SQLContext(sc)\nhivContext = HiveContext(sc)\n\nquery = 'SELECT split(parse_url(page.viewed_page, \"PATH\"), \"/\")[1] as path FROM df'\n\nhivContext.sql(query) # this will work\nsqlContext.sql(query) # this will not work",
            "masked_line": "sc = SparkContext()",
            "answer": "SparkContext",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_96"
        },
        {
            "dependency": "numpy",
            "version": "==1.13.0",
            "time": "2019-05-23",
            "description": "The code initializes an array of length 10 with elements set to 0. Then it assigns 1 to the first and middle index, assigns 2 to the indices between the first and middle element, and assigns 0 to the indices after the middle element. Finally, it prints the resulting array.",
            "code": "import numpy as np\n\nn = 10\na = np.zeros(n)\na[np.r_[0,n//2]] = 1\na[np.r_[1:n//2]] = 2\na[np.r_[n//2+1:n]] = 0\n\nprint(a)\narray([1., 2., 2., 2., 2., 1., 0., 0., 0., 0.])",
            "masked_code": "import numpy as np\n\nn = 10\n<line_mask>\na[np.r_[0,n//2]] = 1\na[np.r_[1:n//2]] = 2\na[np.r_[n//2+1:n]] = 0\n\nprint(a)\narray([1., 2., 2., 2., 2., 1., 0., 0., 0., 0.])",
            "masked_line": "a = np.zeros(n)",
            "answer": "zeros",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_97"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.x",
            "time": "2019-03-05",
            "description": "This code calculates the 90th percentile pixel value for each image in a batch, and then creates a new set of images where each pixel value is set to 0 if it is not in the top 10% of pixel values in the original image.",
            "code": "import tensorflow as tf\n\nimages = ... # [N, W, H, C]\nn = tf.shape(images)[0]\nimages_flat = tf.reshape(images, [n, -1])\np = tf.contrib.distributions.percentile(images_flat, 90, axis=1, interpolation='higher')\nimages_top10 = tf.where(images >= tf.reshape(p, [n, 1, 1, 1]),\n                        images, tf.zeros_like(images))",
            "masked_code": "import tensorflow as tf\n\nimages = ... # [N, W, H, C]\nn = tf.shape(images)[0]\nimages_flat = tf.reshape(images, [n, -1])\n<line_mask>\nimages_top10 = tf.where(images >= tf.reshape(p, [n, 1, 1, 1]),\n                        images, tf.zeros_like(images))",
            "masked_line": "p = tf.contrib.distributions.percentile(images_flat, 90, axis=1, interpolation='higher')",
            "answer": "distributions",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_98"
        },
        {
            "dependency": "plotly",
            "version": "==3.7.0",
            "time": "2019-04-13",
            "description": "The code generates a 3D surface plot using Plotly library, displaying the data provided in the dictionary df3.",
            "code": "from plotly import offline\nfrom plotly import graph_objs as go\noffline.init_notebook_mode(connected=False)\n\ndf3 = {'x':[1, 2, 3, 4, 5],'y':[10, 20, 30, 40, 50],'z': [[5, 4, 3, 2, 1]]*5}\noffline.iplot(dict(data=[go.Surface(x=df3['x'], y=df3['y'], z=df3['z'])]))",
            "masked_code": "from plotly import offline\nfrom plotly import graph_objs as go\noffline.init_notebook_mode(connected=False)\n\ndf3 = {'x':[1, 2, 3, 4, 5],'y':[10, 20, 30, 40, 50],'z': [[5, 4, 3, 2, 1]]*5}\n<line_mask>",
            "masked_line": "offline.iplot(dict(data=[go.Surface(x=df3['x'], y=df3['y'], z=df3['z'])]))",
            "answer": "iplot",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_99"
        },
        {
            "dependency": "numpy",
            "version": "==1.13.0",
            "time": "2019-03-08",
            "description": "This code assigns fruits based on the given decisions to the variable daily_decision.",
            "code": "import numpy as np\ndaily_choices = np.array([['apple','orange'],['strawberry','orange'],['watermelon','apple']])\ndecisions = [0, 1, 0]\n\ndaily_decision = daily_choices[range(len(daily_choices)), decisions]\nprint(daily_decision)",
            "masked_code": "import numpy as np\n<line_mask>\ndecisions = [0, 1, 0]\n\ndaily_decision = daily_choices[range(len(daily_choices)), decisions]\nprint(daily_decision)",
            "masked_line": "daily_choices = np.array([['apple','orange'],['strawberry','orange'],['watermelon','apple']])",
            "answer": "array",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_100"
        },
        {
            "dependency": "pandas",
            "version": ">=0.25.0",
            "time": "2019-10-03",
            "description": "The code merges two dataframes on specific columns and returns a new dataframe with 'userid' and 'contentId' columns after dropping any duplicates and converting the values to integers.",
            "code": "import pandas as pd\nfrom numpy import nan\ndfp = pd.DataFrame({'contentId': {0: nan, 1: 2.0, 2: nan, 3: 4.0, 4: 5.0, 5: 6.0, 6: nan, 7: 8.0, 8: 9.0}, 'Categories': {0: '1', 1: '12;2', 2: '3', 3: '2', 4: '3;15', 5: '15', 6: '7', 7: '20', 8: '20;2'}})\ndfu = pd.DataFrame({'intrestcategories': {0: '12;2', 1: '3', 2: '15'}, 'userid': {0: 2, 1: 3, 2: 4}})\n\ndfp.Categories = dfp.Categories.str.split(';')\ndfp = dfp.explode('Categories')\n\ndfu.intrestcategories = dfu.intrestcategories.str.split(';')\ndfu = dfu.explode('intrestcategories')\n\ndfp.dropna().merge(dfu,left_on='Categories',right_on='intrestcategories')[['userid','contentId']].drop_duplicates().astype(int)",
            "masked_code": "import pandas as pd\nfrom numpy import nan\ndfp = pd.DataFrame({'contentId': {0: nan, 1: 2.0, 2: nan, 3: 4.0, 4: 5.0, 5: 6.0, 6: nan, 7: 8.0, 8: 9.0}, 'Categories': {0: '1', 1: '12;2', 2: '3', 3: '2', 4: '3;15', 5: '15', 6: '7', 7: '20', 8: '20;2'}})\ndfu = pd.DataFrame({'intrestcategories': {0: '12;2', 1: '3', 2: '15'}, 'userid': {0: 2, 1: 3, 2: 4}})\n\ndfp.Categories = dfp.Categories.str.split(';')\ndfp = dfp.explode('Categories')\n\n<line_mask>\ndfu = dfu.explode('intrestcategories')\n\ndfp.dropna().merge(dfu,left_on='Categories',right_on='intrestcategories')[['userid','contentId']].drop_duplicates().astype(int)",
            "masked_line": "dfu.intrestcategories = dfu.intrestcategories.str.split(';')",
            "answer": "split",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_101"
        },
        {
            "dependency": "networkx",
            "version": "==1.10",
            "time": "2019-04-06",
            "description": "This code checks if there is a simple cycle containing a specific node starting from a given list of nodes.",
            "code": "import networkx as nx\n\ndef has_simple_cycle(l, start):\n    G = nx.DiGraph()\n    G.add_edges_from((v1, v2) for v1 in l for v2 in l if v1 != v2 and max(abs(v1[0] - v2[0]), abs(v1[1] - v2[1])) <= 1)\n    return any(start in c and len(c) > 2 for c in nx.simple_cycles(G))",
            "masked_code": "import networkx as nx\n\ndef has_simple_cycle(l, start):\n    G = nx.DiGraph()\n    <line_mask>\n    return any(start in c and len(c) > 2 for c in nx.simple_cycles(G))",
            "masked_line": "G.add_edges_from((v1, v2) for v1 in l for v2 in l if v1 != v2 and max(abs(v1[0] - v2[0]), abs(v1[1] - v2[1])) <= 1)",
            "answer": "add_edges_from",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_102"
        },
        {
            "dependency": "numpy",
            "version": "==1.13.0",
            "time": "2019-10-16",
            "description": "The code generates random samples based on the probabilities specified in the 2D array P.",
            "code": "import numpy as np\n\nP = np.array([[0,1/2,1/2],[1,0,0],[1/3,1/3,1/3]])\n\ndef rand_choice(c):\n  return np.random.choice(c.size, p=c)\n\nsamples = np.apply_along_axis(rand_choice, 1, P)",
            "masked_code": "import numpy as np\n\nP = np.array([[0,1/2,1/2],[1,0,0],[1/3,1/3,1/3]])\n\ndef rand_choice(c):\n  <line_mask>\n\nsamples = np.apply_along_axis(rand_choice, 1, P)",
            "masked_line": "return np.random.choice(c.size, p=c)",
            "answer": "random",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_103"
        },
        {
            "dependency": "tkcalendar",
            "version": "==1.5.0",
            "time": "2019-08-29",
            "description": "This code creates a tkinter window and adds two DateEntry widgets to it, one with custom date formatting and one with default date formatting. The window will remain open until the user closes it.",
            "code": "import tkinter as tk\nfrom tkcalendar import DateEntry\n\nwindow = tk.Tk()\n\nDateEntry(window, locale='en_US', date_pattern='mm/dd/y').pack()  # custom formatting\nDateEntry(window, locale='en_US').pack()  # default formatting\nwindow.mainloop()",
            "masked_code": "import tkinter as tk\nfrom tkcalendar import DateEntry\n\nwindow = tk.Tk()\n\nDateEntry(window, locale='en_US', date_pattern='mm/dd/y').pack()  # custom formatting\n<line_mask>\nwindow.mainloop()",
            "masked_line": "DateEntry(window, locale='en_US').pack()  # default formatting",
            "answer": "pack",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_104"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-06-14",
            "description": "The code generates a 1000x1000 matrix 'U' filled with random uniform numbers between 0 and 1. It then creates a symmetric matrix 'S' by taking the lower triangular part of 'U' and adding its transpose. Finally, it prints the histograms of the flattened 'S', the first row of 'S', and the first column of 'S'.",
            "code": "import numpy as np \n\nU = np.random.uniform(low=0, high=1.0, size=(1000, 1000))\nS = np.tril(U) + np.tril(U, -1).T\n\nprint(np.histogram(S.flatten()))\nprint(np.histogram(S[0,:]))\nprint(np.histogram(S[:,0]))",
            "masked_code": "import numpy as np \n\nU = np.random.uniform(low=0, high=1.0, size=(1000, 1000))\nS = np.tril(U) + np.tril(U, -1).T\n\n<line_mask>\nprint(np.histogram(S[0,:]))\nprint(np.histogram(S[:,0]))",
            "masked_line": "print(np.histogram(S.flatten()))",
            "answer": "histogram",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_105"
        },
        {
            "dependency": "bokeh",
            "version": "==1.3.0",
            "time": "2019-11-16",
            "description": "The code generates 3 plots with 2 lines each, where each line represents a random set of 10 data points. The plots are displayed in a single column layout without interactive tools merged.",
            "code": "from bokeh.plotting import figure, show\nfrom bokeh.layouts import gridplot\nimport numpy as np\n\nplots = [figure() for i in range(3)]\nglyphs = [plot.line(np.arange(10), np.random.random(10)) for plot in plots for i in range(2)]\nshow(gridplot(children = plots, ncols = 1, merge_tools = False))",
            "masked_code": "from bokeh.plotting import figure, show\n<line_mask>\nimport numpy as np\n\nplots = [figure() for i in range(3)]\nglyphs = [plot.line(np.arange(10), np.random.random(10)) for plot in plots for i in range(2)]\nshow(gridplot(children = plots, ncols = 1, merge_tools = False))",
            "masked_line": "from bokeh.layouts import gridplot",
            "answer": "gridplot",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_106"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.1",
            "time": "2019-01-08",
            "description": "The code generates a mesh grid from the given arrays of values and then multiplies the values along the specified axis to produce a final result.",
            "code": "import numpy as np\n\n\ndef mesh(values):\n    return np.array(np.meshgrid(*values)).T\n\nX = [1,2,3]\nY = [4,5,6,7]\n\nZ = mesh([X, Y])\n\nresult = np.multiply.reduce(Z, axis=2)\nprint(result)",
            "masked_code": "import numpy as np\n\n\ndef mesh(values):\n    return np.array(np.meshgrid(*values)).T\n\nX = [1,2,3]\nY = [4,5,6,7]\n\nZ = mesh([X, Y])\n\n<line_mask>\nprint(result)",
            "masked_line": "result = np.multiply.reduce(Z, axis=2)",
            "answer": "reduce",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_107"
        },
        {
            "dependency": "networkx",
            "version": "==1.10",
            "time": "2019-10-06",
            "description": "The code creates a directed multigraph using NetworkX library in Python, with nodes labeled from 0 to 5 and edges connecting the nodes as specified in the code.",
            "code": "import networkx as nx\nnodes = [0, 1, 2, 3, 4, 5]\nedges = [(0,1), (1,0), (1, 0),(0, 1), (2, 3), (2, 3), (2, 3), (2, 3),\n         (4, 1), (4, 1), (4, 1), (4, 1), (4, 1), (4, 1), (4, 5), (5, 0)]\nG = nx.MultiDiGraph()\nG.add_nodes_from(nodes)\nG.add_edges_from(edges)",
            "masked_code": "import networkx as nx\nnodes = [0, 1, 2, 3, 4, 5]\nedges = [(0,1), (1,0), (1, 0),(0, 1), (2, 3), (2, 3), (2, 3), (2, 3),\n         (4, 1), (4, 1), (4, 1), (4, 1), (4, 1), (4, 1), (4, 5), (5, 0)]\nG = nx.MultiDiGraph()\nG.add_nodes_from(nodes)\n<line_mask>",
            "masked_line": "G.add_edges_from(edges)",
            "answer": "add_edges_from",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_108"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-01-18",
            "description": "The code calculates the root of a function by solving a nonlinear equation using the fsolve function from the scipy.optimize module. The function takes in an array as an argument and returns the sum of f multiplied by the exponential function of -g*x minus a constant K. The code then computes the root of this function with an initial guess x0=1 and extra dimensions introduced for f and g.",
            "code": "import numpy as np\nimport scipy.optimize\n\nnp.random.seed(123)\n\nf = np.random.uniform(size=50)\ng = np.random.uniform(size=f.size)\nK = np.sum(f * np.exp(-g*np.pi))\n\ndef func(x, f, g, K):\n    return np.sum(f * np.exp(-g*x), axis=0) - K\n\n# The argument to the function is an array itself,\n# so we need to introduce extra dimensions for f, g.\nres = scipy.optimize.fsolve(func, x0=1, args=(f[:, None], g[:, None], K))",
            "masked_code": "import numpy as np\nimport scipy.optimize\n\n<line_mask>\n\nf = np.random.uniform(size=50)\ng = np.random.uniform(size=f.size)\nK = np.sum(f * np.exp(-g*np.pi))\n\ndef func(x, f, g, K):\n    return np.sum(f * np.exp(-g*x), axis=0) - K\n\n# The argument to the function is an array itself,\n# so we need to introduce extra dimensions for f, g.\nres = scipy.optimize.fsolve(func, x0=1, args=(f[:, None], g[:, None], K))",
            "masked_line": "np.random.seed(123)",
            "answer": "seed",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_109"
        },
        {
            "dependency": "spacy",
            "version": ">=3.0",
            "time": "2022-03-16",
            "description": "The code initializes a spaCy language model, creates a document object with a list of tokens, and prints out the text and part-of-speech tags for each token in the document.",
            "code": "import spacy\nfrom spacy.tokens import Doc\nnlp = spacy.load(\"en_core_web_sm\")\n\nsent = [\"This\", \"is\", \"a\", \"sentence\"]\n\ndoc = Doc(nlp.vocab, sent)\nfor token in nlp(doc):\n    print(token.text, token.pos_)",
            "masked_code": "import spacy\nfrom spacy.tokens import Doc\nnlp = spacy.load(\"en_core_web_sm\")\n\nsent = [\"This\", \"is\", \"a\", \"sentence\"]\n\n<line_mask>\nfor token in nlp(doc):\n    print(token.text, token.pos_)",
            "masked_line": "doc = Doc(nlp.vocab, sent)",
            "answer": "nlp",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_110"
        },
        {
            "dependency": "tensorflow",
            "version": "<1.13",
            "time": "2019-07-05",
            "description": "This code concatenates two sets of column indices, sorts them in ascending order, and returns the sorted column indices.",
            "code": "import tensorflow as tf\n\na = [[[1,1],[2,2],[3,3]],\n     [[4,4],[5,5],[6,6]],\n     [[7,7],[8,8],[9,9]]]\n\nb = [[[10,10],[11,11]],\n     [[12,12],[13,13]],\n     [[14,14],[15,15]]]\n\na_tf = tf.constant(a)\nb_tf = tf.constant(b)\n\na_tf_column = tf.range(a_tf.shape[1])*2\n# [0 2 4]\nb_tf_column = tf.range(b_tf.shape[1])*2+1\n# [1 3]\n\ncolumn_indices = tf.concat([a_tf_column,b_tf_column],axis=-1)\n# Before TF v1.13\ncolumn_indices = tf.contrib.framework.argsort(column_indices)\n## From TF v1.13\n# column_indices = tf.argsort(column_indices)\n\n# [0 3 1 4 2]",
            "masked_code": "import tensorflow as tf\n\na = [[[1,1],[2,2],[3,3]],\n     [[4,4],[5,5],[6,6]],\n     [[7,7],[8,8],[9,9]]]\n\nb = [[[10,10],[11,11]],\n     [[12,12],[13,13]],\n     [[14,14],[15,15]]]\n\na_tf = tf.constant(a)\n<line_mask>\n\na_tf_column = tf.range(a_tf.shape[1])*2\n# [0 2 4]\nb_tf_column = tf.range(b_tf.shape[1])*2+1\n# [1 3]\n\ncolumn_indices = tf.concat([a_tf_column,b_tf_column],axis=-1)\n# Before TF v1.13\ncolumn_indices = tf.contrib.framework.argsort(column_indices)\n## From TF v1.13\n# column_indices = tf.argsort(column_indices)\n\n# [0 3 1 4 2]",
            "masked_line": "b_tf = tf.constant(b)",
            "answer": "constant",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_111"
        },
        {
            "dependency": "seaborn",
            "version": "==0.9.0",
            "time": "2019-05-07",
            "description": "This code creates a scatter plot using the Seaborn library, displaying the relationship between total bill and tip amount. The plot is colored based on the day of the week. The legend is customized to display the days of the week as labels.",
            "code": "import matplotlib.pyplot as plt\nimport seaborn as sns\n\ntips = sns.load_dataset(\"tips\")\ng = sns.scatterplot(x=\"total_bill\", y=\"tip\", hue=\"day\",\n                    data=tips, s=75,  edgecolor='k')\n\n# Assumes Seaborn 0.9.0\nlegend = g.legend_\n\n# Set legend title\nlegend.get_texts()[0].set_text('Day of Week')\n\nlabels=['Thursday', 'Friday', 'Saturday', 'Sunday']\n\n# Set legend labels\nfor i, label in enumerate(labels):\n    # i+1 because i=0 is the title, and i starts at 0\n    legend.get_texts()[i+1].set_text(label) \n\n# sns.plt.show() for me gives \"AttributeError: module 'seaborn' has no attribute 'plt'\"\nplt.show()",
            "masked_code": "import matplotlib.pyplot as plt\nimport seaborn as sns\n\n<line_mask>\ng = sns.scatterplot(x=\"total_bill\", y=\"tip\", hue=\"day\",\n                    data=tips, s=75,  edgecolor='k')\n\n# Assumes Seaborn 0.9.0\nlegend = g.legend_\n\n# Set legend title\nlegend.get_texts()[0].set_text('Day of Week')\n\nlabels=['Thursday', 'Friday', 'Saturday', 'Sunday']\n\n# Set legend labels\nfor i, label in enumerate(labels):\n    # i+1 because i=0 is the title, and i starts at 0\n    legend.get_texts()[i+1].set_text(label) \n\n# sns.plt.show() for me gives \"AttributeError: module 'seaborn' has no attribute 'plt'\"\nplt.show()",
            "masked_line": "tips = sns.load_dataset(\"tips\")",
            "answer": "load_dataset",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_112"
        },
        {
            "dependency": "glom",
            "version": "==19.11.0",
            "time": "2020-02-14",
            "description": "The code retrieves the 'description' value from nested dictionaries within a specified dictionary and returns a list of these descriptions.",
            "code": "from glom import glom, Call, T, Iter\n\nd = { ... }  # put your example lines into this dictionary.\n\ndef get_desc(subdict):\n    return {k: v.get('description', None) \n            for k,v in subdict[1]['nestedStats']['entries'].items()}\n\nspec = (Call(list, args=(T.items(),) ), Iter().map(get_desc).all())\n\nresult = glom(d, spec)\n\nprint(result)",
            "masked_code": "from glom import glom, Call, T, Iter\n\nd = { ... }  # put your example lines into this dictionary.\n\ndef get_desc(subdict):\n    return {k: v.get('description', None) \n            for k,v in subdict[1]['nestedStats']['entries'].items()}\n\n<line_mask>\n\nresult = glom(d, spec)\n\nprint(result)",
            "masked_line": "spec = (Call(list, args=(T.items(),) ), Iter().map(get_desc).all())",
            "answer": "map",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_113"
        },
        {
            "dependency": "numpy",
            "version": "==1.10.1",
            "time": "2019-04-21",
            "description": "The code generates a new array by selecting specific elements from the original array 'a', based on the specified rows and columns indices.",
            "code": "import numpy as np\na=np.arange(2*3*5).reshape(2, 3, 5)\n\nrows = np.array([[0], [1]], dtype=np.intp)\ncols = np.array([[2, 3], [1, 2]], dtype=np.intp)\n\naa = np.stack(a[rows, :, cols]).swapaxes(1, 2)\n# array([[[ 2,  3],\n#         [ 7,  8],\n#         [12, 13]],\n\n#        [[16, 17],\n#         [21, 22],\n#         [26, 27]]])",
            "masked_code": "import numpy as np\n<line_mask>\n\nrows = np.array([[0], [1]], dtype=np.intp)\ncols = np.array([[2, 3], [1, 2]], dtype=np.intp)\n\naa = np.stack(a[rows, :, cols]).swapaxes(1, 2)\n# array([[[ 2,  3],\n#         [ 7,  8],\n#         [12, 13]],\n\n#        [[16, 17],\n#         [21, 22],\n#         [26, 27]]])",
            "masked_line": "a=np.arange(2*3*5).reshape(2, 3, 5)",
            "answer": "reshape",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_114"
        },
        {
            "dependency": "networkx",
            "version": "==1.9",
            "time": "2019-03-09",
            "description": "This code identifies and filters out paths that do not contain any nodes from the list of important nodes.",
            "code": "import NetworkX as nx\nimportant_nodes=[]#list of important nodes    \npaths = nx.all_simple_paths(G, source, target)\npaths=list(paths)\n#This is pseudocode, next four lines could be done with list comprehension\nexclusive_paths=[]\nfor path in paths:\n    if important_nodes not in path:\n        exclusive_paths.append(path)",
            "masked_code": "import NetworkX as nx\nimportant_nodes=[]#list of important nodes    \n<line_mask>\npaths=list(paths)\n#This is pseudocode, next four lines could be done with list comprehension\nexclusive_paths=[]\nfor path in paths:\n    if important_nodes not in path:\n        exclusive_paths.append(path)",
            "masked_line": "paths = nx.all_simple_paths(G, source, target)",
            "answer": "all_simple_paths",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_115"
        },
        {
            "dependency": "pandas",
            "version": ">=0.25",
            "time": "2019-07-25",
            "description": "The code merges two dataframes, df1 and df2, based on the common values in their respective columns 'col1' and 'col2', and then assigns corresponding values from df1 to the merged dataframe. Finally, it drops the 'index' column from the merged dataframe.",
            "code": "import pandas as pd\n\ndf1 = pd.DataFrame({'col1': [[\"a\",\"b\",\"c\"],[\"a\",\"b\"],[\"d\",\"e\"]]})\ndf2 = pd.DataFrame({'col2': [\"a\",\"b\",\"d\"]})\n\ndf1_flat = df1.col1.explode().reset_index()\ndf_merged = pd.merge(df1_flat,df2,left_on='col1',right_on='col2')\n\ndf_merged['col2'] = df1.loc[df_merged['index']].values\ndf_merged.drop('index',axis=1, inplace=True)",
            "masked_code": "import pandas as pd\n\ndf1 = pd.DataFrame({'col1': [[\"a\",\"b\",\"c\"],[\"a\",\"b\"],[\"d\",\"e\"]]})\ndf2 = pd.DataFrame({'col2': [\"a\",\"b\",\"d\"]})\n\n<line_mask>\ndf_merged = pd.merge(df1_flat,df2,left_on='col1',right_on='col2')\n\ndf_merged['col2'] = df1.loc[df_merged['index']].values\ndf_merged.drop('index',axis=1, inplace=True)",
            "masked_line": "df1_flat = df1.col1.explode().reset_index()",
            "answer": "explode",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_116"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.1.0",
            "time": "2019-06-21",
            "description": "The code generates a plot with no data points and displays the Mean Absolute Error (MAE) and Mean Squared Error (MSE) values as text in the plot.",
            "code": "import matplotlib.pyplot as plt\n\nmae, mse = 1, 1\nplt.plot()  # in your case : plt.plot(test_index, y_pred,color=\"goldenrod\")\nplt.text(.5, .5, 'MAE:{}\\nMSE:{}'.format(mae, mse))\nplt.tight_layout()\nplt.show(block=False)\nplt.show()",
            "masked_code": "import matplotlib.pyplot as plt\n\nmae, mse = 1, 1\nplt.plot()  # in your case : plt.plot(test_index, y_pred,color=\"goldenrod\")\nplt.text(.5, .5, 'MAE:{}\\nMSE:{}'.format(mae, mse))\n<line_mask>\nplt.show(block=False)\nplt.show()",
            "masked_line": "plt.tight_layout()",
            "answer": "tight_layout",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_117"
        },
        {
            "dependency": "numpy",
            "version": "==1.10.4",
            "time": "2019-04-25",
            "description": "The code creates a matrix where each row contains k consecutive non-null values from a pandas DataFrame column 'values'. It fills the rest of the row with null values.",
            "code": "#!/usr/bin/env python3\n\nimport numpy as np\nimport pandas as pd\n\nnan = np.nan\n\ndf = pd.DataFrame([\n         nan, 1, 2, nan, nan, 33, 34, 90, \n         nan, 5, nan, 22, 70, nan, 672, \n         10, 73, 9, nan, 15], \n     columns=['values'])\n\nn = len(df)\nk = 5\nr = n - k + 1\n\nmat = np.tile([1] * k + [0] * r, r)[:-r].reshape(r, n)\n\nmat = np.apply_along_axis(lambda row: np.where(row, df['values'], row), 1, mat)\n\nprint(mat)",
            "masked_code": "#!/usr/bin/env python3\n\nimport numpy as np\nimport pandas as pd\n\nnan = np.nan\n\ndf = pd.DataFrame([\n         nan, 1, 2, nan, nan, 33, 34, 90, \n         nan, 5, nan, 22, 70, nan, 672, \n         10, 73, 9, nan, 15], \n     columns=['values'])\n\nn = len(df)\nk = 5\nr = n - k + 1\n\n<line_mask>\n\nmat = np.apply_along_axis(lambda row: np.where(row, df['values'], row), 1, mat)\n\nprint(mat)",
            "masked_line": "mat = np.tile([1] * k + [0] * r, r)[:-r].reshape(r, n)",
            "answer": "tile",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_118"
        },
        {
            "dependency": "bokeh",
            "version": "==1.3.0",
            "time": "2019-10-21",
            "description": "The code generates a Bokeh plot with a line representing time and value data. The plot is updated every second with a random value within the range of 5 to 10.",
            "code": "from bokeh.plotting import figure, curdoc\nfrom datetime import datetime\nimport random\n\nplot = figure(plot_width = 1200, x_axis_type = 'datetime', tools = 'pan,box_select,crosshair,reset,save,wheel_zoom')\nline = plot.line(x = 'time', y = 'value', line_color = 'black', source = dict(time = [datetime.now()], value = [random.randint(5, 10)]))\n\ndef update(): \n    line.data_source.stream(dict(time = [datetime.now()], value = [random.randint(5, 10)]))\n\ncurdoc().add_root(plot)\ncurdoc().add_periodic_callback(update, 1000)",
            "masked_code": "from bokeh.plotting import figure, curdoc\nfrom datetime import datetime\nimport random\n\nplot = figure(plot_width = 1200, x_axis_type = 'datetime', tools = 'pan,box_select,crosshair,reset,save,wheel_zoom')\nline = plot.line(x = 'time', y = 'value', line_color = 'black', source = dict(time = [datetime.now()], value = [random.randint(5, 10)]))\n\ndef update(): \n    line.data_source.stream(dict(time = [datetime.now()], value = [random.randint(5, 10)]))\n\ncurdoc().add_root(plot)\n<line_mask>",
            "masked_line": "curdoc().add_periodic_callback(update, 1000)",
            "answer": "curdoc",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_119"
        },
        {
            "dependency": "pynput",
            "version": ">=1.5.0",
            "time": "2019-11-04",
            "description": "The code simulates pressing the play/pause media key on the keyboard using the pynput library.",
            "code": "from pynput.keyboard import Controller, KeyCode\n\n\ndef main():\n    keyboard = Controller()\n\n    print('Pausing/Resuming... ')\n\n    keyboard.press(KeyCode.from_vk(0xB3))  # Play/Pause\n\nif __name__ == \"__main__\":\n    main()",
            "masked_code": "from pynput.keyboard import Controller, KeyCode\n\n\ndef main():\n    keyboard = Controller()\n\n    print('Pausing/Resuming... ')\n\n    <line_mask>\n\nif __name__ == \"__main__\":\n    main()",
            "masked_line": "keyboard.press(KeyCode.from_vk(0xB3))  # Play/Pause",
            "answer": "from_vk",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_120"
        },
        {
            "dependency": "XlsxWriter",
            "version": ">=1.1.7",
            "time": "2019-06-11",
            "description": "This code creates a new Excel workbook with a line chart and inserts the chart into the worksheet. Data is written to column A and added as a series to the chart.",
            "code": "import xlsxwriter\n\nworkbook = xlsxwriter.Workbook('chart.xlsx')\nworksheet = workbook.add_worksheet()\n\nchart = workbook.add_chart({'type': 'line'})\n\nworksheet.write_column('A1', [2, 4, 6, 8, 10])\n\nchart.add_series({'values': '=Sheet1!$A$1:$A$5'})\n\nworksheet.insert_chart('A7', chart, {'object_position': 3})\n\nworkbook.close()",
            "masked_code": "import xlsxwriter\n\n<line_mask>\nworksheet = workbook.add_worksheet()\n\nchart = workbook.add_chart({'type': 'line'})\n\nworksheet.write_column('A1', [2, 4, 6, 8, 10])\n\nchart.add_series({'values': '=Sheet1!$A$1:$A$5'})\n\nworksheet.insert_chart('A7', chart, {'object_position': 3})\n\nworkbook.close()",
            "masked_line": "workbook = xlsxwriter.Workbook('chart.xlsx')",
            "answer": "Workbook",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_121"
        },
        {
            "dependency": "Flask",
            "version": "==1.0.2",
            "time": "2019-04-18",
            "description": "This code defines a simple Flask web application that, when accessed via a web browser, returns the headers of the HTTP request as a string in the format \"header_name: header_value\".",
            "code": "from flask import Flask, request\napp = Flask(__name__)\n\n\n@app.route(\"/\", methods=[\"GET\", \"POST\"])\ndef index():\n    return \"\".join(list(map(lambda i: f\"{i[0]}: {i[1]}\", request.headers.items()))) + \"\"\"\n    \"\"\"\n\n\nif __name__ == \"__main__\":\n    app.run()",
            "masked_code": "from flask import Flask, request\napp = Flask(__name__)\n\n\n@app.route(\"/\", methods=[\"GET\", \"POST\"])\ndef index():\n    return \"\".join(list(map(lambda i: f\"{i[0]}: {i[1]}\", request.headers.items()))) + \"\"\"\n    \"\"\"\n\n\nif __name__ == \"__main__\":\n    <line_mask>",
            "masked_line": "app.run()",
            "answer": "run",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_122"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.1",
            "time": "2019-01-13",
            "description": "This code creates a single-channel dummy image array of shape (48, 48, 1) and then concatenates it three times along the last axis to create a three-channel image array of shape (48, 48, 3).",
            "code": "import numpy as np\na = np.zeros((2304), dtype = np.uint8) #Just a dummy array representing a single pic\nsingle_channel = a.reshape(48, 48, 1)\n\nresult = np.concatenate([single_channel,single_channel,single_channel], axis = -1)\nprint(result.shape) #(48, 48, 3)",
            "masked_code": "import numpy as np\n<line_mask>\nsingle_channel = a.reshape(48, 48, 1)\n\nresult = np.concatenate([single_channel,single_channel,single_channel], axis = -1)\nprint(result.shape) #(48, 48, 3)",
            "masked_line": "a = np.zeros((2304), dtype = np.uint8) #Just a dummy array representing a single pic",
            "answer": "zeros",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_123"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-09-16",
            "description": "The code generates 500 random float numbers from an exponential distribution and then scales the numbers using min-max scaling to the specified feature range.",
            "code": "import numpy as np\nfrom sklearn.preprocessing import minmax_scale\n# define the number of parameters to generate \nnumber_of_params = 500\n# generate random floats from an exponential distribution\nx = np.random.exponential(scale=1.0, size=number_of_params)\n# min-max scaler\nx = minmax_scale(x, feature_range=(2**-15, 2**15), axis=0, copy=True)",
            "masked_code": "import numpy as np\nfrom sklearn.preprocessing import minmax_scale\n# define the number of parameters to generate \nnumber_of_params = 500\n# generate random floats from an exponential distribution\n<line_mask>\n# min-max scaler\nx = minmax_scale(x, feature_range=(2**-15, 2**15), axis=0, copy=True)",
            "masked_line": "x = np.random.exponential(scale=1.0, size=number_of_params)",
            "answer": "exponential",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_124"
        },
        {
            "dependency": "numpy",
            "version": "==1.13.0",
            "time": "2019-08-15",
            "description": "The code creates a black image with dimensions 400x400 pixels. It then counts the number of pixels with a specific color intensity (150,150,150) in the image. It identifies pixels with the desired color intensity and draws them onto a mask. Finally, it applies the mask to change the color of the identified pixels to (36,255,12).",
            "code": "import numpy as np\n\n# Create black image\nimage = np.zeros((400,400,3), dtype=np.uint8)\nimage[300:400,300:400] = (150,150,150)\n\n# Count number of pixels of specific color intensity\ncount = np.count_nonzero((image == [150, 150, 150]).all(axis = 2))\nprint(count)\n\n# Find pixels of desired color intensity and draw onto mask\nmask = (image == [150.,150.,150.]).all(axis=2)\n\n# Apply the mask to change the pixels\nimage[mask] = [36,255,12]",
            "masked_code": "import numpy as np\n\n# Create black image\nimage = np.zeros((400,400,3), dtype=np.uint8)\nimage[300:400,300:400] = (150,150,150)\n\n# Count number of pixels of specific color intensity\n<line_mask>\nprint(count)\n\n# Find pixels of desired color intensity and draw onto mask\nmask = (image == [150.,150.,150.]).all(axis=2)\n\n# Apply the mask to change the pixels\nimage[mask] = [36,255,12]",
            "masked_line": "count = np.count_nonzero((image == [150, 150, 150]).all(axis = 2))",
            "answer": "count_nonzero",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_125"
        },
        {
            "dependency": "click",
            "version": "==6.7",
            "time": "2019-06-11",
            "description": "This code defines a command line function called version_cmd that takes in optional arguments '--long' and '--check', and when called, it echoes the values of these arguments.",
            "code": "import click\n\ndef importable_command(*args, **kwargs):\n    def decorator(f):\n        return click.decorators.command(*args, **kwargs)(f)\n    return decorator\n\n\n@importable_command('version')\n@click.option('--long')\n@click.option('--check')\ndef version_cmd(long, check):\n    click.echo('version long: {}'.format(long))\n    click.echo('version check: {}'.format(check))",
            "masked_code": "import click\n\ndef importable_command(*args, **kwargs):\n    def decorator(f):\n        return click.decorators.command(*args, **kwargs)(f)\n    return decorator\n\n\n@importable_command('version')\n@click.option('--long')\n<line_mask>\ndef version_cmd(long, check):\n    click.echo('version long: {}'.format(long))\n    click.echo('version check: {}'.format(check))",
            "masked_line": "@click.option('--check')",
            "answer": "option",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_126"
        },
        {
            "dependency": "numpy",
            "version": "==1.9.3",
            "time": "2019-05-04",
            "description": "The function calculates a modified Heaviside step function that returns 0.5 when the input is close to zero, and the actual Heaviside step function value otherwise.",
            "code": "import numpy as np\ndef heaviside_close(x1, x2):\n    closeCheck = np.isclose(x1, np.zeros_like(x1))\n    heavisideBare = np.heaviside(x1, 0.0)\n    zeroVal = np.where(closeCheck, x2, 0.0)-np.where(closeCheck, heavisideBare, np.zeros_like(heavisideBare))\n    result = heavisideBare+zeroVal\n    return result\nprint(heaviside_close(np.asarray([-1., -0.1, 1e-20, 0.1, 1.]), 0.5))\n# >>> [0.  0.  0.5 1.  1. ]\nprint(np.heaviside(np.asarray([-1., -0.1, 1e-20, 0.1, 1.]), 0.5))\n# >>> [0.  0.  1.  1.  1. ]",
            "masked_code": "import numpy as np\ndef heaviside_close(x1, x2):\n    closeCheck = np.isclose(x1, np.zeros_like(x1))\n    <line_mask>\n    zeroVal = np.where(closeCheck, x2, 0.0)-np.where(closeCheck, heavisideBare, np.zeros_like(heavisideBare))\n    result = heavisideBare+zeroVal\n    return result\nprint(heaviside_close(np.asarray([-1., -0.1, 1e-20, 0.1, 1.]), 0.5))\n# >>> [0.  0.  0.5 1.  1. ]\nprint(np.heaviside(np.asarray([-1., -0.1, 1e-20, 0.1, 1.]), 0.5))\n# >>> [0.  0.  1.  1.  1. ]",
            "masked_line": "heavisideBare = np.heaviside(x1, 0.0)",
            "answer": "heaviside",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_127"
        },
        {
            "dependency": "sphinx",
            "version": ">=1.8.2",
            "time": "2019-04-18",
            "description": "The code defines a custom Sphinx napoleon configuration with specific settings for parameter and return type annotations. It then creates a Google style docstring with custom sections for writes and parameters, and prints the formatted docstring using the configured settings.",
            "code": "from sphinxcontrib.napoleon import Config\nfrom sphinxcontrib.napoleon import GoogleDocstring\n\nconfig = Config(napoleon_use_param=True, napoleon_use_rtype=True, napoleon_custom_sections=('Writes', 'Parameters'))\ndocstring=\"\"\"This is an example of Google style with a custom section.\n\nArgs:\n    param1: This is the first param.\n    param2: This is a second parpytham.\n\nReturns:\n    This is a description of what is returned.\n\nRaises:\n    KeyErr\n\nWrites:\n    write1: This is writting things !\n\n\"\"\"\n\nprint(GoogleDocstring(docstring, config))",
            "masked_code": "from sphinxcontrib.napoleon import Config\nfrom sphinxcontrib.napoleon import GoogleDocstring\n\n<line_mask>\ndocstring=\"\"\"This is an example of Google style with a custom section.\n\nArgs:\n    param1: This is the first param.\n    param2: This is a second parpytham.\n\nReturns:\n    This is a description of what is returned.\n\nRaises:\n    KeyErr\n\nWrites:\n    write1: This is writting things !\n\n\"\"\"\n\nprint(GoogleDocstring(docstring, config))",
            "masked_line": "config = Config(napoleon_use_param=True, napoleon_use_rtype=True, napoleon_custom_sections=('Writes', 'Parameters'))",
            "answer": "Config",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_128"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-01-16",
            "description": "The code creates a dictionary \"dfs\" and splits a DataFrame \"df\" based on the condition that the column 'C' is not null. It then further splits the DataFrame based on the values in column 'A' that have a difference of more than 10, and stores the split DataFrames in the dictionary \"dfs\" with incremental keys generated from itertools.count().",
            "code": "from itertools import count\n\nc = count()\ndfs = {}\n\nc_valid = df['C'].notnull()\ndfs[next(c)] = df[c_valid]\n\nsplit_indices = np.where(df.loc[~c_valid, 'A'].diff() > 10)[0]\nfor df_split in np.split(df[~c_valid], split_indices):\n    dfs[next(c)] = df_split",
            "masked_code": "from itertools import count\n\nc = count()\ndfs = {}\n\nc_valid = df['C'].notnull()\ndfs[next(c)] = df[c_valid]\n\nsplit_indices = np.where(df.loc[~c_valid, 'A'].diff() > 10)[0]\n<line_mask>\n    dfs[next(c)] = df_split",
            "masked_line": "for df_split in np.split(df[~c_valid], split_indices):",
            "answer": "split",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_129"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-01-13",
            "description": "The code updates the 'value1' and 'value2' columns in a DataFrame based on a condition defined by the 'id' column and a list of ids to filter.",
            "code": "import numpy as np\n\nmask = df['id'].isin(id_list)\nvalue_array = np.vstack((value1_list, value2_list)).T\ndf.loc[mask, ['value1', 'value2']] = value_array\n\nprint(df)\n#    id  value1  value2\n# 0  24     100     125\n# 1  26     200     175\n# 2  28     300     165\n# 3  30       4       8",
            "masked_code": "import numpy as np\n\nmask = df['id'].isin(id_list)\n<line_mask>\ndf.loc[mask, ['value1', 'value2']] = value_array\n\nprint(df)\n#    id  value1  value2\n# 0  24     100     125\n# 1  26     200     175\n# 2  28     300     165\n# 3  30       4       8",
            "masked_line": "value_array = np.vstack((value1_list, value2_list)).T",
            "answer": "vstack",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_130"
        },
        {
            "dependency": "numpy",
            "version": "==1.17.0",
            "time": "2019-10-04",
            "description": "This code assigns values from the 'values' array to a new array 'result' based on the indices provided in the 'indices' array. The result is a 2D array where the values are assigned at the specified indices.",
            "code": "import numpy as np\n\nindices = np.array([0, 1, 1, 0, 0, 1, 0])\nvalues = np.array([1, 2, 3, 4, 5, 6, 7])\n\nresult = np.zeros((len(indices), 2))\n\nresult[np.arange(len(indices)), indices] = values\n\nprint(result)",
            "masked_code": "import numpy as np\n\nindices = np.array([0, 1, 1, 0, 0, 1, 0])\nvalues = np.array([1, 2, 3, 4, 5, 6, 7])\n\nresult = np.zeros((len(indices), 2))\n\n<line_mask>\n\nprint(result)",
            "masked_line": "result[np.arange(len(indices)), indices] = values",
            "answer": "arange",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_131"
        },
        {
            "dependency": "pandas",
            "version": "==0.24.2",
            "time": "2019-06-11",
            "description": "This code reads an Excel file from an Azure blob storage trigger function, extracts data using pandas into a DataFrame, and logs the DataFrame information.",
            "code": "import logging\n\nimport azure.functions as func\n\nimport pandas as pd\nimport xlrd\n\ndef main(myblob: func.InputStream):\n    logging.info(f\"Python blob trigger function processed blob \\n\"\n                 f\"Name: {myblob.name}\\n\"\n                 f\"Blob Size: {myblob.length} bytes\")\n    book = xlrd.open_workbook(file_contents=myblob.read())\n    df = pd.read_excel(book)\n    logging.info(f\"{df}\")",
            "masked_code": "import logging\n\nimport azure.functions as func\n\nimport pandas as pd\nimport xlrd\n\ndef main(myblob: func.InputStream):\n    logging.info(f\"Python blob trigger function processed blob \\n\"\n                 f\"Name: {myblob.name}\\n\"\n                 f\"Blob Size: {myblob.length} bytes\")\n    book = xlrd.open_workbook(file_contents=myblob.read())\n    <line_mask>\n    logging.info(f\"{df}\")",
            "masked_line": "df = pd.read_excel(book)",
            "answer": "read_excel",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_132"
        },
        {
            "dependency": "xlrd",
            "version": ">=1.0.0",
            "time": "2019-06-11",
            "description": "This code reads an Excel file from a Azure blob storage triggered by a blob upload event, logs information about the uploaded blob, opens the Excel file using xlrd, and then reads the Excel file into a pandas DataFrame.",
            "code": "import logging\n\nimport azure.functions as func\n\nimport pandas as pd\nimport xlrd\n\ndef main(myblob: func.InputStream):\n    logging.info(f\"Python blob trigger function processed blob \\n\"\n                 f\"Name: {myblob.name}\\n\"\n                 f\"Blob Size: {myblob.length} bytes\")\n    book = xlrd.open_workbook(file_contents=myblob.read())\n    df = pd.read_excel(book)\n    logging.info(f\"{df}\")",
            "masked_code": "import logging\n\nimport azure.functions as func\n\nimport pandas as pd\nimport xlrd\n\ndef main(myblob: func.InputStream):\n    logging.info(f\"Python blob trigger function processed blob \\n\"\n                 f\"Name: {myblob.name}\\n\"\n                 f\"Blob Size: {myblob.length} bytes\")\n    <line_mask>\n    df = pd.read_excel(book)\n    logging.info(f\"{df}\")",
            "masked_line": "book = xlrd.open_workbook(file_contents=myblob.read())",
            "answer": "open_workbook",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_133"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.4",
            "time": "2019-03-29",
            "description": "This code calculates the determinant and sign-determinant of a 2x2 matrix, and then attempts to find the inverse of the matrix. If the matrix is singular (non-invertible), it prints \"inversion failed\".",
            "code": "import numpy as np\nmatrix=np.array([[5.,10.],[2.,4.]])\nprint(np.linalg.det(matrix))\nprint(np.linalg.slogdet(matrix))\n\ntry:\n    invmatrix=np.linalg.inv(matrix)\n\nexcept np.linalg.LinAlgError:\n    print(\"inversion failed\")",
            "masked_code": "import numpy as np\nmatrix=np.array([[5.,10.],[2.,4.]])\nprint(np.linalg.det(matrix))\nprint(np.linalg.slogdet(matrix))\n\ntry:\n    <line_mask>\n\nexcept np.linalg.LinAlgError:\n    print(\"inversion failed\")",
            "masked_line": "invmatrix=np.linalg.inv(matrix)",
            "answer": "inv",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_134"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.0",
            "time": "2020-03-10",
            "description": "The code configures the GPU memory allocation for TensorFlow to use a fraction of the available memory per process (0.2) and allows the GPU memory to grow as needed during runtime.",
            "code": "from tensorflow.compat.v1 import ConfigProto\nfrom tensorflow.compat.v1 import InteractiveSession\n\nconfig = ConfigProto()\nconfig.gpu_options.per_process_gpu_memory_fraction = 0.2\nconfig.gpu_options.allow_growth = True\nsession = InteractiveSession(config=config)",
            "masked_code": "from tensorflow.compat.v1 import ConfigProto\n<line_mask>\n\nconfig = ConfigProto()\nconfig.gpu_options.per_process_gpu_memory_fraction = 0.2\nconfig.gpu_options.allow_growth = True\nsession = InteractiveSession(config=config)",
            "masked_line": "from tensorflow.compat.v1 import InteractiveSession",
            "answer": "InteractiveSession",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_135"
        },
        {
            "dependency": "networkx",
            "version": "==1.10",
            "time": "2020-03-30",
            "description": "The code creates a bipartite graph using the NetworkX library in Python. Nodes from the first set are integers 1 to 6, while nodes from the second set are strings 'a' to 'k'. The code also adds edges between the nodes based on predefined connections. Finally, it visualizes the bipartite graph with specific node colors and labels using matplotlib.",
            "code": "import networkx as nx\n\nB = nx.Graph()\nB.add_nodes_from([1, 2, 3, 4, 5, 6], bipartite=0)\nB.add_nodes_from(['a', 'b', 'c', 'j', 'k'], bipartite=1)\nB.add_edges_from([(1, 'a'), (1, 'b'), (2, 'b'), (2, 'c'), (3, 'c'), (4, 'a'), \n                  (2, 'b'), (3, 'a'), (5, 'k'), (6, 'k'), (6, 'j')])\n\n\nrcParams['figure.figsize'] = 12, 6\nnx.draw(B, node_color='lightblue', \n        with_labels=True)",
            "masked_code": "import networkx as nx\n\n<line_mask>\nB.add_nodes_from([1, 2, 3, 4, 5, 6], bipartite=0)\nB.add_nodes_from(['a', 'b', 'c', 'j', 'k'], bipartite=1)\nB.add_edges_from([(1, 'a'), (1, 'b'), (2, 'b'), (2, 'c'), (3, 'c'), (4, 'a'), \n                  (2, 'b'), (3, 'a'), (5, 'k'), (6, 'k'), (6, 'j')])\n\n\nrcParams['figure.figsize'] = 12, 6\nnx.draw(B, node_color='lightblue', \n        with_labels=True)",
            "masked_line": "B = nx.Graph()",
            "answer": "Graph",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_136"
        },
        {
            "dependency": "click",
            "version": "==7.x",
            "time": "2020-11-07",
            "description": "This code defines a command-line interface using the Click library in Python. It defines a main function that takes two options \"--foo\" and \"--bar\" and calls another function some_func(bar) to print the value of the \"--foo\" option.",
            "code": "# test2.py\nimport click\n\n\ndef some_func(bar):\n    c = click.get_current_context()\n    foo = c.params[\"foo\"]\n    print(f\"The value of foo is: {foo}\")\n\n\n@click.command()\n@click.option(\"--foo\")\n@click.option(\"--bar\")\ndef main(foo, bar):\n    some_func(bar)\n\n\nif __name__ == \"__main__\":\n    main()",
            "masked_code": "# test2.py\nimport click\n\n\ndef some_func(bar):\n    c = click.get_current_context()\n    foo = c.params[\"foo\"]\n    print(f\"The value of foo is: {foo}\")\n\n\n@click.command()\n<line_mask>\n@click.option(\"--bar\")\ndef main(foo, bar):\n    some_func(bar)\n\n\nif __name__ == \"__main__\":\n    main()",
            "masked_line": "@click.option(\"--foo\")",
            "answer": "option",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_137"
        },
        {
            "dependency": "discord.py",
            "version": "==1.5",
            "time": "2020-10-06",
            "description": "The code creates a Discord bot that subscribes to the privileged members intent and uses a command prefix of \"!\".",
            "code": "import discord\nfrom discord.ext import commands\n\nintents = discord.Intents.default()\nintents.members = True  # Subscribe to the privileged members intent.\nbot = commands.Bot(command_prefix='!', intents=intents)",
            "masked_code": "import discord\nfrom discord.ext import commands\n\n<line_mask>\nintents.members = True  # Subscribe to the privileged members intent.\nbot = commands.Bot(command_prefix='!', intents=intents)",
            "masked_line": "intents = discord.Intents.default()",
            "answer": "Intents",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_138"
        },
        {
            "dependency": "networkx",
            "version": "==1.9",
            "time": "2020-07-14",
            "description": "The code generates node embeddings for a graph using the node2vec algorithm with specific parameters. The embeddings are then saved in a file named \"embedding.emb\".",
            "code": "import networkx as nx\nG=nx.Graph();\nG=nx.read_edgelist(\"edges.txt\") # edges.txt contains the edge list of your graph\n\n# help to draw https://networkx.github.io/documentation/networkx-1.9/examples/drawing/labels_and_colors.html\nnx.draw(G,with_labels = True,node_color='b',node_size=500);\n\nfrom node2vec import Node2Vec\n# Generate walks\nnode2vec = Node2Vec(G, dimensions=2, walk_length=20, num_walks=10,workers=4)\n# Learn embeddings \nmodel = node2vec.fit(window=10, min_count=1)\n#model.wv.most_similar('1')\nmodel.wv.save_word2vec_format(\"embedding.emb\") #save the embedding in file embedding.emb",
            "masked_code": "import networkx as nx\n<line_mask>\nG=nx.read_edgelist(\"edges.txt\") # edges.txt contains the edge list of your graph\n\n# help to draw https://networkx.github.io/documentation/networkx-1.9/examples/drawing/labels_and_colors.html\nnx.draw(G,with_labels = True,node_color='b',node_size=500);\n\nfrom node2vec import Node2Vec\n# Generate walks\nnode2vec = Node2Vec(G, dimensions=2, walk_length=20, num_walks=10,workers=4)\n# Learn embeddings \nmodel = node2vec.fit(window=10, min_count=1)\n#model.wv.most_similar('1')\nmodel.wv.save_word2vec_format(\"embedding.emb\") #save the embedding in file embedding.emb",
            "masked_line": "G=nx.Graph();",
            "answer": "Graph",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_139"
        },
        {
            "dependency": "discord.py",
            "version": "==1.3.3",
            "time": "2020-06-19",
            "description": "This code creates a Discord bot that listens for messages starting with \"$WhoAmI\", then responds with the name of the message author.",
            "code": "import discord\n\nclient = discord.Client()\n\n@client.event\nasync def on_message(message):\n    if message.author == client.user:\n        return\n    if message.content.startswith('$WhoAmI'):\n        await message.channel.send('You are {}'.format(message.author.name))\n\nclient.run('token')",
            "masked_code": "import discord\n\n<line_mask>\n\n@client.event\nasync def on_message(message):\n    if message.author == client.user:\n        return\n    if message.content.startswith('$WhoAmI'):\n        await message.channel.send('You are {}'.format(message.author.name))\n\nclient.run('token')",
            "masked_line": "client = discord.Client()",
            "answer": "Client",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_140"
        },
        {
            "dependency": "discord.py",
            "version": ">1.5.0",
            "time": "2020-10-12",
            "description": "The code sets up a Discord client with the ability to receive notifications when a new member joins a server and sends a welcome message to the new member.",
            "code": "import discord\n\nintents = discord.Intents.default()\nintents.members = True\n\nclient = discord.Client(intents=intents)\n\n@client.event\nasync def on_member_join(member):\n    await member.send(\"Welcome!\")",
            "masked_code": "import discord\n\nintents = discord.Intents.default()\nintents.members = True\n\n<line_mask>\n\n@client.event\nasync def on_member_join(member):\n    await member.send(\"Welcome!\")",
            "masked_line": "client = discord.Client(intents=intents)",
            "answer": "Client",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_141"
        },
        {
            "dependency": "networkx",
            "version": "==1.10",
            "time": "2020-04-13",
            "description": "The code creates a graph from a list of edges and then creates a dictionary where each node in the graph is a key and the value is a list of its neighboring nodes.",
            "code": "import networkx as nx\n\nG = nx.from_edgelist([s.split('-') for s in Edges])\n\ngraph = dict()\nfor node in G.nodes():\n    graph[node] = list(nx.neighbors(G, node))",
            "masked_code": "import networkx as nx\n\nG = nx.from_edgelist([s.split('-') for s in Edges])\n\ngraph = dict()\nfor node in G.nodes():\n    <line_mask>",
            "masked_line": "graph[node] = list(nx.neighbors(G, node))",
            "answer": "neighbors",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_142"
        },
        {
            "dependency": "scipy",
            "version": "==1.7.1",
            "time": "2021-09-27",
            "description": "The code generates a dendrogram using hierarchical clustering on the given data points and then creates a scatter plot of the data points with colors assigned based on clustering from the dendrogram. The colors are manually assigned by analyzing the dendrogram as the code failed to retrieve colors from the dendrogram directly.",
            "code": "import numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.cluster.hierarchy import linkage, dendrogram\n\n# DATA EXAMPLE\nx = np.array([[ 5, 3],\n              [10,15],\n              [15,12],\n              [24,10],\n              [30,30],\n              [85,70],\n              [71,80]])\n\n# DENDROGRAM\nplt.figure()\nplt.subplot(121)\nz = linkage(x, 'single')\nd = dendrogram(z)\n\n# COLORED PLOT\n# This is what I would like to achieve. Colors are assigned manually by looking\n# at the dendrogram, because I failed to get it from d['color_list'] (it refers \n# to links, not observations)\nplt.subplot(122)\n\n#NEW CODE\nplt.scatter(x[d['leaves'],0],x[d['leaves'],1], color=d['leaves_color_list'])",
            "masked_code": "import numpy as np\nimport matplotlib.pyplot as plt\n<line_mask>\n\n# DATA EXAMPLE\nx = np.array([[ 5, 3],\n              [10,15],\n              [15,12],\n              [24,10],\n              [30,30],\n              [85,70],\n              [71,80]])\n\n# DENDROGRAM\nplt.figure()\nplt.subplot(121)\nz = linkage(x, 'single')\nd = dendrogram(z)\n\n# COLORED PLOT\n# This is what I would like to achieve. Colors are assigned manually by looking\n# at the dendrogram, because I failed to get it from d['color_list'] (it refers \n# to links, not observations)\nplt.subplot(122)\n\n#NEW CODE\nplt.scatter(x[d['leaves'],0],x[d['leaves'],1], color=d['leaves_color_list'])",
            "masked_line": "from scipy.cluster.hierarchy import linkage, dendrogram",
            "answer": "dendrogram",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_143"
        },
        {
            "dependency": "networkx",
            "version": "==1.9",
            "time": "2020-07-27",
            "description": "This code generates a random graph with 100 nodes and a probability of connection between nodes of 0.05, then it visualizes the graph using a spring layout with node labels, light blue node color, and node size of 400.",
            "code": "from matplotlib import pyplot as plt\n\nG = nx.fast_gnp_random_graph(100, .05)\nplt.figure(figsize=(10,6))\npos = nx.spring_layout(G, k=0.8)\nnx.draw(G, pos , with_labels = True, width=0.4, \n        node_color='lightblue', node_size=400)",
            "masked_code": "from matplotlib import pyplot as plt\n\nG = nx.fast_gnp_random_graph(100, .05)\nplt.figure(figsize=(10,6))\npos = nx.spring_layout(G, k=0.8)\n<line_mask>\n        node_color='lightblue', node_size=400)",
            "masked_line": "nx.draw(G, pos , with_labels = True, width=0.4,",
            "answer": "draw",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_144"
        },
        {
            "dependency": "scipy",
            "version": "==0.14.0",
            "time": "2020-05-19",
            "description": "The code creates a 9x9 block diagonal matrix where each block is a 3x3 matrix consisting of repeated values from the original 3x3 matrix x.",
            "code": "\"\"\"\n>>> print(answer)\n[[0 1 2 0 0 0 0 0 0]\n [0 1 2 0 0 0 0 0 0]\n [0 1 2 0 0 0 0 0 0]\n [0 0 0 3 4 5 0 0 0]\n [0 0 0 3 4 5 0 0 0]\n [0 0 0 3 4 5 0 0 0]\n [0 0 0 0 0 0 6 7 8]\n [0 0 0 0 0 0 6 7 8]\n [0 0 0 0 0 0 6 7 8]]\n\"\"\"\nfrom scipy.linalg import block_diag\nimport numpy as np\n\nx = np.arange(9).reshape(3, 3)\nanswer = block_diag(*np.array_split(x.repeat(3, axis=0), 3))",
            "masked_code": "\"\"\"\n>>> print(answer)\n[[0 1 2 0 0 0 0 0 0]\n [0 1 2 0 0 0 0 0 0]\n [0 1 2 0 0 0 0 0 0]\n [0 0 0 3 4 5 0 0 0]\n [0 0 0 3 4 5 0 0 0]\n [0 0 0 3 4 5 0 0 0]\n [0 0 0 0 0 0 6 7 8]\n [0 0 0 0 0 0 6 7 8]\n [0 0 0 0 0 0 6 7 8]]\n\"\"\"\nfrom scipy.linalg import block_diag\nimport numpy as np\n\nx = np.arange(9).reshape(3, 3)\n<line_mask>",
            "masked_line": "answer = block_diag(*np.array_split(x.repeat(3, axis=0), 3))",
            "answer": "block_diag",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_145"
        },
        {
            "dependency": "pandas",
            "version": ">=1.0",
            "time": "2020-12-23",
            "description": "The code creates a DataFrame with columns of different data types (integer, float, boolean, and object) containing various values including missing values, and writes this DataFrame to a CSV file named 'MixedTypes.csv'. It then reads the CSV file back into a new DataFrame 'df', replicating the behavior of reading and writing CSV files with mixed data types and missing values.",
            "code": "import pandas as pd\nimport numpy as np\n\ndftemp = pd.DataFrame({'dt_col': ['1/1/2020',np.nan,'1/3/2020','1/4/2020'], 'int_col':[4,np.nan,3,1],\n                      'float_col':[0.0,1.0,np.nan,4.5],'bool_col':[True, False, False, True],'text_col':['a','b',None,'d']})\n\n#Write to CSV (to be read back in to fully simulate CSV behavior with missing values etc.)\ndftemp.to_csv('MixedTypes.csv', index=False)\n\nlst_cols = ['int_col','float_col','bool_col','text_col']\nlst_dtypes = ['Int16','float','bool','object']\ndict_types = dict(zip(lst_cols,lst_dtypes))\n\n#Unoptimized DataFrame    \ndf = pd.read_csv('MixedTypes.csv')\ndf",
            "masked_code": "import pandas as pd\nimport numpy as np\n\ndftemp = pd.DataFrame({'dt_col': ['1/1/2020',np.nan,'1/3/2020','1/4/2020'], 'int_col':[4,np.nan,3,1],\n                      'float_col':[0.0,1.0,np.nan,4.5],'bool_col':[True, False, False, True],'text_col':['a','b',None,'d']})\n\n#Write to CSV (to be read back in to fully simulate CSV behavior with missing values etc.)\ndftemp.to_csv('MixedTypes.csv', index=False)\n\nlst_cols = ['int_col','float_col','bool_col','text_col']\nlst_dtypes = ['Int16','float','bool','object']\ndict_types = dict(zip(lst_cols,lst_dtypes))\n\n#Unoptimized DataFrame    \n<line_mask>\ndf",
            "masked_line": "df = pd.read_csv('MixedTypes.csv')",
            "answer": "read_csv",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_146"
        },
        {
            "dependency": "panel",
            "version": "==0.13.1",
            "time": "2022-09-29",
            "description": "This code creates a dropdown menu of unique provider names from a DataFrame and allows users to query the DataFrame based on the selected provider.",
            "code": "import pandas as pd\nimport panel as pn\npn.extension()\n\n# Dataframe\ndf = pd.DataFrame({\n    'CcyPair':['EUR/USD', 'AUD/USD' ,'USD/JPY'], \n    'Requester':['Client1', 'Client2' ,'Client3'],\n    'Provider':['LP1', 'LP2' ,'LP3']\n})\n\n# Dropdown\nproviders = list(df.Provider.unique())\nselect_widget = pn.widgets.Select(options=providers)\n\n# Query dataframe based on value in Provider dropdown\n@pn.depends(select_widget)\ndef query(x):\n    filtered_df = pn.widgets.DataFrame(df[df.Provider==x])\n    return filtered_df\n        \n# Display Output\npn.Column(select_widget, query)",
            "masked_code": "import pandas as pd\nimport panel as pn\npn.extension()\n\n# Dataframe\ndf = pd.DataFrame({\n    'CcyPair':['EUR/USD', 'AUD/USD' ,'USD/JPY'], \n    'Requester':['Client1', 'Client2' ,'Client3'],\n    'Provider':['LP1', 'LP2' ,'LP3']\n})\n\n# Dropdown\nproviders = list(df.Provider.unique())\nselect_widget = pn.widgets.Select(options=providers)\n\n# Query dataframe based on value in Provider dropdown\n<line_mask>\ndef query(x):\n    filtered_df = pn.widgets.DataFrame(df[df.Provider==x])\n    return filtered_df\n        \n# Display Output\npn.Column(select_widget, query)",
            "masked_line": "@pn.depends(select_widget)",
            "answer": "depends",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_147"
        },
        {
            "dependency": "opencv-python",
            "version": "==4.5.1",
            "time": "2021-02-02",
            "description": "The code reads an image file, converts it to grayscale, uses a GPU to detect objects in the image using a cascade classifier, and prints the first detected object's information if any object is detected.",
            "code": "import cv2\n\nimg = cv2.imread('./img_sample.jpg')\ncascade = cv2.cuda_CascadeClassifier.create('./cascade_file.xml')\ngray_img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\ncuFrame = cv2.cuda_GpuMat(gray_img)\nresult = cascade.detectMultiScale(cuFrame).download() # download() gets the result as UMat\n\nif result is not None:\n    print(result[0])",
            "masked_code": "import cv2\n\nimg = cv2.imread('./img_sample.jpg')\ncascade = cv2.cuda_CascadeClassifier.create('./cascade_file.xml')\n<line_mask>\ncuFrame = cv2.cuda_GpuMat(gray_img)\nresult = cascade.detectMultiScale(cuFrame).download() # download() gets the result as UMat\n\nif result is not None:\n    print(result[0])",
            "masked_line": "gray_img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)",
            "answer": "cvtColor",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_148"
        },
        {
            "dependency": "scipy",
            "version": "==1.4.1",
            "time": "2020-03-06",
            "description": "This code calculates the numerical solution of a first-order differential equation using the scipy.integrate.solve_ivp function. The differential equation being solved is y' = -a*y, where a is a constant. The initial condition is y(0) = 5, and the solution is computed for the time interval [0, 10]. The printed output is the solution of the differential equation at different time points.",
            "code": "from scipy.integrate import solve_ivp\n\ndef ydot(t,y,a): return -a*y\n\nsol=solve_ivp(ydot,[0,10],[5],args=(8,))\nprint(sol.y)",
            "masked_code": "from scipy.integrate import solve_ivp\n\ndef ydot(t,y,a): return -a*y\n\n<line_mask>\nprint(sol.y)",
            "masked_line": "sol=solve_ivp(ydot,[0,10],[5],args=(8,))",
            "answer": "solve_ivp",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_149"
        },
        {
            "dependency": "matplotlib",
            "version": ">=3.2",
            "time": "2020-12-16",
            "description": "The code creates a custom colormap using green and red colors, then sets the color for missing values to black, and finally assigns a specific color value to represent NaN values.",
            "code": "from matplotlib.colors import ListedColormap\n\nmatplotlib.__version__\n# '3.3.3' \n\ncm = ListedColormap(['green','red'])\ncm.set_bad(color=\"black\")\n\ncm(np.nan)\n# (0.0, 0.0, 0.0, 1.0)",
            "masked_code": "from matplotlib.colors import ListedColormap\n\nmatplotlib.__version__\n# '3.3.3' \n\n<line_mask>\ncm.set_bad(color=\"black\")\n\ncm(np.nan)\n# (0.0, 0.0, 0.0, 1.0)",
            "masked_line": "cm = ListedColormap(['green','red'])",
            "answer": "ListedColormap",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_150"
        },
        {
            "dependency": "networkx",
            "version": "==1.10",
            "time": "2020-07-27",
            "description": "The code generates a set of nodes connected to the source node in a graph using the edge depth-first search algorithm with reverse orientation.",
            "code": "from itertools import chain \nsource = 4120882840\n\n*n, _ = zip(*(nx.edge_dfs(G, source, orientation='reverse')))\nprint(set(chain.from_iterable(n)))\n{4120874720, 4120871840, 4121480930, 4120874920, 4121480780, \n 4121482000, 4120871830, 4120882840}",
            "masked_code": "from itertools import chain \nsource = 4120882840\n\n<line_mask>\nprint(set(chain.from_iterable(n)))\n{4120874720, 4120871840, 4121480930, 4120874920, 4121480780, \n 4121482000, 4120871830, 4120882840}",
            "masked_line": "*n, _ = zip(*(nx.edge_dfs(G, source, orientation='reverse')))",
            "answer": "edge_dfs",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_151"
        },
        {
            "dependency": "scipy",
            "version": "==0.13.0",
            "time": "2020-02-07",
            "description": "The code optimizes the 'function' by finding the values of x that minimize it, subject to the constraint that the sum of (x * [5, 3, 8, 6]) should equal to 11.",
            "code": "from scipy.optimize import fmin_slsqp\nimport numpy as np\n\n\ndef zero_equation(x):\n    return (x*np.array([5,3,8,6])).sum()-11\n\n\ndef function(x):\n    return x[0]+x[1]+x[2]+x[3]\n\n\nb = (0,1)\nbounds = (b,b,b,b)\nstarting_parameters = np.array([0,0,0,1])\nresult = fmin_slsqp(function, x0=starting_parameters , bounds=bounds ,eqcons=[zero_equation])",
            "masked_code": "from scipy.optimize import fmin_slsqp\nimport numpy as np\n\n\ndef zero_equation(x):\n    return (x*np.array([5,3,8,6])).sum()-11\n\n\ndef function(x):\n    return x[0]+x[1]+x[2]+x[3]\n\n\nb = (0,1)\nbounds = (b,b,b,b)\nstarting_parameters = np.array([0,0,0,1])\n<line_mask>",
            "masked_line": "result = fmin_slsqp(function, x0=starting_parameters , bounds=bounds ,eqcons=[zero_equation])",
            "answer": "fmin_slsqp",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_152"
        },
        {
            "dependency": "Shady",
            "version": ">=1.12",
            "time": "2020-09-23",
            "description": "The code defines a custom color transformation function called PhotoNegative, which calculates the negative of the input color by subtracting each RGB component from 1.0. This transformation is then applied to a stimulus in a Shady world.",
            "code": "import Shady;  Shady.RequireShadyVersion('1.12')\n\nShady.AddCustomColorTransformation(\"\"\"\n\n    vec4 PhotoNegative(vec4 color)\n    {\n        color.rgb = 1.0 - color.rgb;\n        return color;\n    }\n\n\"\"\")\nw = Shady.World()\ns = w.Stimulus(Shady.EXAMPLE_MEDIA.alien1, frame=Shady.Integral(16))\ns.colorTransformation = Shady.COLORTRANS.PhotoNegative",
            "masked_code": "<line_mask>\n\nShady.AddCustomColorTransformation(\"\"\"\n\n    vec4 PhotoNegative(vec4 color)\n    {\n        color.rgb = 1.0 - color.rgb;\n        return color;\n    }\n\n\"\"\")\nw = Shady.World()\ns = w.Stimulus(Shady.EXAMPLE_MEDIA.alien1, frame=Shady.Integral(16))\ns.colorTransformation = Shady.COLORTRANS.PhotoNegative",
            "masked_line": "import Shady;  Shady.RequireShadyVersion('1.12')",
            "answer": "RequireShadyVersion",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_153"
        },
        {
            "dependency": "rq",
            "version": "==1.5.0",
            "time": "2020-07-31",
            "description": "The code creates a job queue using Redis and RQ, enqueues a job that runs a randomly failing task with a maximum of 3 retries, and enqueues another job that depends on the completion of the randomly failing job.",
            "code": "from redis import Redis\nfrom rq import Queue, Retry\nfrom somewhere import randomly_failing_task, dependent_task\n\njob_queue = Queue(connection=Redis())\nrandomly_failing_job = job_queue.enqueue(randomly_failing_task, retry=Retry(max=3))\ndependent_job = job_queue.enqueue(dependent_task, depends_on=randomly_failing_job)",
            "masked_code": "from redis import Redis\nfrom rq import Queue, Retry\nfrom somewhere import randomly_failing_task, dependent_task\n\njob_queue = Queue(connection=Redis())\n<line_mask>\ndependent_job = job_queue.enqueue(dependent_task, depends_on=randomly_failing_job)",
            "masked_line": "randomly_failing_job = job_queue.enqueue(randomly_failing_task, retry=Retry(max=3))",
            "answer": "Retry",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_154"
        },
        {
            "dependency": "transformers",
            "version": "==3.1.0",
            "time": "2020-10-08",
            "description": "The code performs zero-shot classification on the given sequence using a pre-trained model. It takes a sequence as input and predicts the most relevant label(s) from the provided candidate labels along with their corresponding scores.",
            "code": "# pip install transformers==3.1.0  # pip install in terminal\nfrom transformers import pipeline\n\nclassifier = pipeline(\"zero-shot-classification\")\n\nsequence = \"Hi, I welcome you to this event\"\ncandidate_labels = [\"greeting\", \"insult\", \"congratulation\"]\n\nclassifier(sequence, candidate_labels)\n\n# output: {'sequence': 'Hi, I welcome you to this event',\n# 'labels': ['greeting', 'congratulation', 'insult'],\n# 'scores': [0.9001138210296631, 0.09858417510986328, 0.001302019809372723]}",
            "masked_code": "# pip install transformers==3.1.0  # pip install in terminal\nfrom transformers import pipeline\n\nclassifier = pipeline(\"zero-shot-classification\")\n\nsequence = \"Hi, I welcome you to this event\"\ncandidate_labels = [\"greeting\", \"insult\", \"congratulation\"]\n\n<line_mask>\n\n# output: {'sequence': 'Hi, I welcome you to this event',\n# 'labels': ['greeting', 'congratulation', 'insult'],\n# 'scores': [0.9001138210296631, 0.09858417510986328, 0.001302019809372723]}",
            "masked_line": "classifier(sequence, candidate_labels)",
            "answer": "classifier",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_155"
        },
        {
            "dependency": "scipy",
            "version": "==0.14.0",
            "time": "2020-04-08",
            "description": "The code generates a figure with two subplots. The first subplot displays the distribution of the 'train' data using Seaborn. The second subplot displays a Q-Q plot of the 'train' data using SciPy.",
            "code": "import matplotlib.pyplot as plt\nimport seaborn as sns\nfrom scipy import stats\n\ntrain = [1,2,2,3,3,3,4,4,4,5,6]*2\n\nfig, ax = plt.subplots(1,2)\n\n#Distribution from seaborn\nsns.distplot(train, ax=ax[0]);\n\n#QQ-plot plot from stats\nstats.probplot(train, plot=ax[1])",
            "masked_code": "import matplotlib.pyplot as plt\nimport seaborn as sns\nfrom scipy import stats\n\ntrain = [1,2,2,3,3,3,4,4,4,5,6]*2\n\nfig, ax = plt.subplots(1,2)\n\n#Distribution from seaborn\nsns.distplot(train, ax=ax[0]);\n\n#QQ-plot plot from stats\n<line_mask>",
            "masked_line": "stats.probplot(train, plot=ax[1])",
            "answer": "probplot",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_156"
        },
        {
            "dependency": "networkx",
            "version": "==1.10",
            "time": "2020-05-21",
            "description": "The code calculates the shortest path length between pairs of nodes in a given list and prints the results in a dictionary format.",
            "code": "from itertools import combinations\n\nH = nx.to_undirected(G)\n\nnodelist = [0,6,7,8]\npaths = {}\nfor nodes in combinations(nodelist, r=2):\n    paths[nodes] = nx.shortest_path_length(H, *nodes)\n\nprint(paths)\n# {(0, 6): 4, (0, 7): 3, (0, 8): 2, (6, 7): 1, (6, 8): 2, (7, 8): 1}",
            "masked_code": "from itertools import combinations\n\nH = nx.to_undirected(G)\n\nnodelist = [0,6,7,8]\npaths = {}\nfor nodes in combinations(nodelist, r=2):\n    <line_mask>\n\nprint(paths)\n# {(0, 6): 4, (0, 7): 3, (0, 8): 2, (6, 7): 1, (6, 8): 2, (7, 8): 1}",
            "masked_line": "paths[nodes] = nx.shortest_path_length(H, *nodes)",
            "answer": "shortest_path_length",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_157"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.x",
            "time": "2020-09-21",
            "description": "The code sets up a TensorFlow session with GPU options to allow memory growth, and then initializes a Sequential classifier.",
            "code": "import tensorflow as tf\ngpuoptions = tf.compat.v1.GPUOptions(allow_growth=True)\nsession = tf.compat.v1.Session(config=tf.compat.v1.ConfigProto(gpu_options=gpuoptions))\nK.set_session(session)\nclassifier = Sequential()",
            "masked_code": "import tensorflow as tf\ngpuoptions = tf.compat.v1.GPUOptions(allow_growth=True)\n<line_mask>\nK.set_session(session)\nclassifier = Sequential()",
            "masked_line": "session = tf.compat.v1.Session(config=tf.compat.v1.ConfigProto(gpu_options=gpuoptions))",
            "answer": "ConfigProto",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_158"
        },
        {
            "dependency": "scipy",
            "version": ">=1.9",
            "time": "2022-02-02",
            "description": "This code uses the differential evolution optimization algorithm to minimize the Rosenbrock function within the given bounds. The maplike_fun function is defined to handle the function evaluation for the population of parameters x.",
            "code": "from scipy.optimize import rosen, differential_evolution\nbounds=[(0, 10), (0, 10)]\n\ndef maplike_fun(func, x):\n    # x.shape == (S, N), where S is the size of the population and N\n    # is the number of parameters. This is where you'd call out from\n    # Python to COMSOL, instead of the following line.\n    return func(x.T)\n\nres = differential_evolution(rosen, bounds, workers=maplike_fun, polish=False, updating='deferred')",
            "masked_code": "from scipy.optimize import rosen, differential_evolution\nbounds=[(0, 10), (0, 10)]\n\ndef maplike_fun(func, x):\n    # x.shape == (S, N), where S is the size of the population and N\n    # is the number of parameters. This is where you'd call out from\n    # Python to COMSOL, instead of the following line.\n    return func(x.T)\n\n<line_mask>",
            "masked_line": "res = differential_evolution(rosen, bounds, workers=maplike_fun, polish=False, updating='deferred')",
            "answer": "differential_evolution",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_159"
        },
        {
            "dependency": "plotly",
            "version": "==4.10.0",
            "time": "2020-09-13",
            "description": "This code creates a polar line plot using Plotly Express, displaying the values of 'r' along the 'theta' axis. The plot is then filled to create a closed shape and the layout is updated to customize the polar axes tick values and labels. Finally, the plot is displayed.",
            "code": "import plotly.express as px\nimport pandas as pd\n\ndf = pd.DataFrame(dict(\n    r=[1, 5, 2, 2, 3],\n    theta=['processing cost', 'mechanical properties', 'chemical stability', 'thermal stability', 'device integration']))\n\nfig = px.line_polar(df, r='r', theta='theta', line_close=True)\nfig.update_traces(fill='toself')\n\nfig.update_layout(\n    polar = dict(\n        radialaxis = dict(tickvals=[0,1,2,3,4,5], showticklabels=True, ticks=''),\n        angularaxis = dict(showticklabels=True, ticks='')\n    )\n)\n\nfig.show()",
            "masked_code": "import plotly.express as px\nimport pandas as pd\n\ndf = pd.DataFrame(dict(\n    r=[1, 5, 2, 2, 3],\n    theta=['processing cost', 'mechanical properties', 'chemical stability', 'thermal stability', 'device integration']))\n\nfig = px.line_polar(df, r='r', theta='theta', line_close=True)\n<line_mask>\n\nfig.update_layout(\n    polar = dict(\n        radialaxis = dict(tickvals=[0,1,2,3,4,5], showticklabels=True, ticks=''),\n        angularaxis = dict(showticklabels=True, ticks='')\n    )\n)\n\nfig.show()",
            "masked_line": "fig.update_traces(fill='toself')",
            "answer": "update_traces",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_160"
        },
        {
            "dependency": "scipy",
            "version": "==0.15.1",
            "time": "2020-05-09",
            "description": "This code reads in an image in grayscale where blobs are assumed to be at pixel value 255 and background at pixel value 0. It then fills any holes within the blobs in the image and saves the resulting image as 'out.png'.",
            "code": "import numpy as np\nimport cv2\nfrom scipy.ndimage.morphology import binary_fill_holes\n\n# Read in image as grayscale and assuming blobs are at 255 and background at 0\nim = cv2.imread('boxes.png',0)\n\ncv2.imwrite('out.png', (binary_fill_holes(im)*255).astype(np.uint8))",
            "masked_code": "import numpy as np\nimport cv2\n<line_mask>\n\n# Read in image as grayscale and assuming blobs are at 255 and background at 0\nim = cv2.imread('boxes.png',0)\n\ncv2.imwrite('out.png', (binary_fill_holes(im)*255).astype(np.uint8))",
            "masked_line": "from scipy.ndimage.morphology import binary_fill_holes",
            "answer": "binary_fill_holes",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_161"
        },
        {
            "dependency": "tf-models-official",
            "version": "==2.5.0",
            "time": "2021-06-20",
            "description": "The code predicts ratings for user 1 with item IDs 1, 2, 3, 4, and 5 using a pre-trained model that has been modified to remove the loss and metric layers.",
            "code": "from tensorflow.keras import Model\nimport tensorflow as tf\n\ninputUserIds = keras_model.input['user_id']\ninputItemIds = keras_model.input['item_id']\n# Cut off the unnecessary parts of the model for predictions.\n# Specifically, we're removing the loss and metric layers in the architecture.\n# Note: we are not training a new model, just taking the parts of the model we need.\noutputs = keras_model.get_layer('rating').output\nnewModel = Model(inputs=[inputUserIds, inputItemIds], outputs=outputs)\n\n## Make predictions for user 1 with items ids 1, 2, 3, 4, 5\n# Make a user. Each row will be user_id 1. The shape of this tensor is (5,1)\nuserIds = tf.constant([1, 1, 1, 1, 1])[:, tf.newaxis]\n# Make a tensor of items. Each row will be different item ids. The shape of this tensor is (5,1)\nitemIds = tf.constant([1,2,3,4,5])[:, tf.newaxis]\n\n# Make preds. This predicts for user id 1 and items ids 1,2,3,4,5.\npreds = newModel.predict(x=[userIds, itemIds])",
            "masked_code": "from tensorflow.keras import Model\nimport tensorflow as tf\n\ninputUserIds = keras_model.input['user_id']\ninputItemIds = keras_model.input['item_id']\n# Cut off the unnecessary parts of the model for predictions.\n# Specifically, we're removing the loss and metric layers in the architecture.\n# Note: we are not training a new model, just taking the parts of the model we need.\noutputs = keras_model.get_layer('rating').output\nnewModel = Model(inputs=[inputUserIds, inputItemIds], outputs=outputs)\n\n## Make predictions for user 1 with items ids 1, 2, 3, 4, 5\n# Make a user. Each row will be user_id 1. The shape of this tensor is (5,1)\nuserIds = tf.constant([1, 1, 1, 1, 1])[:, tf.newaxis]\n# Make a tensor of items. Each row will be different item ids. The shape of this tensor is (5,1)\nitemIds = tf.constant([1,2,3,4,5])[:, tf.newaxis]\n\n# Make preds. This predicts for user id 1 and items ids 1,2,3,4,5.\n<line_mask>",
            "masked_line": "preds = newModel.predict(x=[userIds, itemIds])",
            "answer": "predict",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_162"
        },
        {
            "dependency": "pandas",
            "version": "==1.x",
            "time": "2020-03-06",
            "description": "The code retrieves data from a nested JSON structure, normalizes it into a DataFrame, and concatenates the results into a single DataFrame. It then outputs information about the DataFrame.",
            "code": "# for older versions of pandas import json_normalize like so:\n# from pandas.io.json import json_normalize\n\n# use this for pandas version 1.x\nfrom pandas import json_normalize\nframes = []\n\nfor idx in range(len(a)):\n    for estate in (a[idx][\"_embedded\"][\"estates\"]):\n        frames.append(json_normalize(estate))\n\ndf_estates = pd.concat(frames)\ndf_estates.info()",
            "masked_code": "# for older versions of pandas import json_normalize like so:\n# from pandas.io.json import json_normalize\n\n# use this for pandas version 1.x\n<line_mask>\nframes = []\n\nfor idx in range(len(a)):\n    for estate in (a[idx][\"_embedded\"][\"estates\"]):\n        frames.append(json_normalize(estate))\n\ndf_estates = pd.concat(frames)\ndf_estates.info()",
            "masked_line": "from pandas import json_normalize",
            "answer": "json_normalize",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_163"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.1.0",
            "time": "2020-03-25",
            "description": "The code loads a pre-trained Keras model saved in a .h5 file using TensorFlow, prints a summary of the loaded model, and then prints a summary of each layer in the model.",
            "code": "import tensorflow as tf\nprint('Running Tensorflow version {}'.format(tf.__version__)) # Tensorflow 2.1.0\n\nmodel_path = '/content/keras_model.h5'\n\nloaded_model = tf.keras.models.load_model(model_path)\nloaded_model.summary()\n\ninp = loaded_model.input   \nlayer_summary = [layer.summary() for layer in loaded_model.layers]",
            "masked_code": "import tensorflow as tf\nprint('Running Tensorflow version {}'.format(tf.__version__)) # Tensorflow 2.1.0\n\nmodel_path = '/content/keras_model.h5'\n\n<line_mask>\nloaded_model.summary()\n\ninp = loaded_model.input   \nlayer_summary = [layer.summary() for layer in loaded_model.layers]",
            "masked_line": "loaded_model = tf.keras.models.load_model(model_path)",
            "answer": "load_model",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_164"
        },
        {
            "dependency": "StyleFrame",
            "version": "==2.0.5",
            "time": "2020-01-02",
            "description": "This code reads an Excel file and creates a StyleFrame object. It filters out cells that have a white or 'FFFFFFFF' background color and replaces them with NaN values. Finally, it prints the cleaned StyleFrame object.",
            "code": "from StyleFrame import StyleFrame, utils\n\ndef only_cells_with_colored_background(cell):\n    return cell if cell.style.bg_color not in {utils.colors.white, 'FFFFFFFF'} else np.nan\n\nsf = StyleFrame.read_excel('test.xlsx', read_style=True, skip_blank_lines=False)\nsf = StyleFrame(sf.applymap(only_cells_with_colored_background).dropna(axis=(0, 1),\n                how='all'))\nprint(sf)",
            "masked_code": "from StyleFrame import StyleFrame, utils\n\ndef only_cells_with_colored_background(cell):\n    return cell if cell.style.bg_color not in {utils.colors.white, 'FFFFFFFF'} else np.nan\n\nsf = StyleFrame.read_excel('test.xlsx', read_style=True, skip_blank_lines=False)\n<line_mask>\n                how='all'))\nprint(sf)",
            "masked_line": "sf = StyleFrame(sf.applymap(only_cells_with_colored_background).dropna(axis=(0, 1),",
            "answer": "dropna",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_165"
        },
        {
            "dependency": "discord.py",
            "version": "==1.5.1",
            "time": "2020-10-20",
            "description": "The code initializes a Discord bot with all intents enabled and a specified command prefix.",
            "code": "from discord import Intents\nfrom discord.ext.commands import Bot\n\nintent = Intents().all()\n\nbot = Bot(command_prefix='prefix', intents=intent)\n\n... # Some code under this line",
            "masked_code": "from discord import Intents\nfrom discord.ext.commands import Bot\n\n<line_mask>\n\nbot = Bot(command_prefix='prefix', intents=intent)\n\n... # Some code under this line",
            "masked_line": "intent = Intents().all()",
            "answer": "all",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_166"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.1.0",
            "time": "2020-03-23",
            "description": "The code creates tensors with complex values and performs inverse FFT (Fast Fourier Transform) operations on the concatenated tensors for verification purposes.",
            "code": "import tensorflow as tf\nprint('TensorFlow Version : {}'.format(tf.__version__)) # Using TensorFlow 2.1.0\n\nBATCH_SIZE = 64\n\nnol = tf.zeros([BATCH_SIZE,1,12],tf.complex64)\npv = tf.fill([BATCH_SIZE,1,8],3+3j)\npv = tf.cast(pv,dtype=tf.complex64)\n\n#Assuming your data X based on your error\nx = tf.zeros([BATCH_SIZE,1,32],tf.complex64)\n\n# Verification 1\ntf.signal.ifft(tf.concat([nol,x,pv,nol],axis=-1)) \n\n# Verification 2\ntf.keras.layers.Lambda(lambda x : tf.signal.ifft(tf.concat([nol,x,pv,nol],axis=-1)), output_shape=(1,64))(x)",
            "masked_code": "import tensorflow as tf\nprint('TensorFlow Version : {}'.format(tf.__version__)) # Using TensorFlow 2.1.0\n\nBATCH_SIZE = 64\n\nnol = tf.zeros([BATCH_SIZE,1,12],tf.complex64)\n<line_mask>\npv = tf.cast(pv,dtype=tf.complex64)\n\n#Assuming your data X based on your error\nx = tf.zeros([BATCH_SIZE,1,32],tf.complex64)\n\n# Verification 1\ntf.signal.ifft(tf.concat([nol,x,pv,nol],axis=-1)) \n\n# Verification 2\ntf.keras.layers.Lambda(lambda x : tf.signal.ifft(tf.concat([nol,x,pv,nol],axis=-1)), output_shape=(1,64))(x)",
            "masked_line": "pv = tf.fill([BATCH_SIZE,1,8],3+3j)",
            "answer": "fill",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_167"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.2.1",
            "time": "2020-06-04",
            "description": "This code generates a heatmap showing the Spearman correlation between two lists of values provided for A and B, respectively.",
            "code": "import pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\nA = [...] # insert here your list of values for A\n\nB = [...] # insert here your list of values for B\n\ndf = pd.DataFrame({'A': A,\n                   'B': B})\n\ncorr = df.corr(method = 'spearman')\n\nsns.heatmap(corr, annot = True)\n\nplt.show()",
            "masked_code": "import pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\nA = [...] # insert here your list of values for A\n\nB = [...] # insert here your list of values for B\n\ndf = pd.DataFrame({'A': A,\n                   'B': B})\n\ncorr = df.corr(method = 'spearman')\n\nsns.heatmap(corr, annot = True)\n\n<line_mask>",
            "masked_line": "plt.show()",
            "answer": "show",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_168"
        },
        {
            "dependency": "pandas",
            "version": "==1.0.4",
            "time": "2020-06-04",
            "description": "The code generates a heatmap to visualize the Spearman correlation between two lists of values (A and B) in a DataFrame using pandas, seaborn, and matplotlib in Python.",
            "code": "import pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\nA = [...] # insert here your list of values for A\n\nB = [...] # insert here your list of values for B\n\ndf = pd.DataFrame({'A': A,\n                   'B': B})\n\ncorr = df.corr(method = 'spearman')\n\nsns.heatmap(corr, annot = True)\n\nplt.show()",
            "masked_code": "import pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\nA = [...] # insert here your list of values for A\n\nB = [...] # insert here your list of values for B\n\ndf = pd.DataFrame({'A': A,\n                   'B': B})\n\ncorr = df.corr(method = 'spearman')\n\n<line_mask>\n\nplt.show()",
            "masked_line": "sns.heatmap(corr, annot = True)",
            "answer": "corr",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_169"
        },
        {
            "dependency": "seaborn",
            "version": "==0.10.1",
            "time": "2020-06-04",
            "description": "This code generates a heatmap visualization of the Spearman correlation between two lists of values A and B.",
            "code": "import pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\nA = [...] # insert here your list of values for A\n\nB = [...] # insert here your list of values for B\n\ndf = pd.DataFrame({'A': A,\n                   'B': B})\n\ncorr = df.corr(method = 'spearman')\n\nsns.heatmap(corr, annot = True)\n\nplt.show()",
            "masked_code": "import pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\nA = [...] # insert here your list of values for A\n\nB = [...] # insert here your list of values for B\n\ndf = pd.DataFrame({'A': A,\n                   'B': B})\n\ncorr = df.corr(method = 'spearman')\n\n<line_mask>\n\nplt.show()",
            "masked_line": "sns.heatmap(corr, annot = True)",
            "answer": "heatmap",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_170"
        },
        {
            "dependency": "pyarrow",
            "version": "==10.0.1",
            "time": "2023-01-11",
            "description": "This code converts a CSV file ('box.csv') to a pandas DataFrame, then parses and converts the 'SETTLEMENTDATE' column to datetime format. It creates a new column 'Date' with only the date part of 'SETTLEMENTDATE'. Next, it converts the DataFrame to a pyarrow table and writes it to a Parquet dataset ('nem.parquet') with partitioning based on the 'Date' column. If there are existing matching data, it deletes them before writing the new data.",
            "code": "import pandas as pd\nimport pyarrow as pa\nimport pyarrow.parquet as pq\n\n\ndf = pd.read_csv('box.csv',parse_dates=True)\ndf['SETTLEMENTDATE'] = pd.to_datetime(df['SETTLEMENTDATE'])\ndf['Date'] = df['SETTLEMENTDATE'].dt.date\n\n# convert to pyarrow table\ndf_pa = pa.Table.from_pandas(df)\n\npq.write_to_dataset(df_pa,\n  root_path = 'nem.parquet',\n  partition_cols = ['Date'],\n  basename_template = \"part-{i}.parquet\",\n  existing_data_behavior = 'delete_matching')",
            "masked_code": "import pandas as pd\nimport pyarrow as pa\nimport pyarrow.parquet as pq\n\n\ndf = pd.read_csv('box.csv',parse_dates=True)\ndf['SETTLEMENTDATE'] = pd.to_datetime(df['SETTLEMENTDATE'])\ndf['Date'] = df['SETTLEMENTDATE'].dt.date\n\n# convert to pyarrow table\ndf_pa = pa.Table.from_pandas(df)\n\n<line_mask>\n  root_path = 'nem.parquet',\n  partition_cols = ['Date'],\n  basename_template = \"part-{i}.parquet\",\n  existing_data_behavior = 'delete_matching')",
            "masked_line": "pq.write_to_dataset(df_pa,",
            "answer": "write_to_dataset",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_171"
        },
        {
            "dependency": "seaborn",
            "version": "==0.11.0",
            "time": "2021-02-11",
            "description": "The code generates a histogram overlaid with a Kernel Density Estimate (KDE) using Seaborn. It sets the number of bins to 20, normalizes the histogram by density, adds a KDE line, and customizes the appearance of the plot. Additionally, it edits the line color and adds a legend without a frame, as well as a title to the plot before displaying it.",
            "code": "# Plot seaborn histogram overlaid with KDE\nax = sns.histplot(data=df['variable'], bins=20, stat='density', alpha= 1, kde=True,\n                  edgecolor='white', linewidth=0.5,\n                  line_kws=dict(color='black', alpha=0.5, linewidth=1.5, label='KDE'))\nax.get_lines()[0].set_color('black') # edit line color due to bug in sns v 0.11.0\n\n# Edit legemd and add title\nax.legend(frameon=False)\nax.set_title('Seaborn histogram overlaid with KDE', fontsize=14, pad=15)\n\nplt.show()",
            "masked_code": "# Plot seaborn histogram overlaid with KDE\nax = sns.histplot(data=df['variable'], bins=20, stat='density', alpha= 1, kde=True,\n                  edgecolor='white', linewidth=0.5,\n                  line_kws=dict(color='black', alpha=0.5, linewidth=1.5, label='KDE'))\n<line_mask>\n\n# Edit legemd and add title\nax.legend(frameon=False)\nax.set_title('Seaborn histogram overlaid with KDE', fontsize=14, pad=15)\n\nplt.show()",
            "masked_line": "ax.get_lines()[0].set_color('black') # edit line color due to bug in sns v 0.11.0",
            "answer": "get_lines",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_172"
        },
        {
            "dependency": "dash",
            "version": "==2.0.0",
            "time": "2021-10-12",
            "description": "This code creates a web application using Dash that includes two dropdown menus for selecting materials, a graph for displaying new cases data, and styling elements such as font and text alignment. The application is run and displayed inline in the Jupyter notebook.",
            "code": "import json\nimport numpy as np\nimport dash_bootstrap_components as dbc\nimport dash\nfrom jupyter_dash import JupyterDash\n\nall_options = {k: v for k, v in zip(list(\"ABCD\"), np.random.randint(1, 4, 4))}\noptions1 = list(all_options.keys())\n# Build App\napp = JupyterDash(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP])\napp.layout = dash.html.Div(\n    [\n        dbc.Row(\n            [\n                dbc.Col(\n                    dbc.Row(\n                        [\n                            dash.html.Label(\"Material 1\"),\n                            dash.dcc.Dropdown(\n                                id=\"dropdown1\",\n                                options=[\n                                    {\"label\": k, \"value\": k} for k in all_options.keys()\n                                ],\n                                value=options1[0],\n                                style={\"width\": \"400px\", \"margin-left\": 0},\n                            ),\n                        ],\n                        justify=\"center\",\n                    ),\n                ),\n                dbc.Col(\n                    dbc.Row(\n                        [\n                            dash.html.Label(\"Material 2\"),\n                            dash.dcc.Dropdown(\n                                id=\"dropdown2\",\n                                options=[\n                                    {\"label\": k, \"value\": k} for k in all_options.keys()\n                                ],\n                                value=options1[0],\n                                style={\"width\": \"400px\", \"margin-left\": 0},\n                            ),\n                        ],\n                        justify=\"center\",\n                    ),\n                ),\n            ],\n            justify=\"center\",\n        ),\n        dash.dcc.Graph(id=\"newCases\", style={\"height\": \"45vh\"}),\n    ],\n    style={\"font-family\": \"Arial\", \"font-size\": \"0.9em\", \"text-align\": \"center\"},\n)\n\n\n# Run app and display result inline in the notebook\napp.run_server(mode=\"inline\")",
            "masked_code": "import json\nimport numpy as np\nimport dash_bootstrap_components as dbc\nimport dash\nfrom jupyter_dash import JupyterDash\n\nall_options = {k: v for k, v in zip(list(\"ABCD\"), np.random.randint(1, 4, 4))}\noptions1 = list(all_options.keys())\n# Build App\napp = JupyterDash(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP])\n<line_mask>\n    [\n        dbc.Row(\n            [\n                dbc.Col(\n                    dbc.Row(\n                        [\n                            dash.html.Label(\"Material 1\"),\n                            dash.dcc.Dropdown(\n                                id=\"dropdown1\",\n                                options=[\n                                    {\"label\": k, \"value\": k} for k in all_options.keys()\n                                ],\n                                value=options1[0],\n                                style={\"width\": \"400px\", \"margin-left\": 0},\n                            ),\n                        ],\n                        justify=\"center\",\n                    ),\n                ),\n                dbc.Col(\n                    dbc.Row(\n                        [\n                            dash.html.Label(\"Material 2\"),\n                            dash.dcc.Dropdown(\n                                id=\"dropdown2\",\n                                options=[\n                                    {\"label\": k, \"value\": k} for k in all_options.keys()\n                                ],\n                                value=options1[0],\n                                style={\"width\": \"400px\", \"margin-left\": 0},\n                            ),\n                        ],\n                        justify=\"center\",\n                    ),\n                ),\n            ],\n            justify=\"center\",\n        ),\n        dash.dcc.Graph(id=\"newCases\", style={\"height\": \"45vh\"}),\n    ],\n    style={\"font-family\": \"Arial\", \"font-size\": \"0.9em\", \"text-align\": \"center\"},\n)\n\n\n# Run app and display result inline in the notebook\napp.run_server(mode=\"inline\")",
            "masked_line": "app.layout = dash.html.Div(",
            "answer": "html",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_173"
        },
        {
            "dependency": "pandas",
            "version": "==1.3.3",
            "time": "2021-09-30",
            "description": "The code randomly replaces some elements in a 3x4 numpy array with infinity and then creates a DataFrame using pandas with MultiIndex columns 'A' and 'B' for 'value1' and 'value2'.",
            "code": "import numpy as np\nimport pandas as pd  # version 1.3.3\nimport seaborn as sns\nfrom matplotlib import colors as mcolors\n\nnp.random.seed(25)\na = np.random.random((3, 4))\n# Replace Randomly With inf\na[np.random.randint(0, 2, size=a.shape) == 0] = np.inf\n\ndata = pd.DataFrame(a, columns=pd.MultiIndex.from_product([\n    list('AB'),\n    ['value1', 'value2']\n]))\ndata",
            "masked_code": "import numpy as np\nimport pandas as pd  # version 1.3.3\nimport seaborn as sns\nfrom matplotlib import colors as mcolors\n\nnp.random.seed(25)\na = np.random.random((3, 4))\n# Replace Randomly With inf\na[np.random.randint(0, 2, size=a.shape) == 0] = np.inf\n\n<line_mask>\n    list('AB'),\n    ['value1', 'value2']\n]))\ndata",
            "masked_line": "data = pd.DataFrame(a, columns=pd.MultiIndex.from_product([",
            "answer": "DataFrame",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_174"
        },
        {
            "dependency": "pandas",
            "version": ">=1.2",
            "time": "2021-07-24",
            "description": "The code generates sentences describing a scenario where a person named person1 travels to a country with another person named person2 every year.",
            "code": "import pandas as pd\n\ndata = {\n    \"~GPE~\": ['UK', 'USA'],\n    \"~PERSON~\": ['John Davies', 'Tom Banton', 'Joe Morgan'],\n    # and so on ...\n}\n\ncountry = pd.DataFrame({'country':data['~GPE~']})\nperson = pd.DataFrame({'person':data['~PERSON~']})\n\ncart = country.merge(person, how='cross').merge(person, how='cross')\n\ncart.columns = ['country', 'person1', 'person2']\n\ncart = cart.query('person1 != person2').reset_index()\n\ncart['sentence'] = cart.apply(lambda row: f\"My name is {row['person1']}. I travel to {row['country']} with {row['person2']} every year.\" , axis=1)\n\nsentences = cart['sentence'].to_list()\n\nprint('\\n'.join(sentences))",
            "masked_code": "import pandas as pd\n\ndata = {\n    \"~GPE~\": ['UK', 'USA'],\n    \"~PERSON~\": ['John Davies', 'Tom Banton', 'Joe Morgan'],\n    # and so on ...\n}\n\ncountry = pd.DataFrame({'country':data['~GPE~']})\nperson = pd.DataFrame({'person':data['~PERSON~']})\n\ncart = country.merge(person, how='cross').merge(person, how='cross')\n\ncart.columns = ['country', 'person1', 'person2']\n\ncart = cart.query('person1 != person2').reset_index()\n\ncart['sentence'] = cart.apply(lambda row: f\"My name is {row['person1']}. I travel to {row['country']} with {row['person2']} every year.\" , axis=1)\n\n<line_mask>\n\nprint('\\n'.join(sentences))",
            "masked_line": "sentences = cart['sentence'].to_list()",
            "answer": "to_list",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_175"
        },
        {
            "dependency": "ctypes",
            "version": "==1.1.0 ",
            "time": "2021-10-01",
            "description": "The code opens a connection to a power meter using the FieldMax2Lib.dll library and checks for the availability of the power meter. It then prints the response.",
            "code": "import ctypes as c\n\nmydll = c.WinDLL(r'C:\\Program Files (x86)\\Coherent\\FieldMaxII PC\\Drivers\\Win10\\FieldMax2Lib\\x64\\FieldMax2Lib.dll')\n\npy_connect=mydll.fm2LibOpenDriver\npy_connect.restype=c.c_int32\npy_connect.argtypes=[c.c_int16]\nresponse=py_connect(0) # arg 0 = 1 available power meter\nprint(response)",
            "masked_code": "import ctypes as c\n\n<line_mask>\n\npy_connect=mydll.fm2LibOpenDriver\npy_connect.restype=c.c_int32\npy_connect.argtypes=[c.c_int16]\nresponse=py_connect(0) # arg 0 = 1 available power meter\nprint(response)",
            "masked_line": "mydll = c.WinDLL(r'C:\\Program Files (x86)\\Coherent\\FieldMaxII PC\\Drivers\\Win10\\FieldMax2Lib\\x64\\FieldMax2Lib.dll')",
            "answer": "WinDLL",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_176"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.4",
            "time": "2021-01-09",
            "description": "The code creates a sparse tensor from a given dense tensor using TensorFlow.",
            "code": "import tensorflow as tf\nimport numpy as np\n\na = np.array([[1., 0., 2., 0.],\n              [3., 0., 0., 4.]])\n\na_t = tf.constant(a)\na_s = tf.sparse.from_dense(a_t)",
            "masked_code": "import tensorflow as tf\nimport numpy as np\n\na = np.array([[1., 0., 2., 0.],\n              [3., 0., 0., 4.]])\n\n<line_mask>\na_s = tf.sparse.from_dense(a_t)",
            "masked_line": "a_t = tf.constant(a)",
            "answer": "constant",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_177"
        },
        {
            "dependency": "numpy",
            "version": ">=1.19",
            "time": "2021-09-29",
            "description": "The code generates a random permutation of the elements in each row of a 2D numpy array.",
            "code": "import numpy as np\n\narr = np.array([[0, 0, 0, 0, 0], [0, 4, 1, 1, 1], [0, 1, 1, 2, 2], [0, 3, 2, 2, 2]])\n\nrng = np.random.default_rng()\narr_rand3 = rng.permutation(arr, axis=1)\n\nprint(arr_rand3)",
            "masked_code": "import numpy as np\n\n<line_mask>\n\nrng = np.random.default_rng()\narr_rand3 = rng.permutation(arr, axis=1)\n\nprint(arr_rand3)",
            "masked_line": "arr = np.array([[0, 0, 0, 0, 0], [0, 4, 1, 1, 1], [0, 1, 1, 2, 2], [0, 3, 2, 2, 2]])",
            "answer": "array",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_178"
        },
        {
            "dependency": "dash",
            "version": "==1.2.0",
            "time": "2021-06-14",
            "description": "The code creates a Dash web application with a layout containing a syntax error where a list of lists is used as children inside a html.Div element.",
            "code": "import dash\nimport dash_html_components as html\n\napp = dash.Dash()\napp.layout = html.Div([[\"Hello world\"]])  # list of lists as children, a typical syntax error\n\nif __name__ == '__main__':\n    app.run_server(debug=True)",
            "masked_code": "import dash\nimport dash_html_components as html\n\napp = dash.Dash()\napp.layout = html.Div([[\"Hello world\"]])  # list of lists as children, a typical syntax error\n\nif __name__ == '__main__':\n    <line_mask>",
            "masked_line": "app.run_server(debug=True)",
            "answer": "run_server",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_179"
        },
        {
            "dependency": "shap",
            "version": "==0.36",
            "time": "2021-12-10",
            "description": "The code displays SHAP (SHapley Additive exPlanations) plots in a Streamlit web application with a specified height of 400 pixels.",
            "code": "import streamlit as st\nimport streamlit.components.v1 as components\n\ndef st_shap(plot, height=None):\n    shap_html = f\"{shap.getjs()}{plot.html()}\"\n    components.html(shap_html, height=height)\n\nst_shap(shap.plots.text(shap_values),400)",
            "masked_code": "import streamlit as st\nimport streamlit.components.v1 as components\n\ndef st_shap(plot, height=None):\n    shap_html = f\"{shap.getjs()}{plot.html()}\"\n    components.html(shap_html, height=height)\n\n<line_mask>",
            "masked_line": "st_shap(shap.plots.text(shap_values),400)",
            "answer": "plots",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_180"
        },
        {
            "dependency": "scipy",
            "version": "==1.7.0",
            "time": "2021-07-16",
            "description": "The code creates a cubic spline interpolation for the given dataset (x, y) and then calculates the derivative of the spline. It then plots the original spline and its derivative using matplotlib.",
            "code": "from scipy.interpolate import UnivariateSpline\n\nspl = UnivariateSpline(x, y, k=4, s=0)\ndiffspl = spl.derivative()\n\nplt.plot(x, spl(x), '--')\nplt.plot(x, diffspl(x), '--')\nplt.show()",
            "masked_code": "from scipy.interpolate import UnivariateSpline\n\nspl = UnivariateSpline(x, y, k=4, s=0)\n<line_mask>\n\nplt.plot(x, spl(x), '--')\nplt.plot(x, diffspl(x), '--')\nplt.show()",
            "masked_line": "diffspl = spl.derivative()",
            "answer": "derivative",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_181"
        },
        {
            "dependency": "matplotlib",
            "version": ">=3.3.1",
            "time": "2021-02-07",
            "description": "The code generates a time plot of the range from 0 to 10 with x-axis formatted as hours:minutes:seconds.",
            "code": "import matplotlib.pyplot as plt\nimport matplotlib as mpl\nimport time\n\nnow_ms = int(time.time() * 1000)\nx = [now_ms+t for t in range(0,10_000,1000)]\n\nplt.plot([mpl.dates.epoch2num(t/1000) for t in x], range(10))\nplt.gca().xaxis.set_major_formatter(mpl.dates.DateFormatter(\"%H:%M:%S\"))",
            "masked_code": "import matplotlib.pyplot as plt\nimport matplotlib as mpl\nimport time\n\nnow_ms = int(time.time() * 1000)\nx = [now_ms+t for t in range(0,10_000,1000)]\n\nplt.plot([mpl.dates.epoch2num(t/1000) for t in x], range(10))\n<line_mask>",
            "masked_line": "plt.gca().xaxis.set_major_formatter(mpl.dates.DateFormatter(\"%H:%M:%S\"))",
            "answer": "gca",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_182"
        },
        {
            "dependency": "transformers",
            "version": "==4.5.1",
            "time": "2021-05-12",
            "description": "The code initializes a BertTokenizer with the 'bert-base-uncased' pre-trained model, tokenizes the input text \"This is an example with an emoji .\", adds the emoji token '' to the tokenizer, and tokenizes the same input text again to include the added emoji token.",
            "code": "from transformers import BertTokenizer\nt = BertTokenizer.from_pretrained('bert-base-uncased')\nprint(t.tokenize(\"This is an example with an emoji .\"))\nt.add_tokens([''])\nprint(t.tokenize(\"This is an example with an emoji .\"))",
            "masked_code": "from transformers import BertTokenizer\n<line_mask>\nprint(t.tokenize(\"This is an example with an emoji .\"))\nt.add_tokens([''])\nprint(t.tokenize(\"This is an example with an emoji .\"))",
            "masked_line": "t = BertTokenizer.from_pretrained('bert-base-uncased')",
            "answer": "from_pretrained",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_183"
        },
        {
            "dependency": "pandas",
            "version": "==1.1.3",
            "time": "2021-02-27",
            "description": "The code creates a joint plot using seaborn to visualize the relationship between two sets of data points. The first set of data points is represented by the variables x1 and y1 with categories 'a' and 'b', and the second set of data points is represented by the variables x2 and y2 with categories 'c' and 'd'. The code also extracts new colors for the categories from the color palette used in the joint plot to plot additional points from the second dataframe on the same scatter plot.",
            "code": "import pandas as pd    # v 1.1.3\nimport seaborn as sns  # v 0.11.0\n\nd = {\n    'x1': [3,2,5,1,1,0],\n    'y1': [1,1,2,3,0,2],\n    'cat': ['a','a','a','b','b','b']\n}\n\ndf = pd.DataFrame(d)\n\n# Set seaborn color palette\nsns.set_palette('bright')\ng = sns.jointplot(data=df, x='x1', y='y1', hue='cat')\n\nd = {\n    'x2': [2,0,6,0,4,1],\n    'y2': [-3,-2,0,2,3,4],\n    'cat': ['c','c','c','c','d','d']\n}\ndf2 = pd.DataFrame(d)\n\n# Extract new colors from currently selected color palette\ncolors = sns.color_palette()[g.hue.nunique():][:df2['cat'].nunique()]\n\n# Plot additional points from second dataframe in scatter plot of the joint plot\nsns.scatterplot(data=df2, x='x2', y='y2', hue='cat', palette=colors, ax=g.ax_joint);",
            "masked_code": "import pandas as pd    # v 1.1.3\nimport seaborn as sns  # v 0.11.0\n\nd = {\n    'x1': [3,2,5,1,1,0],\n    'y1': [1,1,2,3,0,2],\n    'cat': ['a','a','a','b','b','b']\n}\n\ndf = pd.DataFrame(d)\n\n# Set seaborn color palette\nsns.set_palette('bright')\ng = sns.jointplot(data=df, x='x1', y='y1', hue='cat')\n\nd = {\n    'x2': [2,0,6,0,4,1],\n    'y2': [-3,-2,0,2,3,4],\n    'cat': ['c','c','c','c','d','d']\n}\ndf2 = pd.DataFrame(d)\n\n# Extract new colors from currently selected color palette\n<line_mask>\n\n# Plot additional points from second dataframe in scatter plot of the joint plot\nsns.scatterplot(data=df2, x='x2', y='y2', hue='cat', palette=colors, ax=g.ax_joint);",
            "masked_line": "colors = sns.color_palette()[g.hue.nunique():][:df2['cat'].nunique()]",
            "answer": "nunique",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_184"
        },
        {
            "dependency": "seaborn",
            "version": "==0.11.0",
            "time": "2021-02-27",
            "description": "The code creates two dataframes with x, y, and category columns, then plots a joint plot with the first dataframe points colored by category and additional points from the second dataframe plotted with different colors based on the category.",
            "code": "import pandas as pd    # v 1.1.3\nimport seaborn as sns  # v 0.11.0\n\nd = {\n    'x1': [3,2,5,1,1,0],\n    'y1': [1,1,2,3,0,2],\n    'cat': ['a','a','a','b','b','b']\n}\n\ndf = pd.DataFrame(d)\n\n# Set seaborn color palette\nsns.set_palette('bright')\ng = sns.jointplot(data=df, x='x1', y='y1', hue='cat')\n\nd = {\n    'x2': [2,0,6,0,4,1],\n    'y2': [-3,-2,0,2,3,4],\n    'cat': ['c','c','c','c','d','d']\n}\ndf2 = pd.DataFrame(d)\n\n# Extract new colors from currently selected color palette\ncolors = sns.color_palette()[g.hue.nunique():][:df2['cat'].nunique()]\n\n# Plot additional points from second dataframe in scatter plot of the joint plot\nsns.scatterplot(data=df2, x='x2', y='y2', hue='cat', palette=colors, ax=g.ax_joint);",
            "masked_code": "import pandas as pd    # v 1.1.3\nimport seaborn as sns  # v 0.11.0\n\nd = {\n    'x1': [3,2,5,1,1,0],\n    'y1': [1,1,2,3,0,2],\n    'cat': ['a','a','a','b','b','b']\n}\n\ndf = pd.DataFrame(d)\n\n# Set seaborn color palette\nsns.set_palette('bright')\ng = sns.jointplot(data=df, x='x1', y='y1', hue='cat')\n\nd = {\n    'x2': [2,0,6,0,4,1],\n    'y2': [-3,-2,0,2,3,4],\n    'cat': ['c','c','c','c','d','d']\n}\ndf2 = pd.DataFrame(d)\n\n# Extract new colors from currently selected color palette\ncolors = sns.color_palette()[g.hue.nunique():][:df2['cat'].nunique()]\n\n# Plot additional points from second dataframe in scatter plot of the joint plot\n<line_mask>",
            "masked_line": "sns.scatterplot(data=df2, x='x2', y='y2', hue='cat', palette=colors, ax=g.ax_joint);",
            "answer": "scatterplot",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_185"
        },
        {
            "dependency": "numpy",
            "version": "==1.19.2",
            "time": "2021-02-26",
            "description": "This code generates a sample dataset with columns 'Type', 'Label', and 'Date'. The 'Type' column contains random choices of 'A', 'B', 'C', or 'D'. The 'Label' column contains random choices of 0 or 1. The 'Date' column contains random dates between '2020-01-01' and '2020-01-31'.",
            "code": "import numpy as np   # v 1.19.2\nimport pandas as pd  # v 1.1.3\n\n# Create sample dataset\nrng = np.random.default_rng(seed=1)  # random number generator\ndti = pd.date_range('2020-01-01', '2020-01-31', freq='D')\nsize = 2*dti.size\ndfraw = pd.DataFrame(data=dict(Type = rng.choice(list('ABCD'), size=size),\n                               Label = rng.choice([0,1], size=size),\n                               Date = rng.choice(dti, size=size)))\ndfraw.head()",
            "masked_code": "import numpy as np   # v 1.19.2\nimport pandas as pd  # v 1.1.3\n\n# Create sample dataset\nrng = np.random.default_rng(seed=1)  # random number generator\ndti = pd.date_range('2020-01-01', '2020-01-31', freq='D')\nsize = 2*dti.size\n<line_mask>\n                               Label = rng.choice([0,1], size=size),\n                               Date = rng.choice(dti, size=size)))\ndfraw.head()",
            "masked_line": "dfraw = pd.DataFrame(data=dict(Type = rng.choice(list('ABCD'), size=size),",
            "answer": "choice",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_186"
        },
        {
            "dependency": "pandas",
            "version": "==1.1.3",
            "time": "2021-02-26",
            "description": "This code snippet generates a sample dataset consisting of Type, Label, and Date columns using random choices. The Type column contains random choices from the letters 'A', 'B', 'C', 'D', the Label column contains random choices of 0 or 1, and the Date column contains random dates from January 1, 2020, to January 31, 2020.",
            "code": "import numpy as np   # v 1.19.2\nimport pandas as pd  # v 1.1.3\n\n# Create sample dataset\nrng = np.random.default_rng(seed=1)  # random number generator\ndti = pd.date_range('2020-01-01', '2020-01-31', freq='D')\nsize = 2*dti.size\ndfraw = pd.DataFrame(data=dict(Type = rng.choice(list('ABCD'), size=size),\n                               Label = rng.choice([0,1], size=size),\n                               Date = rng.choice(dti, size=size)))\ndfraw.head()",
            "masked_code": "import numpy as np   # v 1.19.2\nimport pandas as pd  # v 1.1.3\n\n# Create sample dataset\nrng = np.random.default_rng(seed=1)  # random number generator\n<line_mask>\nsize = 2*dti.size\ndfraw = pd.DataFrame(data=dict(Type = rng.choice(list('ABCD'), size=size),\n                               Label = rng.choice([0,1], size=size),\n                               Date = rng.choice(dti, size=size)))\ndfraw.head()",
            "masked_line": "dti = pd.date_range('2020-01-01', '2020-01-31', freq='D')",
            "answer": "date_range",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_187"
        },
        {
            "dependency": "bokeh",
            "version": "==2.1.1",
            "time": "2021-08-06",
            "description": "This code creates a DataTable with two columns and an empty data source, then adds the DataTable to the document root but sets it to not be visible.",
            "code": "from bokeh.io import curdoc\nfrom bokeh.models import ColumnDataSource, DataTable, TableColumn\n\ncolumns=[TableColumn(field=str(i),title=str(i),width=200,name=str(i)) for i in range(2)]\nsource = ColumnDataSource(data={}, name='mySource')\ntable=DataTable(source=source,columns=columns,name='myTable',visible=False)\ncurdoc().add_root(table)",
            "masked_code": "from bokeh.io import curdoc\n<line_mask>\n\ncolumns=[TableColumn(field=str(i),title=str(i),width=200,name=str(i)) for i in range(2)]\nsource = ColumnDataSource(data={}, name='mySource')\ntable=DataTable(source=source,columns=columns,name='myTable',visible=False)\ncurdoc().add_root(table)",
            "masked_line": "from bokeh.models import ColumnDataSource, DataTable, TableColumn",
            "answer": "TableColumn",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_188"
        },
        {
            "dependency": "lark",
            "version": "==0.11.3",
            "time": "2021-06-20",
            "description": "This code defines a parser that can recognize and accept specific values assigned to a variable in a text input.",
            "code": "from lark import Lark\n\nparser = Lark(r\"\"\"\n?start: NAME \"=\" possible_values\npossible_values: \"apple\" | \"banana\" | \"orange\"\nNAME: /\\w+/\n%ignore /\\s+/\n\"\"\", parser=\"lalr\")\n\ninteractive = parser.parse_interactive(\"my_variable = \")\n\n# feeds the text given to above into the parsers. This is not done automatically.\ninteractive.exhaust_lexer()\n\n\n# returns the names of the Terminals that are currently accepted.\nprint(interactive.accepts())",
            "masked_code": "from lark import Lark\n\nparser = Lark(r\"\"\"\n?start: NAME \"=\" possible_values\npossible_values: \"apple\" | \"banana\" | \"orange\"\nNAME: /\\w+/\n%ignore /\\s+/\n\"\"\", parser=\"lalr\")\n\ninteractive = parser.parse_interactive(\"my_variable = \")\n\n# feeds the text given to above into the parsers. This is not done automatically.\ninteractive.exhaust_lexer()\n\n\n# returns the names of the Terminals that are currently accepted.\n<line_mask>",
            "masked_line": "print(interactive.accepts())",
            "answer": "accepts",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_189"
        },
        {
            "dependency": "bokeh",
            "version": "==2.1.1",
            "time": "2021-06-16",
            "description": "The code creates a Bokeh layout with a button and a radio button group. When the button is clicked, it triggers a JavaScript code that displays an alert message if the radio button group is set to 'Alert ON'. The layout is then shown on the Bokeh server.",
            "code": "from bokeh.io import curdoc, show\nfrom bokeh.models.widgets import Button, RadioButtonGroup\nfrom bokeh.layouts import column\nfrom bokeh.models.callbacks import CustomJS\n\nbutton_classify = Button(label=\"Create Pop-up alert\")\nbutton_group = RadioButtonGroup(labels=['Alert ON', 'Alert OFF'], active=0)\n\ncode = 'if (button_group.active == 0) { alert(\"ALERT !\"); }'\nbutton_classify.js_on_click(CustomJS(args={'button_group': button_group}, code=code))\nlayout = column(button_group, button_classify)\n\nshow(layout)\n\n# curdoc().add_root(layout)\n# curdoc().title = \"Pop-up Alert\"",
            "masked_code": "from bokeh.io import curdoc, show\nfrom bokeh.models.widgets import Button, RadioButtonGroup\nfrom bokeh.layouts import column\nfrom bokeh.models.callbacks import CustomJS\n\nbutton_classify = Button(label=\"Create Pop-up alert\")\nbutton_group = RadioButtonGroup(labels=['Alert ON', 'Alert OFF'], active=0)\n\ncode = 'if (button_group.active == 0) { alert(\"ALERT !\"); }'\n<line_mask>\nlayout = column(button_group, button_classify)\n\nshow(layout)\n\n# curdoc().add_root(layout)\n# curdoc().title = \"Pop-up Alert\"",
            "masked_line": "button_classify.js_on_click(CustomJS(args={'button_group': button_group}, code=code))",
            "answer": "js_on_click",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_190"
        },
        {
            "dependency": "boto3",
            "version": "==1.0.0",
            "time": "2021-05-27",
            "description": "The code enables versioning on all buckets in an AWS S3 account using boto3 library in Python.",
            "code": "import json\nimport boto3\n\n\ndef lambda_handler(event, context):\n    s3 = boto3.client('s3')\n    response = s3.list_buckets()\n\n    for bucket in response['Buckets']:\n        s3.put_bucket_versioning(Bucket=bucket[\"Name\"],\n                             VersioningConfiguration={\n                                 'MFADelete': 'Disabled',\n                                 'Status': 'Enabled',\n                             },\n        )\n    \n    print(\"Enabled versioning on bucket : \", bucket[\"Name\"])\n    \n    return {\n        'statusCode': 200,\n        'body': json.dumps('Hello from Lambda!')\n    }",
            "masked_code": "import json\nimport boto3\n\n\ndef lambda_handler(event, context):\n    s3 = boto3.client('s3')\n    response = s3.list_buckets()\n\n    for bucket in response['Buckets']:\n        <line_mask>\n                             VersioningConfiguration={\n                                 'MFADelete': 'Disabled',\n                                 'Status': 'Enabled',\n                             },\n        )\n    \n    print(\"Enabled versioning on bucket : \", bucket[\"Name\"])\n    \n    return {\n        'statusCode': 200,\n        'body': json.dumps('Hello from Lambda!')\n    }",
            "masked_line": "s3.put_bucket_versioning(Bucket=bucket[\"Name\"],",
            "answer": "put_bucket_versioning",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_191"
        },
        {
            "dependency": "pandas",
            "version": "==1.1.3",
            "time": "2021-02-26",
            "description": "This code creates a line plot using the seaborn library, where the x-axis represents the values in column 'a4' of a Pandas DataFrame, the y-axis represents the values in column 'a3', each subplot column represents the unique values in column 'a1', the line colors are based on the values in column 'a2', and the height of each subplot is 4 units.",
            "code": "import pandas as pd    # v 1.1.3\nimport seaborn as sns  # v 0.11.0\n\nd = {'a1': ['l1','l1','l1','l1','l1','l1','l2','l2','l2','l2','l2','l2'],\n     'a2': ['a', 'a', 'b','b','c','c','d','d','e','e','f','f'],\n     'a3': [15,20,17,19,23,15,22,21,23,23,24,27],\n     'a4': [1,2,1,2,1,2,1,2,1,2,1,2]}\ndf = pd.DataFrame(d)\n\nsns.relplot(data=df, x='a4', y='a3', col='a1', hue ='a2', kind='line', height=4)",
            "masked_code": "import pandas as pd    # v 1.1.3\nimport seaborn as sns  # v 0.11.0\n\nd = {'a1': ['l1','l1','l1','l1','l1','l1','l2','l2','l2','l2','l2','l2'],\n     'a2': ['a', 'a', 'b','b','c','c','d','d','e','e','f','f'],\n     'a3': [15,20,17,19,23,15,22,21,23,23,24,27],\n     'a4': [1,2,1,2,1,2,1,2,1,2,1,2]}\n<line_mask>\n\nsns.relplot(data=df, x='a4', y='a3', col='a1', hue ='a2', kind='line', height=4)",
            "masked_line": "df = pd.DataFrame(d)",
            "answer": "DataFrame",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_192"
        },
        {
            "dependency": "seaborn",
            "version": "==0.11.0",
            "time": "2021-02-26",
            "description": "The code creates a line plot using seaborn's relplot function, displaying the relationship between the values in column 'a4' on the x-axis and the values in column 'a3' on the y-axis. The plot is separated into multiple columns based on the unique values in column 'a1', with different colors distinguishing the values in column 'a2'.",
            "code": "import pandas as pd    # v 1.1.3\nimport seaborn as sns  # v 0.11.0\n\nd = {'a1': ['l1','l1','l1','l1','l1','l1','l2','l2','l2','l2','l2','l2'],\n     'a2': ['a', 'a', 'b','b','c','c','d','d','e','e','f','f'],\n     'a3': [15,20,17,19,23,15,22,21,23,23,24,27],\n     'a4': [1,2,1,2,1,2,1,2,1,2,1,2]}\ndf = pd.DataFrame(d)\n\nsns.relplot(data=df, x='a4', y='a3', col='a1', hue ='a2', kind='line', height=4)",
            "masked_code": "import pandas as pd    # v 1.1.3\nimport seaborn as sns  # v 0.11.0\n\nd = {'a1': ['l1','l1','l1','l1','l1','l1','l2','l2','l2','l2','l2','l2'],\n     'a2': ['a', 'a', 'b','b','c','c','d','d','e','e','f','f'],\n     'a3': [15,20,17,19,23,15,22,21,23,23,24,27],\n     'a4': [1,2,1,2,1,2,1,2,1,2,1,2]}\ndf = pd.DataFrame(d)\n\n<line_mask>",
            "masked_line": "sns.relplot(data=df, x='a4', y='a3', col='a1', hue ='a2', kind='line', height=4)",
            "answer": "relplot",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_193"
        },
        {
            "dependency": "seaborn",
            "version": "==0.11.1",
            "time": "2021-01-25",
            "description": "The code generates a plot showing the distribution of 'TOTL_SQ_FT_CNT' values for two different deciles (10 and 1) in the dataset 'check3' with choice value equal to 1. The plot uses seaborn library to display the distribution of 'TOTL_SQ_FT_CNT' values for decile 10 and decile 1 on the same graph.",
            "code": "d10_ft = check3[(check3['choice'] == 1)&(check3['decile'] == 10)]['TOTL_SQ_FT_CNT']\nd1_ft = check3[(check3['choice'] == 1)&(check3['decile'] == 1)]['TOTL_SQ_FT_CNT']\n\nf, ax = plt.subplots(1, 1)\nsns.distplot(d10_ft, label = 'decile 10',ax=ax)\nsns.distplot(d1_ft, label = 'decile 1',ax=ax)\nax.legend()",
            "masked_code": "d10_ft = check3[(check3['choice'] == 1)&(check3['decile'] == 10)]['TOTL_SQ_FT_CNT']\nd1_ft = check3[(check3['choice'] == 1)&(check3['decile'] == 1)]['TOTL_SQ_FT_CNT']\n\nf, ax = plt.subplots(1, 1)\n<line_mask>\nsns.distplot(d1_ft, label = 'decile 1',ax=ax)\nax.legend()",
            "masked_line": "sns.distplot(d10_ft, label = 'decile 10',ax=ax)",
            "answer": "distplot",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_194"
        },
        {
            "dependency": "SimpleITK",
            "version": "==1.2.4",
            "time": "2022-09-09",
            "description": "This code reads an image file using SimpleITK, sets the title of the image viewer to 'Cell Image', specifies the application to be used for viewing the image (e.g. ImageJ or ITK-SNAP), sets the file extension to \".tiff\", and displays the image using the image viewer.",
            "code": "import SimpleITK as sitk\n\nImage = sitk.ReadImage(inputImageFileName)\nimage_viewer = sitk.ImageViewer()\nimage_viewer.SetTitle('Cell Image') #title image (optional )\nimage_viewer.SetApplication(r'path\\ij153-win-java8\\ImageJ\\ImageJ.exe') #Application to be used e.g. ImageJ or ITK-SNAP\nimage_viewer.SetFileExtension(\".tiff\") #any formats you use\nimage_viewer.Execute(Image)",
            "masked_code": "import SimpleITK as sitk\n\nImage = sitk.ReadImage(inputImageFileName)\nimage_viewer = sitk.ImageViewer()\nimage_viewer.SetTitle('Cell Image') #title image (optional )\nimage_viewer.SetApplication(r'path\\ij153-win-java8\\ImageJ\\ImageJ.exe') #Application to be used e.g. ImageJ or ITK-SNAP\n<line_mask>\nimage_viewer.Execute(Image)",
            "masked_line": "image_viewer.SetFileExtension(\".tiff\") #any formats you use",
            "answer": "SetFileExtension",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_195"
        },
        {
            "dependency": "discord-py-slash-command",
            "version": "==1.1.2",
            "time": "2021-11-25",
            "description": "This code defines a Discord bot using the discord and discord_slash libraries, declares a slash command named \"ping\", and sends a message \"Pong!\" in response to the slash command being invoked.",
            "code": "import discord\nfrom discord_slash import SlashCommand\nclient = discord.Client(intents=discord.Intents.all())\nslash = SlashCommand(client, sync_commands=True) # Declares slash commands through the client.\n\nguild_ids = [1234567890] # Put your server IDs in this array.\n\n@slash.slash(name=\"ping\", guild_ids=guild_ids)\nasync def _ping(ctx):\n    await ctx.send(\"Pong!\")\n\nclient.run(\"token\")",
            "masked_code": "import discord\nfrom discord_slash import SlashCommand\nclient = discord.Client(intents=discord.Intents.all())\nslash = SlashCommand(client, sync_commands=True) # Declares slash commands through the client.\n\nguild_ids = [1234567890] # Put your server IDs in this array.\n\n<line_mask>\nasync def _ping(ctx):\n    await ctx.send(\"Pong!\")\n\nclient.run(\"token\")",
            "masked_line": "@slash.slash(name=\"ping\", guild_ids=guild_ids)",
            "answer": "slash",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_196"
        },
        {
            "dependency": "stellargraph",
            "version": "==1.2.1",
            "time": "2022-04-29",
            "description": "The code creates an original graph with nodes 'a', 'b', 'c', and 'd', and edges connecting these nodes. It then adds new edges between nodes '3'-'1' and '3'-'2' to create a new graph with updated edge connections.",
            "code": "import pandas as pd\nfrom stellargraph import IndexedArray, StellarGraph\n\n#### original data / graph\n\nnodes = IndexedArray(index=['a', 'b', 'c', 'd'])\noriginal_edges = pd.DataFrame(\n    {\n        'source' : [0, 1, 2, 3, 0],\n        'target' : [1, 2, 3, 0, 2]\n    }\n)\noriginal_graph = StellarGraph(\n    nodes, \n    original_edges\n)\n\n#### new data\n\nnew_edges = pd.DataFrame(\n    {\n        'source' : [3, 3],\n        'target' : [1, 2]\n    }\n)\n\n#### new graph\n\nnew_graph = StellarGraph(\n    nodes, \n    pd.concat(\n        [\n            original_edges,\n            new_edges\n        ],\n        ignore_index=True\n    )\n)",
            "masked_code": "import pandas as pd\nfrom stellargraph import IndexedArray, StellarGraph\n\n#### original data / graph\n\nnodes = IndexedArray(index=['a', 'b', 'c', 'd'])\noriginal_edges = pd.DataFrame(\n    {\n        'source' : [0, 1, 2, 3, 0],\n        'target' : [1, 2, 3, 0, 2]\n    }\n)\n<line_mask>\n    nodes, \n    original_edges\n)\n\n#### new data\n\nnew_edges = pd.DataFrame(\n    {\n        'source' : [3, 3],\n        'target' : [1, 2]\n    }\n)\n\n#### new graph\n\nnew_graph = StellarGraph(\n    nodes, \n    pd.concat(\n        [\n            original_edges,\n            new_edges\n        ],\n        ignore_index=True\n    )\n)",
            "masked_line": "original_graph = StellarGraph(",
            "answer": "StellarGraph",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_197"
        },
        {
            "dependency": "SQLAlchemy",
            "version": "==2.0",
            "time": "2023-06-01",
            "description": "This Python code defines a model class called Email that represents an email entity in a database. The class has attributes such as name, sender, subject, html, and template_id. Each attribute is mapped to a specific column in the database table named 'emails'. The template_id attribute is mapped to a UUID column with a foreign key constraint referencing the 'id' column in a table named 'templates'. The class enforces non-null constraints on certain attributes such as name, sender, subject, html while providing default values for others.",
            "code": "import uuid\nfrom sqlalchemy.orm import Mapped, mapped_column\nfrom sqlalchemy.dialects.postgresql import UUID\n\nclass Email(Model):\n    __tablename__ = 'emails'\n\n    name: Mapped[str] = mapped_column(String, nullable=False)\n    sender: Mapped[str] = mapped_column(\n        String, default=default_sender, nullable=False\n    )\n    subject: Mapped[str] = mapped_column(String, nullable=False)\n    html: Mapped[str] = mapped_column(String, nullable=False)\n    template_id: Mapped[uuid.UUID] = mapped_column(\n        UUID(as_uuid=True),\n        ForeignKey('templates.id'),\n        index=True,\n    )",
            "masked_code": "import uuid\nfrom sqlalchemy.orm import Mapped, mapped_column\nfrom sqlalchemy.dialects.postgresql import UUID\n\nclass Email(Model):\n    __tablename__ = 'emails'\n\n    name: Mapped[str] = mapped_column(String, nullable=False)\n    sender: Mapped[str] = mapped_column(\n        String, default=default_sender, nullable=False\n    )\n    subject: Mapped[str] = mapped_column(String, nullable=False)\n    html: Mapped[str] = mapped_column(String, nullable=False)\n    <line_mask>\n        UUID(as_uuid=True),\n        ForeignKey('templates.id'),\n        index=True,\n    )",
            "masked_line": "template_id: Mapped[uuid.UUID] = mapped_column(",
            "answer": "mapped_column",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_198"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.7.0",
            "time": "2022-01-12",
            "description": "The code converts a TensorFlow model stored in a SavedModel directory into a TensorFlow Lite model and saves it as a file named 'model.tflite'.",
            "code": "import tensorflow as tf\n\n# Convert the model\nconverter = tf.lite.TFLiteConverter.from_saved_model(saved_model_dir) # path to the SavedModel directory\ntflite_model = converter.convert()\n\n# Save the model.\nwith open('model.tflite', 'wb') as f:\n  f.write(tflite_model)",
            "masked_code": "import tensorflow as tf\n\n# Convert the model\n<line_mask>\ntflite_model = converter.convert()\n\n# Save the model.\nwith open('model.tflite', 'wb') as f:\n  f.write(tflite_model)",
            "masked_line": "converter = tf.lite.TFLiteConverter.from_saved_model(saved_model_dir) # path to the SavedModel directory",
            "answer": "lite",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_199"
        },
        {
            "dependency": "amazon-textract-textractor",
            "version": "==1.0.16",
            "time": "2022-10-26",
            "description": "The code extracts text data from a PDF document using Amazon Textract. It analyzes the document by answering specified queries (\"What is X?\", \"What is Y?\", etc.) and uploads the results to an S3 bucket.",
            "code": "from textractor import Textractor\nfrom textractor.data.constants import TextractFeatures\n\nextractor = Textractor(profile_name=\"default\")\ndocument = extractor.start_document_analysis(\n    file_source=(\"Application Form trimmed.pdf\"),\n    features=[TextractFeatures.QUERIES],\n    queries=[\n        \"What is X?\",\n        \"What is Y?\",\n        # Up to 15 questions here\n    ],\n    s3_upload_path=\"s3://textractbucket2/\"\n)\n\nprint(document.queries)",
            "masked_code": "from textractor import Textractor\nfrom textractor.data.constants import TextractFeatures\n\n<line_mask>\ndocument = extractor.start_document_analysis(\n    file_source=(\"Application Form trimmed.pdf\"),\n    features=[TextractFeatures.QUERIES],\n    queries=[\n        \"What is X?\",\n        \"What is Y?\",\n        # Up to 15 questions here\n    ],\n    s3_upload_path=\"s3://textractbucket2/\"\n)\n\nprint(document.queries)",
            "masked_line": "extractor = Textractor(profile_name=\"default\")",
            "answer": "Textractor",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_200"
        },
        {
            "dependency": "plotly",
            "version": "==5.10.0",
            "time": "2022-08-26",
            "description": "This code generates a plot using Plotly library with dummy data. It creates a scatter plot of 'Measure' against 'Date' from a DataFrame with date range data. The x-axis includes range breaks to skip weekends and a range selector with a button for 1 month interval. The plot also includes a range slider for zooming in on the date range. The plot is displayed using the 'fig.show()' function.",
            "code": "import pandas as pd\nimport plotly.graph_objects as go\n\n# Dummy data\ns = pd.date_range(end=pd.Timestamp('2022-08-27'), periods=100, freq='D')\ndf = pd.DataFrame({'Date':s, 'Measure': s.day})\n\n# Plot\nfig = go.Figure()\n\nfig.add_trace(\n    # replace Scattergl with the Scatter object\n    go.Scatter(x=df.Date, y=df.Measure))\n\nfig.update_xaxes(\n    rangebreaks=[\n        dict(bounds=[\"sat\", \"mon\"]), # skip weekends\n    ],\n    rangeselector=dict(\n        buttons=list([\n            dict(count=1,\n                 label=\"1m\",\n                 step=\"month\",\n                 stepmode=\"backward\")\n        ])\n    ),\n    rangeslider=dict(\n        visible=True\n    ),\n    type=\"date\"\n)\n\nfig.show()",
            "masked_code": "import pandas as pd\nimport plotly.graph_objects as go\n\n# Dummy data\ns = pd.date_range(end=pd.Timestamp('2022-08-27'), periods=100, freq='D')\ndf = pd.DataFrame({'Date':s, 'Measure': s.day})\n\n# Plot\nfig = go.Figure()\n\nfig.add_trace(\n    # replace Scattergl with the Scatter object\n    <line_mask>\n\nfig.update_xaxes(\n    rangebreaks=[\n        dict(bounds=[\"sat\", \"mon\"]), # skip weekends\n    ],\n    rangeselector=dict(\n        buttons=list([\n            dict(count=1,\n                 label=\"1m\",\n                 step=\"month\",\n                 stepmode=\"backward\")\n        ])\n    ),\n    rangeslider=dict(\n        visible=True\n    ),\n    type=\"date\"\n)\n\nfig.show()",
            "masked_line": "go.Scatter(x=df.Date, y=df.Measure))",
            "answer": "Scatter",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_201"
        },
        {
            "dependency": "plotly",
            "version": "==4.14.0",
            "time": "2022-01-23",
            "description": "This code generates a 3D mesh plot using the data loaded from a text file and displays it using Plotly.",
            "code": "import plotly.graph_objects as go\nimport numpy as np\n\npts = np.loadtxt(np.DataSource().open('https://raw.githubusercontent.com/plotly/datasets/master/mesh_dataset.txt'))\nx, y, z = pts.T\n\nfig = go.Figure(data=[go.Mesh3d(x=x, y=y, z=z,\n                   alphahull=5,\n                   opacity=0.4,\n                   color='cyan')])\nfig.show()",
            "masked_code": "import plotly.graph_objects as go\nimport numpy as np\n\npts = np.loadtxt(np.DataSource().open('https://raw.githubusercontent.com/plotly/datasets/master/mesh_dataset.txt'))\nx, y, z = pts.T\n\nfig = go.Figure(data=[go.Mesh3d(x=x, y=y, z=z,\n                   alphahull=5,\n                   opacity=0.4,\n                   color='cyan')])\n<line_mask>",
            "masked_line": "fig.show()",
            "answer": "show",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_202"
        },
        {
            "dependency": "undetected-chromedriver",
            "version": "==3.1.3",
            "time": "2022-01-27",
            "description": "The code opens a Chrome browser using an undetected chromedriver, disables notifications, and navigates to a specified URL.",
            "code": "import undetected_chromedriver as webdriver\noptions = webdriver.ChromeOptions()\noptions.add_argument('--disable-notifications')\n\ndriver = webdriver.Chrome(browser_executable_path=your_chrome_driver_path, options=options) \n\ndriver.get('https://...')",
            "masked_code": "import undetected_chromedriver as webdriver\n<line_mask>\noptions.add_argument('--disable-notifications')\n\ndriver = webdriver.Chrome(browser_executable_path=your_chrome_driver_path, options=options) \n\ndriver.get('https://...')",
            "masked_line": "options = webdriver.ChromeOptions()",
            "answer": "ChromeOptions",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_203"
        },
        {
            "dependency": "pytest",
            "version": "==7.1.1",
            "time": "2022-04-22",
            "description": "The code defines two functions, func(x) which returns x + 1 and func_var(x) which raises a NotImplementedError. It also includes two test functions, test_answer() and test_answer_var(), which assert the output of func(3) should be 5 and func_var(3) should be 4 respectively. Both test functions are marked with pytest's xfail to indicate that they are expected to fail due to the functions not being fully implemented.",
            "code": "import pytest\n\ndef func(x):\n    return x + 1\n\ndef func_var(x):\n    raise NotImplementedError\n\n@pytest.mark.xfail(raises=NotImplementedError)\ndef test_answer():\n    assert func(3) == 5\n\n@pytest.mark.xfail(raises=NotImplementedError)\ndef test_answer_var():\n    assert func_var(3) == 4",
            "masked_code": "import pytest\n\ndef func(x):\n    return x + 1\n\ndef func_var(x):\n    raise NotImplementedError\n\n@pytest.mark.xfail(raises=NotImplementedError)\ndef test_answer():\n    assert func(3) == 5\n\n<line_mask>\ndef test_answer_var():\n    assert func_var(3) == 4",
            "masked_line": "@pytest.mark.xfail(raises=NotImplementedError)",
            "answer": "mark",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_204"
        },
        {
            "dependency": "xpress",
            "version": ">=9.0",
            "time": "2022-12-14",
            "description": "The code creates two variables x and y, adds them to a problem p, and adds a constraint that the product of x and y must equal 0. The code then optimizes the problem by maximizing the value of x.",
            "code": "import xpress as xp\n\nx = xp.var()\ny = xp.var()\n\np = xp.problem()\np.addVariable(x, y)\np.addConstraint(x * y == 0)\n\np.optimize('x')",
            "masked_code": "import xpress as xp\n\nx = xp.var()\ny = xp.var()\n\np = xp.problem()\np.addVariable(x, y)\n<line_mask>\n\np.optimize('x')",
            "masked_line": "p.addConstraint(x * y == 0)",
            "answer": "addConstraint",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_205"
        },
        {
            "dependency": "xlwings",
            "version": ">=0.24.3",
            "time": "2022-08-11",
            "description": "This code opens an Excel file, creates a new Excel worksheet, writes a DataFrame to a specific cell on the worksheet, saves the changes to the Excel file, and then closes the Excel file.",
            "code": "import xlwings as xw\n\npath = r\"test.xlsx\"\n\nwith xw.App(visible=False) as app:\n    wb = xw.Book(path)\n    ws = wb.sheets[1]\n    ws.range(\"A2\").options(index=False).value = df\n    wb.save(path)\n    wb.close()",
            "masked_code": "import xlwings as xw\n\npath = r\"test.xlsx\"\n\nwith xw.App(visible=False) as app:\n    <line_mask>\n    ws = wb.sheets[1]\n    ws.range(\"A2\").options(index=False).value = df\n    wb.save(path)\n    wb.close()",
            "masked_line": "wb = xw.Book(path)",
            "answer": "Book",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_206"
        },
        {
            "dependency": "wordcloud",
            "version": "==1.8.2.2",
            "time": "2022-12-22",
            "description": "The code generates a word cloud image from the frequencies of specific words and saves it as a JPG file.",
            "code": "from wordcloud import WordCloud\n\nwords={\n    ''     : 2,\n    ''     : 3,\n    '' : 4,\n    ''   : 4\n    }\n\n# The font is taken from\n# https://github.com/amueller/word_cloud/raw/master/examples/fonts/SourceHanSerif/SourceHanSerifK-Light.otf \nwc = WordCloud(\n    font_path='./SourceHanSerifK-Light.otf',\n    background_color=\"white\",\n    width=1000,\n    height=860\n    )\n\nwen = wc.generate_from_frequencies(words)\nwc.to_file('./wc.jpg')",
            "masked_code": "<line_mask>\n\nwords={\n    ''     : 2,\n    ''     : 3,\n    '' : 4,\n    ''   : 4\n    }\n\n# The font is taken from\n# https://github.com/amueller/word_cloud/raw/master/examples/fonts/SourceHanSerif/SourceHanSerifK-Light.otf \nwc = WordCloud(\n    font_path='./SourceHanSerifK-Light.otf',\n    background_color=\"white\",\n    width=1000,\n    height=860\n    )\n\nwen = wc.generate_from_frequencies(words)\nwc.to_file('./wc.jpg')",
            "masked_line": "from wordcloud import WordCloud",
            "answer": "WordCloud",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_207"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.8.0",
            "time": "2022-04-13",
            "description": "This code creates a 3D plot using matplotlib to visualize a mesh loaded from an STL file, specifically the 'HalfDonut.stl' file. The plot is then displayed on the screen with the mesh vectors added to it.",
            "code": "from stl import mesh\nfrom mpl_toolkits import mplot3d\nfrom matplotlib import pyplot\n\n# Create a new plot\nfigure = pyplot.figure()\naxes = figure.add_subplot(projection='3d')\n\n# Load the STL files and add the vectors to the plot \n# file is at https://github.com/wolph/numpy-stl/tree/develop/tests/stl_binary\nyour_mesh = mesh.Mesh.from_file('tests/stl_binary/HalfDonut.stl')\naxes.add_collection3d(mplot3d.art3d.Poly3DCollection(your_mesh.vectors))\n\n# Auto scale to the mesh size\nscale = your_mesh.points.flatten()\naxes.auto_scale_xyz(scale, scale, scale)\n\n# Show the plot to the screen\npyplot.show()",
            "masked_code": "from stl import mesh\nfrom mpl_toolkits import mplot3d\nfrom matplotlib import pyplot\n\n# Create a new plot\nfigure = pyplot.figure()\n<line_mask>\n\n# Load the STL files and add the vectors to the plot \n# file is at https://github.com/wolph/numpy-stl/tree/develop/tests/stl_binary\nyour_mesh = mesh.Mesh.from_file('tests/stl_binary/HalfDonut.stl')\naxes.add_collection3d(mplot3d.art3d.Poly3DCollection(your_mesh.vectors))\n\n# Auto scale to the mesh size\nscale = your_mesh.points.flatten()\naxes.auto_scale_xyz(scale, scale, scale)\n\n# Show the plot to the screen\npyplot.show()",
            "masked_line": "axes = figure.add_subplot(projection='3d')",
            "answer": "add_subplot",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_208"
        },
        {
            "dependency": "stl",
            "version": "==3.0.1",
            "time": "2022-04-13",
            "description": "The code loads an STL file, creates a 3D plot, adds the vectors from the STL file to the plot, auto-scales the plot to the mesh size, and then displays the 3D plot on the screen.",
            "code": "from stl import mesh\nfrom mpl_toolkits import mplot3d\nfrom matplotlib import pyplot\n\n# Create a new plot\nfigure = pyplot.figure()\naxes = figure.add_subplot(projection='3d')\n\n# Load the STL files and add the vectors to the plot \n# file is at https://github.com/wolph/numpy-stl/tree/develop/tests/stl_binary\nyour_mesh = mesh.Mesh.from_file('tests/stl_binary/HalfDonut.stl')\naxes.add_collection3d(mplot3d.art3d.Poly3DCollection(your_mesh.vectors))\n\n# Auto scale to the mesh size\nscale = your_mesh.points.flatten()\naxes.auto_scale_xyz(scale, scale, scale)\n\n# Show the plot to the screen\npyplot.show()",
            "masked_code": "from stl import mesh\nfrom mpl_toolkits import mplot3d\nfrom matplotlib import pyplot\n\n# Create a new plot\nfigure = pyplot.figure()\naxes = figure.add_subplot(projection='3d')\n\n# Load the STL files and add the vectors to the plot \n# file is at https://github.com/wolph/numpy-stl/tree/develop/tests/stl_binary\n<line_mask>\naxes.add_collection3d(mplot3d.art3d.Poly3DCollection(your_mesh.vectors))\n\n# Auto scale to the mesh size\nscale = your_mesh.points.flatten()\naxes.auto_scale_xyz(scale, scale, scale)\n\n# Show the plot to the screen\npyplot.show()",
            "masked_line": "your_mesh = mesh.Mesh.from_file('tests/stl_binary/HalfDonut.stl')",
            "answer": "Mesh",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_209"
        },
        {
            "dependency": "gensim",
            "version": "==3.6",
            "time": "2022-04-08",
            "description": "This code snippet uses the gensim library to train a Word2Vec model on common_texts data. It creates word vectors of dimension 100 and extracts the vector for the word \"computer\".",
            "code": "import gensim\ngensim.__version__\n# 3.6.0\n\nfrom gensim.test.utils import common_texts\nfrom gensim.models import Word2Vec\n\nmodel = Word2Vec(sentences=common_texts, window=5, min_count=1, workers=4) # do not specify size, leave the default 100\n\nwv = model.wv['computer']  # get numpy vector of a word in the corpus\nwv.shape # verify the dimension of a single vector is 100\n# (100,)",
            "masked_code": "import gensim\ngensim.__version__\n# 3.6.0\n\nfrom gensim.test.utils import common_texts\n<line_mask>\n\nmodel = Word2Vec(sentences=common_texts, window=5, min_count=1, workers=4) # do not specify size, leave the default 100\n\nwv = model.wv['computer']  # get numpy vector of a word in the corpus\nwv.shape # verify the dimension of a single vector is 100\n# (100,)",
            "masked_line": "from gensim.models import Word2Vec",
            "answer": "Word2Vec",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_210"
        },
        {
            "dependency": "pandas",
            "version": "==1.4.3",
            "time": "2022-08-25",
            "description": "This code generates a list of quarterly dates starting from the first date of the input period (specified as a quarter) to the last date of the input period. It then prints out the list of quarterly dates with the frequency set to December quarters.",
            "code": "import pandas as pd\nfrom pprint import pprint\n\nstart_date = '2021Q4'\nend_date = '2024Q1'\n\nfirst_date_of_period  = pd.Period(start_date, 'Q').to_timestamp('D', 'S') # D for day, S for start\nlast_date_of_period = pd.Period(end_date, 'Q').to_timestamp('D', 'E') # D for day, E for end\n\nprint(first_date_of_period)\n# >> 2021-10-01 00:00:00\nprint(last_date_of_period)\n# >> 2024-03-31 23:59:59.999999999\n\ndates=pd.date_range(start=first_date_of_period, end=last_date_of_period, freq='Q').to_list()\npprint(dates)\n# >> [Timestamp('2021-12-31 00:00:00', freq='Q-DEC'),\n# >>  Timestamp('2022-03-31 00:00:00', freq='Q-DEC'),\n# >>  Timestamp('2022-06-30 00:00:00', freq='Q-DEC'),\n# >>  Timestamp('2022-09-30 00:00:00', freq='Q-DEC'),\n# >>  Timestamp('2022-12-31 00:00:00', freq='Q-DEC'),\n# >>  Timestamp('2023-03-31 00:00:00', freq='Q-DEC'),\n# >>  Timestamp('2023-06-30 00:00:00', freq='Q-DEC'),\n# >>  Timestamp('2023-09-30 00:00:00', freq='Q-DEC'),\n# >>  Timestamp('2023-12-31 00:00:00', freq='Q-DEC'),\n# >>  Timestamp('2024-03-31 00:00:00', freq='Q-DEC')]",
            "masked_code": "import pandas as pd\nfrom pprint import pprint\n\nstart_date = '2021Q4'\nend_date = '2024Q1'\n\n<line_mask>\nlast_date_of_period = pd.Period(end_date, 'Q').to_timestamp('D', 'E') # D for day, E for end\n\nprint(first_date_of_period)\n# >> 2021-10-01 00:00:00\nprint(last_date_of_period)\n# >> 2024-03-31 23:59:59.999999999\n\ndates=pd.date_range(start=first_date_of_period, end=last_date_of_period, freq='Q').to_list()\npprint(dates)\n# >> [Timestamp('2021-12-31 00:00:00', freq='Q-DEC'),\n# >>  Timestamp('2022-03-31 00:00:00', freq='Q-DEC'),\n# >>  Timestamp('2022-06-30 00:00:00', freq='Q-DEC'),\n# >>  Timestamp('2022-09-30 00:00:00', freq='Q-DEC'),\n# >>  Timestamp('2022-12-31 00:00:00', freq='Q-DEC'),\n# >>  Timestamp('2023-03-31 00:00:00', freq='Q-DEC'),\n# >>  Timestamp('2023-06-30 00:00:00', freq='Q-DEC'),\n# >>  Timestamp('2023-09-30 00:00:00', freq='Q-DEC'),\n# >>  Timestamp('2023-12-31 00:00:00', freq='Q-DEC'),\n# >>  Timestamp('2024-03-31 00:00:00', freq='Q-DEC')]",
            "masked_line": "first_date_of_period  = pd.Period(start_date, 'Q').to_timestamp('D', 'S') # D for day, S for start",
            "answer": "to_timestamp",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_211"
        },
        {
            "dependency": "pandas",
            "version": "==1.5.2",
            "time": "2022-12-29",
            "description": "The code concatenates three dataframes (df1, df2, df3) into a single dataframe (df). The resulting dataframe contains columns for City, Country, Phone, and Street. The final dataframe (df) contains all the rows from the input dataframes (df1, df2, df3) combined.",
            "code": "import pandas as pd\ndf1 = pd.DataFrame({\"City\":[\"Berlin\",\"Paris\"],\"Country\":[\"DE\",\"FR\"],\"Phone\":[111,122]})\ndf2 = pd.DataFrame({\"City\":[\"Amstera\",\"Copenhag\"],\"Country\":[\"NL\",\"DK\"]})\ndf3 = pd.DataFrame({\"City\":[\"Vienna\",\"Madrid\"],\"Country\":[\"AT\",\"ES\"],\"Phone\":[222,343],\"Street\":[\"Leoplstr\",\"Avenia\"]})\ndf = pd.concat([df1,df2,df3])\nprint(df)",
            "masked_code": "import pandas as pd\ndf1 = pd.DataFrame({\"City\":[\"Berlin\",\"Paris\"],\"Country\":[\"DE\",\"FR\"],\"Phone\":[111,122]})\ndf2 = pd.DataFrame({\"City\":[\"Amstera\",\"Copenhag\"],\"Country\":[\"NL\",\"DK\"]})\n<line_mask>\ndf = pd.concat([df1,df2,df3])\nprint(df)",
            "masked_line": "df3 = pd.DataFrame({\"City\":[\"Vienna\",\"Madrid\"],\"Country\":[\"AT\",\"ES\"],\"Phone\":[222,343],\"Street\":[\"Leoplstr\",\"Avenia\"]})",
            "answer": "DataFrame",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_212"
        },
        {
            "dependency": "pandas",
            "version": "==1.5",
            "time": "2022-12-10",
            "description": "The code creates a multi-index DataFrame by grouping and categorizing the data based on the values in columns A, B, C, D, and E.",
            "code": "import pandas as pd\n\ndata = {\n  'A' : [0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0],\n  'B' : [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n  'C' : [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1],\n  'D' : [1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0],\n  'E' : [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n}\n\ndf = pd.DataFrame.from_dict(data)\n\ncategorical = pd.from_dummies(df)[\"\"].rename(\"category\")\ngroups = (categorical != categorical.shift()).cumsum().rename(\"group_num\")\n\nindex = pd.MultiIndex.from_arrays([\n    df.index,\n    pd.concat([categorical, groups], axis=1).groupby(\"category\")[\"group_num\"].transform(lambda x: (x != x.shift()).cumsum()),\n    groups.groupby(groups).cumcount().add(1).rename(\"group_id\"),\n    categorical\n])\n\nprint(df.set_index(index))",
            "masked_code": "import pandas as pd\n\ndata = {\n  'A' : [0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0],\n  'B' : [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n  'C' : [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1],\n  'D' : [1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0],\n  'E' : [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n}\n\ndf = pd.DataFrame.from_dict(data)\n\ncategorical = pd.from_dummies(df)[\"\"].rename(\"category\")\ngroups = (categorical != categorical.shift()).cumsum().rename(\"group_num\")\n\nindex = pd.MultiIndex.from_arrays([\n    df.index,\n    pd.concat([categorical, groups], axis=1).groupby(\"category\")[\"group_num\"].transform(lambda x: (x != x.shift()).cumsum()),\n    groups.groupby(groups).cumcount().add(1).rename(\"group_id\"),\n    categorical\n])\n\n<line_mask>",
            "masked_line": "print(df.set_index(index))",
            "answer": "set_index",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_213"
        },
        {
            "dependency": "pandas",
            "version": "==1.5.2",
            "time": "2022-11-30",
            "description": "This code creates a pandas DataFrame with product names and their corresponding values, including a column called 'MAX' to store the product with the highest value. It then assigns the product name with the highest value to the 'MAX' column for each row in the DataFrame.",
            "code": "# Panda 1.5.2\nimport pandas as pd\n\nd = {'prod': ['p1', 'p2', 'p3'], 'p1': [10, 20.0, 30], 'p2': [7 ,6 ,4], 'p3': [12,50,5], 'MAX': ['','','']}\ndf = pd.DataFrame(data=d)\nprint(type(df)) # \ndf['MAX'] = df.idxmax(1, numeric_only=True)\nprint(df)",
            "masked_code": "# Panda 1.5.2\nimport pandas as pd\n\nd = {'prod': ['p1', 'p2', 'p3'], 'p1': [10, 20.0, 30], 'p2': [7 ,6 ,4], 'p3': [12,50,5], 'MAX': ['','','']}\ndf = pd.DataFrame(data=d)\nprint(type(df)) # \n<line_mask>\nprint(df)",
            "masked_line": "df['MAX'] = df.idxmax(1, numeric_only=True)",
            "answer": "idxmax",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_214"
        },
        {
            "dependency": "selenium",
            "version": ">=4.6",
            "time": "2023-07-09",
            "description": "The Python code initializes a Firefox WebDriver with specific options for binary location and opens a Firefox browser for web automation tasks.",
            "code": "from selenium import webdriver\nfrom selenium.webdriver import FirefoxOptions\n\noptions = FirefoxOptions()\noptions.binary_location = '\\path\\to\\firefox'\ndriver = webdriver.Firefox(options = options)",
            "masked_code": "from selenium import webdriver\n<line_mask>\n\noptions = FirefoxOptions()\noptions.binary_location = '\\path\\to\\firefox'\ndriver = webdriver.Firefox(options = options)",
            "masked_line": "from selenium.webdriver import FirefoxOptions",
            "answer": "FirefoxOptions",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_215"
        },
        {
            "dependency": "transformers",
            "version": "==4.27.2",
            "time": "2023-04-08",
            "description": "The code initializes TrainingArguments object with a specified directory path and sets the device attribute to CPU.",
            "code": "import torch\nfrom transformers import TrainingArguments\n\nargs = TrainingArguments('./')\n\nargs.device  # [out]: device(type='cpu')\n\nargs.device = torch.device(type='cpu')",
            "masked_code": "import torch\n<line_mask>\n\nargs = TrainingArguments('./')\n\nargs.device  # [out]: device(type='cpu')\n\nargs.device = torch.device(type='cpu')",
            "masked_line": "from transformers import TrainingArguments",
            "answer": "TrainingArguments",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_216"
        },
        {
            "dependency": "pandas",
            "version": "==2.0.0",
            "time": "2023-07-19",
            "description": "This code extracts specific information from lines in a file related to a certain type, applies literal evaluation to the extracted type, and then normalizes the extracted dictionary data into a DataFrame.",
            "code": "import pandas as pd\nimport ast\n\nregex = r'^(?P.*) INFO    Type:type: (?P.*), (?P\\{.*\\})$'\n\nwith open(infile) as f:\n    lines = [line for line in f if \"type\" in line]\n\ndf = pd.Series(lines).str.extract(regex)\ndf['type'] = df['type'].apply(ast.literal_eval).str[0]\n# Uses pop!\ndf = df.join(df.pop('dict').apply(ast.literal_eval).pipe(pd.json_normalize))",
            "masked_code": "import pandas as pd\nimport ast\n\nregex = r'^(?P.*) INFO    Type:type: (?P.*), (?P\\{.*\\})$'\n\nwith open(infile) as f:\n    lines = [line for line in f if \"type\" in line]\n\ndf = pd.Series(lines).str.extract(regex)\ndf['type'] = df['type'].apply(ast.literal_eval).str[0]\n# Uses pop!\n<line_mask>",
            "masked_line": "df = df.join(df.pop('dict').apply(ast.literal_eval).pipe(pd.json_normalize))",
            "answer": "join",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_217"
        },
        {
            "dependency": "pandas",
            "version": "==1.5.2",
            "time": "2023-09-20",
            "description": "This code creates a Pandas DataFrame with two columns \"a\" and \"b\" containing consecutive numbers from 1 to 999999 and 2 to 1000000 respectively. It then saves this DataFrame to a CSV file named \"irrelevant.csv\" and appends the same DataFrame to a file named \"test.csv\" in append mode.",
            "code": "import pandas as pd\n\ndf = pd.DataFrame({\n    \"a\": range(1, 1000000),\n    \"b\": range(2, 1000001),\n})\nprint(df)\n# This causes the pandas CSV library to be loaded\ndf.to_csv(\"irrelevant.csv\")\n\ndump = \"test.csv\"\nprint(\"appending\")\ndf.to_csv(dump, mode=\"a+\")",
            "masked_code": "import pandas as pd\n\ndf = pd.DataFrame({\n    \"a\": range(1, 1000000),\n    \"b\": range(2, 1000001),\n})\nprint(df)\n# This causes the pandas CSV library to be loaded\n<line_mask>\n\ndump = \"test.csv\"\nprint(\"appending\")\ndf.to_csv(dump, mode=\"a+\")",
            "masked_line": "df.to_csv(\"irrelevant.csv\")",
            "answer": "to_csv",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_218"
        },
        {
            "dependency": "selenium",
            "version": "==4.12",
            "time": "2023-09-21",
            "description": "This code initializes a headless Firefox browser using Selenium, allowing for automated browsing tasks without displaying the browser interface.",
            "code": "from selenium import webdriver\nfrom selenium.webdriver.firefox.service import Service as FirefoxService\nfrom subprocess import CREATE_NO_WINDOW\noptions = webdriver.FirefoxOptions()\noptions.add_argument(\"--headless\")\n\nservice = FirefoxService(log_output=os.devnull)\nservice.creation_flags = CREATE_NO_WINDOW\ndriver = webdriver.Firefox(service=service, options=options)",
            "masked_code": "from selenium import webdriver\nfrom selenium.webdriver.firefox.service import Service as FirefoxService\nfrom subprocess import CREATE_NO_WINDOW\noptions = webdriver.FirefoxOptions()\noptions.add_argument(\"--headless\")\n\nservice = FirefoxService(log_output=os.devnull)\nservice.creation_flags = CREATE_NO_WINDOW\n<line_mask>",
            "masked_line": "driver = webdriver.Firefox(service=service, options=options)",
            "answer": "Firefox",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_219"
        },
        {
            "dependency": "graphene",
            "version": "==2.1.9",
            "time": "2023-11-30",
            "description": "This Python code defines a class `MutationWithAuth` that inherits from `Mutation`. It includes a class attribute `decorators` that holds a list of decorators, such as `login_required`.\n\nThe `Field` method within the class dynamically generates a `Field` object for the mutation. It applies the decorators listed in the `decorators` attribute to the resolver function of the mutation.\n\nOverall, this code aims to add authentication functionality to mutations in a GraphQL schema by applying decorators to the resolver function.",
            "code": "from graphene import Mutation, Field\n\n\nclass MutationWithAuth(Mutation):\n    class Meta:\n        abstract = True\n\n    # App-wide decorators for all mutations\n    decorators = [login_required]  # <-- list your desired decorators here\n\n    @classmethod\n    def Field(cls, name=None, description=None, deprecation_reason=None, required=False):\n        resolver = cls._meta.resolver\n        for decorator in cls.decorators:\n            resolver = decorator(cls._meta.resolver)  # <-- here we apply them\n\n        return Field(\n            cls._meta.output,\n            args=cls._meta.arguments,\n            resolver=resolver,\n            name=name,\n            description=description or cls._meta.description,\n            deprecation_reason=deprecation_reason,\n            required=required,\n        )",
            "masked_code": "<line_mask>\n\n\nclass MutationWithAuth(Mutation):\n    class Meta:\n        abstract = True\n\n    # App-wide decorators for all mutations\n    decorators = [login_required]  # <-- list your desired decorators here\n\n    @classmethod\n    def Field(cls, name=None, description=None, deprecation_reason=None, required=False):\n        resolver = cls._meta.resolver\n        for decorator in cls.decorators:\n            resolver = decorator(cls._meta.resolver)  # <-- here we apply them\n\n        return Field(\n            cls._meta.output,\n            args=cls._meta.arguments,\n            resolver=resolver,\n            name=name,\n            description=description or cls._meta.description,\n            deprecation_reason=deprecation_reason,\n            required=required,\n        )",
            "masked_line": "from graphene import Mutation, Field",
            "answer": "Field",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_220"
        },
        {
            "dependency": "deepl",
            "version": "==1.15.0",
            "time": "2023-11-06",
            "description": "The code reads an Excel file and then translates the text content in the file from one language to another language using the DeepL API. It prints the translated text along with the original text.",
            "code": "import pandas as pd\nimport deepl\n\ninput_file = 'excel_example.xlsx'\ndf = pd.read_excel(input_file, header=None)\ndf.applymap(lambda text: print(text))\n# prints the following:\n# :1: FutureWarning: DataFrame.applymap has been deprecated. Use DataFrame.map instead.\n# Table 1\n# This is an example sentence.\n# This is another example sentence.\n#      0\n# 0  None\n# 1  None\n# 2  None\nt = deepl.Translator('MY_API_KEY')\nres = df.applymap(lambda text: t.translate_text(str(text), target_lang=\"DE\"))\nprint(res)\n# prints the following\n#                                      0\n# 0                            Tabelle 1\n# 1           Dies ist ein Beispielsatz.\n# 2  Dies ist ein weiterer Beispielsatz.",
            "masked_code": "import pandas as pd\nimport deepl\n\ninput_file = 'excel_example.xlsx'\ndf = pd.read_excel(input_file, header=None)\ndf.applymap(lambda text: print(text))\n# prints the following:\n# :1: FutureWarning: DataFrame.applymap has been deprecated. Use DataFrame.map instead.\n# Table 1\n# This is an example sentence.\n# This is another example sentence.\n#      0\n# 0  None\n# 1  None\n# 2  None\nt = deepl.Translator('MY_API_KEY')\n<line_mask>\nprint(res)\n# prints the following\n#                                      0\n# 0                            Tabelle 1\n# 1           Dies ist ein Beispielsatz.\n# 2  Dies ist ein weiterer Beispielsatz.",
            "masked_line": "res = df.applymap(lambda text: t.translate_text(str(text), target_lang=\"DE\"))",
            "answer": "translate_text",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_221"
        },
        {
            "dependency": "pandas",
            "version": "==2.1.2",
            "time": "2023-11-06",
            "description": "This code reads data from an Excel file, prints the contents of the file, translates the text in the file to German language using the DeepL API, and then prints the translated text.",
            "code": "import pandas as pd\nimport deepl\n\ninput_file = 'excel_example.xlsx'\ndf = pd.read_excel(input_file, header=None)\ndf.applymap(lambda text: print(text))\n# prints the following:\n# :1: FutureWarning: DataFrame.applymap has been deprecated. Use DataFrame.map instead.\n# Table 1\n# This is an example sentence.\n# This is another example sentence.\n#      0\n# 0  None\n# 1  None\n# 2  None\nt = deepl.Translator('MY_API_KEY')\nres = df.applymap(lambda text: t.translate_text(str(text), target_lang=\"DE\"))\nprint(res)\n# prints the following\n#                                      0\n# 0                            Tabelle 1\n# 1           Dies ist ein Beispielsatz.\n# 2  Dies ist ein weiterer Beispielsatz.",
            "masked_code": "import pandas as pd\nimport deepl\n\ninput_file = 'excel_example.xlsx'\ndf = pd.read_excel(input_file, header=None)\ndf.applymap(lambda text: print(text))\n# prints the following:\n# :1: FutureWarning: DataFrame.applymap has been deprecated. Use DataFrame.map instead.\n# Table 1\n# This is an example sentence.\n# This is another example sentence.\n#      0\n# 0  None\n# 1  None\n# 2  None\nt = deepl.Translator('MY_API_KEY')\n<line_mask>\nprint(res)\n# prints the following\n#                                      0\n# 0                            Tabelle 1\n# 1           Dies ist ein Beispielsatz.\n# 2  Dies ist ein weiterer Beispielsatz.",
            "masked_line": "res = df.applymap(lambda text: t.translate_text(str(text), target_lang=\"DE\"))",
            "answer": "applymap",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_222"
        },
        {
            "dependency": "SQLAlchemy",
            "version": "==1.4.4",
            "time": "2023-11-03",
            "description": "The code reads data from a table named \"wikipedia\" using the SQLAlchemy library.",
            "code": "# pip install sqlalchemy==1.4.4\nfrom sqlalchemy import MetaData, Table\nfrom sqlalchemy.engine import create_engine\n\nengine = create_engine(\"druid://localhost:8888/druid/v2/sql\") # add ?header=True\nta = Table(\"wikipedia\", MetaData(bind=engine), autoload=True) # if needed\n\ndf = pd.read_sql(ta.select(), engine)",
            "masked_code": "# pip install sqlalchemy==1.4.4\nfrom sqlalchemy import MetaData, Table\nfrom sqlalchemy.engine import create_engine\n\nengine = create_engine(\"druid://localhost:8888/druid/v2/sql\") # add ?header=True\nta = Table(\"wikipedia\", MetaData(bind=engine), autoload=True) # if needed\n\n<line_mask>",
            "masked_line": "df = pd.read_sql(ta.select(), engine)",
            "answer": "select",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_223"
        },
        {
            "dependency": "selenium",
            "version": ">=4.6",
            "time": "2023-07-24",
            "description": "The code initializes a Chrome WebDriver with specific options for headless browsing and downloading files to the current working directory.",
            "code": "from selenium import webdriver\nfrom selenium.webdriver.chrome.options import Options\n\noptions = Options()\noptions.add_argument(\"download.default_directory={}\".format(os.getcwd()))\noptions.add_argument(\"--headless=new\")\noptions.binary_location = \".\\\\chrome-win32\\\\chrome.exe\"\ndriver = webdriver.Chrome(options=options)",
            "masked_code": "from selenium import webdriver\nfrom selenium.webdriver.chrome.options import Options\n\noptions = Options()\noptions.add_argument(\"download.default_directory={}\".format(os.getcwd()))\noptions.add_argument(\"--headless=new\")\noptions.binary_location = \".\\\\chrome-win32\\\\chrome.exe\"\n<line_mask>",
            "masked_line": "driver = webdriver.Chrome(options=options)",
            "answer": "Chrome",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_224"
        },
        {
            "dependency": "pandas",
            "version": "==2.0",
            "time": "2023-04-19",
            "description": "This code defines a function that returns an empty pandas DataFrame with columns specified by the input schema, with specified data types.",
            "code": "import pandas as pd\nimport numpy as np\nimport pyarrow as pa\n\ndef return_empty_dataframe(schema: dict[str, np.dtype]): \n    return pd.DataFrame(columns=schema.keys()).astype(schema)\n\nschema = {'time': 'time64[us][pyarrow]', 'power': 'float32[pyarrow]', 'profile': 'string[pyarrow]'}  \nempty_df = return_empty_dataframe(schema)",
            "masked_code": "import pandas as pd\nimport numpy as np\nimport pyarrow as pa\n\ndef return_empty_dataframe(schema: dict[str, np.dtype]): \n    <line_mask>\n\nschema = {'time': 'time64[us][pyarrow]', 'power': 'float32[pyarrow]', 'profile': 'string[pyarrow]'}  \nempty_df = return_empty_dataframe(schema)",
            "masked_line": "return pd.DataFrame(columns=schema.keys()).astype(schema)",
            "answer": "astype",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_225"
        },
        {
            "dependency": "smtplib",
            "version": ">=3.6",
            "time": "2023-03-11",
            "description": "This Python code sends an email using the SMTP protocol with a secure SSL context.",
            "code": "import smtplib, ssl\n\n# Create secure SSL context\ncont = ssl.create_default_context()\n\nserver = smtplib.SMTP(smtp_server, port = 587)\nserver.starttls(context = cont)\nserver.login(sender_email, password)\nserver.sendmail(sender_email, receiver_email, message)\nserver.quit()",
            "masked_code": "import smtplib, ssl\n\n# Create secure SSL context\ncont = ssl.create_default_context()\n\nserver = smtplib.SMTP(smtp_server, port = 587)\nserver.starttls(context = cont)\nserver.login(sender_email, password)\nserver.sendmail(sender_email, receiver_email, message)\n<line_mask>",
            "masked_line": "server.quit()",
            "answer": "quit",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_226"
        },
        {
            "dependency": "Flask",
            "version": "==2.3.2",
            "time": "2023-08-09",
            "description": "This code creates a Flask web application that defines a route for the root URL (\"/\"). When the user visits the root URL, the code renders the \"index.html\" template with the options variable containing a list of tuples representing different options.",
            "code": "from flask import Flask, render_template\n\napp = Flask(__name__)\n\n@app.route(\"/\")\ndef index_view():\n    options = [(1,\"uno\"),(2,\"dos\"),(3,\"tres\")]\n    return render_template(\"index.html\", options=options)\n\nif __name__ == \"__main__\":\n    app.run()",
            "masked_code": "from flask import Flask, render_template\n\napp = Flask(__name__)\n\n@app.route(\"/\")\ndef index_view():\n    options = [(1,\"uno\"),(2,\"dos\"),(3,\"tres\")]\n    return render_template(\"index.html\", options=options)\n\nif __name__ == \"__main__\":\n    <line_mask>",
            "masked_line": "app.run()",
            "answer": "run",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_227"
        },
        {
            "dependency": "xmlschema",
            "version": "==2.2.3",
            "time": "2023-04-28",
            "description": "The code parses an XML document using lxml library, then validates the XML document against an XML schema using xmlschema library. It iterates through any validation errors and prints out the error details including sourceline, path, reason, and message.",
            "code": "import lxml.etree as ET\n\nfrom xmlschema import XMLSchema\n\nxml_doc = ET.parse(\"sample1.xml\")\n\nschema = XMLSchema(\"sample1.xsd\")\n\nfor error in schema.iter_errors(xml_doc):\n    print(f'sourceline: {error.sourceline}; path: {error.path} | reason: {error.reason} | message: {error.message}')",
            "masked_code": "import lxml.etree as ET\n\nfrom xmlschema import XMLSchema\n\nxml_doc = ET.parse(\"sample1.xml\")\n\nschema = XMLSchema(\"sample1.xsd\")\n\n<line_mask>\n    print(f'sourceline: {error.sourceline}; path: {error.path} | reason: {error.reason} | message: {error.message}')",
            "masked_line": "for error in schema.iter_errors(xml_doc):",
            "answer": "iter_errors",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_228"
        },
        {
            "dependency": "scipy",
            "version": ">=1.11.1",
            "time": "2023-07-25",
            "description": "The code optimizes a linear programming problem using the linear programming solver from scipy.optimize. It uses the 'highs-ipm' solver with specified parameters to minimize the objective function subject to inequality and equality constraints, and calculates the number of iterations used in the crossover process, which should be 0.",
            "code": "from scipy.optimize import linprog\n\n# Define c, A_ub, b_ub, A_eq, b_eq, bounds\n...\n\n# Define options\nsolver = 'highs-ipm'\nparams = {'run_crossover': False}\n\n# Optimize\nsol = linprog(c, A_ub, b_ub, A_eq, b_eq, bounds, method=solver, options=params)\n\n# Check the number of iteration in crossover\nprint(sol.crossover_nit)  # it should be 0",
            "masked_code": "<line_mask>\n\n# Define c, A_ub, b_ub, A_eq, b_eq, bounds\n...\n\n# Define options\nsolver = 'highs-ipm'\nparams = {'run_crossover': False}\n\n# Optimize\nsol = linprog(c, A_ub, b_ub, A_eq, b_eq, bounds, method=solver, options=params)\n\n# Check the number of iteration in crossover\nprint(sol.crossover_nit)  # it should be 0",
            "masked_line": "from scipy.optimize import linprog",
            "answer": "linprog",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_229"
        },
        {
            "dependency": "pandas",
            "version": "==1.5.3",
            "time": "2023-02-13",
            "description": "The code overrides the default text parsing behavior in pandas.read_html for HTML parsing by defining a custom_text_getter function, which extracts the text content of HTML elements and returns it as a string.",
            "code": "import lxml.html\nimport pandas as pd\n\nhtml = \"\"\"\n \n \n X1 \n X2 \n\n \n   \nTest   \n Test2  \n\n\n\n\"\"\"\n\ndef custom_text_getter(self, obj):\n   result = obj.xpath(\"node()\")[0]\n   if isinstance(result, lxml.html.HtmlElement):\n      result = lxml.html.tostring(result, encoding=\"unicode\")\n   return result\n\npd.io.html._LxmlFrameParser._text_getter = custom_text_getter\n\nprint(\n    pd.read_html(html)[0]\n)",
            "masked_code": "import lxml.html\nimport pandas as pd\n\nhtml = \"\"\"\n \n \n X1 \n X2 \n\n \n   \nTest   \n Test2  \n\n\n\n\"\"\"\n\ndef custom_text_getter(self, obj):\n   result = obj.xpath(\"node()\")[0]\n   if isinstance(result, lxml.html.HtmlElement):\n      result = lxml.html.tostring(result, encoding=\"unicode\")\n   return result\n\npd.io.html._LxmlFrameParser._text_getter = custom_text_getter\n\nprint(\n    <line_mask>\n)",
            "masked_line": "pd.read_html(html)[0]",
            "answer": "read_html",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_230"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.x",
            "time": "2022-04-01",
            "description": "The code creates a TensorFlow StaticHashTable with keys and values tensors, then creates a dataset from given data. It maps each item in the dataset to a tuple containing the lookup result based on 'investment_id' key, 'features' value, and 'target' value. Finally, it prints each item in the dataset.",
            "code": "import tensorflow as tf\n\ndata = {\n    \"investment_id\": [1, 2, 3, 4, 5], \n    \"features\": [12, 912, 28, 90, 17],\n    \"target\": [1, 0, 1, 1, 1]\n}\n\nkeys_tensor = tf.constant([1, 2, 3])\nvals_tensor = tf.constant([1, 2, 3])\ntable = tf.lookup.StaticHashTable(\n    tf.lookup.KeyValueTensorInitializer(keys_tensor, vals_tensor),\n    default_value=0)\n\n\nds = tf.data.Dataset.from_tensor_slices(data)\nds = ds.map(lambda item: (table.lookup(item['investment_id']), item['features'], item['target']))\n\nfor d in ds:\n  print(d)",
            "masked_code": "import tensorflow as tf\n\ndata = {\n    \"investment_id\": [1, 2, 3, 4, 5], \n    \"features\": [12, 912, 28, 90, 17],\n    \"target\": [1, 0, 1, 1, 1]\n}\n\nkeys_tensor = tf.constant([1, 2, 3])\nvals_tensor = tf.constant([1, 2, 3])\n<line_mask>\n    tf.lookup.KeyValueTensorInitializer(keys_tensor, vals_tensor),\n    default_value=0)\n\n\nds = tf.data.Dataset.from_tensor_slices(data)\nds = ds.map(lambda item: (table.lookup(item['investment_id']), item['features'], item['target']))\n\nfor d in ds:\n  print(d)",
            "masked_line": "table = tf.lookup.StaticHashTable(",
            "answer": "StaticHashTable",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_231"
        },
        {
            "dependency": "django",
            "version": ">=2.1",
            "time": "2019-10-16",
            "description": "This code defines a Django model called Person with two fields: first_name and last_name. It also defines a method full_name that concatenates the first_name and last_name fields to return the full name of the person. Additionally, it sets the admin_order_field for the full_name method to concatenate the first_name and last_name fields in the database query for ordering purposes in the Django admin interface.",
            "code": "from django.db.models import Value\nfrom django.db.models.functions import Concat\n\nclass Person(models.Model):\n    first_name = models.CharField(max_length=50)\n    last_name = models.CharField(max_length=50)\n\n    def full_name(self):\n        return self.first_name + ' ' + self.last_name\n    full_name.admin_order_field = Concat('first_name', Value(' '), 'last_name')",
            "masked_code": "from django.db.models import Value\nfrom django.db.models.functions import Concat\n\nclass Person(models.Model):\n    first_name = models.CharField(max_length=50)\n    last_name = models.CharField(max_length=50)\n\n    def full_name(self):\n        return self.first_name + ' ' + self.last_name\n    <line_mask>",
            "masked_line": "full_name.admin_order_field = Concat('first_name', Value(' '), 'last_name')",
            "answer": "Value",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_232"
        },
        {
            "dependency": "elasticsearch",
            "version": "==6.6",
            "time": "2019-02-13",
            "description": "This code snippet creates a mapping in Elasticsearch for an index called \"2\" with a nested type called \"tablets\", which contains properties for \"Names\" with fields for \"ID\", \"Combination\", and \"Synonyms\". It also inserts two documents into the index with the specified fields.",
            "code": "import time\n\nfrom elasticsearch import Elasticsearch\nes = Elasticsearch()\n\n# fix typo - missing comma after \"nested\"\nmapping = '''{\n\"mappings\": {\n    \"tablets\": {\n      \"properties\": {\n        \"Names\": {\n          \"type\": \"nested\",\n          \"properties\":{\n              \"ID\": {\"type\" : \"long\"},\n              \"Combination\": {\"type\" : \"text\"},\n              \"Synonyms\": {\"type\" : \"text\"}\n          }\n        }\n      }\n    }\n  }\n}'''\n\n# remove ignore=\"400\"\nes.indices.create(index=\"2\", body=mapping)\n\ntablets = {\n    \"Names\": [\n        {\n            \"ID\": 1,\n            \"Combination\": \"Paracetamol\",\n            \"Synonyms\": \"Crocin\"\n        }, {\n            \"ID\": 2,\n            \"Combination\": \"Pantaprazole\",\n            \"Synonyms\": \"Pantap\"\n        }\n    ]\n}",
            "masked_code": "import time\n\nfrom elasticsearch import Elasticsearch\n<line_mask>\n\n# fix typo - missing comma after \"nested\"\nmapping = '''{\n\"mappings\": {\n    \"tablets\": {\n      \"properties\": {\n        \"Names\": {\n          \"type\": \"nested\",\n          \"properties\":{\n              \"ID\": {\"type\" : \"long\"},\n              \"Combination\": {\"type\" : \"text\"},\n              \"Synonyms\": {\"type\" : \"text\"}\n          }\n        }\n      }\n    }\n  }\n}'''\n\n# remove ignore=\"400\"\nes.indices.create(index=\"2\", body=mapping)\n\ntablets = {\n    \"Names\": [\n        {\n            \"ID\": 1,\n            \"Combination\": \"Paracetamol\",\n            \"Synonyms\": \"Crocin\"\n        }, {\n            \"ID\": 2,\n            \"Combination\": \"Pantaprazole\",\n            \"Synonyms\": \"Pantap\"\n        }\n    ]\n}",
            "masked_line": "es = Elasticsearch()",
            "answer": "Elasticsearch",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_233"
        },
        {
            "dependency": "numpy",
            "version": "==1.13.0",
            "time": "2019-02-17",
            "description": "This code fits a generalized extreme value distribution to a given array of data using the method of maximum likelihood estimation.",
            "code": "import numpy as np\nfrom scipy.stats import genextreme as gev\nwith np.errstate(divide='ignore', invalid='ignore'):\n    t=np.array([3.8482, 3.6435, 3.0417, 4.0329, 3.2967, 3.3535, 3.6179, 3.3042, 3.6164, 3.5855, 2.7932, 2.8833, 2.6513, 2.7794, 3.2649, 3.2613, 3.1736, 3.1131, 3.3896, 4.2891])\n    a=gev.fit(t)",
            "masked_code": "import numpy as np\nfrom scipy.stats import genextreme as gev\n<line_mask>\n    t=np.array([3.8482, 3.6435, 3.0417, 4.0329, 3.2967, 3.3535, 3.6179, 3.3042, 3.6164, 3.5855, 2.7932, 2.8833, 2.6513, 2.7794, 3.2649, 3.2613, 3.1736, 3.1131, 3.3896, 4.2891])\n    a=gev.fit(t)",
            "masked_line": "with np.errstate(divide='ignore', invalid='ignore'):",
            "answer": "errstate",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_234"
        },
        {
            "dependency": "pyautogui",
            "version": "==0.9.52",
            "time": "2020-12-06",
            "description": "This code checks if the image 'foo.png' is present on the screen using PyAutoGUI. If the image is found, it prints 'image found', otherwise it prints 'ImageNotFoundException: image not found'.",
            "code": "import pyautogui\n\n# force use of ImageNotFoundException\npyautogui.useImageNotFoundException()\n\ntry:\n    location = pyautogui.locateOnScreen('foo.png')\n    print('image found')\nexcept pyautogui.ImageNotFoundException:\n    print('ImageNotFoundException: image not found')",
            "masked_code": "import pyautogui\n\n# force use of ImageNotFoundException\npyautogui.useImageNotFoundException()\n\ntry:\n    <line_mask>\n    print('image found')\nexcept pyautogui.ImageNotFoundException:\n    print('ImageNotFoundException: image not found')",
            "masked_line": "location = pyautogui.locateOnScreen('foo.png')",
            "answer": "locateOnScreen",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_235"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.15.0",
            "time": "2019-10-30",
            "description": "The code creates a constant tensor using TensorFlow with values [1, 2, 3] and prints it, enabling eager mode. It also prints the second dimension of a TensorShape object [1, 2], which is 2.",
            "code": "import os\nos.environ['TF2_BEHAVIOR'] = '1'\nimport tensorflow as tf\n\nprint(tf.constant([1, 2, 3]))  # Eager mode is enabled\n# tf.Tensor([1 2 3], shape=(3,), dtype=int32)\nprint(tf.TensorShape([1, 2])[1])  # TensorShape dimensions are int\n# 2",
            "masked_code": "import os\nos.environ['TF2_BEHAVIOR'] = '1'\nimport tensorflow as tf\n\n<line_mask>\n# tf.Tensor([1 2 3], shape=(3,), dtype=int32)\nprint(tf.TensorShape([1, 2])[1])  # TensorShape dimensions are int\n# 2",
            "masked_line": "print(tf.constant([1, 2, 3]))  # Eager mode is enabled",
            "answer": "constant",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_236"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.0",
            "time": "2020-01-07",
            "description": "The code initializes a TensorFlow session with GPU memory allocation set to allow growth.",
            "code": "from tensorflow.compat.v1 import ConfigProto\nfrom tensorflow.compat.v1 import InteractiveSession\nconfig = ConfigProto()\nconfig.gpu_options.allow_growth = True\nsession = InteractiveSession(config=config)",
            "masked_code": "from tensorflow.compat.v1 import ConfigProto\n<line_mask>\nconfig = ConfigProto()\nconfig.gpu_options.allow_growth = True\nsession = InteractiveSession(config=config)",
            "masked_line": "from tensorflow.compat.v1 import InteractiveSession",
            "answer": "InteractiveSession",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_237"
        },
        {
            "dependency": "bokeh",
            "version": "==1.1.0",
            "time": "2019-04-23",
            "description": "The code generates a Bokeh plot with two tabs, each containing different content. The first tab displays a line plot with x values of 1 and 2, and y values of 3 and 4. The second tab displays a paragraph with the text \"Another tab\". The plot and paragraph are displayed within a column layout and saved to an output file using a specified template.",
            "code": "from bokeh.plotting import save, figure\nfrom bokeh.models import Paragraph, Panel, Tabs, Column\n\ntemplate = \"\"\"\n{% block postamble %}\n\n{% endblock %}\n\"\"\"\n\np = Paragraph(text = \"Another tab\", width = 600)\n\nplot = figure()\nplot.line(x = [1, 2], y = [3, 4])\ntabs = [Panel(title = 'Tab1', child = plot)]\ntabs.append(Panel(title = 'Tab2', child = p))\n\nsave(Column(Tabs(tabs = tabs, width = 600)), template = template)",
            "masked_code": "<line_mask>\nfrom bokeh.models import Paragraph, Panel, Tabs, Column\n\ntemplate = \"\"\"\n{% block postamble %}\n\n{% endblock %}\n\"\"\"\n\np = Paragraph(text = \"Another tab\", width = 600)\n\nplot = figure()\nplot.line(x = [1, 2], y = [3, 4])\ntabs = [Panel(title = 'Tab1', child = plot)]\ntabs.append(Panel(title = 'Tab2', child = p))\n\nsave(Column(Tabs(tabs = tabs, width = 600)), template = template)",
            "masked_line": "from bokeh.plotting import save, figure",
            "answer": "save",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_238"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.0",
            "time": "2019-08-30",
            "description": "This code takes an input of shape [None, 3], reshapes it to [1, 1, 3], then broadcasts it to a larger shape [None, 5, 5, 3]. Finally, it creates a TensorFlow model that takes this reshaped and broadcasted input and outputs the shape (8, 5, 5, 3) when given a random input of size (8, 3).",
            "code": "import tensorflow as tf\nimport tensorflow.keras.layers as kl\nimport numpy as np\n\nx = tf.keras.Input([3])  # Shape [None, 3]\ny = kl.Reshape([1, 1, 3])(x)  # Need to add empty dims before broadcasting\n# Retain the batch and depth dimensions, but broadcast along H and W\nbroadcast_shape = tf.where([True, False, False, True],\n                           tf.shape(y), [0, 5, 5, 0])\ny = tf.broadcast_to(y, broadcast_shape)  # Broadcast to shape [None, 5, 5, 3]\n\nmodel = tf.keras.Model(inputs=x, outputs=y)\n\nprint(model(np.random.random(size=(8, 3))).shape)\n# prints: \"(8, 5, 5, 3)\"",
            "masked_code": "import tensorflow as tf\nimport tensorflow.keras.layers as kl\nimport numpy as np\n\nx = tf.keras.Input([3])  # Shape [None, 3]\ny = kl.Reshape([1, 1, 3])(x)  # Need to add empty dims before broadcasting\n# Retain the batch and depth dimensions, but broadcast along H and W\nbroadcast_shape = tf.where([True, False, False, True],\n                           tf.shape(y), [0, 5, 5, 0])\ny = tf.broadcast_to(y, broadcast_shape)  # Broadcast to shape [None, 5, 5, 3]\n\nmodel = tf.keras.Model(inputs=x, outputs=y)\n\n<line_mask>\n# prints: \"(8, 5, 5, 3)\"",
            "masked_line": "print(model(np.random.random(size=(8, 3))).shape)",
            "answer": "model",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_239"
        },
        {
            "dependency": "numpy",
            "version": "==1.5.x",
            "time": "2019-08-09",
            "description": "The code subtracts the elements of array 'vec' from the first column of matrix 'mt' and prints the updated 'mt' matrix.",
            "code": "import numpy as np\n\nvec=np.array([15.1,7.9,4.5,12.8,10.5],ndmin = 2)\nmt = np.matrix([[1,35.5,1.23],[1,40.8,1.89],[1,30.2,1.55],[1,4.3,1.18], [1,10.7,1.68]])\n\nmt[..., 0] = vec.T - mt[..., 0]\n#or\n#mt.T[0] = np.subtract(vec, mt.T[0])\n\nprint(mt)",
            "masked_code": "import numpy as np\n\n<line_mask>\nmt = np.matrix([[1,35.5,1.23],[1,40.8,1.89],[1,30.2,1.55],[1,4.3,1.18], [1,10.7,1.68]])\n\nmt[..., 0] = vec.T - mt[..., 0]\n#or\n#mt.T[0] = np.subtract(vec, mt.T[0])\n\nprint(mt)",
            "masked_line": "vec=np.array([15.1,7.9,4.5,12.8,10.5],ndmin = 2)",
            "answer": "array",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_240"
        },
        {
            "dependency": "scipy",
            "version": "==0.14.0",
            "time": "2019-12-01",
            "description": "This function finds the closest background (zero) element for each element in the input image by calculating the distance to the nearest zero element using Euclidean distance transform. It then returns a dictionary mapping each non-zero element's position to its distance to the nearest zero element.",
            "code": "from scipy import ndimage\nimport pprint\n\ndef nearest_zero(image):\n    \" Finds closest background (zero) element for each element in image \"\n\n    # Find closest zero elements in the inverted image (same as closest non-zero for image)\n    edt = ndimage.distance_transform_edt(image, return_indices=False)\n\n    # Create dictionary of indexes\n    return {(r,c):edt[r][c] for r in range(image.shape[0]) for c in range(image.shape[1]) if image[r][c]}",
            "masked_code": "from scipy import ndimage\nimport pprint\n\ndef nearest_zero(image):\n    \" Finds closest background (zero) element for each element in image \"\n\n    # Find closest zero elements in the inverted image (same as closest non-zero for image)\n    <line_mask>\n\n    # Create dictionary of indexes\n    return {(r,c):edt[r][c] for r in range(image.shape[0]) for c in range(image.shape[1]) if image[r][c]}",
            "masked_line": "edt = ndimage.distance_transform_edt(image, return_indices=False)",
            "answer": "distance_transform_edt",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_241"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.1",
            "time": "2019-01-03",
            "description": "The code calculates the mean values of each row in the `arr` array and then stacks the `ids` array along with the computed mean values vertically to form a new array.",
            "code": "import numpy as np\n\nids = np.array([1, 2])  # this is just array2\narr = np.array([[99, 73, 97, 98],\n          [98, 71, 70, 99]])\nresult = np.vstack((ids, np.mean(arr, axis=1)))\nprint(result)",
            "masked_code": "import numpy as np\n\nids = np.array([1, 2])  # this is just array2\narr = np.array([[99, 73, 97, 98],\n          [98, 71, 70, 99]])\n<line_mask>\nprint(result)",
            "masked_line": "result = np.vstack((ids, np.mean(arr, axis=1)))",
            "answer": "vstack",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_242"
        },
        {
            "dependency": "plotly",
            "version": ">=1.9.4",
            "time": "2019-02-14",
            "description": "The code generates a simple table using the data contained in the dataframe \"df\", displays the table using Plotly offline mode, and saves the table as an image file named \"sample.png\" using Plotly.",
            "code": "from plotly.offline import plot as off\nimport plotly.figure_factory as ff\nimport plotly.io as pio\n\ntable = ff.create_table(df, index=True)\nfig = off(table, filename='simple_table')\npio.write_image(table, 'sample.png')",
            "masked_code": "from plotly.offline import plot as off\nimport plotly.figure_factory as ff\nimport plotly.io as pio\n\n<line_mask>\nfig = off(table, filename='simple_table')\npio.write_image(table, 'sample.png')",
            "masked_line": "table = ff.create_table(df, index=True)",
            "answer": "create_table",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_243"
        },
        {
            "dependency": "numpy",
            "version": "==1.13.0",
            "time": "2019-08-21",
            "description": "The code rounds the values in the 'SCORE' column of a pandas DataFrame to the nearest integer and converts them to integers. If the 'SCORE' column contains NaN values, it uses the 'Int64' data type, which is supported in pandas 0.24+. If the 'SCORE' column does not contain NaN values, it simply converts the rounded values to integers.",
            "code": "import pandas as pd\nimport numpy as np\n\ndf = pd.DataFrame({'SCORE':[100.000000,96.199205,np.nan,95.983358]})\nprint(df)\n\"\"\"\n   1. if series has NaN value, solution work for pandas 0.24+\n      df['SCORE'] = np.round(df.SCORE).astype('Int64')\n   https://pandas.pydata.org/pandas-docs/stable/user_guide/integer_na.html\n\n  2. If series has not NaN value, try this\n    df['SCORE'] = np.round(df.SCORE).astype(int)\n\n\"\"\"\ndf['SCORE'] = np.round(df.SCORE).astype('Int64')\nprint(df)",
            "masked_code": "import pandas as pd\nimport numpy as np\n\ndf = pd.DataFrame({'SCORE':[100.000000,96.199205,np.nan,95.983358]})\nprint(df)\n\"\"\"\n   1. if series has NaN value, solution work for pandas 0.24+\n      df['SCORE'] = np.round(df.SCORE).astype('Int64')\n   https://pandas.pydata.org/pandas-docs/stable/user_guide/integer_na.html\n\n  2. If series has not NaN value, try this\n    df['SCORE'] = np.round(df.SCORE).astype(int)\n\n\"\"\"\n<line_mask>\nprint(df)",
            "masked_line": "df['SCORE'] = np.round(df.SCORE).astype('Int64')",
            "answer": "round",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_244"
        },
        {
            "dependency": "pandas",
            "version": ">=0.24",
            "time": "2019-08-21",
            "description": "The code rounds the values in the 'SCORE' column of a pandas DataFrame to the nearest whole number and converts them to integer type. If the 'SCORE' column contains NaN values, it uses the Int64 datatype to handle integer data with missing values starting from pandas version 0.24. If there are no NaN values in the 'SCORE' column, it simply converts the rounded values to integer type.",
            "code": "import pandas as pd\nimport numpy as np\n\ndf = pd.DataFrame({'SCORE':[100.000000,96.199205,np.nan,95.983358]})\nprint(df)\n\"\"\"\n   1. if series has NaN value, solution work for pandas 0.24+\n      df['SCORE'] = np.round(df.SCORE).astype('Int64')\n   https://pandas.pydata.org/pandas-docs/stable/user_guide/integer_na.html\n\n  2. If series has not NaN value, try this\n    df['SCORE'] = np.round(df.SCORE).astype(int)\n\n\"\"\"\ndf['SCORE'] = np.round(df.SCORE).astype('Int64')\nprint(df)",
            "masked_code": "import pandas as pd\nimport numpy as np\n\n<line_mask>\nprint(df)\n\"\"\"\n   1. if series has NaN value, solution work for pandas 0.24+\n      df['SCORE'] = np.round(df.SCORE).astype('Int64')\n   https://pandas.pydata.org/pandas-docs/stable/user_guide/integer_na.html\n\n  2. If series has not NaN value, try this\n    df['SCORE'] = np.round(df.SCORE).astype(int)\n\n\"\"\"\ndf['SCORE'] = np.round(df.SCORE).astype('Int64')\nprint(df)",
            "masked_line": "df = pd.DataFrame({'SCORE':[100.000000,96.199205,np.nan,95.983358]})",
            "answer": "DataFrame",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_245"
        },
        {
            "dependency": "bokeh",
            "version": "==1.0.4",
            "time": "2019-04-05",
            "description": "The code creates a multi-line plot using the Bokeh library to visualize data from a pandas DataFrame. The plot displays multiple lines representing different columns of the DataFrame against the 'version' column on the x-axis. Each line is colored differently using a predefined color palette.",
            "code": "import pandas as pd\nimport numpy as np\nfrom bokeh.palettes import Spectral11\nfrom bokeh.plotting import figure, show\n\ntoy_df = pd.DataFrame(data = {'version': ['v1.0.0', 'v1.0.1', 'v1.0.2', 'v1.0.3'],\n                              '2x8x8': [10.2, 11.3, 9.5, 10.9],\n                              '2x8x10': [9.2, 10.4, 9.3, 9.9],\n                              '2x8x12': [8.2, 10.2, 9.1, 11.1]}, columns = ('version', '2x8x8' , '2x8x10', '2x8x12'))\n\nnumlines = len(toy_df.columns)\nmypalette = Spectral11[0:numlines]\n\np = figure(width = 500, height = 300, x_range = toy_df['version'])\np.multi_line(xs = [toy_df['version'].values] * numlines,\n             ys = [toy_df[name].values for name in toy_df],\n             line_color = mypalette,\n             line_width = 5)\nshow(p)",
            "masked_code": "import pandas as pd\nimport numpy as np\nfrom bokeh.palettes import Spectral11\nfrom bokeh.plotting import figure, show\n\ntoy_df = pd.DataFrame(data = {'version': ['v1.0.0', 'v1.0.1', 'v1.0.2', 'v1.0.3'],\n                              '2x8x8': [10.2, 11.3, 9.5, 10.9],\n                              '2x8x10': [9.2, 10.4, 9.3, 9.9],\n                              '2x8x12': [8.2, 10.2, 9.1, 11.1]}, columns = ('version', '2x8x8' , '2x8x10', '2x8x12'))\n\nnumlines = len(toy_df.columns)\nmypalette = Spectral11[0:numlines]\n\n<line_mask>\np.multi_line(xs = [toy_df['version'].values] * numlines,\n             ys = [toy_df[name].values for name in toy_df],\n             line_color = mypalette,\n             line_width = 5)\nshow(p)",
            "masked_line": "p = figure(width = 500, height = 300, x_range = toy_df['version'])",
            "answer": "figure",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_246"
        },
        {
            "dependency": "pyglet",
            "version": "==1.2",
            "time": "2019-08-20",
            "description": "The code plays an explosion sound on loop using the pyglet library in Python.",
            "code": "import pyglet\nimport time\n\npyglet.options['audio'] = ('openal', 'pulse', 'directsound', 'silent')\nsource = pyglet.media.StaticSource(pyglet.media.load('explosion.wav'))\n\nplayer = pyglet.media.Player()\nplayer.queue(source)\nplayer.EOS_LOOP = 'loop'\nplayer.play()\n\npyglet.app.run()",
            "masked_code": "import pyglet\nimport time\n\npyglet.options['audio'] = ('openal', 'pulse', 'directsound', 'silent')\n<line_mask>\n\nplayer = pyglet.media.Player()\nplayer.queue(source)\nplayer.EOS_LOOP = 'loop'\nplayer.play()\n\npyglet.app.run()",
            "masked_line": "source = pyglet.media.StaticSource(pyglet.media.load('explosion.wav'))",
            "answer": "StaticSource",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_247"
        },
        {
            "dependency": "pandas",
            "version": "==0.24",
            "time": "2019-02-06",
            "description": "The code generates a line plot showing the data values against the corresponding quarters.",
            "code": "import pandas as pd\nimport matplotlib.pyplot as plt\n\ndata = {\n    'Quarter': ['Q1-2018', 'Q2-2018', 'Q3-2018', 'Q4-2018', 'Q1-2019'],\n    'Data': [1,3,2,4,1]\n}\ndf = pd.DataFrame(data=data)\n\nplt.plot(\"Quarter\", \"Data\", data=df)\n\nplt.show()",
            "masked_code": "import pandas as pd\nimport matplotlib.pyplot as plt\n\ndata = {\n    'Quarter': ['Q1-2018', 'Q2-2018', 'Q3-2018', 'Q4-2018', 'Q1-2019'],\n    'Data': [1,3,2,4,1]\n}\n<line_mask>\n\nplt.plot(\"Quarter\", \"Data\", data=df)\n\nplt.show()",
            "masked_line": "df = pd.DataFrame(data=data)",
            "answer": "DataFrame",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_248"
        },
        {
            "dependency": "scikit-learn",
            "version": "==0.21.2",
            "time": "2019-07-28",
            "description": "The code splits the Iris dataset into training and testing sets, fits a Decision Tree classifier with a maximum depth of 1 to the training data, predicts the classes of the test data, and plots the decision tree.",
            "code": "from sklearn.model_selection import train_test_split\nfrom sklearn.datasets import load_iris\nfrom sklearn.tree import plot_tree\n\ndataset = load_iris()\n\nX_train,X_test,y_train,y_test = train_test_split(dataset.data,\n                                                 dataset.target,\n                                                 test_size=0.3,\n                                                 random_state=0)\nfrom sklearn.tree import DecisionTreeClassifier\nclf = DecisionTreeClassifier(max_depth=1, random_state=1)\nclf.fit(X_train,y_train)\nprint(clf.predict(X_test))\n\nplot_tree(clf)",
            "masked_code": "from sklearn.model_selection import train_test_split\n<line_mask>\nfrom sklearn.tree import plot_tree\n\ndataset = load_iris()\n\nX_train,X_test,y_train,y_test = train_test_split(dataset.data,\n                                                 dataset.target,\n                                                 test_size=0.3,\n                                                 random_state=0)\nfrom sklearn.tree import DecisionTreeClassifier\nclf = DecisionTreeClassifier(max_depth=1, random_state=1)\nclf.fit(X_train,y_train)\nprint(clf.predict(X_test))\n\nplot_tree(clf)",
            "masked_line": "from sklearn.datasets import load_iris",
            "answer": "load_iris",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_249"
        },
        {
            "dependency": "dash",
            "version": "==0.38.0",
            "time": "2019-05-03",
            "description": "This code creates a Dash web application using JupyterDash and displays a Cytoscape network visualization with two nodes and one edge.",
            "code": "from jupyter_plotly_dash import JupyterDash\nimport dash\nimport dash_cytoscape as cyto\nimport dash_html_components as html\n\napp = JupyterDash('YourAppExample')\n\napp.layout = html.Div([\n    cyto.Cytoscape(\n        id='cytoscape',\n        elements=[\n            {'data': {'id': 'one', 'label': 'Node 1'}, 'position': {'x': 50, 'y': 50}},\n            {'data': {'id': 'two', 'label': 'Node 2'}, 'position': {'x': 200, 'y': 200}},\n            {'data': {'source': 'one', 'target': 'two','label': 'Node 1 to 2'}}\n        ],\n        layout={'name': 'preset'}\n    )\n])\n\napp",
            "masked_code": "from jupyter_plotly_dash import JupyterDash\nimport dash\nimport dash_cytoscape as cyto\nimport dash_html_components as html\n\napp = JupyterDash('YourAppExample')\n\n<line_mask>\n    cyto.Cytoscape(\n        id='cytoscape',\n        elements=[\n            {'data': {'id': 'one', 'label': 'Node 1'}, 'position': {'x': 50, 'y': 50}},\n            {'data': {'id': 'two', 'label': 'Node 2'}, 'position': {'x': 200, 'y': 200}},\n            {'data': {'source': 'one', 'target': 'two','label': 'Node 1 to 2'}}\n        ],\n        layout={'name': 'preset'}\n    )\n])\n\napp",
            "masked_line": "app.layout = html.Div([",
            "answer": "Div",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_250"
        },
        {
            "dependency": "pandas",
            "version": "==0.24.2",
            "time": "2019-03-28",
            "description": "The code reads data from a website that provides predictions for football matches with over 1.5 goals. It then processes the data to extract information such as the date, time, football league, home team, and away team for each match. Finally, it renames the \"Logic\" column to \"Description\" for clarity.",
            "code": "import pandas as pd\n\ntables = pd.read_html('https://afootballreport.com/predictions/over-1.5-goals/')\ntable = tables[0]\n\ntable[['Date', 'Time']] = table['Home team - Away team'].str.split('  ', expand=True)\ntable = table.drop(['Home team - Away team'],axis=1)\ntable =  table.rename(columns={\"Logic\":\"Description\"})   \n\n\ntable[['Football League', 'Home Team', 'Away Team']] = table['Home team - Away team.1'].str.split('  ', expand=True)\ntable = table.drop(['Home team - Away team.1'],axis=1)",
            "masked_code": "import pandas as pd\n\n<line_mask>\ntable = tables[0]\n\ntable[['Date', 'Time']] = table['Home team - Away team'].str.split('  ', expand=True)\ntable = table.drop(['Home team - Away team'],axis=1)\ntable =  table.rename(columns={\"Logic\":\"Description\"})   \n\n\ntable[['Football League', 'Home Team', 'Away Team']] = table['Home team - Away team.1'].str.split('  ', expand=True)\ntable = table.drop(['Home team - Away team.1'],axis=1)",
            "masked_line": "tables = pd.read_html('https://afootballreport.com/predictions/over-1.5-goals/')",
            "answer": "read_html",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_251"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.14.0",
            "time": "2019-09-13",
            "description": "The code initializes a ResNet50 model using TensorFlow, generates a random image, and passes the random image through the ResNet50 model to get the model's output.",
            "code": "import tensorflow as tf\n\nmodel = tf.keras.applications.ResNet50()\n\ninit_op = tf.global_variables_initializer()\nwith tf.compat.v1.Session() as sess:\n    random_image, _ = sess.run([tf.random.normal(shape=[1, 224, 224, 3]), init_op])\n    outputs = sess.run(model.output, feed_dict={model.input:random_image})",
            "masked_code": "import tensorflow as tf\n\n<line_mask>\n\ninit_op = tf.global_variables_initializer()\nwith tf.compat.v1.Session() as sess:\n    random_image, _ = sess.run([tf.random.normal(shape=[1, 224, 224, 3]), init_op])\n    outputs = sess.run(model.output, feed_dict={model.input:random_image})",
            "masked_line": "model = tf.keras.applications.ResNet50()",
            "answer": "ResNet50",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_252"
        },
        {
            "dependency": "django",
            "version": "==2.2",
            "time": "2019-04-05",
            "description": "This code defines a class TradePlantPage that extends the RoutablePageMixin and PlantPage classes. It specifies that instances of TradePlantPage can only be children of TradePlantIndexPage instances and cannot have any subpages. The trade method within the class takes a request and a plant_slug as parameters, retrieves a PlantPage object with the given slug, and renders a template with trade-related information including the plant object and the current page object.",
            "code": "from django.shortcuts import get_object_or_404, render\n\nclass TradePlantPage(RoutablePageMixin, PlantPage):\n    parent_page_types = ['TradePlantIndexPage']\n    subpage_types = []\n\n    @route(r'^([-\\w]+)/$')\n    def trade(self, request, plant_slug):\n        plant = get_object_or_404(PlantPage, slug=plant_slug)\n\n        return render(request, 'plants/plant_page.html', {\n            'trade': True,\n            'plant': plant,\n            'page': self,\n        })",
            "masked_code": "<line_mask>\n\nclass TradePlantPage(RoutablePageMixin, PlantPage):\n    parent_page_types = ['TradePlantIndexPage']\n    subpage_types = []\n\n    @route(r'^([-\\w]+)/$')\n    def trade(self, request, plant_slug):\n        plant = get_object_or_404(PlantPage, slug=plant_slug)\n\n        return render(request, 'plants/plant_page.html', {\n            'trade': True,\n            'plant': plant,\n            'page': self,\n        })",
            "masked_line": "from django.shortcuts import get_object_or_404, render",
            "answer": "render",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_253"
        },
        {
            "dependency": "bokeh",
            "version": "==1.1.0",
            "time": "2019-04-17",
            "description": "The code creates a Bokeh plot with a line chart of specified coordinates, overlaid with an image of a dog head.",
            "code": "from bokeh.plotting import figure, show\nfrom bokeh.models import CustomJS, Div, Row\n\np1 = figure(plot_width = 300, plot_height = 300, x_range = (0, 10), y_range = (0, 10), title = \"Doggy as background\")\np1.line([1, 2, 3, 5, 6, 7, 8, 9, 10], [4, 5, 6, 1, 2, 3, 7, 8, 9, 0], line_width = 5)\nurl = \"https://cdn3.iconfinder.com/data/icons/line/36/dog_head-512.png\"\nd1 = Div(text = '')\n\nshow(Row(p1, d1))",
            "masked_code": "from bokeh.plotting import figure, show\nfrom bokeh.models import CustomJS, Div, Row\n\np1 = figure(plot_width = 300, plot_height = 300, x_range = (0, 10), y_range = (0, 10), title = \"Doggy as background\")\np1.line([1, 2, 3, 5, 6, 7, 8, 9, 10], [4, 5, 6, 1, 2, 3, 7, 8, 9, 0], line_width = 5)\nurl = \"https://cdn3.iconfinder.com/data/icons/line/36/dog_head-512.png\"\nd1 = Div(text = '')\n\n<line_mask>",
            "masked_line": "show(Row(p1, d1))",
            "answer": "Row",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_254"
        },
        {
            "dependency": "pyproj",
            "version": "==2.4.1",
            "time": "2020-07-01",
            "description": "The code calculates the distance in kilometers between two sets of geographical coordinates given in EPSG:3857 projection using the WGS84 ellipsoid.",
            "code": "import pyproj  #v2.4.1\nx1, y1 = (12875996.563923, -3940011.116702)\nx2, y2 = (12872802.929335, -3937989.118438)\nlon1, lat1 = pyproj.Proj(\"epsg:3857\")(x1, y1, inverse=True)\nlon2, lat2 = pyproj.Proj(\"epsg:3857\")(x2, y2, inverse=True)\n_,_,dist_km = pyproj.Geod(ellps='WGS84').inv(lon1, lat1, lon2, lat2)\ndist_km   # 3157.214113925091",
            "masked_code": "import pyproj  #v2.4.1\nx1, y1 = (12875996.563923, -3940011.116702)\nx2, y2 = (12872802.929335, -3937989.118438)\n<line_mask>\nlon2, lat2 = pyproj.Proj(\"epsg:3857\")(x2, y2, inverse=True)\n_,_,dist_km = pyproj.Geod(ellps='WGS84').inv(lon1, lat1, lon2, lat2)\ndist_km   # 3157.214113925091",
            "masked_line": "lon1, lat1 = pyproj.Proj(\"epsg:3857\")(x1, y1, inverse=True)",
            "answer": "Proj",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_255"
        },
        {
            "dependency": "selenium",
            "version": "==3.141.0",
            "time": "2020-11-15",
            "description": "This code launches a headless Chrome browser with specified options and navigates to the Google website.",
            "code": "from selenium import webdriver\n\noptions = webdriver.ChromeOptions() \noptions.add_argument('--headless')\noptions.add_argument('--window-size=1920,1080')\n# options.add_argument('--profile-directory=Profile 1')\noptions.add_argument(r\"--user-data-dir=C:\\Users\\Soma Bhattacharjee\\AppData\\Local\\Google\\Chrome\\User Data\\Default\")\noptions.add_argument(\"--remote-debugging-port=9222\")\ndriver = webdriver.Chrome(options=options, executable_path=r'C:\\WebDrivers\\chromedriver.exe')\ndriver.get('https://www.google.com/')\nprint(\"Chrome Headless launched\")",
            "masked_code": "from selenium import webdriver\n\noptions = webdriver.ChromeOptions() \noptions.add_argument('--headless')\noptions.add_argument('--window-size=1920,1080')\n# options.add_argument('--profile-directory=Profile 1')\noptions.add_argument(r\"--user-data-dir=C:\\Users\\Soma Bhattacharjee\\AppData\\Local\\Google\\Chrome\\User Data\\Default\")\noptions.add_argument(\"--remote-debugging-port=9222\")\ndriver = webdriver.Chrome(options=options, executable_path=r'C:\\WebDrivers\\chromedriver.exe')\n<line_mask>\nprint(\"Chrome Headless launched\")",
            "masked_line": "driver.get('https://www.google.com/')",
            "answer": "get",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_256"
        },
        {
            "dependency": "matplotlib",
            "version": "<3.2",
            "time": "2020-01-10",
            "description": "The code generates a diverging color plot (pcolormesh) of a 2D grid with values ranging from -2 to 4, using the \"RdBu_r\" colormap. A colorbar is added to indicate the mapping of values to colors, and the plot is displayed using matplotlib.",
            "code": "import numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import DivergingNorm\n\nx, y = np.meshgrid(np.linspace(0,50,51), np.linspace(0,50,51))\nz = np.linspace(-2,4,50*50).reshape(50,50)\n\nnorm = DivergingNorm(vmin=z.min(), vcenter=0, vmax=z.max())\npc = plt.pcolormesh(x,y,z, norm=norm, cmap=\"RdBu_r\")\nplt.colorbar(pc)\n\nplt.show()",
            "masked_code": "import numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import DivergingNorm\n\nx, y = np.meshgrid(np.linspace(0,50,51), np.linspace(0,50,51))\nz = np.linspace(-2,4,50*50).reshape(50,50)\n\nnorm = DivergingNorm(vmin=z.min(), vcenter=0, vmax=z.max())\n<line_mask>\nplt.colorbar(pc)\n\nplt.show()",
            "masked_line": "pc = plt.pcolormesh(x,y,z, norm=norm, cmap=\"RdBu_r\")",
            "answer": "pcolormesh",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_257"
        },
        {
            "dependency": "numpy",
            "version": "==1.14.0",
            "time": "2020-02-10",
            "description": "The code creates a DataFrame using pandas with columns 'Col1' and 'Value'. It then generates a random value for each row in the 'random' column using a Dirichlet distribution. It finally calculates a new value by multiplying the 'Value' column with the 'random' column and rounding it to the nearest integer.",
            "code": "import pandas as pd\nimport numpy as np\ndf = pd.DataFrame({'Col1': list(\"ABC\"), 'Value': [100]*3})\ndf['random'] = np.around(np.random.dirichlet\n                        (np.ones(df.shape[0]),size=1)[0],\n                         decimals = 1)\ndf['New value'] = (df['Value']*df['random']).astype(int)\nprint(df)",
            "masked_code": "import pandas as pd\nimport numpy as np\ndf = pd.DataFrame({'Col1': list(\"ABC\"), 'Value': [100]*3})\ndf['random'] = np.around(np.random.dirichlet\n                        <line_mask>\n                         decimals = 1)\ndf['New value'] = (df['Value']*df['random']).astype(int)\nprint(df)",
            "masked_line": "(np.ones(df.shape[0]),size=1)[0],",
            "answer": "ones",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_258"
        },
        {
            "dependency": "plotly",
            "version": "==4.10.0",
            "time": "2020-09-14",
            "description": "The code creates a Sankey diagram using Plotly library to visualize the flow of values between nodes labeled from 0 to 6.",
            "code": "import plotly.graph_objects as go\n\nsources = [0,  0,  1,  1,  2,  2] #indices correspond to labels\ntargets = [1,  2,  3,  4,  5,  6] \nvalues  = [45, 30, 15, 30, 20, 10]\nlabels = ['Node 0', 'Node 1', 'Node 2', 'Node 3', 'Node 4', 'Node 5', 'Node 6']\n\nlink = dict(source=sources, target=targets, value=values)\nnode = dict(label=labels)\ndata = go.Sankey(link=link, node=node)\nfig = go.Figure(data)\nfig.show()\n# fig.show(renderer=\"svg\", width=1000, height=500)",
            "masked_code": "import plotly.graph_objects as go\n\nsources = [0,  0,  1,  1,  2,  2] #indices correspond to labels\ntargets = [1,  2,  3,  4,  5,  6] \nvalues  = [45, 30, 15, 30, 20, 10]\nlabels = ['Node 0', 'Node 1', 'Node 2', 'Node 3', 'Node 4', 'Node 5', 'Node 6']\n\nlink = dict(source=sources, target=targets, value=values)\nnode = dict(label=labels)\ndata = go.Sankey(link=link, node=node)\nfig = go.Figure(data)\n<line_mask>\n# fig.show(renderer=\"svg\", width=1000, height=500)",
            "masked_line": "fig.show()",
            "answer": "show",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_259"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.2.0",
            "time": "2020-06-18",
            "description": "This code defines a TensorFlow function named parTest that takes an input x_in and adds each integer from 0 to 4999 to x_in, returning the total sum.",
            "code": "import tensorflow as tf\n@tf.function\ndef parTest(x_in):\n    res = 0\n    for i in tf.range(5000):\n        res += x_in + i\n    return res",
            "masked_code": "import tensorflow as tf\n@tf.function\ndef parTest(x_in):\n    res = 0\n    <line_mask>\n        res += x_in + i\n    return res",
            "masked_line": "for i in tf.range(5000):",
            "answer": "range",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_260"
        },
        {
            "dependency": "selenium",
            "version": "==3.5.3",
            "time": "2020-01-30",
            "description": "The code types the text \"hello'world\" into a textbox on the website \"https://google.com\" using a WebDriver instance.",
            "code": "from selenium import webdriver\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support import expected_conditions as EC\n\ndriver.get(\"https://google.com\")\ntext = \"hello'world\"\ntextbox = WebDriverWait(driver, 20).until(EC.element_to_be_clickable((By.NAME, \"q\")))\nfor i in text:\n    textbox.send_keys(i)",
            "masked_code": "from selenium import webdriver\n<line_mask>\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support import expected_conditions as EC\n\ndriver.get(\"https://google.com\")\ntext = \"hello'world\"\ntextbox = WebDriverWait(driver, 20).until(EC.element_to_be_clickable((By.NAME, \"q\")))\nfor i in text:\n    textbox.send_keys(i)",
            "masked_line": "from selenium.webdriver.support.ui import WebDriverWait",
            "answer": "WebDriverWait",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_261"
        },
        {
            "dependency": "scipy",
            "version": "==1.4.1",
            "time": "2020-05-08",
            "description": "This code generates a list of 100 sparse matrices, each containing random binary values with a shape of 1x200. It then vertically stacks these sparse matrices into a single matrix and returns the shape of the resulting matrix.",
            "code": "from scipy.sparse import csr_matrix, vstack\nimport numpy as np\n\nvec_list = []\nfor i in range(100):\n    vec_list.append(csr_matrix(np.random.randint(2,size=(1,200))))\nvec_mat = vstack(vec_list)\nvec_mat.shape",
            "masked_code": "from scipy.sparse import csr_matrix, vstack\nimport numpy as np\n\nvec_list = []\nfor i in range(100):\n    vec_list.append(csr_matrix(np.random.randint(2,size=(1,200))))\n<line_mask>\nvec_mat.shape",
            "masked_line": "vec_mat = vstack(vec_list)",
            "answer": "vstack",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_262"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.6",
            "time": "2021-09-16",
            "description": "The code defines a ResNet101V2 model using TensorFlow with specified configuration including input shape (224, 224, 3) and no top layer. The model is compiled with mean squared error loss and Adam optimizer. It then fits the model to dummy image and result data for 2 epochs.",
            "code": "import tensorflow as tf\n\ndef dummy_image_float(w,h):\n    return tf.constant([0.,]*(h*w*3), shape=[1,w,h,3], dtype=tf.float32)\ndef dummy_result(w,h,nfeature):\n    return tf.constant([0,]*(h*w*nfeature), shape=[1,w,h,nfeature], dtype=tf.float32)\n\nmodel = tf.keras.applications.ResNet101V2(\n        include_top=False,\n        #input_tensor=x1,\n        weights='imagenet',\n        input_shape=(224, 224, 3),\n        pooling=None\n        )\n\nmodel.compile(optimizer='adam', loss=\"mean_squared_error\", run_eagerly=True)\n\n#train_ds = [ (dummy_image_float(224,224), dummy_result(7,7,2048)) ]\nmodel.fit(dummy_image_float(224,224), dummy_result(7,7,2048), epochs=2)",
            "masked_code": "import tensorflow as tf\n\ndef dummy_image_float(w,h):\n    return tf.constant([0.,]*(h*w*3), shape=[1,w,h,3], dtype=tf.float32)\ndef dummy_result(w,h,nfeature):\n    return tf.constant([0,]*(h*w*nfeature), shape=[1,w,h,nfeature], dtype=tf.float32)\n\n<line_mask>\n        include_top=False,\n        #input_tensor=x1,\n        weights='imagenet',\n        input_shape=(224, 224, 3),\n        pooling=None\n        )\n\nmodel.compile(optimizer='adam', loss=\"mean_squared_error\", run_eagerly=True)\n\n#train_ds = [ (dummy_image_float(224,224), dummy_result(7,7,2048)) ]\nmodel.fit(dummy_image_float(224,224), dummy_result(7,7,2048), epochs=2)",
            "masked_line": "model = tf.keras.applications.ResNet101V2(",
            "answer": "applications",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_263"
        },
        {
            "dependency": "bokeh",
            "version": "<=0.12.7",
            "time": "2020-06-19",
            "description": "The code creates a scatter plot using Bokeh library to visualize the \"X\" and \"Y\" values stored in a pandas DataFrame. It sets the title and axis labels for the plot and saves the plot as an HTML file named \"scatter.html\". Finally, it displays the plot in a web browser.",
            "code": "from bokeh.plotting import figure, output_file, show\nimport pandas as pd\n\ndf = pd.DataFrame(columns=[\"X\",\"Y\"])\ndf[\"X\"] = [1,2,3,4,5]\ndf[\"Y\"] = [5,6,4,5,3]\n\np = figure(title=\"temp observations\", x_axis_label=\"Day\", y_axis_label=\"Temp\")\np.scatter(x=\"X\", y=\"Y\", source=df)\n\noutput_file(\"scatter.html\")\nshow(p)",
            "masked_code": "from bokeh.plotting import figure, output_file, show\nimport pandas as pd\n\ndf = pd.DataFrame(columns=[\"X\",\"Y\"])\ndf[\"X\"] = [1,2,3,4,5]\ndf[\"Y\"] = [5,6,4,5,3]\n\np = figure(title=\"temp observations\", x_axis_label=\"Day\", y_axis_label=\"Temp\")\np.scatter(x=\"X\", y=\"Y\", source=df)\n\n<line_mask>\nshow(p)",
            "masked_line": "output_file(\"scatter.html\")",
            "answer": "output_file",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_264"
        },
        {
            "dependency": "discord.py",
            "version": "==1.5",
            "time": "2020-10-21",
            "description": "The code sets up a bot using the Discord API with all intents enabled, allowing the bot to connect to a Discord server, receive events, and interact with users through commands specified by the given prefix.",
            "code": "import discord\n\nintents = discord.Intents.all()\n\n\nbot = discord.Client(intents=intents)\n\n# or \n\nfrom discord.ext import commands\nbot = commands.Bot(command_prefix = \".\", intents=intents)",
            "masked_code": "import discord\n\n<line_mask>\n\n\nbot = discord.Client(intents=intents)\n\n# or \n\nfrom discord.ext import commands\nbot = commands.Bot(command_prefix = \".\", intents=intents)",
            "masked_line": "intents = discord.Intents.all()",
            "answer": "all",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_265"
        },
        {
            "dependency": "PySimpleGUI",
            "version": "==4.18.0",
            "time": "2020-04-07",
            "description": "This code creates a GUI window with a text input field for entering a filename, a browse button for selecting a file, and OK and Cancel buttons. The window allows the user to input a filename and interact with the buttons.",
            "code": "import PySimpleGUI as sg\n\nsg.theme('Dark Blue 3')  # please make your creations colorful\n\nlayout = [  [sg.Text('Filename')],\n            [sg.Input(), sg.FileBrowse()], \n            [sg.OK(), sg.Cancel()]] \n\nwindow = sg.Window('Get filename example', layout)\n\nevent, values = window.Read()\nwindow.close()",
            "masked_code": "import PySimpleGUI as sg\n\nsg.theme('Dark Blue 3')  # please make your creations colorful\n\n<line_mask>\n            [sg.Input(), sg.FileBrowse()], \n            [sg.OK(), sg.Cancel()]] \n\nwindow = sg.Window('Get filename example', layout)\n\nevent, values = window.Read()\nwindow.close()",
            "masked_line": "layout = [  [sg.Text('Filename')],",
            "answer": "Text",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_266"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.x",
            "time": "2021-05-03",
            "description": "The code initializes a TensorFlow constant named 'aa' with a value of 1, and then prints out the operations and tensor associated with it from the default graph.",
            "code": "import tensorflow as tf\nprint(tf.__version__)\ntf.compat.v1.disable_eager_execution() # disable eager execution\n\na = tf.constant([1],name='aa')\nprint(tf.compat.v1.get_default_graph().get_operations())\nprint(tf.compat.v1.get_default_graph().get_tensor_by_name('aa:0'))",
            "masked_code": "import tensorflow as tf\nprint(tf.__version__)\ntf.compat.v1.disable_eager_execution() # disable eager execution\n\na = tf.constant([1],name='aa')\nprint(tf.compat.v1.get_default_graph().get_operations())\n<line_mask>",
            "masked_line": "print(tf.compat.v1.get_default_graph().get_tensor_by_name('aa:0'))",
            "answer": "get_tensor_by_name",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_267"
        },
        {
            "dependency": "pandas",
            "version": "==1.1.0",
            "time": "2020-08-07",
            "description": "This code creates a DataFrame named `asdf` with a single column labeled 'number' and two rows. It then selects all rows and the column with the label '1'.",
            "code": "import pandas as pd\ntuples = [(1,), (2,)]\ncolumns = pd.MultiIndex.from_tuples(tuples, names=['number'])\nasdf = pd.DataFrame(columns=columns, index=[0, 1])\nasdf.loc[:, (1,)]",
            "masked_code": "import pandas as pd\ntuples = [(1,), (2,)]\ncolumns = pd.MultiIndex.from_tuples(tuples, names=['number'])\n<line_mask>\nasdf.loc[:, (1,)]",
            "masked_line": "asdf = pd.DataFrame(columns=columns, index=[0, 1])",
            "answer": "DataFrame",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_268"
        },
        {
            "dependency": "networkx",
            "version": "==1.10",
            "time": "2020-05-27",
            "description": "This code generates connected components in a graph created from a dataframe where nodes are assigned to different component ids based on their connection. The output is a dictionary mapping nodes to their respective component ids.",
            "code": "import networkx as nx\n\n# Create the graph from the dataframe\ng = nx.Graph()\ng.add_edges_from(df[['id','source_id']].dropna().itertuples(index=False))\n\nconnected_components = nx.connected_components(g)\n# Find the component id of the nodes\nnode2id = {}\nfor cid, component in enumerate(connected_components):\n    for node in component:\n        node2id[node] = cid + 1\n\nprint (node2id)\n{'a6': 1, 'a5': 1, 'a1': 1, 'a2': 2, 'a4': 2, 'a8': 3, 'a3': 3}",
            "masked_code": "import networkx as nx\n\n# Create the graph from the dataframe\n<line_mask>\ng.add_edges_from(df[['id','source_id']].dropna().itertuples(index=False))\n\nconnected_components = nx.connected_components(g)\n# Find the component id of the nodes\nnode2id = {}\nfor cid, component in enumerate(connected_components):\n    for node in component:\n        node2id[node] = cid + 1\n\nprint (node2id)\n{'a6': 1, 'a5': 1, 'a1': 1, 'a2': 2, 'a4': 2, 'a8': 3, 'a3': 3}",
            "masked_line": "g = nx.Graph()",
            "answer": "Graph",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_269"
        },
        {
            "dependency": "selenium",
            "version": "==3.141.0",
            "time": "2020-02-17",
            "description": "This code opens a headless web browser with PhantomJS, sets the window size to 1920x1080, navigates to a specific url, prints the page source, and then closes the browser.",
            "code": "from selenium import webdriver\n\ndriver = webdriver.PhantomJS(executable_path=r'C:\\WebDrivers\\phantomjs.exe', service_args=['--ignore-ssl-errors=true', '--ssl-protocol=tslv1.0'])\ndriver.set_window_size(1920, 1080)\ndriver.get(\"https://account.booking.com/register?op_token=EgVvYXV0aCJ7ChQ2Wjcyb0hPZDM2Tm43emszcGlyaBIJYXV0aG9yaXplGhpodHRwczovL2FkbWluLmJvb2tpbmcuY29tLyo2eyJwYWdlIjoiL3JlZGlyZWN0LXRvLWpvaW5hcHAtbHA_bGFuZz1pdCZhaWQ9MTE4NzM2MCJ9QgRjb2RlKg4QAToAQgBY5dGK8gVgAQ\")\nprint(driver.page_source)\ndriver.quit()",
            "masked_code": "from selenium import webdriver\n\ndriver = webdriver.PhantomJS(executable_path=r'C:\\WebDrivers\\phantomjs.exe', service_args=['--ignore-ssl-errors=true', '--ssl-protocol=tslv1.0'])\ndriver.set_window_size(1920, 1080)\ndriver.get(\"https://account.booking.com/register?op_token=EgVvYXV0aCJ7ChQ2Wjcyb0hPZDM2Tm43emszcGlyaBIJYXV0aG9yaXplGhpodHRwczovL2FkbWluLmJvb2tpbmcuY29tLyo2eyJwYWdlIjoiL3JlZGlyZWN0LXRvLWpvaW5hcHAtbHA_bGFuZz1pdCZhaWQ9MTE4NzM2MCJ9QgRjb2RlKg4QAToAQgBY5dGK8gVgAQ\")\nprint(driver.page_source)\n<line_mask>",
            "masked_line": "driver.quit()",
            "answer": "quit",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_270"
        },
        {
            "dependency": "pytest-asyncio",
            "version": "==0.16.0",
            "time": "2021-11-18",
            "description": "This code defines an asynchronous test named test_simple that waits for 0.5 seconds using asyncio.sleep() function.",
            "code": "import asyncio\nimport pytest\n\npytest_plugins = ('pytest_asyncio',)\n\n@pytest.mark.asyncio\nasync def test_simple():\n    await asyncio.sleep(0.5)",
            "masked_code": "import asyncio\nimport pytest\n\npytest_plugins = ('pytest_asyncio',)\n\n@pytest.mark.asyncio\nasync def test_simple():\n    <line_mask>",
            "masked_line": "await asyncio.sleep(0.5)",
            "answer": "sleep",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_271"
        },
        {
            "dependency": "plotly",
            "version": ">=4.12",
            "time": "2021-01-22",
            "description": "The code generates a scatter plot using the iris dataset, with petal length on the x-axis and petal width on the y-axis. It adds a vertical line at x=2.5 with green dash formatting and a horizontal rectangle with red fill color and 0.2 opacity between y=0.9 and y=2.6. Finally, it displays the plot.",
            "code": "import plotly.express as px\ndf = px.data.iris()\nfig = px.scatter(df, x=\"petal_length\", y=\"petal_width\")\nfig.add_vline(x=2.5, line_width=3, line_dash=\"dash\", line_color=\"green\")\nfig.add_hrect(y0=0.9, y1=2.6, line_width=0, fillcolor=\"red\", opacity=0.2)\nfig.show()",
            "masked_code": "import plotly.express as px\ndf = px.data.iris()\nfig = px.scatter(df, x=\"petal_length\", y=\"petal_width\")\nfig.add_vline(x=2.5, line_width=3, line_dash=\"dash\", line_color=\"green\")\n<line_mask>\nfig.show()",
            "masked_line": "fig.add_hrect(y0=0.9, y1=2.6, line_width=0, fillcolor=\"red\", opacity=0.2)",
            "answer": "add_hrect",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_272"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.6",
            "time": "2022-08-31",
            "description": "The code calculates the difference between a ragged tensor X and the expanded y tensor along a new axis.",
            "code": "import tensorflow as tf # TensorFlow 2.6\nprint(\"TensorFlow version:\", tf. version )\nX = tf.ragged.constant([[[3, 1], [3]],\n                        [[2], [3, 4]]], ragged_rank=2)\ny = tf.constant([[1], [2]])\nprint(X-tf.expand_dims(y, axis=2))",
            "masked_code": "import tensorflow as tf # TensorFlow 2.6\nprint(\"TensorFlow version:\", tf. version )\n<line_mask>\n                        [[2], [3, 4]]], ragged_rank=2)\ny = tf.constant([[1], [2]])\nprint(X-tf.expand_dims(y, axis=2))",
            "masked_line": "X = tf.ragged.constant([[[3, 1], [3]],",
            "answer": "ragged",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_273"
        },
        {
            "dependency": "dash",
            "version": "==1.18.1",
            "time": "2021-01-30",
            "description": "The code creates a Dash web application with two buttons (\"Button 1\" and \"Button 2\") and a log area. When either of the buttons is clicked, it triggers a clientside callback function that updates the log area with a message saying \"Hello from [triggered button]\".",
            "code": "import dash_html_components as html\nfrom dash import Dash\nfrom dash.dependencies import Output, Input\n\n# Create app.\napp = Dash(prevent_initial_callbacks=True)\napp.layout = html.Div([\n    html.Button(\"Button 1\", id=\"btn1\"), html.Button(\"Button 2\", id=\"btn2\"), html.Div(id=\"log\")\n])\napp.clientside_callback(\n    \"\"\"\n    function(x, y){\n        const triggered = dash_clientside.callback_context.triggered.map(t => t.prop_id);\n        return \"Hello from [\" + triggered + \"]\";\n    }\n    \"\"\", Output(\"log\", \"children\"), [Input(\"btn1\", \"n_clicks\"), Input(\"btn2\", \"n_clicks\")])\n\nif __name__ == '__main__':\n    app.run_server()",
            "masked_code": "import dash_html_components as html\nfrom dash import Dash\nfrom dash.dependencies import Output, Input\n\n# Create app.\napp = Dash(prevent_initial_callbacks=True)\napp.layout = html.Div([\n    <line_mask>\n])\napp.clientside_callback(\n    \"\"\"\n    function(x, y){\n        const triggered = dash_clientside.callback_context.triggered.map(t => t.prop_id);\n        return \"Hello from [\" + triggered + \"]\";\n    }\n    \"\"\", Output(\"log\", \"children\"), [Input(\"btn1\", \"n_clicks\"), Input(\"btn2\", \"n_clicks\")])\n\nif __name__ == '__main__':\n    app.run_server()",
            "masked_line": "html.Button(\"Button 1\", id=\"btn1\"), html.Button(\"Button 2\", id=\"btn2\"), html.Div(id=\"log\")",
            "answer": "Button",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_274"
        },
        {
            "dependency": "connexion",
            "version": "==2.6.0",
            "time": "2021-07-20",
            "description": "This Python code initializes a server using the Connexion library to serve a RESTful API defined in a Swagger specification file. The server runs on the specified endpoint with JSON encoding.",
            "code": "#!/usr/bin/env python3\nimport connexion\nfrom swagger_server import encoder\n\napp = connexion.App(__name__, specification_dir='./swagger/')\napp.app.json_encoder = encoder.JSONEncoder\napp.add_api('swagger.yaml', arguments={'title': 'Docuware end point'}, pythonic_params=True)\n\nif __name__ == '__main__':\n    app.run()",
            "masked_code": "#!/usr/bin/env python3\nimport connexion\nfrom swagger_server import encoder\n\napp = connexion.App(__name__, specification_dir='./swagger/')\napp.app.json_encoder = encoder.JSONEncoder\n<line_mask>\n\nif __name__ == '__main__':\n    app.run()",
            "masked_line": "app.add_api('swagger.yaml', arguments={'title': 'Docuware end point'}, pythonic_params=True)",
            "answer": "add_api",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_275"
        },
        {
            "dependency": "pandas",
            "version": "==1.2.1",
            "time": "2021-02-10",
            "description": "The code plots a dummy dataframe 'df' with a datetime index using pandas and matplotlib. It adds vertical lines at specific dates using pandas timestamp and datetime object.",
            "code": "from datetime import datetime\nfrom matplotlib import pyplot as plt\nimport pandas as pd\n\n# dummy dataframe with a datetime index:\ndf = pd.DataFrame({'v': range(12)},\n                  index=pd.date_range('2020', periods=12, freq='MS'))\n\ndf.plot()\n# using a pandas timestamp:\nplt.axvline(pd.Timestamp(\"2020-06-01\"), color='r')\n# using a datetime object:\nplt.axvline(datetime(2020,8,1), color='g')",
            "masked_code": "from datetime import datetime\nfrom matplotlib import pyplot as plt\nimport pandas as pd\n\n# dummy dataframe with a datetime index:\ndf = pd.DataFrame({'v': range(12)},\n                  <line_mask>\n\ndf.plot()\n# using a pandas timestamp:\nplt.axvline(pd.Timestamp(\"2020-06-01\"), color='r')\n# using a datetime object:\nplt.axvline(datetime(2020,8,1), color='g')",
            "masked_line": "index=pd.date_range('2020', periods=12, freq='MS'))",
            "answer": "date_range",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_276"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.3.3",
            "time": "2021-02-10",
            "description": "The code generates a dummy dataframe with a datetime index and plots the values in the dataframe. It also adds vertical lines to the plot at specific dates using pandas timestamp and datetime object.",
            "code": "from datetime import datetime\nfrom matplotlib import pyplot as plt\nimport pandas as pd\n\n# dummy dataframe with a datetime index:\ndf = pd.DataFrame({'v': range(12)},\n                  index=pd.date_range('2020', periods=12, freq='MS'))\n\ndf.plot()\n# using a pandas timestamp:\nplt.axvline(pd.Timestamp(\"2020-06-01\"), color='r')\n# using a datetime object:\nplt.axvline(datetime(2020,8,1), color='g')",
            "masked_code": "from datetime import datetime\nfrom matplotlib import pyplot as plt\nimport pandas as pd\n\n# dummy dataframe with a datetime index:\ndf = pd.DataFrame({'v': range(12)},\n                  index=pd.date_range('2020', periods=12, freq='MS'))\n\ndf.plot()\n# using a pandas timestamp:\n<line_mask>\n# using a datetime object:\nplt.axvline(datetime(2020,8,1), color='g')",
            "masked_line": "plt.axvline(pd.Timestamp(\"2020-06-01\"), color='r')",
            "answer": "axvline",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_277"
        },
        {
            "dependency": "scipy",
            "version": "==0.19.1",
            "time": "2021-07-11",
            "description": "The code finds the nearest neighbors and distances between points in a given matrix A using a KDTree data structure from the scipy library.",
            "code": "from scipy.spatial import KDTree\n\nnonzeros = np.transpose(np.nonzero(A))\nt = KDTree(nonzeros)\ndists, nns = t.query(nonzeros, 2)\n\nfor (i, j), d in zip(nns, dists[:,1]):\n    print(nonzeros[i], \"is closest to\", nonzeros[j], \"with distance\", d)",
            "masked_code": "from scipy.spatial import KDTree\n\nnonzeros = np.transpose(np.nonzero(A))\nt = KDTree(nonzeros)\n<line_mask>\n\nfor (i, j), d in zip(nns, dists[:,1]):\n    print(nonzeros[i], \"is closest to\", nonzeros[j], \"with distance\", d)",
            "masked_line": "dists, nns = t.query(nonzeros, 2)",
            "answer": "query",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_278"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.3.2",
            "time": "2021-02-10",
            "description": "The code plots a scatter plot with x-axis values at positions [2, 15, 120] and y-axis values at [0, 0, 0]. The x-axis tick labels are formatted to have 4 digits, aligning the values to the left and filling empty spaces with nines. The title of the plot explains the formatting of the x-axis tick labels.",
            "code": "import matplotlib.pyplot as plt    # v 3.3.2\n\nx = [2, 15, 120]\ny = [0, 0, 0]\n\nfig, ax = plt.subplots(figsize=(8,4))\nax.scatter(x, y)\nax.set_xticks(x)\n\n# Format tick labels by aligning values to the left and filling space beyond\n# value precision with nines\nax.xaxis.set_major_formatter('{x:9<5.1f}')\n\ntitle = 'x-axis values are shown with 4 digits by using the x-axis major formatter'\nax.set_title(title, pad=10)\n\nplt.show()",
            "masked_code": "import matplotlib.pyplot as plt    # v 3.3.2\n\nx = [2, 15, 120]\ny = [0, 0, 0]\n\nfig, ax = plt.subplots(figsize=(8,4))\nax.scatter(x, y)\nax.set_xticks(x)\n\n# Format tick labels by aligning values to the left and filling space beyond\n# value precision with nines\n<line_mask>\n\ntitle = 'x-axis values are shown with 4 digits by using the x-axis major formatter'\nax.set_title(title, pad=10)\n\nplt.show()",
            "masked_line": "ax.xaxis.set_major_formatter('{x:9<5.1f}')",
            "answer": "xaxis",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_279"
        },
        {
            "dependency": "tqdm",
            "version": "==4.66.1",
            "time": "2021-08-03",
            "description": "The code sends a series of show commands to a networking device specified by the variable 'device', using the ConnectHandler class. The output of each command is collected and stored, and a progress bar is displayed. Finally, the message \"Done!\" is printed to indicate the completion of the process.",
            "code": "rendered_template = [\"show ip interface brief\", \"show running-config\", \"show inventory\"]\n\nwith ConnectHandler(**device) as net_connect:\n    for command in tqdm(iterable=rendered_template, unit=\"command\", desc=\"show commands\"):\n        output = net_connect.send_command(command, cmd_verify=False, read_timeout=60)\nprint(\"Done!\")",
            "masked_code": "rendered_template = [\"show ip interface brief\", \"show running-config\", \"show inventory\"]\n\nwith ConnectHandler(**device) as net_connect:\n    <line_mask>\n        output = net_connect.send_command(command, cmd_verify=False, read_timeout=60)\nprint(\"Done!\")",
            "masked_line": "for command in tqdm(iterable=rendered_template, unit=\"command\", desc=\"show commands\"):",
            "answer": "tqdm",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_280"
        },
        {
            "dependency": "Flask",
            "version": "==1.1.1",
            "time": "2021-07-20",
            "description": "The code defines a Flask endpoint that streams data by yielding chunks of \"something\" 1000 times within a generator function. The endpoint uses a decorator and context for the generator function, and is set up to stream the generated data as a response.",
            "code": "from flask import stream_with_context\n\n@app.route(\"/streamed\")\n@mydecorator\ndef streamed_endpoint():\n    def mygenerator():\n       print(\"start generator\")\n       random_function_that_need_the_decorator_context()\n       for _ in range(1000):\n          yield \"something\"\n       print(\"end generator\")\n\n    return Response(stream_with_context(mygenerator()))",
            "masked_code": "from flask import stream_with_context\n\n@app.route(\"/streamed\")\n@mydecorator\ndef streamed_endpoint():\n    def mygenerator():\n       print(\"start generator\")\n       random_function_that_need_the_decorator_context()\n       for _ in range(1000):\n          yield \"something\"\n       print(\"end generator\")\n\n    <line_mask>",
            "masked_line": "return Response(stream_with_context(mygenerator()))",
            "answer": "stream_with_context",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_281"
        },
        {
            "dependency": "pyarrow",
            "version": "==2.0.0",
            "time": "2021-02-23",
            "description": "Read a zipped shapefile from an HDFS directory, extract the shapefile, create a GeoDataFrame from the shapefile, and print the shape of the GeoDataFrame.",
            "code": "# import packages\nimport pandas as pd\nimport geopandas as gpd\nimport fiona\nimport pyarrow\n\n# establish a connection to HDFS\nfs = pyarrow.hdfs.connect()\n\n# read zipped shapefile\nwith fiona.io.ZipMemoryFile(fs.open('hdfs://my_hdfs_directory/my_zipped_shapefile.zip')) as z:\n    with z.open('my_shp_file_within_zip.shp') as collection:\n        gdf = gpd.GeoDataFrame.from_features(collection)\n        print(gdf.shape)",
            "masked_code": "# import packages\nimport pandas as pd\nimport geopandas as gpd\nimport fiona\nimport pyarrow\n\n# establish a connection to HDFS\nfs = pyarrow.hdfs.connect()\n\n# read zipped shapefile\n<line_mask>\n    with z.open('my_shp_file_within_zip.shp') as collection:\n        gdf = gpd.GeoDataFrame.from_features(collection)\n        print(gdf.shape)",
            "masked_line": "with fiona.io.ZipMemoryFile(fs.open('hdfs://my_hdfs_directory/my_zipped_shapefile.zip')) as z:",
            "answer": "open",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_282"
        },
        {
            "dependency": "fiona",
            "version": "==1.8.18",
            "time": "2021-02-23",
            "description": "This code reads a zipped shapefile from a specified HDFS directory, extracts the shapefile within the zip file, converts it to a GeoDataFrame, and then prints the shape of the GeoDataFrame.",
            "code": "# import packages\nimport pandas as pd\nimport geopandas as gpd\nimport fiona\nimport pyarrow\n\n# establish a connection to HDFS\nfs = pyarrow.hdfs.connect()\n\n# read zipped shapefile\nwith fiona.io.ZipMemoryFile(fs.open('hdfs://my_hdfs_directory/my_zipped_shapefile.zip')) as z:\n    with z.open('my_shp_file_within_zip.shp') as collection:\n        gdf = gpd.GeoDataFrame.from_features(collection)\n        print(gdf.shape)",
            "masked_code": "# import packages\nimport pandas as pd\nimport geopandas as gpd\nimport fiona\nimport pyarrow\n\n# establish a connection to HDFS\nfs = pyarrow.hdfs.connect()\n\n# read zipped shapefile\n<line_mask>\n    with z.open('my_shp_file_within_zip.shp') as collection:\n        gdf = gpd.GeoDataFrame.from_features(collection)\n        print(gdf.shape)",
            "masked_line": "with fiona.io.ZipMemoryFile(fs.open('hdfs://my_hdfs_directory/my_zipped_shapefile.zip')) as z:",
            "answer": "io",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_283"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.3.4",
            "time": "2021-02-03",
            "description": "The code generates a bar plot comparing the probability of an event S and the conditional probability of event S given event X for different values of event S. The plot is displayed using matplotlib.",
            "code": "from matplotlib import pyplot as plt\nimport pandas as pd\n\n\nif __name__ == '__main__':\n    s = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6]\n    p_s = [0.05, 0.15, 0.20, 0.30, 0.20, 0.10]\n    p_s_x = [0.06005163309361129, 0.4378503494734475,0.3489460783665687,0.1404287057633398,0.012362455732360653,0.00036077757067209113]\n    \n    df_to_plot = pd.DataFrame(data={\"P(S)\": p_s,\n                                    \"P(S|X)\": p_s_x,\n                                    \"S\": s})\n    \n    df_to_plot.plot.bar(y=['P(S)', 'P(S|X)'],\n                    x='S',\n                    alpha=0.7,\n                    color=['red', 'green'],\n                    figsize=(8,5))\n    plt.show()",
            "masked_code": "from matplotlib import pyplot as plt\nimport pandas as pd\n\n\nif __name__ == '__main__':\n    s = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6]\n    p_s = [0.05, 0.15, 0.20, 0.30, 0.20, 0.10]\n    p_s_x = [0.06005163309361129, 0.4378503494734475,0.3489460783665687,0.1404287057633398,0.012362455732360653,0.00036077757067209113]\n    \n    df_to_plot = pd.DataFrame(data={\"P(S)\": p_s,\n                                    \"P(S|X)\": p_s_x,\n                                    \"S\": s})\n    \n    df_to_plot.plot.bar(y=['P(S)', 'P(S|X)'],\n                    x='S',\n                    alpha=0.7,\n                    color=['red', 'green'],\n                    figsize=(8,5))\n    <line_mask>",
            "masked_line": "plt.show()",
            "answer": "show",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_284"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.4",
            "time": "2021-03-24",
            "description": "This code defines a TensorFlow function that uses a GradientTape to calculate gradients for the trainable weights of a TensorFlow model named \"encode\" using some input data. Then, it prints the output of the model for the input data.",
            "code": "import numpy as np\n\ndata = np.zeros((1, 4))\n\n@tf.function\ndef run():\n    with tf.GradientTape( watch_accessed_variables=False) as tape:\n        tape.watch(encode.trainable_weights)\n        y = encode([data, data, data], training=True)\n    tf.print(y)\n\nrun()\n\n# [[-0.799545228]]",
            "masked_code": "import numpy as np\n\ndata = np.zeros((1, 4))\n\n@tf.function\ndef run():\n    with tf.GradientTape( watch_accessed_variables=False) as tape:\n        tape.watch(encode.trainable_weights)\n        y = encode([data, data, data], training=True)\n    <line_mask>\n\nrun()\n\n# [[-0.799545228]]",
            "masked_line": "tf.print(y)",
            "answer": "print",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_285"
        },
        {
            "dependency": "pandas",
            "version": "==1.1.3",
            "time": "2021-02-26",
            "description": "This code reads a dataset from a CSV file, converts the 'date' column to datetime format, creates a bar plot with 'date' on the x-axis and 'tickqty' on the y-axis, formats the x-axis to display time in hours and minutes, and displays the plot.",
            "code": "import pandas as pd                # v 1.1.3\nimport matplotlib.pyplot as plt    # v 3.3.2\nimport matplotlib.dates as mdates\n\ndataset = pd.read_csv('data.csv')\ndataset['date'] = pd.to_datetime(dataset['date'])\nplt.bar(dataset['date'], dataset['tickqty'], width=0.002)\nplt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%H:%M'))\nplt.show()",
            "masked_code": "import pandas as pd                # v 1.1.3\nimport matplotlib.pyplot as plt    # v 3.3.2\nimport matplotlib.dates as mdates\n\n<line_mask>\ndataset['date'] = pd.to_datetime(dataset['date'])\nplt.bar(dataset['date'], dataset['tickqty'], width=0.002)\nplt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%H:%M'))\nplt.show()",
            "masked_line": "dataset = pd.read_csv('data.csv')",
            "answer": "read_csv",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_286"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.3.2",
            "time": "2021-02-26",
            "description": "The code reads a dataset from a CSV file, converts the 'date' column to datetime format, and then plots a bar chart showing the 'tickqty' values against the 'date' values. The x-axis of the plot is formatted to display hours and minutes. Finally, the plot is displayed.",
            "code": "import pandas as pd                # v 1.1.3\nimport matplotlib.pyplot as plt    # v 3.3.2\nimport matplotlib.dates as mdates\n\ndataset = pd.read_csv('data.csv')\ndataset['date'] = pd.to_datetime(dataset['date'])\nplt.bar(dataset['date'], dataset['tickqty'], width=0.002)\nplt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%H:%M'))\nplt.show()",
            "masked_code": "import pandas as pd                # v 1.1.3\nimport matplotlib.pyplot as plt    # v 3.3.2\nimport matplotlib.dates as mdates\n\ndataset = pd.read_csv('data.csv')\ndataset['date'] = pd.to_datetime(dataset['date'])\n<line_mask>\nplt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%H:%M'))\nplt.show()",
            "masked_line": "plt.bar(dataset['date'], dataset['tickqty'], width=0.002)",
            "answer": "bar",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_287"
        },
        {
            "dependency": "requests",
            "version": "==2.26.0",
            "time": "2021-12-13",
            "description": "The code sends a GET request to the specified URL 'https://www.overstock.com/api/product.json?prod_id=10897789', using the provided headers, and retrieves the JSON response from the server. Finally, it prints the JSON data to the console.",
            "code": "import requests\n\nheaders = {\n    'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 11_5) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.1.2 Safari/605.1.15',\n    'Accept': 'application/json',\n    'Connection': 'keep-alive',\n    'Accept-Encoding': 'gzip, deflate, br'\n}\n\n\nwith requests.Session() as session:\n    (r := session.get('https://www.overstock.com/api/product.json?prod_id=10897789', headers=headers)).raise_for_status()\n    print(r.json())",
            "masked_code": "import requests\n\nheaders = {\n    'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 11_5) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.1.2 Safari/605.1.15',\n    'Accept': 'application/json',\n    'Connection': 'keep-alive',\n    'Accept-Encoding': 'gzip, deflate, br'\n}\n\n\n<line_mask>\n    (r := session.get('https://www.overstock.com/api/product.json?prod_id=10897789', headers=headers)).raise_for_status()\n    print(r.json())",
            "masked_line": "with requests.Session() as session:",
            "answer": "Session",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_288"
        },
        {
            "dependency": "scipy",
            "version": "==1.6.0",
            "time": "2021-02-04",
            "description": "The code loads a MATLAB file called 'CameraParams.mat' using scipy.io, iterates over the key-value pairs in the loaded data, and prints out the key, type, and value. If the value is a numpy array, it prints ' --> Numpy array'.",
            "code": "import scipy.io as sio\nimport numpy as np\n\nMat = sio.loadmat('CameraParams.mat')\n\nfor k, v in Mat.items():\n    print(\"\\n\\n\", k, type(v), v)\n    if isinstance(v, np.ndarray):  # Numpy array?\n        print(' --> Numpy array')",
            "masked_code": "import scipy.io as sio\nimport numpy as np\n\n<line_mask>\n\nfor k, v in Mat.items():\n    print(\"\\n\\n\", k, type(v), v)\n    if isinstance(v, np.ndarray):  # Numpy array?\n        print(' --> Numpy array')",
            "masked_line": "Mat = sio.loadmat('CameraParams.mat')",
            "answer": "loadmat",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_289"
        },
        {
            "dependency": "pandas",
            "version": "==1.2.0",
            "time": "2021-02-02",
            "description": "This code generates a new dataframe by combining and filling missing values from the original dataframe based on instance ID, timestamp, CPU load, and memory load columns.",
            "code": "import pandas as pd\nimport io\nimport datetime as dt\nimport numpy as np\ndf = pd.read_csv(io.StringIO(\"\"\"id  creTimestamp    CPULoad instnceId\n0   2021-01-22 18:00:00 22.0    instanceA\n1   2021-01-22 19:00:00 22.0    instanceA\n2   2021-01-22 20:00:00 23.0    instanceB\n3   2021-01-23 18:00:00 24.0    instanceA\n4   2021-01-23 20:00:00 22.0    instanceA\n5   2021-01-24 18:00:00 23.0    instanceB\n6   2021-01-24 20:00:00 23.5    instanceA\n\"\"\"), sep=\"\\t\", index_col=0)\n\ndf.creTimestamp = pd.to_datetime(df.creTimestamp)\ndf[\"memload\"] = np.random.random(len(df))\n\n# generate a DF for each time in instance in each date\ndf2 = (pd.merge(\n    # for each time in instance\n    df.assign(timestamp=df.creTimestamp.dt.time)\n        .loc[:,[\"instnceId\",\"timestamp\"]]\n        .drop_duplicates()\n        .assign(foo=1),\n    # for each date\n    df.creTimestamp.dt.date.drop_duplicates().to_frame().assign(foo=1),\n    on=\"foo\"\n).assign(creTimestamp=lambda dfa: dfa.apply(lambda r: dt.datetime.combine(r[\"creTimestamp\"], r[\"timestamp\"]), axis=1))\n .drop(columns=\"foo\")\n       # merge values back..\n .merge(df, on=[\"creTimestamp\", \"instnceId\"], how=\"left\")\n)\n\n# now get values to fill NaN\ndf2 = (df2.merge(df2.dropna().drop_duplicates(subset=[\"instnceId\",\"timestamp\"], keep=\"last\"),\n         on=[\"timestamp\",\"instnceId\"], suffixes=(\"\",\"_pre\"))\n .assign(CPULoad=lambda dfa: dfa.CPULoad.fillna(dfa.CPULoad_pre))\n .assign(memload=lambda dfa: dfa.memload.fillna(dfa.memload_pre))\n\n)",
            "masked_code": "import pandas as pd\nimport io\nimport datetime as dt\nimport numpy as np\ndf = pd.read_csv(io.StringIO(\"\"\"id  creTimestamp    CPULoad instnceId\n0   2021-01-22 18:00:00 22.0    instanceA\n1   2021-01-22 19:00:00 22.0    instanceA\n2   2021-01-22 20:00:00 23.0    instanceB\n3   2021-01-23 18:00:00 24.0    instanceA\n4   2021-01-23 20:00:00 22.0    instanceA\n5   2021-01-24 18:00:00 23.0    instanceB\n6   2021-01-24 20:00:00 23.5    instanceA\n\"\"\"), sep=\"\\t\", index_col=0)\n\n<line_mask>\ndf[\"memload\"] = np.random.random(len(df))\n\n# generate a DF for each time in instance in each date\ndf2 = (pd.merge(\n    # for each time in instance\n    df.assign(timestamp=df.creTimestamp.dt.time)\n        .loc[:,[\"instnceId\",\"timestamp\"]]\n        .drop_duplicates()\n        .assign(foo=1),\n    # for each date\n    df.creTimestamp.dt.date.drop_duplicates().to_frame().assign(foo=1),\n    on=\"foo\"\n).assign(creTimestamp=lambda dfa: dfa.apply(lambda r: dt.datetime.combine(r[\"creTimestamp\"], r[\"timestamp\"]), axis=1))\n .drop(columns=\"foo\")\n       # merge values back..\n .merge(df, on=[\"creTimestamp\", \"instnceId\"], how=\"left\")\n)\n\n# now get values to fill NaN\ndf2 = (df2.merge(df2.dropna().drop_duplicates(subset=[\"instnceId\",\"timestamp\"], keep=\"last\"),\n         on=[\"timestamp\",\"instnceId\"], suffixes=(\"\",\"_pre\"))\n .assign(CPULoad=lambda dfa: dfa.CPULoad.fillna(dfa.CPULoad_pre))\n .assign(memload=lambda dfa: dfa.memload.fillna(dfa.memload_pre))\n\n)",
            "masked_line": "df.creTimestamp = pd.to_datetime(df.creTimestamp)",
            "answer": "to_datetime",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_290"
        },
        {
            "dependency": "apache-airflow",
            "version": "==1.10.15",
            "time": "2021-10-21",
            "description": "The code defines an Airflow DAG named \"parquet_load_to_bq\" that creates an external table in Google BigQuery from a Parquet file stored in a bucket. The DAG runs daily and includes tasks to create the external table and print the DAG run configuration in the Airflow logs.",
            "code": "import datetime\nimport airflow\nfrom airflow.operators import bash_operator\nfrom airflow.providers.google.cloud.operators.bigquery import BigQueryCreateExternalTableOperator\n\nYESTERDAY = datetime.datetime.now() - datetime.timedelta(days=1)\n\ndefault_args = {\n    'owner': 'Composer Example',\n    'depends_on_past': False,\n    'email': [''],\n    'email_on_failure': False,\n    'email_on_retry': False,\n    'retries': 1,\n    'retry_delay': datetime.timedelta(minutes=5),\n    'start_date': YESTERDAY,\n}\n\nwith airflow.DAG(\n        'parquet_load_to_bq',\n        'catchup=False',\n        default_args=default_args,\n        schedule_interval=datetime.timedelta(days=1)) as dag:\n\n    create_imp_external_table = BigQueryCreateExternalTableOperator(\n        task_id=f\"create_imp_external_table\",\n        bucket='my-bucket',\n        source_objects=[\"/data/userdata1.parquet\"], #pass a list\n        destination_project_dataset_table=f\"my-project.my_dataset.parquet_table\",\n        source_format='PARQUET', #use source_format instead of file_format\n    )\n\n    # Print the dag_run id from the Airflow logs\n    print_dag_run_conf = bash_operator.BashOperator(\n        task_id='print_dag_run_conf', bash_command='echo {{ dag_run.id }}')\n\ncreate_imp_external_table >> print_dag_run_conf",
            "masked_code": "import datetime\nimport airflow\nfrom airflow.operators import bash_operator\nfrom airflow.providers.google.cloud.operators.bigquery import BigQueryCreateExternalTableOperator\n\nYESTERDAY = datetime.datetime.now() - datetime.timedelta(days=1)\n\ndefault_args = {\n    'owner': 'Composer Example',\n    'depends_on_past': False,\n    'email': [''],\n    'email_on_failure': False,\n    'email_on_retry': False,\n    'retries': 1,\n    'retry_delay': datetime.timedelta(minutes=5),\n    'start_date': YESTERDAY,\n}\n\nwith airflow.DAG(\n        'parquet_load_to_bq',\n        'catchup=False',\n        default_args=default_args,\n        schedule_interval=datetime.timedelta(days=1)) as dag:\n\n    create_imp_external_table = BigQueryCreateExternalTableOperator(\n        task_id=f\"create_imp_external_table\",\n        bucket='my-bucket',\n        source_objects=[\"/data/userdata1.parquet\"], #pass a list\n        destination_project_dataset_table=f\"my-project.my_dataset.parquet_table\",\n        source_format='PARQUET', #use source_format instead of file_format\n    )\n\n    # Print the dag_run id from the Airflow logs\n    <line_mask>\n        task_id='print_dag_run_conf', bash_command='echo {{ dag_run.id }}')\n\ncreate_imp_external_table >> print_dag_run_conf",
            "masked_line": "print_dag_run_conf = bash_operator.BashOperator(",
            "answer": "BashOperator",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_291"
        },
        {
            "dependency": "pandas",
            "version": ">=1.5.0",
            "time": "2022-10-25",
            "description": "This code snippet updates the values in the first column of a Pandas DataFrame with new values stored in a NumPy array, while ignoring a future warning related to setting values in-place in Pandas.",
            "code": "import numpy as np\nimport pandas as pd\nimport warnings\n\ndf = pd.DataFrame({\"price\": [11.1, 12.2]}, index=[\"book1\", \"book2\"])\noriginal_prices = df[\"price\"]\nnew_prices = np.array([98, 99])\nwith warnings.catch_warnings():\n    # Setting values in-place is fine, ignore the warning in Pandas >= 1.5.0\n    # This can be removed, if Pandas 1.5.0 does not need to be supported any longer.\n    # See also: https://stackoverflow.com/q/74057367/859591\n    warnings.filterwarnings(\n        \"ignore\",\n        category=FutureWarning,\n        message=(\n            \".*will attempt to set the values inplace instead of always setting a new array. \"\n            \"To retain the old behavior, use either.*\"\n        ),\n    )\n\n    df.iloc[:, 0] = new_prices\n\ndf.iloc[:, 0]",
            "masked_code": "import numpy as np\nimport pandas as pd\nimport warnings\n\n<line_mask>\noriginal_prices = df[\"price\"]\nnew_prices = np.array([98, 99])\nwith warnings.catch_warnings():\n    # Setting values in-place is fine, ignore the warning in Pandas >= 1.5.0\n    # This can be removed, if Pandas 1.5.0 does not need to be supported any longer.\n    # See also: https://stackoverflow.com/q/74057367/859591\n    warnings.filterwarnings(\n        \"ignore\",\n        category=FutureWarning,\n        message=(\n            \".*will attempt to set the values inplace instead of always setting a new array. \"\n            \"To retain the old behavior, use either.*\"\n        ),\n    )\n\n    df.iloc[:, 0] = new_prices\n\ndf.iloc[:, 0]",
            "masked_line": "df = pd.DataFrame({\"price\": [11.1, 12.2]}, index=[\"book1\", \"book2\"])",
            "answer": "DataFrame",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_292"
        },
        {
            "dependency": "hypothesis",
            "version": "==6.48.1",
            "time": "2022-06-28",
            "description": "The code defines a fixture named 'stuff' that returns the string \"kittens\". It also defines a test function 'test_stuff' that takes two arguments 'a' and 'stuff'. The test asserts that 'a' is None and that 'stuff' is equal to \"kittens\".",
            "code": "from hypothesis import given, strategies as st, settings, HealthCheck\nfrom pytest import fixture\n\n\n@fixture\ndef stuff():\n    return \"kittens\"\n\n\n@given(a=st.none())\n@settings(suppress_health_check=[HealthCheck.function_scoped_fixture])\ndef test_stuff(a, stuff):\n    assert a is None\n    assert stuff == \"kittens\"",
            "masked_code": "<line_mask>\nfrom pytest import fixture\n\n\n@fixture\ndef stuff():\n    return \"kittens\"\n\n\n@given(a=st.none())\n@settings(suppress_health_check=[HealthCheck.function_scoped_fixture])\ndef test_stuff(a, stuff):\n    assert a is None\n    assert stuff == \"kittens\"",
            "masked_line": "from hypothesis import given, strategies as st, settings, HealthCheck",
            "answer": "settings",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_293"
        },
        {
            "dependency": "geopandas",
            "version": ">=0.11",
            "time": "2022-09-14",
            "description": "The code reads two geospatial datasets from online sources, shards the second dataset into a dictionary based on a specified attribute, and then performs a spatial join operation based on the attribute values between the two datasets to create a new dataset.",
            "code": "import geopandas as gpd\n\n\ndf1 = gpd.read_file(\"https://github.com/gracedoherty/urban_growth/blob/main/df1.zip?raw=true\")\ndf2 = gpd.read_file(\"https://github.com/gracedoherty/urban_growth/blob/main/df2.zip?raw=true\")\n\n# shard the smaller dataframe into a dict\nshards = {k:d for k, d in df2.groupby(\"ADM\")}\n\n# now just group by ADM, sjoin_nearest appropriate shard\ndf_n = df1.groupby(\"ADM\").apply(lambda d: gpd.sjoin_nearest(d, shards[d[\"ADM\"].values[0]]))\n\ndf_n.sample(5, random_state=42)",
            "masked_code": "import geopandas as gpd\n\n\ndf1 = gpd.read_file(\"https://github.com/gracedoherty/urban_growth/blob/main/df1.zip?raw=true\")\ndf2 = gpd.read_file(\"https://github.com/gracedoherty/urban_growth/blob/main/df2.zip?raw=true\")\n\n# shard the smaller dataframe into a dict\n<line_mask>\n\n# now just group by ADM, sjoin_nearest appropriate shard\ndf_n = df1.groupby(\"ADM\").apply(lambda d: gpd.sjoin_nearest(d, shards[d[\"ADM\"].values[0]]))\n\ndf_n.sample(5, random_state=42)",
            "masked_line": "shards = {k:d for k, d in df2.groupby(\"ADM\")}",
            "answer": "groupby",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_294"
        },
        {
            "dependency": "numba",
            "version": "==0.55.1",
            "time": "2022-04-07",
            "description": "The function fills a 2D array with values based on column indices provided.",
            "code": "import numba as nb\n\n@nb.njit(parallel=False) # Try parallel=True for multi-threaded execution, no speed up in my benchmarks \ndef fill(val, ids):\n    res = np.zeros(ids.shape[::-1])\n    for i in nb.prange(len(res)):\n        for j in range(res.shape[1]):\n            res[i, ids[j,i]] += val[j]\n    return res\n\nfill(values, col_ids)",
            "masked_code": "import numba as nb\n\n@nb.njit(parallel=False) # Try parallel=True for multi-threaded execution, no speed up in my benchmarks \ndef fill(val, ids):\n    res = np.zeros(ids.shape[::-1])\n    <line_mask>\n        for j in range(res.shape[1]):\n            res[i, ids[j,i]] += val[j]\n    return res\n\nfill(values, col_ids)",
            "masked_line": "for i in nb.prange(len(res)):",
            "answer": "prange",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_295"
        },
        {
            "dependency": "click",
            "version": "==8.1.x",
            "time": "2022-08-22",
            "description": "This code is testing the functionality of listing all \"foos\" with a specific command by using Click library for command line interfaces in Python.",
            "code": "from click.testing import CliRunner\n# ...\n\n\ndef test_foo_list():\n    runner = CliRunner()\n    result = runner.invoke(commands.get_all_foos, [\"ctm\", \"10\"])\n    response = result.return_value",
            "masked_code": "from click.testing import CliRunner\n# ...\n\n\ndef test_foo_list():\n    runner = CliRunner()\n    <line_mask>\n    response = result.return_value",
            "masked_line": "result = runner.invoke(commands.get_all_foos, [\"ctm\", \"10\"])",
            "answer": "invoke",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_296"
        },
        {
            "dependency": "pandas",
            "version": "==1.4.1",
            "time": "2022-04-12",
            "description": "This code creates two DataFrames, df and df1, where df contains columns 'poi_name', 'column_1', 'column_2', 'column_3', 'column_4' and df1 contains columns 'poi_name', 'column_1', 'column_3', 'column_5'. Both DataFrames are then set_index to 'poi_name' and filled with values from df1 where there are missing values in df. Finally, the filled DataFrame df is printed.",
            "code": "from numpy import nan\ndf = pd.DataFrame({'poi_name': ['block', 'block'],\n                   'column_1': ['uts', 'utr'],\n                   'column_2': [nan, nan],\n                   'column_3': [nan, nan],\n                   'column_4': ['tyi', 'tyi']})\n\ndf1 = pd.DataFrame({'poi_name': ['block'],\n                    'column_1': ['uta'],\n                    'column_3': ['yuw'],\n                    'column_5': ['tyu']})\n\ndf = df.set_index('poi_name')\ndf1 = df1.set_index('poi_name')\ndf = df.fillna(df1)\n\nprint(df)",
            "masked_code": "from numpy import nan\ndf = pd.DataFrame({'poi_name': ['block', 'block'],\n                   'column_1': ['uts', 'utr'],\n                   'column_2': [nan, nan],\n                   'column_3': [nan, nan],\n                   'column_4': ['tyi', 'tyi']})\n\n<line_mask>\n                    'column_1': ['uta'],\n                    'column_3': ['yuw'],\n                    'column_5': ['tyu']})\n\ndf = df.set_index('poi_name')\ndf1 = df1.set_index('poi_name')\ndf = df.fillna(df1)\n\nprint(df)",
            "masked_line": "df1 = pd.DataFrame({'poi_name': ['block'],",
            "answer": "DataFrame",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_297"
        },
        {
            "dependency": "streamlit",
            "version": "==1.14.0",
            "time": "2022-11-01",
            "description": "The code generates a bar chart using the Altair library in Streamlit, where the data is grouped based on date and group, and the counts are displayed on the y-axis for each group.",
            "code": "import streamlit as st #version 1.14.0\nimport pandas as pd    #version 1.5.1\nimport altair as alt   #version 4.2.0\n\ndf=pd.DataFrame({'mydate':pd.date_range(start='1/1/2020', end='4/09/2020').repeat(10),\n  'mygroup':pd.Series([\"A\", \"B\", \"C\"]).sample(n=1000, replace=True)})\n\ndf['mydate2'] = df['mydate'].dt.strftime('%Y-%m-15')\ndf2 = df.groupby(by=['mydate2', 'mygroup']).count().reset_index().rename(columns={'mydate': 'counts'})\n\nc = alt.Chart(df2, width=75, height=200).mark_bar(size=20).encode(\n  x='mygroup:N',\n  y='counts:Q',\n  facet='month(mydate2):O',\n  color='mygroup:N'\n).configure_header(labelOrient='bottom',\n                    labelPadding = 3).configure_facet(spacing=5\n )\nst.altair_chart(c) #, use_container_width=True)",
            "masked_code": "import streamlit as st #version 1.14.0\nimport pandas as pd    #version 1.5.1\nimport altair as alt   #version 4.2.0\n\ndf=pd.DataFrame({'mydate':pd.date_range(start='1/1/2020', end='4/09/2020').repeat(10),\n  'mygroup':pd.Series([\"A\", \"B\", \"C\"]).sample(n=1000, replace=True)})\n\ndf['mydate2'] = df['mydate'].dt.strftime('%Y-%m-15')\ndf2 = df.groupby(by=['mydate2', 'mygroup']).count().reset_index().rename(columns={'mydate': 'counts'})\n\nc = alt.Chart(df2, width=75, height=200).mark_bar(size=20).encode(\n  x='mygroup:N',\n  y='counts:Q',\n  facet='month(mydate2):O',\n  color='mygroup:N'\n).configure_header(labelOrient='bottom',\n                    labelPadding = 3).configure_facet(spacing=5\n )\n<line_mask>",
            "masked_line": "st.altair_chart(c) #, use_container_width=True)",
            "answer": "altair_chart",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_298"
        },
        {
            "dependency": "pandas",
            "version": "==1.5.1",
            "time": "2022-11-01",
            "description": "The code creates a DataFrame with columns 'mydate', 'mygroup' and 'mydate2' by generating dates and groups. It then groups the data by 'mydate2' and 'mygroup', counts the occurrences, and visualizes the data using Altair with a bar chart showing the count of each group per month on the x-axis and the number of occurrences on the y-axis.",
            "code": "import streamlit as st #version 1.14.0\nimport pandas as pd    #version 1.5.1\nimport altair as alt   #version 4.2.0\n\ndf=pd.DataFrame({'mydate':pd.date_range(start='1/1/2020', end='4/09/2020').repeat(10),\n  'mygroup':pd.Series([\"A\", \"B\", \"C\"]).sample(n=1000, replace=True)})\n\ndf['mydate2'] = df['mydate'].dt.strftime('%Y-%m-15')\ndf2 = df.groupby(by=['mydate2', 'mygroup']).count().reset_index().rename(columns={'mydate': 'counts'})\n\nc = alt.Chart(df2, width=75, height=200).mark_bar(size=20).encode(\n  x='mygroup:N',\n  y='counts:Q',\n  facet='month(mydate2):O',\n  color='mygroup:N'\n).configure_header(labelOrient='bottom',\n                    labelPadding = 3).configure_facet(spacing=5\n )\nst.altair_chart(c) #, use_container_width=True)",
            "masked_code": "import streamlit as st #version 1.14.0\nimport pandas as pd    #version 1.5.1\nimport altair as alt   #version 4.2.0\n\ndf=pd.DataFrame({'mydate':pd.date_range(start='1/1/2020', end='4/09/2020').repeat(10),\n  'mygroup':pd.Series([\"A\", \"B\", \"C\"]).sample(n=1000, replace=True)})\n\ndf['mydate2'] = df['mydate'].dt.strftime('%Y-%m-15')\n<line_mask>\n\nc = alt.Chart(df2, width=75, height=200).mark_bar(size=20).encode(\n  x='mygroup:N',\n  y='counts:Q',\n  facet='month(mydate2):O',\n  color='mygroup:N'\n).configure_header(labelOrient='bottom',\n                    labelPadding = 3).configure_facet(spacing=5\n )\nst.altair_chart(c) #, use_container_width=True)",
            "masked_line": "df2 = df.groupby(by=['mydate2', 'mygroup']).count().reset_index().rename(columns={'mydate': 'counts'})",
            "answer": "reset_index",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_299"
        },
        {
            "dependency": "altair",
            "version": "==4.2.0",
            "time": "2022-11-01",
            "description": "The code generates a bar chart using Altair to display the count of occurrences of different groups over time. The chart uses a DataFrame that includes dates, groups, and counts, and it groups the data by a specific date format. The chart is displayed using Streamlit.",
            "code": "import streamlit as st #version 1.14.0\nimport pandas as pd    #version 1.5.1\nimport altair as alt   #version 4.2.0\n\ndf=pd.DataFrame({'mydate':pd.date_range(start='1/1/2020', end='4/09/2020').repeat(10),\n  'mygroup':pd.Series([\"A\", \"B\", \"C\"]).sample(n=1000, replace=True)})\n\ndf['mydate2'] = df['mydate'].dt.strftime('%Y-%m-15')\ndf2 = df.groupby(by=['mydate2', 'mygroup']).count().reset_index().rename(columns={'mydate': 'counts'})\n\nc = alt.Chart(df2, width=75, height=200).mark_bar(size=20).encode(\n  x='mygroup:N',\n  y='counts:Q',\n  facet='month(mydate2):O',\n  color='mygroup:N'\n).configure_header(labelOrient='bottom',\n                    labelPadding = 3).configure_facet(spacing=5\n )\nst.altair_chart(c) #, use_container_width=True)",
            "masked_code": "import streamlit as st #version 1.14.0\nimport pandas as pd    #version 1.5.1\nimport altair as alt   #version 4.2.0\n\ndf=pd.DataFrame({'mydate':pd.date_range(start='1/1/2020', end='4/09/2020').repeat(10),\n  'mygroup':pd.Series([\"A\", \"B\", \"C\"]).sample(n=1000, replace=True)})\n\ndf['mydate2'] = df['mydate'].dt.strftime('%Y-%m-15')\ndf2 = df.groupby(by=['mydate2', 'mygroup']).count().reset_index().rename(columns={'mydate': 'counts'})\n\n<line_mask>\n  x='mygroup:N',\n  y='counts:Q',\n  facet='month(mydate2):O',\n  color='mygroup:N'\n).configure_header(labelOrient='bottom',\n                    labelPadding = 3).configure_facet(spacing=5\n )\nst.altair_chart(c) #, use_container_width=True)",
            "masked_line": "c = alt.Chart(df2, width=75, height=200).mark_bar(size=20).encode(",
            "answer": "mark_bar",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_300"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.5.2",
            "time": "2022-07-01",
            "description": "The code creates a scatter plot using matplotlib library, where x and y values are plotted with different colors indicated by the z values. The plot has customized features like linewidths, alpha, edgecolor, and size. The plot includes a legend indicating the colors used in the plot.",
            "code": "import matplotlib.pyplot as plt\n\nx = [1, 2, 3, 4, 5]\ny = [1, 2, 3, 4, 5]\nz = [3, 8.5, 2.1, 1.8, 9]\n\nfig1, ax1 = plt.subplots()\nscat = ax1.scatter(x, y, linewidths=1, alpha = .7, edgecolor= 'k', s=200, c=z)\nax1.legend(*scat.legend_elements(), title=\"Colors\")\n\nplt.show()",
            "masked_code": "import matplotlib.pyplot as plt\n\nx = [1, 2, 3, 4, 5]\ny = [1, 2, 3, 4, 5]\nz = [3, 8.5, 2.1, 1.8, 9]\n\nfig1, ax1 = plt.subplots()\nscat = ax1.scatter(x, y, linewidths=1, alpha = .7, edgecolor= 'k', s=200, c=z)\n<line_mask>\n\nplt.show()",
            "masked_line": "ax1.legend(*scat.legend_elements(), title=\"Colors\")",
            "answer": "legend",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_301"
        },
        {
            "dependency": "datasets",
            "version": "==1.1.1",
            "time": "2022-12-13",
            "description": "The code creates a dataset object containing 100 images with each image represented as a 512x512x3 tensor and associated with the caption 'hello'.",
            "code": "img_tensor = np.zeros((100, 512, 512, 3))\ncaptions = []\nfor i in range(100):\n  captions.append('hello')\ncaptioned_imgs = {\n    'images': img_tensor,\n    'text': captions\n}\nfrom datasets import Dataset\nout = Dataset.from_dict(captioned_imgs)\nprint(type(out))",
            "masked_code": "img_tensor = np.zeros((100, 512, 512, 3))\ncaptions = []\nfor i in range(100):\n  captions.append('hello')\ncaptioned_imgs = {\n    'images': img_tensor,\n    'text': captions\n}\nfrom datasets import Dataset\n<line_mask>\nprint(type(out))",
            "masked_line": "out = Dataset.from_dict(captioned_imgs)",
            "answer": "from_dict",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_302"
        },
        {
            "dependency": "pandas",
            "version": "==1.5.2",
            "time": "2022-11-29",
            "description": "This code creates a DataFrame with columns \"weight_KG\", \"UpperBoundary\", and \"LowerBoundary\" using lists of values. It then filters the DataFrame to select rows where the \"weight_KG\" value is within the range defined by the \"UpperBoundary\" and \"LowerBoundary\" columns. Finally, it prints the filtered DataFrame and the version of pandas used.",
            "code": "import pandas as pd\n\n# Build DataFrame\nnames = [\"weight_KG\", \"UpperBoundary\", \"LowerBoundary\"]\nweight_KG = [23.2, 55.2, 44.2, 47.8, 38.7, 0]\nUpperBoundary = [30, 40, 50, 50, 30, 20]\nLowerBoundary = [20, 30, 40, 40, 20, 10]\n\ndict = {\n    \"weight_KG\": weight_KG,\n    \"UpperBoundary\": UpperBoundary,\n    \"LowerBoundary\": LowerBoundary,\n}\ndf1 = pd.DataFrame(dict)\n\ndf2 = df1[\n    (df1[\"weight_KG\"] <= df1[\"UpperBoundary\"])\n    & (df1[\"weight_KG\"] >= df1[\"LowerBoundary\"])\n]\nprint(df2)\nprint(pd.__version__)",
            "masked_code": "import pandas as pd\n\n# Build DataFrame\nnames = [\"weight_KG\", \"UpperBoundary\", \"LowerBoundary\"]\nweight_KG = [23.2, 55.2, 44.2, 47.8, 38.7, 0]\nUpperBoundary = [30, 40, 50, 50, 30, 20]\nLowerBoundary = [20, 30, 40, 40, 20, 10]\n\ndict = {\n    \"weight_KG\": weight_KG,\n    \"UpperBoundary\": UpperBoundary,\n    \"LowerBoundary\": LowerBoundary,\n}\n<line_mask>\n\ndf2 = df1[\n    (df1[\"weight_KG\"] <= df1[\"UpperBoundary\"])\n    & (df1[\"weight_KG\"] >= df1[\"LowerBoundary\"])\n]\nprint(df2)\nprint(pd.__version__)",
            "masked_line": "df1 = pd.DataFrame(dict)",
            "answer": "DataFrame",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_303"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.15.2",
            "time": "2022-03-08",
            "description": "The code defines an input layer with a shape of (3, 2, 4) using TensorFlow's Keras API, and then creates a prediction layer by flattening the input layer. Finally, it prints the shapes of the input and prediction layers.",
            "code": "import tensorflow as tf\nprint(tf.__version__)\ninputs = tf.keras.layers.Input(shape=(3,2,4))\nprediction = tf.keras.layers.Flatten()(inputs)\nprint(inputs.shape, prediction.shape)",
            "masked_code": "import tensorflow as tf\nprint(tf.__version__)\ninputs = tf.keras.layers.Input(shape=(3,2,4))\n<line_mask>\nprint(inputs.shape, prediction.shape)",
            "masked_line": "prediction = tf.keras.layers.Flatten()(inputs)",
            "answer": "Flatten",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_304"
        },
        {
            "dependency": "mss",
            "version": "==7.0.1",
            "time": "2022-12-20",
            "description": "This code creates a Tkinter window and initializes a mss object. It runs the Tkinter main loop indefinitely, and closes the mss object when the window is closed.",
            "code": "import tkinter as tk\nimport mss\n\nmss_obj = mss.mss()\n\nroot = tk.Tk()\n...\ntry:\n    root.mainloop()\nfinally:\n    mss_obj.close()",
            "masked_code": "import tkinter as tk\nimport mss\n\nmss_obj = mss.mss()\n\nroot = tk.Tk()\n...\ntry:\n    root.mainloop()\nfinally:\n    <line_mask>",
            "masked_line": "mss_obj.close()",
            "answer": "close",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_305"
        },
        {
            "dependency": "moto",
            "version": "==4.0.6",
            "time": "2022-10-04",
            "description": "The code sets up a mock for AWS Systems Manager (SSM) service using Moto library. It creates a parameter \"/aws/test\" with some specific values in the mock SSM backend. Then, it uses boto3 to create a client for SSM in the \"us-east-1\" region and retrieves the parameters using the \"get_parameters\" method with the name \"/aws/test\". Finally, it prints the response containing the parameter values.",
            "code": "@mock_ssm\ndef test_default_param():\n    client = boto3.client(\"ssm\", region_name=\"us-east-1\")\n\n    from moto.ssm.models import ssm_backends, Parameter\n    ssm_backends[\"123456789012\"][\"us-east-1\"]._parameters[\"/aws/test\"].append(Parameter(\n        account_id=\"123456789012\",\n        name=\"/aws/test\",\n        value=\"val\",\n        parameter_type=\"String\",\n        description=\"...\",\n        allowed_pattern=None,\n        keyid=None,\n        last_modified_date=1664230158.399,\n        version=None,\n        tags=[],\n        data_type=\"text\",\n    ))\n\n    response = client.get_parameters(Names=[\"/aws/test\"])\n    print(response)",
            "masked_code": "@mock_ssm\ndef test_default_param():\n    client = boto3.client(\"ssm\", region_name=\"us-east-1\")\n\n    from moto.ssm.models import ssm_backends, Parameter\n    <line_mask>\n        account_id=\"123456789012\",\n        name=\"/aws/test\",\n        value=\"val\",\n        parameter_type=\"String\",\n        description=\"...\",\n        allowed_pattern=None,\n        keyid=None,\n        last_modified_date=1664230158.399,\n        version=None,\n        tags=[],\n        data_type=\"text\",\n    ))\n\n    response = client.get_parameters(Names=[\"/aws/test\"])\n    print(response)",
            "masked_line": "ssm_backends[\"123456789012\"][\"us-east-1\"]._parameters[\"/aws/test\"].append(Parameter(",
            "answer": "append",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_306"
        },
        {
            "dependency": "pyflann",
            "version": "==1.6.14",
            "time": "2022-07-29",
            "description": "The code creates a FLANN index from random data, saves the index to a file, and then retrieves the 500 nearest neighbors of a specific data point.",
            "code": "from pyflann.index import FLANN, set_distance_type\n \n# creating the data\ndatas = np.random.rand(1000000, 512)\ndatas = np.float32(datas)\n \n# declaring the FLANN\nflann = FLANN()\n# build the index from datas\nflann.build_index(datas, algorithm=\"linear\", checks=10)\n# Saving the index created therebefore\nflann.save_index(b\"my_saved_flann.txt\")\n \n# Searched data\nsearched = datas[i]\nsearched = np.expand_dims(searched, axis=0)\n \n# retrieving the 500 nearest neighbours of searched\nresults, distances = flann.nn_index(searched, 500)",
            "masked_code": "from pyflann.index import FLANN, set_distance_type\n \n# creating the data\ndatas = np.random.rand(1000000, 512)\ndatas = np.float32(datas)\n \n# declaring the FLANN\n<line_mask>\n# build the index from datas\nflann.build_index(datas, algorithm=\"linear\", checks=10)\n# Saving the index created therebefore\nflann.save_index(b\"my_saved_flann.txt\")\n \n# Searched data\nsearched = datas[i]\nsearched = np.expand_dims(searched, axis=0)\n \n# retrieving the 500 nearest neighbours of searched\nresults, distances = flann.nn_index(searched, 500)",
            "masked_line": "flann = FLANN()",
            "answer": "FLANN",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_307"
        },
        {
            "dependency": "numpy",
            "version": "==1.23.2",
            "time": "2022-08-30",
            "description": "func_1() takes a list of strings and concatenates 'x' to each element in the list, while func_2() takes a numpy char array and concatenates 'x' to each element in the array. Both functions are timed with the timeit module running 100 times.",
            "code": "import numpy\nfrom timeit import timeit\n\nlc = list(map(str, range(500_000)))\nla = numpy.char.array(lc)\n\ndef func_1():\n    return [e+'x' for e in lc]\n\ndef func_2():\n    return la+'x'\n\nfor func in func_1, func_2:\n    print(func.__name__, timeit(lambda: func(), number=100))",
            "masked_code": "import numpy\nfrom timeit import timeit\n\nlc = list(map(str, range(500_000)))\n<line_mask>\n\ndef func_1():\n    return [e+'x' for e in lc]\n\ndef func_2():\n    return la+'x'\n\nfor func in func_1, func_2:\n    print(func.__name__, timeit(lambda: func(), number=100))",
            "masked_line": "la = numpy.char.array(lc)",
            "answer": "char",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_308"
        },
        {
            "dependency": "pandas",
            "version": "==1.0.4",
            "time": "2022-07-05",
            "description": "This code snippet uses the Pandas library to create a DataFrame with two columns 'xxx' and 'tmp'. It then modifies the values in the 'xxx' column by taking the first 10 characters of the string, replacing any '-' characters with an empty string, and updating the DataFrame with these modified values.",
            "code": "import pandas as pd\nprint(pd.__version__)\ndf = pd.DataFrame(\n    {'xxx': ['AABBCC-DDEEE', 'DIs-sssssssssssP', 'KKK', 'A', 'A'],\n     'tmp': [1, 2, 3, 4, 5]})\nprint(df)\ndf.loc[df['xxx'].notna(), 'xxx'] = df.loc[df['xxx'].notna(), 'xxx'].astype(str).str[:10].str.replace('-','')\nprint(df)",
            "masked_code": "import pandas as pd\nprint(pd.__version__)\ndf = pd.DataFrame(\n    {'xxx': ['AABBCC-DDEEE', 'DIs-sssssssssssP', 'KKK', 'A', 'A'],\n     'tmp': [1, 2, 3, 4, 5]})\nprint(df)\n<line_mask>\nprint(df)",
            "masked_line": "df.loc[df['xxx'].notna(), 'xxx'] = df.loc[df['xxx'].notna(), 'xxx'].astype(str).str[:10].str.replace('-','')",
            "answer": "replace",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_309"
        },
        {
            "dependency": "pandas",
            "version": "==0.15",
            "time": "2022-04-04",
            "description": "The code creates a dataframe containing information about order totals on different weekdays. The dataframe is then sorted by the weekdays in a predefined order (Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday) and printed.",
            "code": "import pandas as pd\n\ndf = pd.DataFrame(\n    {\n        'OrderDayName': ['Friday', 'Monday', 'Saturday', 'Sunday', 'Thursday', 'Tuesday', 'Wednesday'],\n        'ItemTotal': [4073, 6787, 2965, 4416, 4260, 4378, 3476],\n    }\n)\nsorted_weekdays = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']\ndf['OrderDayName'] = pd.Categorical(df['OrderDayName'], sorted_weekdays)\nprint(df.sort_values(\"OrderDayName\"))",
            "masked_code": "import pandas as pd\n\ndf = pd.DataFrame(\n    {\n        'OrderDayName': ['Friday', 'Monday', 'Saturday', 'Sunday', 'Thursday', 'Tuesday', 'Wednesday'],\n        'ItemTotal': [4073, 6787, 2965, 4416, 4260, 4378, 3476],\n    }\n)\nsorted_weekdays = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']\ndf['OrderDayName'] = pd.Categorical(df['OrderDayName'], sorted_weekdays)\n<line_mask>",
            "masked_line": "print(df.sort_values(\"OrderDayName\"))",
            "answer": "sort_values",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_310"
        },
        {
            "dependency": "pillow",
            "version": "==10.0.0",
            "time": "2023-07-04",
            "description": "This code generates a gradient image with a sharp color boundary across the diagonal, converts it to a PIL Image object, resizes it to a smaller size using Lanczos resampling, and then displays both the original large image and the resized small image.",
            "code": "import PIL\nimport numpy as np\n\n# Gradient image with a sharp color boundary across the diagonal\nlarge_arr = np.fromfunction(lambda x, y, z: (x+y)//(z+1),\n                            (256, 256, 3)).astype(np.uint8)\nlarge_img = PIL.Image.fromarray(large_arr)\n\n# Resize it: PIL.Image.LANCZOS also works here\nsmall_img = large_img.resize((128, 128), PIL.Image.Resampling.LANCZOS)\nprint(small_img.size)\n\nlarge_img.show()\nsmall_img.show()",
            "masked_code": "import PIL\nimport numpy as np\n\n# Gradient image with a sharp color boundary across the diagonal\nlarge_arr = np.fromfunction(lambda x, y, z: (x+y)//(z+1),\n                            (256, 256, 3)).astype(np.uint8)\nlarge_img = PIL.Image.fromarray(large_arr)\n\n# Resize it: PIL.Image.LANCZOS also works here\nsmall_img = large_img.resize((128, 128), PIL.Image.Resampling.LANCZOS)\nprint(small_img.size)\n\n<line_mask>\nsmall_img.show()",
            "masked_line": "large_img.show()",
            "answer": "show",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_311"
        },
        {
            "dependency": "openai",
            "version": "==1.1.1",
            "time": "2023-11-08",
            "description": "The code uses the OpenAI API to generate a chat completion response based on the given messages. It specifies a role for the system and the user, with the system providing information about answering questions related to Web services. The chat completion response is generated using a specified GPT model with a temperature of 0, and the final response message is then printed.",
            "code": "from openai import OpenAI\n\nclient = OpenAI(api_key='YourKey')\nGPT_MODEL = \"gpt-4-1106-preview\" #\"gpt-3.5-turbo-1106\"\nmessages = [\n        {\"role\": \"system\", \"content\": 'You answer question about Web  services.'\n        },\n        {\"role\": \"user\", \"content\": 'the user message'},\n    ]\nresponse = client.chat.completions.create(\n        model=model,\n        messages=messages,\n        temperature=0\n    )\nresponse_message = response.choices[0].message.content\nprint(response_message )",
            "masked_code": "<line_mask>\n\nclient = OpenAI(api_key='YourKey')\nGPT_MODEL = \"gpt-4-1106-preview\" #\"gpt-3.5-turbo-1106\"\nmessages = [\n        {\"role\": \"system\", \"content\": 'You answer question about Web  services.'\n        },\n        {\"role\": \"user\", \"content\": 'the user message'},\n    ]\nresponse = client.chat.completions.create(\n        model=model,\n        messages=messages,\n        temperature=0\n    )\nresponse_message = response.choices[0].message.content\nprint(response_message )",
            "masked_line": "from openai import OpenAI",
            "answer": "OpenAI",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_312"
        },
        {
            "dependency": "fastapi",
            "version": "==0.104",
            "time": "2023-12-20",
            "description": "This code defines a FastAPI application with a single route (\"/\") that returns a plain text response of \"Hello \"World\"!\". The application is then run using uvicorn.",
            "code": "import uvicorn\nfrom fastapi import FastAPI\nfrom fastapi.responses import PlainTextResponse\n\napp = FastAPI()\n\n\n@app.get(\n    \"/\",\n    response_class=PlainTextResponse,\n)\ndef read_root():\n    return 'Hello \"World\"!'\n\n\nuvicorn.run(app)",
            "masked_code": "import uvicorn\nfrom fastapi import FastAPI\nfrom fastapi.responses import PlainTextResponse\n\n<line_mask>\n\n\n@app.get(\n    \"/\",\n    response_class=PlainTextResponse,\n)\ndef read_root():\n    return 'Hello \"World\"!'\n\n\nuvicorn.run(app)",
            "masked_line": "app = FastAPI()",
            "answer": "FastAPI",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_313"
        },
        {
            "dependency": "selenium",
            "version": ">=4.6",
            "time": "2023-07-18",
            "description": "The code opens a Chrome browser window with maximized window size and navigates to the Google homepage.",
            "code": "from selenium import webdriver\n\noption = webdriver.ChromeOptions()\noption.add_argument(\"--start-maximized\")\ndriver = webdriver.Chrome(options=option)\ndriver.get(\"https://google.com/\")",
            "masked_code": "from selenium import webdriver\n\n<line_mask>\noption.add_argument(\"--start-maximized\")\ndriver = webdriver.Chrome(options=option)\ndriver.get(\"https://google.com/\")",
            "masked_line": "option = webdriver.ChromeOptions()",
            "answer": "ChromeOptions",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_314"
        },
        {
            "dependency": "connexion",
            "version": "==3.0.2",
            "time": "2023-11-28",
            "description": "The code creates a Flask web application using the Connexion library and initializes it with an OpenAPI specification file named \"openapi.yaml\" to validate responses.",
            "code": "from connexion import FlaskApp\n\ndef create_app():\n    app = FlaskApp(__name__)\n    app.add_api(\"openapi.yaml\", validate_responses=True)\n    return app\n\napp = create_app()",
            "masked_code": "from connexion import FlaskApp\n\ndef create_app():\n    app = FlaskApp(__name__)\n    <line_mask>\n    return app\n\napp = create_app()",
            "masked_line": "app.add_api(\"openapi.yaml\", validate_responses=True)",
            "answer": "add_api",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_315"
        },
        {
            "dependency": "selenium",
            "version": "==4.10.0",
            "time": "2023-06-20",
            "description": "The code initiates a headless Chrome browser using Selenium, with the Chrome browser options set to run in headless mode. It then prints \"done\" to the console.",
            "code": "from selenium import webdriver\nfrom selenium.webdriver.chrome.options import Options\n\noptions = webdriver.ChromeOptions()\noptions.add_argument('\"--headless=new\"')\ndriver = webdriver.Chrome(options=options)\nprint(\"done\")",
            "masked_code": "from selenium import webdriver\nfrom selenium.webdriver.chrome.options import Options\n\noptions = webdriver.ChromeOptions()\n<line_mask>\ndriver = webdriver.Chrome(options=options)\nprint(\"done\")",
            "masked_line": "options.add_argument('\"--headless=new\"')",
            "answer": "add_argument",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_316"
        },
        {
            "dependency": "pytest",
            "version": "==7.3.0",
            "time": "2023-05-02",
            "description": "The code defines a list of instance sizes with CPU and memory specifications. It also includes a function `get_instance_size` that returns the instance size that meets the specified CPU and memory requirements. Additionally, there is a test function `test_get_instance_size` that tests the `get_instance_size` function for specific CPU and memory inputs.",
            "code": "import pytest\n\ninstance_sizes = [\n    {\"name\": \"t3a.nano\", \"cpu\": 2, \"mem\": 0.5},\n    {\"name\": \"t3a.micro\", \"cpu\": 2, \"mem\": 1},\n    {\"name\": \"t3a.small\", \"cpu\": 2, \"mem\": 2},\n    {\"name\": \"t3a.medium/c5a.large\", \"cpu\": 2, \"mem\": 4},\n    {\"name\": \"t3a/m5a.large\", \"cpu\": 2, \"mem\": 8},\n    {\"name\": \"c5a.xlarge\", \"cpu\": 4, \"mem\": 8},\n    {\"name\": \"t3a/m5a.xlarge\", \"cpu\": 4, \"mem\": 16},\n    {\"name\": \"c5a.2xlarge\", \"cpu\": 8, \"mem\": 16},\n    {\"name\": \"t3a/m5a.2xlarge\", \"cpu\": 8, \"mem\": 32},\n]\n\n\ndef get_instance_size(cpu, mem):\n    return next(\n        x\n        for x in sorted(instance_sizes, key=lambda size: size[\"cpu\"])\n        if x[\"cpu\"] >= cpu and x[\"mem\"] >= mem\n    )\n\n\n@pytest.mark.parametrize(\n    \"cpu,mem,expected\",\n    (\n        (1.8, 6, \"t3a/m5a.large\"),\n        (0.1, 6, \"t3a/m5a.large\"),\n        (2.1, 6, \"c5a.xlarge\"),\n        (6, 16, \"c5a.2xlarge\"),\n    ),\n)\ndef test_get_instance_size(cpu, mem, expected):\n    res = get_instance_size(cpu, mem)\n\n    assert res is not None\n    assert res[\"name\"] == expected",
            "masked_code": "import pytest\n\ninstance_sizes = [\n    {\"name\": \"t3a.nano\", \"cpu\": 2, \"mem\": 0.5},\n    {\"name\": \"t3a.micro\", \"cpu\": 2, \"mem\": 1},\n    {\"name\": \"t3a.small\", \"cpu\": 2, \"mem\": 2},\n    {\"name\": \"t3a.medium/c5a.large\", \"cpu\": 2, \"mem\": 4},\n    {\"name\": \"t3a/m5a.large\", \"cpu\": 2, \"mem\": 8},\n    {\"name\": \"c5a.xlarge\", \"cpu\": 4, \"mem\": 8},\n    {\"name\": \"t3a/m5a.xlarge\", \"cpu\": 4, \"mem\": 16},\n    {\"name\": \"c5a.2xlarge\", \"cpu\": 8, \"mem\": 16},\n    {\"name\": \"t3a/m5a.2xlarge\", \"cpu\": 8, \"mem\": 32},\n]\n\n\ndef get_instance_size(cpu, mem):\n    return next(\n        x\n        for x in sorted(instance_sizes, key=lambda size: size[\"cpu\"])\n        if x[\"cpu\"] >= cpu and x[\"mem\"] >= mem\n    )\n\n\n<line_mask>\n    \"cpu,mem,expected\",\n    (\n        (1.8, 6, \"t3a/m5a.large\"),\n        (0.1, 6, \"t3a/m5a.large\"),\n        (2.1, 6, \"c5a.xlarge\"),\n        (6, 16, \"c5a.2xlarge\"),\n    ),\n)\ndef test_get_instance_size(cpu, mem, expected):\n    res = get_instance_size(cpu, mem)\n\n    assert res is not None\n    assert res[\"name\"] == expected",
            "masked_line": "@pytest.mark.parametrize(",
            "answer": "mark",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_317"
        },
        {
            "dependency": "pandas",
            "version": "==1.3.5",
            "time": "2023-03-29",
            "description": "The code divides the values in series1 by the values in series2, replaces any resulting NaN values with 0, and returns the resulting Series.",
            "code": "import pandas as pd\nimport numpy as np\n\nseries1 = pd.Series([0.1, 0.2, 0.3])\nseries2 = pd.Series([np.nan, 0.2, 0.3])\n\nseries1.divide(series2).replace(np.nan, 0)",
            "masked_code": "import pandas as pd\nimport numpy as np\n\nseries1 = pd.Series([0.1, 0.2, 0.3])\n<line_mask>\n\nseries1.divide(series2).replace(np.nan, 0)",
            "masked_line": "series2 = pd.Series([np.nan, 0.2, 0.3])",
            "answer": "Series",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_318"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.6",
            "time": "2023-12-29",
            "description": "This code generates a plot with a line graph in matplotlib and adds an image of a plane next to it as an annotation. The resulting plot is saved as an image file named \"example.png\".",
            "code": "import matplotlib.pyplot as plt\n\nfrom matplotlib.offsetbox import (OffsetImage, AnnotationBbox)\n\nim = plt.imread('plane.jpg')\n\nfig, ax = plt.subplots()\nax.plot(range(10))\nax.set_xlabel(\"my label\")\n\nimagebox = OffsetImage(im, zoom = 0.05)\n\nab = AnnotationBbox(imagebox, (1, 0), xycoords='axes fraction', box_alignment=(1.1, 1), frameon = False)\nax.add_artist(ab)\n\nfig.savefig(\"example.png\", bbox_inches=\"tight\")",
            "masked_code": "import matplotlib.pyplot as plt\n\nfrom matplotlib.offsetbox import (OffsetImage, AnnotationBbox)\n\nim = plt.imread('plane.jpg')\n\nfig, ax = plt.subplots()\nax.plot(range(10))\nax.set_xlabel(\"my label\")\n\nimagebox = OffsetImage(im, zoom = 0.05)\n\nab = AnnotationBbox(imagebox, (1, 0), xycoords='axes fraction', box_alignment=(1.1, 1), frameon = False)\n<line_mask>\n\nfig.savefig(\"example.png\", bbox_inches=\"tight\")",
            "masked_line": "ax.add_artist(ab)",
            "answer": "add_artist",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_319"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.8",
            "time": "2023-12-29",
            "description": "This code saves a plot as an image file with an airplane image embedded in the plot.",
            "code": "import matplotlib.pyplot as plt\n\nfrom matplotlib.offsetbox import (OffsetImage, AnnotationBbox)\n\nim = plt.imread('plane.jpg')\n\nfig, ax = plt.subplots()\nax.plot(range(10))\nax.set_xlabel(\"my label\")\n\nimagebox = OffsetImage(im, zoom = 0.05)\n\nab = AnnotationBbox(imagebox, (1, 0), xycoords='axes fraction', box_alignment=(1.1, 1), frameon = False)\nax.add_artist(ab)\n\nfig.savefig(\"example.png\", bbox_inches=\"tight\")",
            "masked_code": "import matplotlib.pyplot as plt\n\nfrom matplotlib.offsetbox import (OffsetImage, AnnotationBbox)\n\nim = plt.imread('plane.jpg')\n\nfig, ax = plt.subplots()\nax.plot(range(10))\n<line_mask>\n\nimagebox = OffsetImage(im, zoom = 0.05)\n\nab = AnnotationBbox(imagebox, (1, 0), xycoords='axes fraction', box_alignment=(1.1, 1), frameon = False)\nax.add_artist(ab)\n\nfig.savefig(\"example.png\", bbox_inches=\"tight\")",
            "masked_line": "ax.set_xlabel(\"my label\")",
            "answer": "set_xlabel",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_320"
        },
        {
            "dependency": "smartsheet-python-sdk",
            "version": "==3.0.2",
            "time": "2023-12-19",
            "description": "The code establishes a connection to the Smartsheet API using an access token, retrieves a list of all sheets within the account, and prints out the list of sheets.",
            "code": "import smartsheet\n\napi_key = \"MY_ACCESS_TOKEN_HERE\"\n\nsmartsheet_client = smartsheet.Smartsheet(api_key)\nsmartsheet_client.errors_as_exceptions(True)\nprint(\"Hello World\\n\")\n\nsheets = smartsheet_client.Sheets.list_sheets(include_all=True).data\nprint(sheets)",
            "masked_code": "import smartsheet\n\napi_key = \"MY_ACCESS_TOKEN_HERE\"\n\nsmartsheet_client = smartsheet.Smartsheet(api_key)\n<line_mask>\nprint(\"Hello World\\n\")\n\nsheets = smartsheet_client.Sheets.list_sheets(include_all=True).data\nprint(sheets)",
            "masked_line": "smartsheet_client.errors_as_exceptions(True)",
            "answer": "errors_as_exceptions",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_321"
        },
        {
            "dependency": "pandas",
            "version": "==2.0.3",
            "time": "2023-07-03",
            "description": "This code generates a DataFrame with a column named 'Runtime' filled with random integer values between 0 and 50. It then calculates the frequency of each unique value in the 'Runtime' column, sorts the values in descending order, and returns the top 10 most frequent values along with their counts.",
            "code": "import numpy as np\nimport pandas as pd\nnp.random.seed(5678)\nvals = np.random.randint(0, 50, size=1000).astype(float)\ndf = pd.DataFrame(vals, columns=['Runtime'])\n\ns = df['Runtime'].value_counts().sort_values(ascending = False)\ns[:10]   # produces 32 rows, the last one with index 10.0\ns.iloc[:10]  # the first 10 rows\ns.head(10)   # also the first 10 rows",
            "masked_code": "import numpy as np\nimport pandas as pd\nnp.random.seed(5678)\nvals = np.random.randint(0, 50, size=1000).astype(float)\ndf = pd.DataFrame(vals, columns=['Runtime'])\n\n<line_mask>\ns[:10]   # produces 32 rows, the last one with index 10.0\ns.iloc[:10]  # the first 10 rows\ns.head(10)   # also the first 10 rows",
            "masked_line": "s = df['Runtime'].value_counts().sort_values(ascending = False)",
            "answer": "value_counts",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_322"
        },
        {
            "dependency": "redis",
            "version": "==4.5.5",
            "time": "2023-05-22",
            "description": "The code connects to a Redis database, creates a pipeline for multiple commands to be executed atomically, increments the value of a key called \"somekey\" by 1, sets a key \"hello\" to have the value \"world\", retrieves the value of the key \"hello\", executes the pipeline, and prints the responses returned from the pipeline execution.",
            "code": "from redis import Redis\n\nredis_client = Redis(decode_responses=True)\n\npipeline = redis_client.pipeline(transaction=False)\n\npipeline.incr(\"somekey\", 1)\npipeline.set(\"hello\", \"world\")\npipeline.get(\"hello\")\nresponses = pipeline.execute()\n\nprint(responses)",
            "masked_code": "from redis import Redis\n\nredis_client = Redis(decode_responses=True)\n\npipeline = redis_client.pipeline(transaction=False)\n\n<line_mask>\npipeline.set(\"hello\", \"world\")\npipeline.get(\"hello\")\nresponses = pipeline.execute()\n\nprint(responses)",
            "masked_line": "pipeline.incr(\"somekey\", 1)",
            "answer": "pipeline",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_323"
        },
        {
            "dependency": "pandas",
            "version": "==1.2.3",
            "time": "2023-12-09",
            "description": "The code calculates the rolling mean of the 'a' column in a pandas DataFrame with a window size of 3, where NaN values are skipped in the first calculation and considered in the second calculation.",
            "code": "import pandas as pd\nimport numpy as np\n\n\ndf = pd.DataFrame({'a': [1, 2, 3, np.nan, 5, 6, 7]})\nprint(df['a'].rolling(3).mean(skipna=True))\nprint(df['a'].rolling(3).mean(skipna=False))",
            "masked_code": "import pandas as pd\nimport numpy as np\n\n\n<line_mask>\nprint(df['a'].rolling(3).mean(skipna=True))\nprint(df['a'].rolling(3).mean(skipna=False))",
            "masked_line": "df = pd.DataFrame({'a': [1, 2, 3, np.nan, 5, 6, 7]})",
            "answer": "DataFrame",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_324"
        },
        {
            "dependency": "bokeh",
            "version": "==3.x",
            "time": "2023-06-30",
            "description": "The code creates a Bokeh plot with a line chart and adds a text label to the plot with specified position and styling. The plot is then displayed in the notebook.",
            "code": "from bokeh.models import Label\nfrom bokeh.plotting import figure, show, output_notebook\noutput_notebook()\n\np = figure(width=300, height=250)\np.line([1,2,3],[0,1,2])\ncitation = Label(\n    x=1, y=1, x_units='screen', y_units='screen',\n    text='Text',\n    border_line_color='wheat',\n    background_fill_color='wheat'\n)\np.add_layout(citation)\nshow(p)",
            "masked_code": "from bokeh.models import Label\n<line_mask>\noutput_notebook()\n\np = figure(width=300, height=250)\np.line([1,2,3],[0,1,2])\ncitation = Label(\n    x=1, y=1, x_units='screen', y_units='screen',\n    text='Text',\n    border_line_color='wheat',\n    background_fill_color='wheat'\n)\np.add_layout(citation)\nshow(p)",
            "masked_line": "from bokeh.plotting import figure, show, output_notebook",
            "answer": "show",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_325"
        },
        {
            "dependency": "gspread",
            "version": "==5.9.0",
            "time": "2023-06-25",
            "description": "This code is used to authorize access to a Google Sheets API using OAuth2 credentials.",
            "code": "from gspread import authorize\nfrom oauth2client.service_account import ServiceAccountCredentials\n\nscopes = [\"https://spreadsheets.google.com/feeds\",\n                  \"https://www.googleapis.com/auth/spreadsheets\",\n                  \"https://www.googleapis.com/auth/drive\",\n                  \"https://www.googleapis.com/auth/drive\"]\ncred = ServiceAccountCredentials.from_json_keyfile_name(\"link_to_the_credentials\", scopes)\ngclient = authorize(cred)",
            "masked_code": "from gspread import authorize\nfrom oauth2client.service_account import ServiceAccountCredentials\n\nscopes = [\"https://spreadsheets.google.com/feeds\",\n                  \"https://www.googleapis.com/auth/spreadsheets\",\n                  \"https://www.googleapis.com/auth/drive\",\n                  \"https://www.googleapis.com/auth/drive\"]\ncred = ServiceAccountCredentials.from_json_keyfile_name(\"link_to_the_credentials\", scopes)\n<line_mask>",
            "masked_line": "gclient = authorize(cred)",
            "answer": "authorize",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_326"
        },
        {
            "dependency": "bokeh",
            "version": "==2.4.3",
            "time": "2023-04-14",
            "description": "The code generates a Bokeh plot with tile-based map background using CARTODBPOSITRON tile provider. The plot has specified range bounds in web mercator coordinates and the x and y axes are in mercator type.",
            "code": "from bokeh.tile_providers import CARTODBPOSITRON, get_provider\n\noutput_file(\"tile.html\")\n\ntile_provider = get_provider(CARTODBPOSITRON)\n\n# range bounds supplied in web mercator coordinates\np = figure(x_range=(-2000000, 6000000), y_range=(-1000000, 7000000),\n           x_axis_type=\"mercator\", y_axis_type=\"mercator\")\np.add_tile(tile_provider)\n\nshow(p)",
            "masked_code": "from bokeh.tile_providers import CARTODBPOSITRON, get_provider\n\noutput_file(\"tile.html\")\n\n<line_mask>\n\n# range bounds supplied in web mercator coordinates\np = figure(x_range=(-2000000, 6000000), y_range=(-1000000, 7000000),\n           x_axis_type=\"mercator\", y_axis_type=\"mercator\")\np.add_tile(tile_provider)\n\nshow(p)",
            "masked_line": "tile_provider = get_provider(CARTODBPOSITRON)",
            "answer": "get_provider",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_327"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.0",
            "time": "2019-09-07",
            "description": "This function calculates the gradient of the model's output with respect to the input data x.",
            "code": "def gradient(model, x):\n    x_tensor = tf.convert_to_tensor(x, dtype=tf.float32)\n    with tf.GradientTape() as t:\n        t.watch(x_tensor)\n        loss = model(x_tensor)\n    return t.gradient(loss, x_tensor).numpy()",
            "masked_code": "def gradient(model, x):\n    x_tensor = tf.convert_to_tensor(x, dtype=tf.float32)\n    <line_mask>\n        t.watch(x_tensor)\n        loss = model(x_tensor)\n    return t.gradient(loss, x_tensor).numpy()",
            "masked_line": "with tf.GradientTape() as t:",
            "answer": "GradientTape",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_328"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.5.0",
            "time": "2022-05-11",
            "description": "This code generates a DataFrame using pandas and then applies a centered gradient styling to the DataFrame using a specific colormap. The centered gradient is based on the median value of each column in the DataFrame. Values above the center are given a gradient color based on the colormap, while values below the center remain unchanged.",
            "code": "from typing import List\n\nimport pandas as pd\nfrom matplotlib.cm import get_cmap\nfrom matplotlib.colors import Colormap, CenteredNorm, rgb2hex\n\ndf = pd.DataFrame({\n    'A': [1, -2, 0, -1, 17],\n    'B': [11, -23, 1, -3, 132],\n    'C': [121, 2029, -243, 17, -45]\n})\n\n\ndef centered_gradient(\n        s: pd.Series, cmap: Colormap, false_css: str = ''\n) -> List[str]:\n    # Find center point\n    center = 1.5 * s.median()\n    # Create normaliser centered on median\n    norm = CenteredNorm(vcenter=center)\n    # s = s.where(s > center, center)\n    return [\n        # Conditionally apply gradient to values above center only\n        f'background-color: {rgb2hex(rgba)}' if row > center else false_css\n        for row, rgba in zip(s, cmap(norm(s)))\n    ]\n\n\ndf.style.apply(centered_gradient, cmap=get_cmap('Greens'))",
            "masked_code": "from typing import List\n\nimport pandas as pd\nfrom matplotlib.cm import get_cmap\nfrom matplotlib.colors import Colormap, CenteredNorm, rgb2hex\n\ndf = pd.DataFrame({\n    'A': [1, -2, 0, -1, 17],\n    'B': [11, -23, 1, -3, 132],\n    'C': [121, 2029, -243, 17, -45]\n})\n\n\ndef centered_gradient(\n        s: pd.Series, cmap: Colormap, false_css: str = ''\n) -> List[str]:\n    # Find center point\n    center = 1.5 * s.median()\n    # Create normaliser centered on median\n    norm = CenteredNorm(vcenter=center)\n    # s = s.where(s > center, center)\n    return [\n        # Conditionally apply gradient to values above center only\n        f'background-color: {rgb2hex(rgba)}' if row > center else false_css\n        for row, rgba in zip(s, cmap(norm(s)))\n    ]\n\n\n<line_mask>",
            "masked_line": "df.style.apply(centered_gradient, cmap=get_cmap('Greens'))",
            "answer": "get_cmap",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_329"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2020-07-10",
            "description": "The code generates a pandas DataFrame with a column 'ColA' containing 10 random integers between 1 and 10, and adds another column 'animal' with random choices of 'dog', 'cat', or 'monkey' for each row. Finally, it counts the occurrences of each unique value in the 'animal' column.",
            "code": "np.random.seed(12345)\n\ndf = pd.DataFrame({'ColA': np.random.randint(1, 10, 10)})\ncatergory = ['dog', 'cat', 'monkey']\n\ndf['animal'] = np.random.choice(catergory, size=len(df))\ndf['animal'].value_counts()",
            "masked_code": "np.random.seed(12345)\n\n<line_mask>\ncatergory = ['dog', 'cat', 'monkey']\n\ndf['animal'] = np.random.choice(catergory, size=len(df))\ndf['animal'].value_counts()",
            "masked_line": "df = pd.DataFrame({'ColA': np.random.randint(1, 10, 10)})",
            "answer": "randint",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_330"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.x",
            "time": "2020-06-05",
            "description": "This code reads an image file \"sample.jpg\", decodes it as a JPEG image with 3 channels, then uses TensorFlow session to evaluate the image array to obtain its height and width, and finally prints out the height and width of the image.",
            "code": "img = tf.io.read_file(\"sample.jpg\")\nimg = tf.image.decode_jpeg(img, channels=3)\n\nwith tf.Session() as sess:\n  array = img.eval(session=sess)\n  height = array.shape[0]\n  width = array.shape[1]\n  print(\"Height:\",height)\n  print(\"Width:\",width)",
            "masked_code": "img = tf.io.read_file(\"sample.jpg\")\n<line_mask>\n\nwith tf.Session() as sess:\n  array = img.eval(session=sess)\n  height = array.shape[0]\n  width = array.shape[1]\n  print(\"Height:\",height)\n  print(\"Width:\",width)",
            "masked_line": "img = tf.image.decode_jpeg(img, channels=3)",
            "answer": "decode_jpeg",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_331"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.x",
            "time": "2021-08-05",
            "description": "The code converts a Keras model into a concrete function, freezes the function to get a frozen ConcreteFunction, and then saves the frozen graph to the hard drive as a .pb file.",
            "code": "# Convert Keras model to ConcreteFunction\nfull_model = tf.function(lambda x: model(x))\nfull_model = full_model.get_concrete_function(\n    tf.TensorSpec(model.inputs[0].shape, model.inputs[0].dtype))\n\n# Get frozen ConcreteFunction\nfrozen_func = convert_variables_to_constants_v2(full_model)\nfrozen_func.graph.as_graph_def()\n\n\n# Save frozen graph from frozen ConcreteFunction to hard drive\ntf.io.write_graph(graph_or_graph_def=frozen_func.graph,\n                  logdir=\"./frozen_models\",\n                  name=\"frozen_graph.pb\",\n                  as_text=False)",
            "masked_code": "# Convert Keras model to ConcreteFunction\nfull_model = tf.function(lambda x: model(x))\nfull_model = full_model.get_concrete_function(\n    <line_mask>\n\n# Get frozen ConcreteFunction\nfrozen_func = convert_variables_to_constants_v2(full_model)\nfrozen_func.graph.as_graph_def()\n\n\n# Save frozen graph from frozen ConcreteFunction to hard drive\ntf.io.write_graph(graph_or_graph_def=frozen_func.graph,\n                  logdir=\"./frozen_models\",\n                  name=\"frozen_graph.pb\",\n                  as_text=False)",
            "masked_line": "tf.TensorSpec(model.inputs[0].shape, model.inputs[0].dtype))",
            "answer": "TensorSpec",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_332"
        },
        {
            "dependency": "gspread",
            "version": "==5.0.0",
            "time": "2021-12-19",
            "description": "This code snippet reads all values from a worksheet, organizes them into a dictionary where the first value of each column becomes the key and the remaining values in the column become a list associated with that key, and finally prints out the resulting dictionary.",
            "code": "values = worksheet.get_all_values()\nobj = {}\nfor e in zip(*values):\n    obj[e[0]] = list(e[1:])\n\nprint(obj)",
            "masked_code": "<line_mask>\nobj = {}\nfor e in zip(*values):\n    obj[e[0]] = list(e[1:])\n\nprint(obj)",
            "masked_line": "values = worksheet.get_all_values()",
            "answer": "get_all_values",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_333"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.5",
            "time": "2023-09-20",
            "description": "This code calculates the gradients of two losses with respect to the model weights using TensorFlow's GradientTape, and then applies the gradients to the model using an optimizer.",
            "code": "with tf.GradientTape(persistent=True) as tp:\n    logits_1,logits_2=model(X_train)\n    loss1= loss_fn_1(y_train_1, logits_1)\n    loss2= loss_fn_2(y_train_2, logits_2)\ngrads = tp.gradient([loss1,loss2], model.weights)\nopt.apply_gradients(zip(grads, model.weights))",
            "masked_code": "<line_mask>\n    logits_1,logits_2=model(X_train)\n    loss1= loss_fn_1(y_train_1, logits_1)\n    loss2= loss_fn_2(y_train_2, logits_2)\ngrads = tp.gradient([loss1,loss2], model.weights)\nopt.apply_gradients(zip(grads, model.weights))",
            "masked_line": "with tf.GradientTape(persistent=True) as tp:",
            "answer": "GradientTape",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_334"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.5",
            "time": "2023-09-20",
            "description": "This code calculates the gradients of two different loss functions with respect to the model weights using Tensorflow's GradientTape. The gradients are then combined and applied to the model using an optimizer.",
            "code": "with tf.GradientTape(persistent=True) as tp:\n    logits_1,logits_2=model(X_train)\n    loss1= loss_fn_1(y_train_1, logits_1)\n    loss2= loss_fn_2(y_train_2, logits_2)\ngrads_1 = tp.gradient(loss1, model.weights)\ngrads_2 = tp.gradient(loss2, model.weights)\ngrads_final = grads_1 + grads_2\nopt.apply_gradients(zip(grads_final, model.weights))",
            "masked_code": "<line_mask>\n    logits_1,logits_2=model(X_train)\n    loss1= loss_fn_1(y_train_1, logits_1)\n    loss2= loss_fn_2(y_train_2, logits_2)\ngrads_1 = tp.gradient(loss1, model.weights)\ngrads_2 = tp.gradient(loss2, model.weights)\ngrads_final = grads_1 + grads_2\nopt.apply_gradients(zip(grads_final, model.weights))",
            "masked_line": "with tf.GradientTape(persistent=True) as tp:",
            "answer": "GradientTape",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_335"
        },
        {
            "dependency": "hdf5storage",
            "version": "==0.1.10",
            "time": "2023-04-11",
            "description": "The code generates three NumPy arrays, writes them to an HDF5 file with individual paths, and then writes all three arrays to the HDF5 file with a dictionary of paths.",
            "code": "arr1 = np.arange(10)\narr2 = np.arange(10,20).reshape(5,2)\narr3 = np.arange(20,30).reshape(2,5)\nhdf5storage.write(arr1, path='/arr1', filename='write_data.h5')\nhdf5storage.write(arr2, path='/arr2', filename='write_data.h5')\nhdf5storage.write(arr3, path='/arr3', filename='write_data.h5')\n\nmdict = {'/arr1':arr1, '/arr2':arr2, '/arr3':arr3}\nhdf5storage.writes(mdict, filename='writes_data.h5')",
            "masked_code": "arr1 = np.arange(10)\narr2 = np.arange(10,20).reshape(5,2)\narr3 = np.arange(20,30).reshape(2,5)\nhdf5storage.write(arr1, path='/arr1', filename='write_data.h5')\nhdf5storage.write(arr2, path='/arr2', filename='write_data.h5')\nhdf5storage.write(arr3, path='/arr3', filename='write_data.h5')\n\nmdict = {'/arr1':arr1, '/arr2':arr2, '/arr3':arr3}\n<line_mask>",
            "masked_line": "hdf5storage.writes(mdict, filename='writes_data.h5')",
            "answer": "writes",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_336"
        },
        {
            "dependency": "pandas",
            "version": "==1.5.2",
            "time": "2019-03-18",
            "description": "The code sets the order of the column in the dataframe, pivots the dataframe based on certain columns, plots an area chart showing the number of launches by country over the years, and adjusts the legend position on the plot.",
            "code": "# set the order of the column in df\ndf.state_code = pd.Categorical(df.state_code, sorted(df.state_code.unique())[::-1], ordered=True)\n\n# now pivot df\nyear_countries = df.pivot(index='launch_year', columns='state_code', values='value')\n\n# plot\nax = year_countries.plot(kind='area', figsize=(9, 6), xticks=range(1957, 1962))\nax.set_xlabel('Launch Year', fontsize=15)\nax.set_ylabel('Number of Launches', fontsize=15)\nax.set_title('Space Launches By Country', fontsize=17)\n\n# move the legend\nax.legend(title='Countries', bbox_to_anchor=(1, 1.02), loc='upper left', frameon=False)",
            "masked_code": "# set the order of the column in df\ndf.state_code = pd.Categorical(df.state_code, sorted(df.state_code.unique())[::-1], ordered=True)\n\n# now pivot df\nyear_countries = df.pivot(index='launch_year', columns='state_code', values='value')\n\n# plot\nax = year_countries.plot(kind='area', figsize=(9, 6), xticks=range(1957, 1962))\n<line_mask>\nax.set_ylabel('Number of Launches', fontsize=15)\nax.set_title('Space Launches By Country', fontsize=17)\n\n# move the legend\nax.legend(title='Countries', bbox_to_anchor=(1, 1.02), loc='upper left', frameon=False)",
            "masked_line": "ax.set_xlabel('Launch Year', fontsize=15)",
            "answer": "set_xlabel",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_337"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.1",
            "time": "2019-01-28",
            "description": "The code stacks the transpose of the array 'gmm' with the array 'gauss' and then transposes the result. It prints the resulting array and its shape. The shape of the resulting array is (3, 2, 2).",
            "code": "gmm = np.array([[[4.64, -1.93],\n                [-1.93, 6.5 ]],\n                [[3.65, 2.89],\n                 [2.89, -1.26]]])\n\ngauss = np.array([[ -1.24, 2.34],\n                  [2.34, 4.76]])\n\n\nresult = np.dstack((gmm.T, gauss)).T\nprint (result)\nprint (result.shape)\n# (3, 2, 2)",
            "masked_code": "gmm = np.array([[[4.64, -1.93],\n                [-1.93, 6.5 ]],\n                [[3.65, 2.89],\n                 [2.89, -1.26]]])\n\ngauss = np.array([[ -1.24, 2.34],\n                  [2.34, 4.76]])\n\n\n<line_mask>\nprint (result)\nprint (result.shape)\n# (3, 2, 2)",
            "masked_line": "result = np.dstack((gmm.T, gauss)).T",
            "answer": "dstack",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_338"
        },
        {
            "dependency": "opencv-python",
            "version": "==3.4",
            "time": "2020-01-16",
            "description": "This function rotates a rectangle around its top left corner by a given angle. It generates the homogenous coordinates of the rectangle's corners, creates a rotation matrix to transform the coordinates, and then applies the transformation to rotate the rectangle.",
            "code": "# Rotate rectangle defined by (x,y,w,h) around its top left corner (x,y) by given angle\ndef rotate_rectangle(x, y, w, h, angle):\n    # Generate homogenous coordinates of the corners\n    # Start top left, go clockwise\n    corners = np.array([\n        (x, y, 1)\n        , (x + w, y, 1)\n        , (x + w, y + h, 1)\n        , (x, y + h, 1)\n    ], np.int32)\n    # Create rotation matrix to transform the coordinates\n    m_rot = cv2.getRotationMatrix2D((x, y), angle, 1.0)\n    # Apply transformation\n    rotated_points = np.dot(m_rot, corners.T).T\n    return rotated_points",
            "masked_code": "# Rotate rectangle defined by (x,y,w,h) around its top left corner (x,y) by given angle\ndef rotate_rectangle(x, y, w, h, angle):\n    # Generate homogenous coordinates of the corners\n    # Start top left, go clockwise\n    corners = np.array([\n        (x, y, 1)\n        , (x + w, y, 1)\n        , (x + w, y + h, 1)\n        , (x, y + h, 1)\n    ], np.int32)\n    # Create rotation matrix to transform the coordinates\n    <line_mask>\n    # Apply transformation\n    rotated_points = np.dot(m_rot, corners.T).T\n    return rotated_points",
            "masked_line": "m_rot = cv2.getRotationMatrix2D((x, y), angle, 1.0)",
            "answer": "getRotationMatrix2D",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_339"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.0",
            "time": "2020-05-13",
            "description": "This function initializes weights for a neural network layer based on the input shape provided. If the condition `self.cause_error` is True, the function reshapes the weights.",
            "code": "def build(self,input_shape): \n    self.input_size = input_shape[1]        \n    self.w = self.add_weight(shape=(self.input_size,\n                                          self.output_size),\n                                   initializer='random_normal',\n                                   trainable=True)\n\n    if self.cause_error:\n        self.w.assign(tf.reshape(self.w,\n                                   shape = (self.input_size,\n                                            self.output_size)))",
            "masked_code": "def build(self,input_shape): \n    self.input_size = input_shape[1]        \n    self.w = self.add_weight(shape=(self.input_size,\n                                          self.output_size),\n                                   initializer='random_normal',\n                                   trainable=True)\n\n    if self.cause_error:\n        <line_mask>\n                                   shape = (self.input_size,\n                                            self.output_size)))",
            "masked_line": "self.w.assign(tf.reshape(self.w,",
            "answer": "reshape",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_340"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2020-04-16",
            "description": "This function generates random binary matrices with unique rows selected from a range specified by input parameters. Each output row is a randomly selected unique row from the specified range. The function also shuffles the columns of each row independently.",
            "code": "def randbin(m, n, p, q):\n    # make the unique rows\n    options = np.arange(n) < np.arange(p, q + 1).reshape(-1, 1)\n    # select random unique row to go into each output row\n    selection = np.random.choice(options.shape[0], size=m, replace=True)\n    # perform the selection\n    result = options[selection]\n    # create indices to shuffle each row independently\n    col_ind = np.argsort(np.random.random(result.shape), axis=1)\n    row_ind = np.arange(m).reshape(-1, 1)\n    # perform the shuffle\n    result = result[row_ind, col_ind]\n    return result",
            "masked_code": "def randbin(m, n, p, q):\n    # make the unique rows\n    options = np.arange(n) < np.arange(p, q + 1).reshape(-1, 1)\n    # select random unique row to go into each output row\n    selection = np.random.choice(options.shape[0], size=m, replace=True)\n    # perform the selection\n    result = options[selection]\n    # create indices to shuffle each row independently\n    col_ind = np.argsort(np.random.random(result.shape), axis=1)\n    <line_mask>\n    # perform the shuffle\n    result = result[row_ind, col_ind]\n    return result",
            "masked_line": "row_ind = np.arange(m).reshape(-1, 1)",
            "answer": "reshape",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_341"
        },
        {
            "dependency": "pandas",
            "version": ">=2.0.0",
            "time": "2023-08-18",
            "description": "The code creates a pandas DataFrame with columns 'A' and 'B', where column 'A' contains values 1, 2, and 3, and column 'B' contains values 4, 5, and NaN. It then prints the DataFrame and displays information about it using the info() method. Finally, it converts the DataFrame to a nullable dtype using the numpy backend and prints the updated DataFrame and its information.",
            "code": "df = pd.DataFrame({'A': [1, 2, 3], 'B': [4, 5, None]})\n\nprint(df)\ndf.info()\n\ndf = df.convert_dtypes(dtype_backend='numpy_nullable')\nprint(df)\ndf.info()",
            "masked_code": "df = pd.DataFrame({'A': [1, 2, 3], 'B': [4, 5, None]})\n\nprint(df)\ndf.info()\n\n<line_mask>\nprint(df)\ndf.info()",
            "masked_line": "df = df.convert_dtypes(dtype_backend='numpy_nullable')",
            "answer": "convert_dtypes",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_342"
        },
        {
            "dependency": "tensorflow",
            "version": ">=2.0",
            "time": "2021-06-13",
            "description": "The code defines two LSTM layers with regularization, return sequences, and optional initial states. It then applies the LSTM layers to input data (premise and hypothesis) and uses an attention mechanism to combine the outputs of the LSTM layers.",
            "code": "lstm_layer_1 = tf.keras.layers.LSTM(100, \n                            kernel_regularizer=lam, \n                            recurrent_regularizer=lam, \n                            return_sequences=True,\n                            return_state=True,\n                            time_major=False)\n\nlstm_layer_2 = tf.keras.layers.LSTM(100, \n                            kernel_regularizer=lam, \n                            recurrent_regularizer=lam, \n                            return_sequences=True,\n                            time_major=False)\n\nl2 = 0.0001\nlam = tf.keras.regularizers.l2(l2=l2)\npremise, forward_h, forward_c, = lstm_layer_1(premise)\ninit_states = [forward_h, forward_c]\nhypothesis = lstm_layer_2(hypothesis, initial_state=init_states)\ntrain_input = RochtaschelAttention(regularizer=lam)(tf.keras.layers.concatenate([premise, hypothesis], axis=1))",
            "masked_code": "lstm_layer_1 = tf.keras.layers.LSTM(100, \n                            kernel_regularizer=lam, \n                            recurrent_regularizer=lam, \n                            return_sequences=True,\n                            return_state=True,\n                            time_major=False)\n\nlstm_layer_2 = tf.keras.layers.LSTM(100, \n                            kernel_regularizer=lam, \n                            recurrent_regularizer=lam, \n                            return_sequences=True,\n                            time_major=False)\n\nl2 = 0.0001\nlam = tf.keras.regularizers.l2(l2=l2)\npremise, forward_h, forward_c, = lstm_layer_1(premise)\ninit_states = [forward_h, forward_c]\n<line_mask>\ntrain_input = RochtaschelAttention(regularizer=lam)(tf.keras.layers.concatenate([premise, hypothesis], axis=1))",
            "masked_line": "hypothesis = lstm_layer_2(hypothesis, initial_state=init_states)",
            "answer": "lstm_layer_2",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_343"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.x",
            "time": "2022-04-20",
            "description": "This function is a generator in a Generative Adversarial Network (GAN) that takes a input tensor 'z', applies two convolutional layers with leaky ReLU activation function, and then applies a dense layer to generate an output tensor 'out'. The function also creates and reuses variables within the \"GAN/Generator\" variable scope.",
            "code": "def generator(z, hsize=[1024, 1024], reuse=False):\n     with tf.variable_scope(\"GAN/Generator\", reuse=reuse):\n         h1 = tf.layers.conv2d(z, 64, [3, 3], activation=tf.nn.leaky_relu)\n         h2 = tf.layers.conv2d(h1, 64, [3, 3], activation=tf.nn.leaky_relu)\n         out = tf.layers.dense(h3, z.shape[-1])\n     return out",
            "masked_code": "def generator(z, hsize=[1024, 1024], reuse=False):\n     with tf.variable_scope(\"GAN/Generator\", reuse=reuse):\n         <line_mask>\n         h2 = tf.layers.conv2d(h1, 64, [3, 3], activation=tf.nn.leaky_relu)\n         out = tf.layers.dense(h3, z.shape[-1])\n     return out",
            "masked_line": "h1 = tf.layers.conv2d(z, 64, [3, 3], activation=tf.nn.leaky_relu)",
            "answer": "conv2d",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_344"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.x",
            "time": "2022-04-20",
            "description": "This function defines a discriminator neural network in a Generative Adversarial Network (GAN) model. It takes an input tensor 'z', applies two convolutional layers with leaky ReLU activation function, reduces the dimensionality of the output tensor, and finally passes it through a dense layer to produce a single scalar output. The 'reuse' parameter controls whether the variables in the scope should be reused or not.",
            "code": "def discriminator(z, hsize=[1024, 1024], reuse=False):\n     with tf.variable_scope(\"GAN/Discriminator\", reuse=reuse):\n         h1 = tf.layers.conv2d(z, 64, [3, 3], activation=tf.nn.leaky_relu)\n         h2 = tf.layers.conv2d(h1, 64, [3, 3], activation=tf.nn.leaky_relu)\n         h3 = tf.math.reduce_mean(h2, 1)\n         h3 = tf.math.reduce_mean(h3, 1)\n         out = tf.layers.dense(h3, 1)\n     return out",
            "masked_code": "def discriminator(z, hsize=[1024, 1024], reuse=False):\n     with tf.variable_scope(\"GAN/Discriminator\", reuse=reuse):\n         h1 = tf.layers.conv2d(z, 64, [3, 3], activation=tf.nn.leaky_relu)\n         h2 = tf.layers.conv2d(h1, 64, [3, 3], activation=tf.nn.leaky_relu)\n         <line_mask>\n         h3 = tf.math.reduce_mean(h3, 1)\n         out = tf.layers.dense(h3, 1)\n     return out",
            "masked_line": "h3 = tf.math.reduce_mean(h2, 1)",
            "answer": "reduce_mean",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_345"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.7.0",
            "time": "2022-01-20",
            "description": "This code defines a neural network model with input layer, data scaling, data augmentation, base model, global average pooling, dropout, dense output layer, and creates a model using the specified inputs and outputs.",
            "code": "inputs = tf.keras.Input(shape=(TARGET_SIZE, TARGET_SIZE, 3))\nx0 = rescale(inputs)\nx0 = data_augmentation(x0)\nx0 = base_model(x0, training=False)\nx0 = tf.keras.layers.GlobalAveragePooling2D()(x0)\nx0 = tf.keras.layers.Dropout(DROPOUT_VAL)(x0)\noutputs = tf.keras.layers.Dense(NUM_CLASSES)(x0)\nembedding_network = tf.keras.Model(inputs, outputs)",
            "masked_code": "inputs = tf.keras.Input(shape=(TARGET_SIZE, TARGET_SIZE, 3))\nx0 = rescale(inputs)\nx0 = data_augmentation(x0)\nx0 = base_model(x0, training=False)\nx0 = tf.keras.layers.GlobalAveragePooling2D()(x0)\n<line_mask>\noutputs = tf.keras.layers.Dense(NUM_CLASSES)(x0)\nembedding_network = tf.keras.Model(inputs, outputs)",
            "masked_line": "x0 = tf.keras.layers.Dropout(DROPOUT_VAL)(x0)",
            "answer": "Dropout",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_346"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.x",
            "time": "2020-01-15",
            "description": "The code converts a frozen graph into a quantized TFLite model and saves it as a .tflite file named \"uno_mobilenetV2.tflite\".",
            "code": "converter = tf.compat.v1.lite.TFLiteConverter.from_frozen_graph(\"/content/tflite_graph.pb\",input_shapes = {'normalized_input_image_tensor':[1,300,300,3]},\n    input_arrays = ['normalized_input_image_tensor'],output_arrays = ['TFLite_Detection_PostProcess','TFLite_Detection_PostProcess:1',\n    'TFLite_Detection_PostProcess:2','TFLite_Detection_PostProcess:3'])\n\nconverter.allow_custom_ops=True\n\n# Convert the model to quantized TFLite model.\nconverter.optimizations =  [tf.lite.Optimize.DEFAULT]\ntflite_model = converter.convert()\n\n\n# Write a model using the following line\nopen(\"/content/uno_mobilenetV2.tflite\", \"wb\").write(tflite_model)",
            "masked_code": "<line_mask>\n    input_arrays = ['normalized_input_image_tensor'],output_arrays = ['TFLite_Detection_PostProcess','TFLite_Detection_PostProcess:1',\n    'TFLite_Detection_PostProcess:2','TFLite_Detection_PostProcess:3'])\n\nconverter.allow_custom_ops=True\n\n# Convert the model to quantized TFLite model.\nconverter.optimizations =  [tf.lite.Optimize.DEFAULT]\ntflite_model = converter.convert()\n\n\n# Write a model using the following line\nopen(\"/content/uno_mobilenetV2.tflite\", \"wb\").write(tflite_model)",
            "masked_line": "converter = tf.compat.v1.lite.TFLiteConverter.from_frozen_graph(\"/content/tflite_graph.pb\",input_shapes = {'normalized_input_image_tensor':[1,300,300,3]},",
            "answer": "v1",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_347"
        },
        {
            "dependency": "abjad",
            "version": "==3.2",
            "time": "2021-03-12",
            "description": "The code creates a musical staff with notes, attaches a BPM (beats per minute) to the staff, creates a LilyPond file object, adds a title to the LilyPond file, and saves the file as a PDF at a custom location.",
            "code": "staff = abjad.Staff(abjad_notes)\n\n# attach BPM to notes file\nmetronome_mark = abjad.MetronomeMark((1, 4), bpm)\nabjad.attach(metronome_mark, staff[0])\n\n# creates lilypond file object\nlilypond_file = abjad.LilyPondFile.new(staff)\n\n# notes title\nlilypond_file.header_block.title = abjad.Markup(title)\n\n# save pdf file at a custom location\nabjad.persist.as_pdf(lilypond_file, '/path/to/file.pdf')",
            "masked_code": "staff = abjad.Staff(abjad_notes)\n\n# attach BPM to notes file\nmetronome_mark = abjad.MetronomeMark((1, 4), bpm)\nabjad.attach(metronome_mark, staff[0])\n\n# creates lilypond file object\nlilypond_file = abjad.LilyPondFile.new(staff)\n\n# notes title\nlilypond_file.header_block.title = abjad.Markup(title)\n\n# save pdf file at a custom location\n<line_mask>",
            "masked_line": "abjad.persist.as_pdf(lilypond_file, '/path/to/file.pdf')",
            "answer": "as_pdf",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_348"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-01-02",
            "description": "The code assigns values to columns 'HS_FIRST_NAME', 'HS_LAST_NAME', and 'HS_SSN' in DataFrame df1 based on the condition of the variable devprod. If devprod is 'prod', it assigns values directly from columns 4, 6, and 8 of DataFrame df. If devprod is not 'prod', it shuffles the values in columns 4, 6, and 8 of DataFrame df using np.random.permutation and assigns them to corresponding columns in DataFrame df1.",
            "code": "if devprod == 'prod':\n    #do not shuffle data\n    df1['HS_FIRST_NAME'] = df[4]\n    df1['HS_LAST_NAME'] = df[6]\n    df1['HS_SSN'] = df[8]\nelse:\n    df1['HS_FIRST_NAME'] = np.random.permutation(df[4].values)\n    df1['HS_LAST_NAME'] = np.random.permutation(df[6].values)\n    df1['HS_SSN'] = np.random.permutation(df[8].values)",
            "masked_code": "if devprod == 'prod':\n    #do not shuffle data\n    df1['HS_FIRST_NAME'] = df[4]\n    df1['HS_LAST_NAME'] = df[6]\n    df1['HS_SSN'] = df[8]\nelse:\n    df1['HS_FIRST_NAME'] = np.random.permutation(df[4].values)\n    df1['HS_LAST_NAME'] = np.random.permutation(df[6].values)\n    <line_mask>",
            "masked_line": "df1['HS_SSN'] = np.random.permutation(df[8].values)",
            "answer": "random",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_349"
        },
        {
            "dependency": "pytest",
            "version": "==3.10.0",
            "time": "2019-10-21",
            "description": "This code defines a pytest hook that runs before each test execution, where it catches different types of exceptions including xfail, skip, exit, ValueError, fail and general exceptions, and handles them accordingly by either raising them or turning them into a skip with a specified message.",
            "code": "import pytest\n\n@pytest.hookimpl(hookwrapper=True)\ndef pytest_runtest_call(item):\n    outcome = yield\n    try:\n        outcome.get_result()\n    except (pytest.xfail.Exception, pytest.skip.Exception, pytest.exit.Exception):\n        raise  # already xfailed,  skipped or explicit exit\n    except ValueError:\n        raise  # not ignoring\n    except (pytest.fail.Exception, Exception):\n        # turn everything else into a skip\n        pytest.skip(\"[NOTRUN] ignoring everything but ValueError\")",
            "masked_code": "import pytest\n\n<line_mask>\ndef pytest_runtest_call(item):\n    outcome = yield\n    try:\n        outcome.get_result()\n    except (pytest.xfail.Exception, pytest.skip.Exception, pytest.exit.Exception):\n        raise  # already xfailed,  skipped or explicit exit\n    except ValueError:\n        raise  # not ignoring\n    except (pytest.fail.Exception, Exception):\n        # turn everything else into a skip\n        pytest.skip(\"[NOTRUN] ignoring everything but ValueError\")",
            "masked_line": "@pytest.hookimpl(hookwrapper=True)",
            "answer": "hookimpl",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_350"
        },
        {
            "dependency": "click",
            "version": "==6.7",
            "time": "2019-02-28",
            "description": "The main function defines a command line interface with a default command that prints \"Does A\" if no subcommand is invoked. The default_cmd_with_args function defines a subcommand that takes arguments and prints \"Does B: \" followed by the supplied arguments.",
            "code": "@click.group(cls=DefaultCommandGroup, invoke_without_command=True)\n@click.pass_context\ndef main(ctx):\n    if not ctx.invoked_subcommand:\n        click.echo(\"Does A\")\n\n@main.command(default_command=True)\n@click.argument('args', nargs=-1)\ndef default_cmd_with_args(args):\n    click.echo(\"Does B: {}\".format(args))",
            "masked_code": "@click.group(cls=DefaultCommandGroup, invoke_without_command=True)\n<line_mask>\ndef main(ctx):\n    if not ctx.invoked_subcommand:\n        click.echo(\"Does A\")\n\n@main.command(default_command=True)\n@click.argument('args', nargs=-1)\ndef default_cmd_with_args(args):\n    click.echo(\"Does B: {}\".format(args))",
            "masked_line": "@click.pass_context",
            "answer": "pass_context",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_351"
        },
        {
            "dependency": "tweepy",
            "version": "==3.5.0",
            "time": "2019-01-30",
            "description": "The code retrieves the last tweet ID from a list called previous_tweets, or sets it to None if the list is empty. It then iterates over a list of Twitter handles, retrieves the latest tweets for each handle since the last tweet ID, and persists the IDs of the latest tweets in memory.",
            "code": "try:\n    since_id = previous_tweets[-1]\nexcept IndexError:\n    since_id = None\n\nfor handle in handles:\n    last_tweet = None\n    for status in tweepy.Cursor(\n      api.user_timeline, screen_name=handle, \n      tweet_mode=\"extended\", since_id=since_id\n    ).items():\n     # ... persist tweets to flat file or database  \n     last_tweet_id = status.id\n\n    # this persists the last_tweet_id in memory.\n    # you may find that persisting this to a database a better way to go.\n    previous_tweets.append(last_tweet_id)",
            "masked_code": "try:\n    since_id = previous_tweets[-1]\nexcept IndexError:\n    since_id = None\n\nfor handle in handles:\n    last_tweet = None\n    <line_mask>\n      api.user_timeline, screen_name=handle, \n      tweet_mode=\"extended\", since_id=since_id\n    ).items():\n     # ... persist tweets to flat file or database  \n     last_tweet_id = status.id\n\n    # this persists the last_tweet_id in memory.\n    # you may find that persisting this to a database a better way to go.\n    previous_tweets.append(last_tweet_id)",
            "masked_line": "for status in tweepy.Cursor(",
            "answer": "Cursor",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_352"
        },
        {
            "dependency": "numpy",
            "version": "==1.14.0",
            "time": "2019-10-12",
            "description": "This code calculates the average of the first and last element in each file in the specified directory, and writes the results to a file named \"average.txt\".",
            "code": "import numpy as np\nimport os\ndata_path = os.path.abspath(\"/media/linux/DATADISK\")\n\nwith open(\"average.txt\", \"a\") as output:\n    for f in os.listdir(data_path):\n        f_path = os.path.join(data_path, f)\n        data = np.loadtxt(f_path, delimiter=' ', usecols=0)\n        average = (data[0] + data[-1]) / 2\n        output.write(str(average) + \"\\n\")",
            "masked_code": "import numpy as np\nimport os\ndata_path = os.path.abspath(\"/media/linux/DATADISK\")\n\nwith open(\"average.txt\", \"a\") as output:\n    for f in os.listdir(data_path):\n        f_path = os.path.join(data_path, f)\n        <line_mask>\n        average = (data[0] + data[-1]) / 2\n        output.write(str(average) + \"\\n\")",
            "masked_line": "data = np.loadtxt(f_path, delimiter=' ', usecols=0)",
            "answer": "loadtxt",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_353"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.0",
            "time": "2019-11-06",
            "description": "The code tests whether the TensorFlow 2.0 implementation of bilinear interpolation for image resizing aligns with the pixel-area-based approach used in OpenCV. The function resizes an input array with equivalent column indices to produce an expected output array with specific values at each position. The test asserts that the TensorFlow output matches the expected output within a specified tolerance level.",
            "code": "def test_tf2_resample_upsample_matches_opencv_methodology():\n    \"\"\"\n    According to the article below, the Tensorflow 1.x implementation of bilinear interpolation for resizing images did\n    not reproduce the pixel-area-based approach adopted by OpenCV. The `align_corners` option was set to False by\n    default due to some questionable legacy reasons but users were advised to set it to True in order to get a\n    'reasonable' output: https://jricheimer.github.io/tensorflow/2019/02/11/resize-confusion/\n    This appears to have been fixed in TF 2.0 and this test confirms that we get the results one would expect from a\n    pixel-area-based technique.\n\n    We start with an input array whose values are equivalent to their column indices:\n    input_arr = np.array([\n        [[0], [1], [2], [3], [4], [5]],\n        [[0], [1], [2], [3], [4], [5]],\n    ])\n\n    And then resize this (holding the rows dimension constant in size, but increasing the column dimnesion to 12) to\n    reproduce the OpenCV example from the article. We expect this to produce the following output:\n    expected_output = np.array([\n        [[0], [0.25], [0.75], [1.25], [1.75], [2.25], [2.75], [3.25], [3.75], [4.25], [4.75], [5]],\n        [[0], [0.25], [0.75], [1.25], [1.75], [2.25], [2.75], [3.25], [3.75], [4.25], [4.75], [5]],\n    ])\n\n    \"\"\"\n    input_tensor = tf.convert_to_tensor(\n        np.array([\n            [[0], [1], [2], [3], [4], [5]],\n            [[0], [1], [2], [3], [4], [5]],\n        ]),\n        dtype=tf.float32,\n    )\n    output_arr = tf.image.resize(\n        images=input_tensor,\n        size=(2,12),\n        method=tf.image.ResizeMethod.BILINEAR).numpy()\n    expected_output = np.array([\n        [[0], [0.25], [0.75], [1.25], [1.75], [2.25], [2.75], [3.25], [3.75], [4.25], [4.75], [5]],\n        [[0], [0.25], [0.75], [1.25], [1.75], [2.25], [2.75], [3.25], [3.75], [4.25], [4.75], [5]],\n    ])\n    np.testing.assert_almost_equal(output_arr, expected_output, decimal=2)",
            "masked_code": "def test_tf2_resample_upsample_matches_opencv_methodology():\n    \"\"\"\n    According to the article below, the Tensorflow 1.x implementation of bilinear interpolation for resizing images did\n    not reproduce the pixel-area-based approach adopted by OpenCV. The `align_corners` option was set to False by\n    default due to some questionable legacy reasons but users were advised to set it to True in order to get a\n    'reasonable' output: https://jricheimer.github.io/tensorflow/2019/02/11/resize-confusion/\n    This appears to have been fixed in TF 2.0 and this test confirms that we get the results one would expect from a\n    pixel-area-based technique.\n\n    We start with an input array whose values are equivalent to their column indices:\n    input_arr = np.array([\n        [[0], [1], [2], [3], [4], [5]],\n        [[0], [1], [2], [3], [4], [5]],\n    ])\n\n    And then resize this (holding the rows dimension constant in size, but increasing the column dimnesion to 12) to\n    reproduce the OpenCV example from the article. We expect this to produce the following output:\n    expected_output = np.array([\n        [[0], [0.25], [0.75], [1.25], [1.75], [2.25], [2.75], [3.25], [3.75], [4.25], [4.75], [5]],\n        [[0], [0.25], [0.75], [1.25], [1.75], [2.25], [2.75], [3.25], [3.75], [4.25], [4.75], [5]],\n    ])\n\n    \"\"\"\n    input_tensor = tf.convert_to_tensor(\n        np.array([\n            [[0], [1], [2], [3], [4], [5]],\n            [[0], [1], [2], [3], [4], [5]],\n        ]),\n        dtype=tf.float32,\n    )\n    <line_mask>\n        images=input_tensor,\n        size=(2,12),\n        method=tf.image.ResizeMethod.BILINEAR).numpy()\n    expected_output = np.array([\n        [[0], [0.25], [0.75], [1.25], [1.75], [2.25], [2.75], [3.25], [3.75], [4.25], [4.75], [5]],\n        [[0], [0.25], [0.75], [1.25], [1.75], [2.25], [2.75], [3.25], [3.75], [4.25], [4.75], [5]],\n    ])\n    np.testing.assert_almost_equal(output_arr, expected_output, decimal=2)",
            "masked_line": "output_arr = tf.image.resize(",
            "answer": "image",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_354"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-02-16",
            "description": "The function of the code is to reshape the input array \"arr_old\" into a new array \"arr_new\" with a shape of (2, 2, 3).",
            "code": "arr_old = np.array([\n               [1, 2, 3],\n               [1, 2, 3],\n               [1, 2, 3],\n               [1, 2, 3],\n               ])\n\nx, y = arr_old.shape # The shape of this input array is (4, 3)\n\narr_new = arr_old.reshape(int(x/2), 2, y) # Reshape the old array\n\nprint (arr_new.shape)  \n# (2, 2, 3)\n\nprint (arr_new)\n\n# [[[1 2 3]\n#  [1 2 3]]\n\n# [[1 2 3]\n#  [1 2 3]]]",
            "masked_code": "arr_old = np.array([\n               [1, 2, 3],\n               [1, 2, 3],\n               [1, 2, 3],\n               [1, 2, 3],\n               ])\n\nx, y = arr_old.shape # The shape of this input array is (4, 3)\n\n<line_mask>\n\nprint (arr_new.shape)  \n# (2, 2, 3)\n\nprint (arr_new)\n\n# [[[1 2 3]\n#  [1 2 3]]\n\n# [[1 2 3]\n#  [1 2 3]]]",
            "masked_line": "arr_new = arr_old.reshape(int(x/2), 2, y) # Reshape the old array",
            "answer": "reshape",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_355"
        },
        {
            "dependency": "pandas",
            "version": ">=0.24.0",
            "time": "2019-04-15",
            "description": "This code constructs intervals from endpoints and computes the intersections between these intervals and a set of original intervals.",
            "code": "endpoints = df.stack().sort_values().reset_index(drop=True)\nintervals = pd.DataFrame({'start':endpoints.shift().fillna(0), \n                          'end':endpoints}).astype(int)\n# construct the list of intervals from the endpoints\nintervals['intv'] = [pd.Interval(a,b) for a,b in zip(intervals.start, intervals.end)]\n\n# these are the original intervals\norig_invt = pd.arrays.IntervalArray([pd.Interval(a,b) for a,b in zip(df.start, df.end)])\n\n# walk through the intervals and compute the intersections\nintervals['total'] = intervals.intv.apply(lambda x: org_intv.overlaps(x).sum())",
            "masked_code": "endpoints = df.stack().sort_values().reset_index(drop=True)\nintervals = pd.DataFrame({'start':endpoints.shift().fillna(0), \n                          'end':endpoints}).astype(int)\n# construct the list of intervals from the endpoints\nintervals['intv'] = [pd.Interval(a,b) for a,b in zip(intervals.start, intervals.end)]\n\n# these are the original intervals\norig_invt = pd.arrays.IntervalArray([pd.Interval(a,b) for a,b in zip(df.start, df.end)])\n\n# walk through the intervals and compute the intersections\n<line_mask>",
            "masked_line": "intervals['total'] = intervals.intv.apply(lambda x: org_intv.overlaps(x).sum())",
            "answer": "intv",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_356"
        },
        {
            "dependency": "click",
            "version": "==7.1.2",
            "time": "2022-04-14",
            "description": "This Python code is creating a decorator that adds a prefix \"pre\" to the value of the \"--testy\" option passed to the decorated function. It then invokes the decorated function with the updated \"testy\" value and allows Click to be aware of the options defined on the wrapper. Finally, it uses functools to update the wrapper function as required.",
            "code": "def decorator_example(f):\n\n    @pass_context\n    @click.option(\"--testy\")\n    def wrapper(ctx, *args, testy, **kwargs):\n        # Do stuff with testy here\n        testy = f\"pre{testy}\"\n    \n    # Think this is the bit that allows click to be aware of options defined on the wrapper\n    return ctx.invoke(wrapped_function, *args, testy=testy, **kwargs)\n\n# Using functools to update the wrapper as required - think this is the same as @wraps(f)?\nreturn update_wrapper(wrapper, wrapped_function)",
            "masked_code": "def decorator_example(f):\n\n    @pass_context\n    <line_mask>\n    def wrapper(ctx, *args, testy, **kwargs):\n        # Do stuff with testy here\n        testy = f\"pre{testy}\"\n    \n    # Think this is the bit that allows click to be aware of options defined on the wrapper\n    return ctx.invoke(wrapped_function, *args, testy=testy, **kwargs)\n\n# Using functools to update the wrapper as required - think this is the same as @wraps(f)?\nreturn update_wrapper(wrapper, wrapped_function)",
            "masked_line": "@click.option(\"--testy\")",
            "answer": "option",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_357"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.1",
            "time": "2019-01-06",
            "description": "The code reindexes the dataframe by shifting the index positions, resets the index, renames the columns of the resulting dataframes with different prefixes, and then concatenates the original dataframe with the modified dataframes along the column axis. Finally, it prints the combined dataframe.",
            "code": "df2 = df.reindex(index=np.roll(df.index, -1)).reset_index(drop=True)\ndf2.columns = ['B{}'.format(i) for i in range(1, len(df.columns) + 1)]\n\ndf3 = df.reindex(index=np.roll(df.index, -2)).reset_index(drop=True)\ndf3.columns = ['C{}'.format(i) for i in range(1, len(df.columns) + 1)]\n\nresult = pd.concat([df, df2, df3], axis=1)\n\nprint(result)",
            "masked_code": "<line_mask>\ndf2.columns = ['B{}'.format(i) for i in range(1, len(df.columns) + 1)]\n\ndf3 = df.reindex(index=np.roll(df.index, -2)).reset_index(drop=True)\ndf3.columns = ['C{}'.format(i) for i in range(1, len(df.columns) + 1)]\n\nresult = pd.concat([df, df2, df3], axis=1)\n\nprint(result)",
            "masked_line": "df2 = df.reindex(index=np.roll(df.index, -1)).reset_index(drop=True)",
            "answer": "roll",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_358"
        },
        {
            "dependency": "pandas",
            "version": ">=0.25",
            "time": "2019-10-05",
            "description": "The code converts the 'start_time' and 'end_time' columns in a pandas DataFrame to Timestamp format if they are not already, and adjusts cases where the times cross the day boundary. It then creates a 'time' column that holds a minutely range using the start and end times. The code further explodes the DataFrame to individual minutes, groups them by time, fills any missing values with 0, and formats the index as time.",
            "code": "# Convert `start_time` and `end_time` to Timestamp, if they\n# are not already. This also allows you to adjust cases where\n# the times cross the day boundary, e.g.: 23:00 - 02:00\ndf['start_time'] = pd.to_datetime(df['start_time'])\ndf['end_time'] = pd.to_datetime(df['end_time'])\n\n# Make a `time` column that holds a minutely range. We will\n# later explode it into individual minutes\nf = lambda row: pd.date_range(row['start_time'], row['end_time'], freq='T')\ndf['time'] = df.apply(f, axis=1)\n\n# The reporting range, adjust as needed\nt = pd.date_range('13:23', '13:30', freq='T')\n\nresult = df.explode('time') \\\n            .groupby('time').size() \\\n            .reindex(t).fillna(0) \\\n            .to_frame('active')\nresult.index = result.index.time",
            "masked_code": "# Convert `start_time` and `end_time` to Timestamp, if they\n# are not already. This also allows you to adjust cases where\n# the times cross the day boundary, e.g.: 23:00 - 02:00\ndf['start_time'] = pd.to_datetime(df['start_time'])\ndf['end_time'] = pd.to_datetime(df['end_time'])\n\n# Make a `time` column that holds a minutely range. We will\n# later explode it into individual minutes\nf = lambda row: pd.date_range(row['start_time'], row['end_time'], freq='T')\ndf['time'] = df.apply(f, axis=1)\n\n# The reporting range, adjust as needed\nt = pd.date_range('13:23', '13:30', freq='T')\n\nresult = df.explode('time') \\\n            .groupby('time').size() \\\n            <line_mask>\n            .to_frame('active')\nresult.index = result.index.time",
            "masked_line": ".reindex(t).fillna(0) \\",
            "answer": "reindex",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_359"
        },
        {
            "dependency": "pandas",
            "version": ">=0.25.0",
            "time": "2019-10-02",
            "description": "This code counts the number of 'C's in each row of a dataframe, then based on the count, it extracts and manipulates ID values to create a final dataframe with concatenated ID values.",
            "code": "# count the amount of C's in each row\nc_count = df['Merged_ID'].str.count('C')\n\n# if the amount of C's is 1, then we take the last 2 characters, else the last 4 (which is id2) and inser a space between the two id2's\nid2 = pd.Series(np.where(c_count==1, df['Merged_ID'].str[-2:], df['Merged_ID'].str[-4:].apply(lambda x: x[:2]+ ' ' + x[2:])))\n\n# we substract id1 from the string\nid1 = df['Merged_ID'].str.split('C\\d').str[0]\n\n# we explode the concatenated id2's to different rows and join id1 back \nfinal = id1.to_frame().join(id2.str.split().explode().to_frame())\n\n# finally we concatenate the strings back to each other\nfinal.assign(Merged_ID = final['Merged_ID'].str.cat(final[0])).iloc[:, 0].to_frame()",
            "masked_code": "# count the amount of C's in each row\nc_count = df['Merged_ID'].str.count('C')\n\n# if the amount of C's is 1, then we take the last 2 characters, else the last 4 (which is id2) and inser a space between the two id2's\nid2 = pd.Series(np.where(c_count==1, df['Merged_ID'].str[-2:], df['Merged_ID'].str[-4:].apply(lambda x: x[:2]+ ' ' + x[2:])))\n\n# we substract id1 from the string\nid1 = df['Merged_ID'].str.split('C\\d').str[0]\n\n# we explode the concatenated id2's to different rows and join id1 back \n<line_mask>\n\n# finally we concatenate the strings back to each other\nfinal.assign(Merged_ID = final['Merged_ID'].str.cat(final[0])).iloc[:, 0].to_frame()",
            "masked_line": "final = id1.to_frame().join(id2.str.split().explode().to_frame())",
            "answer": "to_frame",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_360"
        },
        {
            "dependency": "numpy",
            "version": "==1.14.1",
            "time": "2019-06-26",
            "description": "This code concatenates the 'data' array with 'labels_ext' array along the fourth axis, resulting in a new array with a shape of (100, 81, 121, 8, 3).",
            "code": "In [215]: data = np.random.rand(100,81,121,6,3)\n\nIn [216]: labels = np.random.rand(100,2)\n\nIn [218]: labels_ext = np.broadcast_to(labels[:,None,None,:,None],(100,81,121,2,3))\n\nIn [219]: np.concatenate((data,labels_ext),axis=3).shape\nOut[219]: (100, 81, 121, 8, 3)",
            "masked_code": "In [215]: data = np.random.rand(100,81,121,6,3)\n\nIn [216]: labels = np.random.rand(100,2)\n\n<line_mask>\n\nIn [219]: np.concatenate((data,labels_ext),axis=3).shape\nOut[219]: (100, 81, 121, 8, 3)",
            "masked_line": "In [218]: labels_ext = np.broadcast_to(labels[:,None,None,:,None],(100,81,121,2,3))",
            "answer": "broadcast_to",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_361"
        },
        {
            "dependency": "pandas",
            "version": "==0.25.1",
            "time": "2019-10-30",
            "description": "This function converts a list of dictionaries into a sparse dataframe with three columns: 'docid', 'word', and 'n'.",
            "code": "def dicts_to_sparse_dataframe(docs):\n    rows = ((i, k, v)\n            for i, doc in enumerate(docs)\n            for k, v in doc.items())\n    out = pd.DataFrame(rows, columns=['docid', 'word', 'n'])\n    out = out.set_index(['docid', 'word'])['n'].astype(pd.SparseDtype(float))\n    out = out.unstack()\n    return out",
            "masked_code": "def dicts_to_sparse_dataframe(docs):\n    rows = ((i, k, v)\n            for i, doc in enumerate(docs)\n            for k, v in doc.items())\n    out = pd.DataFrame(rows, columns=['docid', 'word', 'n'])\n    out = out.set_index(['docid', 'word'])['n'].astype(pd.SparseDtype(float))\n    <line_mask>\n    return out",
            "masked_line": "out = out.unstack()",
            "answer": "unstack",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_362"
        },
        {
            "dependency": "dash",
            "version": "==2.0",
            "time": "2022-11-03",
            "description": "This code defines a callback function that displays a tooltip on a graph based on the hover data of a specified graph. The tooltip consists of an image and text content.",
            "code": "# Assuming app is your Dash app\n@app.callback(Output(\"graph-tooltip\", \"show\"), Output(\"graph-tooltip\", \"bbox\"),\n              Output(\"graph-tooltip\", \"children\"), Input(\"graph-basic-2\", \"hoverData\"),\n)\ndef display_hover(hoverData):\n    # ...\n    pt = hoverData[\"points\"][0]\n    bbox = pt[\"bbox\"]\n    # ...\n    # img_src is your image, e.g. from URL or b64 encoded\n    children = [\n        html.Div([\n            html.Img(src=img_src, style={\"width\": \"100%\"}),\n            html.P(\"Tooltip text\"),\n        ])\n    ]\n    return True, bbox, children",
            "masked_code": "# Assuming app is your Dash app\n<line_mask>\n              Output(\"graph-tooltip\", \"children\"), Input(\"graph-basic-2\", \"hoverData\"),\n)\ndef display_hover(hoverData):\n    # ...\n    pt = hoverData[\"points\"][0]\n    bbox = pt[\"bbox\"]\n    # ...\n    # img_src is your image, e.g. from URL or b64 encoded\n    children = [\n        html.Div([\n            html.Img(src=img_src, style={\"width\": \"100%\"}),\n            html.P(\"Tooltip text\"),\n        ])\n    ]\n    return True, bbox, children",
            "masked_line": "@app.callback(Output(\"graph-tooltip\", \"show\"), Output(\"graph-tooltip\", \"bbox\"),",
            "answer": "callback",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_363"
        },
        {
            "dependency": "cartopy",
            "version": "==0.15",
            "time": "2020-03-29",
            "description": "This function takes an xarray DataArray with dimensions (time, lat, lon), adds a cyclic point to the longitude dimension using the cartopy library, and returns a new DataArray with the same structure as the input but with the cyclic point added.",
            "code": "from cartopy.util import add_cyclic_point\nimport xarray as xr \n\ndef xr_add_cyclic_point(da):\n    \"\"\"\n    Inputs\n    da: xr.DataArray with dimensions (time,lat,lon)\n    \"\"\"\n\n    # Use add_cyclic_point to interpolate input data\n    lon_idx = da.dims.index('lon')\n    wrap_data, wrap_lon = add_cyclic_point(da.values, coord=da.lon, axis=lon_idx)\n\n    # Generate output DataArray with new data but same structure as input\n    outp_da = xr.DataArray(data=wrap_data, \n                           coords = {'time': da.time, 'lat': da.lat, 'lon': wrap_lon}, \n                           dims=da.dims, \n                           attrs=da.attrs)\n    \n    return outp_da",
            "masked_code": "<line_mask>\nimport xarray as xr \n\ndef xr_add_cyclic_point(da):\n    \"\"\"\n    Inputs\n    da: xr.DataArray with dimensions (time,lat,lon)\n    \"\"\"\n\n    # Use add_cyclic_point to interpolate input data\n    lon_idx = da.dims.index('lon')\n    wrap_data, wrap_lon = add_cyclic_point(da.values, coord=da.lon, axis=lon_idx)\n\n    # Generate output DataArray with new data but same structure as input\n    outp_da = xr.DataArray(data=wrap_data, \n                           coords = {'time': da.time, 'lat': da.lat, 'lon': wrap_lon}, \n                           dims=da.dims, \n                           attrs=da.attrs)\n    \n    return outp_da",
            "masked_line": "from cartopy.util import add_cyclic_point",
            "answer": "add_cyclic_point",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_364"
        },
        {
            "dependency": "networkx",
            "version": "==1.10",
            "time": "2020-09-15",
            "description": "The code creates a network visualization of a graph using matplotlib and networkx library in Python. It sets the figure size, positions the nodes in a circular layout, draws nodes with specified size, draws edges with different widths and styles, and labels the nodes with specified font size and family. Finally, it hides the axis and displays the graph visualization.",
            "code": "plt.figure(figsize=(10,6))\n\npos = nx.circular_layout(G)  # positions for all nodes\n# nodes\nnx.draw_networkx_nodes(G, pos, node_size=700)\n# edges\nnx.draw_networkx_edges(G, pos, edgelist=elarge, width=6)\nnx.draw_networkx_edges(\n    G, pos, edgelist=esmall, width=6, alpha=0.5, edge_color=\"b\", style=\"dashed\"\n)\n# labels\nnx.draw_networkx_labels(G, pos, font_size=20, font_family=\"sans-serif\")\n\nplt.axis(\"off\")\nplt.show()",
            "masked_code": "plt.figure(figsize=(10,6))\n\npos = nx.circular_layout(G)  # positions for all nodes\n# nodes\nnx.draw_networkx_nodes(G, pos, node_size=700)\n# edges\nnx.draw_networkx_edges(G, pos, edgelist=elarge, width=6)\nnx.draw_networkx_edges(\n    G, pos, edgelist=esmall, width=6, alpha=0.5, edge_color=\"b\", style=\"dashed\"\n)\n# labels\n<line_mask>\n\nplt.axis(\"off\")\nplt.show()",
            "masked_line": "nx.draw_networkx_labels(G, pos, font_size=20, font_family=\"sans-serif\")",
            "answer": "draw_networkx_labels",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_365"
        },
        {
            "dependency": "pandas",
            "version": "==1.1.0",
            "time": "2020-08-05",
            "description": "The code assigns a boolean value to the 'sortkey' column in dataframe df1 based on whether the 'Country' column contains duplicated values. It then sets the column labels of dataframe df2 to be the same as the columns of df1 excluding the last column. Additionally, it assigns a numeric value to the 'sortkey' column in df1 based on whether the 'Country' column contains duplicated values, replacing True with 2 and False with 0. Finally, it concatenates df1 and df2, sorts the resulting dataframe by 'Country' and 'sortkey', and assigns the 'Id' column of each group in 'Country' the value of the first 'Id' within that group. The code then outputs the sorted dataframe without the 'sortkey' column.",
            "code": "df1['sortkey'] = df1['Country'].duplicated()\ndf2 = df2.set_axis(df1.columns[:-1], axis=1)\n\ndf1['sortkey'] = df1['Country'].duplicated().replace({True:2, False:0})\ndf_sorted = (pd.concat([df1, df2.assign(sortkey=1)])\n               .sort_values(['Country', 'sortkey'], \n                            key=lambda x: x.astype(str).str.split(' ').str[0]))\n\ndf_sorted['Id'] = df_sorted.groupby(df_sorted['Country'].str.split(' ').str[0])['Id'].transform('first')\nprint(df_sorted.drop('sortkey', axis=1))",
            "masked_code": "df1['sortkey'] = df1['Country'].duplicated()\ndf2 = df2.set_axis(df1.columns[:-1], axis=1)\n\ndf1['sortkey'] = df1['Country'].duplicated().replace({True:2, False:0})\ndf_sorted = (pd.concat([df1, df2.assign(sortkey=1)])\n               .sort_values(['Country', 'sortkey'], \n                            key=lambda x: x.astype(str).str.split(' ').str[0]))\n\n<line_mask>\nprint(df_sorted.drop('sortkey', axis=1))",
            "masked_line": "df_sorted['Id'] = df_sorted.groupby(df_sorted['Country'].str.split(' ').str[0])['Id'].transform('first')",
            "answer": "split",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_366"
        },
        {
            "dependency": "Flask",
            "version": "==1.1.1",
            "time": "2020-02-14",
            "description": "This code defines a basic Flask application with a route that returns a greeting message 'Hello World!' when a user accesses the root URL '/'.",
            "code": "# [START gae_python37_app]\nfrom flask import Flask\nimport pyzbar\n\napp = Flask(__name__)\n\n\n@app.route('/')\ndef hello():\n   \"\"\"Return a friendly HTTP greeting.\"\"\"\n   return 'Hello World!'",
            "masked_code": "# [START gae_python37_app]\nfrom flask import Flask\nimport pyzbar\n\napp = Flask(__name__)\n\n\n<line_mask>\ndef hello():\n   \"\"\"Return a friendly HTTP greeting.\"\"\"\n   return 'Hello World!'",
            "masked_line": "@app.route('/')",
            "answer": "route",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_367"
        },
        {
            "dependency": "pyttsx3",
            "version": "==2.6",
            "time": "2021-10-16",
            "description": "The code generates speech using pyttsx3, iterating through different voices and speaking the sentence \"The quick brown fox jumped over the lazy dog\" with each voice.",
            "code": "engine = pyttsx3.init()\nvoices = engine.getProperty('voices')\nfor voice in voices:\n  engine.setProperty('voice', voice.id)\n  engine.say('The quick brown fox jumped over the lazy dog.')\nengine.runAndWait()",
            "masked_code": "<line_mask>\nvoices = engine.getProperty('voices')\nfor voice in voices:\n  engine.setProperty('voice', voice.id)\n  engine.say('The quick brown fox jumped over the lazy dog.')\nengine.runAndWait()",
            "masked_line": "engine = pyttsx3.init()",
            "answer": "init",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_368"
        },
        {
            "dependency": "pyparsing",
            "version": "==2.4.7",
            "time": "2021-04-19",
            "description": "The code constructs a parser using pyparsing to parse a query string that may contain a LIMIT clause followed by an integer number, and then parses the query string \"LIMIT 1\" to extract and display the parsed result containing the LIMIT clause and the integer number.",
            "code": "import pyparsing\n\n# construct parser\nLIMIT = 'LIMIT'\nint_num = pyparsing.pyparsing_common.signed_integer()\nlimit_clause = pyparsing.Optional(pyparsing.Group(LIMIT + int_num), None)\nstatement = limit_clause('limit')\n# parse a string\nquery = 'LIMIT 1'\nresult = statement.parseString(query)\nprint(repr(result))",
            "masked_code": "import pyparsing\n\n# construct parser\nLIMIT = 'LIMIT'\n<line_mask>\nlimit_clause = pyparsing.Optional(pyparsing.Group(LIMIT + int_num), None)\nstatement = limit_clause('limit')\n# parse a string\nquery = 'LIMIT 1'\nresult = statement.parseString(query)\nprint(repr(result))",
            "masked_line": "int_num = pyparsing.pyparsing_common.signed_integer()",
            "answer": "signed_integer",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_369"
        },
        {
            "dependency": "pytest",
            "version": "==2.5.2",
            "time": "2021-01-28",
            "description": "The code defines two test functions \"test_foo\" and \"test_bar\", where both tests assert True, with \"test_foo\" marked as order2 and \"test_bar\" marked as order1.",
            "code": "import pytest\n\n@pytest.mark.order2\ndef test_foo():\n    assert True\n\n@pytest.mark.order1\ndef test_bar():\n    assert True",
            "masked_code": "import pytest\n\n@pytest.mark.order2\ndef test_foo():\n    assert True\n\n<line_mask>\ndef test_bar():\n    assert True",
            "masked_line": "@pytest.mark.order1",
            "answer": "order1",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_370"
        },
        {
            "dependency": "numpy",
            "version": "==1.20.0",
            "time": "2022-03-26",
            "description": "The code creates a sliding window view of a flattened array 'a' with size 4, then applies a function 'create_array' along the rows of the sliding window view, which creates a new array containing the first 3 elements of each row and the last element of each row as separate arrays. Finally, it prints the result 'c'.",
            "code": "a = np.array([[1, 3, 5, 7, 8, 7, 1],[11, 13, 51, 17, 18, 17, 10]])\nb = np.lib.stride_tricks.sliding_window_view(a.ravel(),4)\n\ndef create_array(row):\n    return np.array([row[:3],np.array(row[-1])], dtype=object)\n\nc = np.apply_along_axis(create_array, 1, b)\nprint(c)",
            "masked_code": "a = np.array([[1, 3, 5, 7, 8, 7, 1],[11, 13, 51, 17, 18, 17, 10]])\nb = np.lib.stride_tricks.sliding_window_view(a.ravel(),4)\n\ndef create_array(row):\n    return np.array([row[:3],np.array(row[-1])], dtype=object)\n\n<line_mask>\nprint(c)",
            "masked_line": "c = np.apply_along_axis(create_array, 1, b)",
            "answer": "apply_along_axis",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_371"
        },
        {
            "dependency": "pandas",
            "version": ">=1.4",
            "time": "2022-02-02",
            "description": "This code defines a function named `badlines_collect` that takes a list of strings as input and appends the input list to the `badlines_list`. The code then reads a CSV file using pandas, where if there are any bad lines encountered during reading, the `badlines_collect` function is called to collect and store those bad lines in the `badlines_list`.",
            "code": "badlines_list = []\ndef badlines_collect (bad_line: list[str]) -> None:\n        badlines_list.append(bad_line)\n        return None\n\ndf = pd.read_csv(csv_file, engine=\"python\",on_bad_lines=badlines_collect)",
            "masked_code": "badlines_list = []\ndef badlines_collect (bad_line: list[str]) -> None:\n        badlines_list.append(bad_line)\n        return None\n\n<line_mask>",
            "masked_line": "df = pd.read_csv(csv_file, engine=\"python\",on_bad_lines=badlines_collect)",
            "answer": "read_csv",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_372"
        },
        {
            "dependency": "folium",
            "version": "==0.12.1",
            "time": "2022-11-17",
            "description": "The code creates a map using Folium with a specific location and zoom level, then adds the map to a container using Branca. Finally, it renders the map in a web page template along with other context data.",
            "code": "current_map = folium.Map(location=(48.51, 32.25), zoom_start=6)\nmap_container = branca.element.Figure(height=\"100%\")\nmap_container.add_child(current_map)\n...\ncontext = {\"current_map\": map_container.render(), \"form\": form}\nreturn render(request, template_name=\"hub/index.html\", context=context)",
            "masked_code": "<line_mask>\nmap_container = branca.element.Figure(height=\"100%\")\nmap_container.add_child(current_map)\n...\ncontext = {\"current_map\": map_container.render(), \"form\": form}\nreturn render(request, template_name=\"hub/index.html\", context=context)",
            "masked_line": "current_map = folium.Map(location=(48.51, 32.25), zoom_start=6)",
            "answer": "Map",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_373"
        },
        {
            "dependency": "huggingface-hub",
            "version": "==0.13.3",
            "time": "2023-03-22",
            "description": "This code retrieves a list of models for automatic speech recognition from the Hugging Face model hub, then prints the total number of models in the list and the model ID of the first model in the list.",
            "code": "from huggingface_hub import HfApi, ModelFilter\napi = HfApi()\nmodels = api.list_models(\n    filter=ModelFilter(\n        task=\"automatic-speech-recognition\"\n    )\n)\nmodels = list(models)\nprint(len(models))\nprint(models[0].modelId)",
            "masked_code": "<line_mask>\napi = HfApi()\nmodels = api.list_models(\n    filter=ModelFilter(\n        task=\"automatic-speech-recognition\"\n    )\n)\nmodels = list(models)\nprint(len(models))\nprint(models[0].modelId)",
            "masked_line": "from huggingface_hub import HfApi, ModelFilter",
            "answer": "HfApi",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_374"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.7.1",
            "time": "2023-04-06",
            "description": "This code generates a contour plot of the data represented by the arrays x, y, and T. The plot uses the 'turbo' colormap and shows contour levels from 0 to 100 in increments of 5. The plot is displayed with a color bar and the text \"StackOverflow\" is centered at coordinates (0.5, 0.5) on the plot. The aspect ratio of the plot is set to be equal. Finally, the plot is shown.",
            "code": "fig, ax = plt.subplots(figsize=(10, 8))\n\nCS = ax.tricontourf(x, y, T, cmap=cm.turbo, extend='neither', levels=np.arange(0, 101, 5))\n\nfig.colorbar(CS), ax.set_aspect('equal')\n\nax.text(0.5, 0.5, # X & Y coordinates\n        s='StackOverflow', # <-- put your text here\n        fontsize=12, # adjust the fontsize\n        ha='center', transform=ax.transAxes)\n\nplt.show()",
            "masked_code": "<line_mask>\n\nCS = ax.tricontourf(x, y, T, cmap=cm.turbo, extend='neither', levels=np.arange(0, 101, 5))\n\nfig.colorbar(CS), ax.set_aspect('equal')\n\nax.text(0.5, 0.5, # X & Y coordinates\n        s='StackOverflow', # <-- put your text here\n        fontsize=12, # adjust the fontsize\n        ha='center', transform=ax.transAxes)\n\nplt.show()",
            "masked_line": "fig, ax = plt.subplots(figsize=(10, 8))",
            "answer": "subplots",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_375"
        },
        {
            "dependency": "matplotlib",
            "version": "==2.2.2",
            "time": "2019-01-29",
            "description": "This code sorts a list of features and their corresponding importance values, then creates a horizontal bar plot to visualize the importance of each feature.",
            "code": "features_sorted = []\nimportance_sorted = []\n\nfor i in sorted_list:\n    features_sorted += [i[1]]\n    importance_sorted += [i[0]]\n\nplt.title(\"Feature importance\", fontsize=15)\nplt.xlabel(\"Importance\", fontsize=13)\n\nplt.barh(range(len(importance_sorted)), importance_sorted, color=\"green\", edgecolor='green')\nplt.yticks(range(len(importance_sorted)), features_sorted);",
            "masked_code": "features_sorted = []\nimportance_sorted = []\n\nfor i in sorted_list:\n    features_sorted += [i[1]]\n    importance_sorted += [i[0]]\n\nplt.title(\"Feature importance\", fontsize=15)\nplt.xlabel(\"Importance\", fontsize=13)\n\n<line_mask>\nplt.yticks(range(len(importance_sorted)), features_sorted);",
            "masked_line": "plt.barh(range(len(importance_sorted)), importance_sorted, color=\"green\", edgecolor='green')",
            "answer": "barh",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_376"
        },
        {
            "dependency": "tensorflow",
            "version": "==1.13",
            "time": "2019-05-11",
            "description": "The code defines a neural network model consisting of two dense layers with relu and softmax activation functions, respectively. The model is compiled with Adam optimizer, categorical crossentropy loss function, and accuracy metrics. It then trains the model on the provided data and labels for 10 epochs with 2 steps per epoch.",
            "code": "model = tf.keras.Sequential([\ntf.keras.layers.Dense(3, activation='relu'),\ntf.keras.layers.Dense(3, activation='softmax')])\n\nmodel.compile(optimizer=tf.train.AdamOptimizer(0.001),\n              loss='categorical_crossentropy',\n              metrics=['accuracy'])\n\n\ndata = tf.constant([[0,0,1],[0,1,0],[1,0,0]], dtype=tf.float32)\nlabel = tf.constant([[0,0,1],[0,1,0],[1,0,0]], dtype=tf.float32)\nmodel.fit(data, label, epochs=10, steps_per_epoch=2)",
            "masked_code": "model = tf.keras.Sequential([\ntf.keras.layers.Dense(3, activation='relu'),\ntf.keras.layers.Dense(3, activation='softmax')])\n\nmodel.compile(optimizer=tf.train.AdamOptimizer(0.001),\n              loss='categorical_crossentropy',\n              metrics=['accuracy'])\n\n\ndata = tf.constant([[0,0,1],[0,1,0],[1,0,0]], dtype=tf.float32)\nlabel = tf.constant([[0,0,1],[0,1,0],[1,0,0]], dtype=tf.float32)\n<line_mask>",
            "masked_line": "model.fit(data, label, epochs=10, steps_per_epoch=2)",
            "answer": "fit",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_377"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-01-14",
            "description": "The code calculates the 75th, 100th, and 99th percentiles of the values in array 'a', and then uses linear interpolation to find the approximate 99th percentile value.",
            "code": "a = np.array([0,0.2,0.4,0.7,1])\n\nnp.sort(a)  # array([ 0. ,  0.2,  0.4,  0.7,  1. ])\n\nnp.percentile(a, 75)   # 0.70\nnp.percentile(a, 100)  # 1.0\nnp.percentile(a, 99)   # 0.988\n\n0.70 + (1.0 - 0.70) * (99 - 75) / (100 - 75)  # 0.988",
            "masked_code": "<line_mask>\n\nnp.sort(a)  # array([ 0. ,  0.2,  0.4,  0.7,  1. ])\n\nnp.percentile(a, 75)   # 0.70\nnp.percentile(a, 100)  # 1.0\nnp.percentile(a, 99)   # 0.988\n\n0.70 + (1.0 - 0.70) * (99 - 75) / (100 - 75)  # 0.988",
            "masked_line": "a = np.array([0,0.2,0.4,0.7,1])",
            "answer": "array",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_378"
        },
        {
            "dependency": "numpy",
            "version": "==1.13.0",
            "time": "2019-08-12",
            "description": "The function takes an array as input, rounds the elements to the nearest integer, and returns a new array with the rounded values.",
            "code": "nb.jit(nopython=True)\ndef func(x):\n    out = np.empty_like(x)\n    np.round(x, 0, out)\n    return out",
            "masked_code": "nb.jit(nopython=True)\ndef func(x):\n    out = np.empty_like(x)\n    <line_mask>\n    return out",
            "masked_line": "np.round(x, 0, out)",
            "answer": "round",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_379"
        },
        {
            "dependency": "numpy",
            "version": "==1.15.0",
            "time": "2019-10-03",
            "description": "This code shuffles unique values of 'GT' and 'PRED' columns in a DataFrame, creates pairs of shuffled values, and then selects rows in the DataFrame where either 'GT' or 'PRED' matches the shuffled pairs.",
            "code": "gt_u = df2['GT'].unique()\npred_u = df2['PRED'].unique()\n\nnp.random.shuffle(gt_u)\nnp.random.shuffle(pred_u)\n\npairs = pd.DataFrame({'GT':gt_u, 'PRED':pred_u})    \n#pairs = pd.DataFrame([[x, y] for x, y in zip(gt_u, pred_u)], columns=['GT', 'PRED'])\n\nsel = df2.apply(lambda x : (x[['GT', 'PRED']] == pairs).all(axis=1).any(axis=0), axis=1)\nout = df2.loc[sel]",
            "masked_code": "gt_u = df2['GT'].unique()\npred_u = df2['PRED'].unique()\n\nnp.random.shuffle(gt_u)\n<line_mask>\n\npairs = pd.DataFrame({'GT':gt_u, 'PRED':pred_u})    \n#pairs = pd.DataFrame([[x, y] for x, y in zip(gt_u, pred_u)], columns=['GT', 'PRED'])\n\nsel = df2.apply(lambda x : (x[['GT', 'PRED']] == pairs).all(axis=1).any(axis=0), axis=1)\nout = df2.loc[sel]",
            "masked_line": "np.random.shuffle(pred_u)",
            "answer": "random",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_380"
        },
        {
            "dependency": "pandas",
            "version": "==1.0.0",
            "time": "2020-03-10",
            "description": "This code defines a function called \"print_window\" that prints the input window and a line of equal signs below it. It then defines a function called \"example\" which reads data from a CSV file and applies the \"print_window\" function to a rolling window of size 5.",
            "code": "def print_window(window):\n  print(window)\n  print('==================')\n  return 0\n\n\ndef example():\n\n  df = pd.read_csv('window_example.csv')\n\n  df.rolling(5).apply(print_window)",
            "masked_code": "def print_window(window):\n  print(window)\n  print('==================')\n  return 0\n\n\ndef example():\n\n  <line_mask>\n\n  df.rolling(5).apply(print_window)",
            "masked_line": "df = pd.read_csv('window_example.csv')",
            "answer": "read_csv",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_381"
        },
        {
            "dependency": "networkx",
            "version": "==1.9",
            "time": "2020-05-24",
            "description": "This code generates a visualization of a network graph using the spring layout algorithm in NetworkX library, where the nodes are positioned based on their connections and the edges are drawn to connect the nodes. Labels are added to the nodes slightly above their original positions.",
            "code": "pos = nx.spring_layout(G, scale=0.2)\nnx.draw_networkx_nodes(G,pos)\nnx.draw_networkx_edges(G,pos)\ny_off = 0.02\nnx.draw_networkx_labels(G, pos = {k:([v[0], v[1]+y_off]) for k,v in pos.items()})",
            "masked_code": "pos = nx.spring_layout(G, scale=0.2)\n<line_mask>\nnx.draw_networkx_edges(G,pos)\ny_off = 0.02\nnx.draw_networkx_labels(G, pos = {k:([v[0], v[1]+y_off]) for k,v in pos.items()})",
            "masked_line": "nx.draw_networkx_nodes(G,pos)",
            "answer": "draw_networkx_nodes",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_382"
        },
        {
            "dependency": "numba",
            "version": "==0.47.0",
            "time": "2020-02-17",
            "description": "This function calculates the number of steps needed to reach the value 1 from the input value 'b' following the Collatz conjecture algorithm.",
            "code": "@numba.njit\ndef numb_steps(b, steps):\n\n    e = b    \n    d = 0\n\n    while True:\n\n        if e == 1:\n            return d + steps[e]\n\n        if e % 2 == 0:\n            e //= 2\n        else:\n            e = 3*e + 1\n\n        d += 1",
            "masked_code": "<line_mask>\ndef numb_steps(b, steps):\n\n    e = b    \n    d = 0\n\n    while True:\n\n        if e == 1:\n            return d + steps[e]\n\n        if e % 2 == 0:\n            e //= 2\n        else:\n            e = 3*e + 1\n\n        d += 1",
            "masked_line": "@numba.njit",
            "answer": "njit",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_383"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.x",
            "time": "2020-09-04",
            "description": "The code trains a TensorFlow variable 'w' using the gradient descent optimizer to minimize the cost function, which is a quadratic function of 'w' with coefficients provided in the 'coefficients' constant tensor. After 100 iterations, it prints the final value of 'w' that minimizes the cost function.",
            "code": "coefficients = tf.constant([[1.], [-10.], [25.]])\nw = tf.Variable(0.0)\n\n@tf.function\ndef train(x):\n  cost = (x[0][0] * (w**2)) + (x[1][0]*w) + (x[2][0])\n  tf.compat.v1.train.GradientDescentOptimizer(0.05).minimize(cost, var_list=[w])\n\nfor i in range(100):\n    train(coefficients)\n\nprint(w)",
            "masked_code": "<line_mask>\nw = tf.Variable(0.0)\n\n@tf.function\ndef train(x):\n  cost = (x[0][0] * (w**2)) + (x[1][0]*w) + (x[2][0])\n  tf.compat.v1.train.GradientDescentOptimizer(0.05).minimize(cost, var_list=[w])\n\nfor i in range(100):\n    train(coefficients)\n\nprint(w)",
            "masked_line": "coefficients = tf.constant([[1.], [-10.], [25.]])",
            "answer": "constant",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_384"
        },
        {
            "dependency": "opencv-python",
            "version": "==4.2.0",
            "time": "2020-11-14",
            "description": "The code stitches two images together to create a panoramic image.",
            "code": "stitcher = cv2.Stitcher.create(cv2.Stitcher_PANORAMA)\nstitcher.setPanoConfidenceThresh(0.0) # might be too aggressive for real examples\nfoo = cv2.imread(\"/path/to/image1.jpg\")\nbar = cv2.imread(\"/path/to/image2.jpg\")\nstatus, result = stitcher.stitch((foo,bar))\nassert status == 0 # Verify returned status is 'success'\ncv2.imshow(\"result\", result)\ncv2.waitKey(0)\ncv2.destroyAllWindows()",
            "masked_code": "stitcher = cv2.Stitcher.create(cv2.Stitcher_PANORAMA)\n<line_mask>\nfoo = cv2.imread(\"/path/to/image1.jpg\")\nbar = cv2.imread(\"/path/to/image2.jpg\")\nstatus, result = stitcher.stitch((foo,bar))\nassert status == 0 # Verify returned status is 'success'\ncv2.imshow(\"result\", result)\ncv2.waitKey(0)\ncv2.destroyAllWindows()",
            "masked_line": "stitcher.setPanoConfidenceThresh(0.0) # might be too aggressive for real examples",
            "answer": "setPanoConfidenceThresh",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_385"
        },
        {
            "dependency": "Flask",
            "version": "==1.1.2",
            "time": "2020-04-13",
            "description": "This code defines a Flask web application with two routes. The '/custom.html' route renders a custom HTML template, while the '/trigger-python' route prints a success message to the console and returns 'OK'. When the application is run, it starts a development server on localhost at port 8080.",
            "code": "from flask import Flask, render_template\n\napp = Flask(__name__)\n\n\n@app.route('/custom.html')\ndef custom():\n    return render_template('custom.html')\n\n@app.route(\"/trigger-python\")\ndef print_something():\n    print(\"Successful line print\")\n    return 'OK'\n\nif __name__ == '__main__':\n    app.run(host='127.0.0.1', port=8080, debug=True)",
            "masked_code": "from flask import Flask, render_template\n\napp = Flask(__name__)\n\n\n@app.route('/custom.html')\ndef custom():\n    return render_template('custom.html')\n\n@app.route(\"/trigger-python\")\ndef print_something():\n    print(\"Successful line print\")\n    return 'OK'\n\nif __name__ == '__main__':\n    <line_mask>",
            "masked_line": "app.run(host='127.0.0.1', port=8080, debug=True)",
            "answer": "run",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_386"
        },
        {
            "dependency": "networkx",
            "version": "==1.9",
            "time": "2020-06-15",
            "description": "The code reads data from a file, creates a weighted graph, adds weighted edges to the graph, and returns a view of the edges with their weights.",
            "code": "weight = 1\nedges = [[*map(int,line.split()), weight] for line in open(\"file.txt\")]\nG = nx.Graph()\nG.add_weighted_edges_from(edges)\nG.edges(data=True)\n# EdgeDataView([(1, 2, {'weight': 1}), (1, 3, {'weight': 1}), (2, 4, {'weight': 1})])",
            "masked_code": "weight = 1\nedges = [[*map(int,line.split()), weight] for line in open(\"file.txt\")]\n<line_mask>\nG.add_weighted_edges_from(edges)\nG.edges(data=True)\n# EdgeDataView([(1, 2, {'weight': 1}), (1, 3, {'weight': 1}), (2, 4, {'weight': 1})])",
            "masked_line": "G = nx.Graph()",
            "answer": "Graph",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_387"
        },
        {
            "dependency": "scipy",
            "version": "==0.14.0",
            "time": "2020-01-19",
            "description": "This code solves a system of non-linear equations using the fsolve function from the scipy.optimize library. The equations are defined in the equations function, and the initial values are set for the variables x0, x1, and x2. The solution is then calculated for the given initial vector (0.0, 0.0, 0.0) and the parameters a, b, and c. Finally, the solution values x0, x1, and x2 are printed.",
            "code": "from scipy.optimize import fsolve\nfrom numpy import cos, sin, exp\n\n# Define the non-linear equations\ndef equations(X, a,b,c):\n    x0, x1, x2 = X\n    return [3*x0-cos(x1*x2)+ a, x0*x0-81*(x1+0.1)**2+ sin(x2)+b, exp(-x0*x1)+20*x2+c]\n\na = 1.0\nb = 0.5\nc = 2.5\n\n# Using (0.0, 0.0, 0.0) as an initial vector\nx0, x1, x2 = fsolve(equations, x0=(0.,0.,0.), args=(a,b,c)) \nprint(x0, x1, x2)",
            "masked_code": "<line_mask>\nfrom numpy import cos, sin, exp\n\n# Define the non-linear equations\ndef equations(X, a,b,c):\n    x0, x1, x2 = X\n    return [3*x0-cos(x1*x2)+ a, x0*x0-81*(x1+0.1)**2+ sin(x2)+b, exp(-x0*x1)+20*x2+c]\n\na = 1.0\nb = 0.5\nc = 2.5\n\n# Using (0.0, 0.0, 0.0) as an initial vector\nx0, x1, x2 = fsolve(equations, x0=(0.,0.,0.), args=(a,b,c)) \nprint(x0, x1, x2)",
            "masked_line": "from scipy.optimize import fsolve",
            "answer": "fsolve",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_388"
        },
        {
            "dependency": "tensorflow",
            "version": ">2.4",
            "time": "2021-12-01",
            "description": "This Python code defines a TensorFlow model class called TimingModelTF. The call method of this class takes an input tensor x, converts it to a float32 data type, and returns the element at the 0th row and 0th column of the tensor.",
            "code": "class TimingModelTF(tf.keras.Model):\n    def __init__(self, ):\n        super(TimingModelTF, self).__init__()\n\n    @tf.function(jit_compile=True)\n    def call(self, x):\n        return tf.cast(x, dtype=tf.float32)[0, 0]",
            "masked_code": "class TimingModelTF(tf.keras.Model):\n    def __init__(self, ):\n        super(TimingModelTF, self).__init__()\n\n    @tf.function(jit_compile=True)\n    def call(self, x):\n        <line_mask>",
            "masked_line": "return tf.cast(x, dtype=tf.float32)[0, 0]",
            "answer": "cast",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_389"
        },
        {
            "dependency": "seaborn",
            "version": "==0.11.1",
            "time": "2021-05-06",
            "description": "The code generates a horizontal bar plot using seaborn library to visualize the new data with predictions for different variables. The plot displays the values for each variable with different colors representing different predictions.",
            "code": "import pandas as pd\nimport seaborn as sns\n\n# new data; note there are different values for prediction\n{'prediction': {5: 'c1', 4: 'c3', 3: 'c3', 2: 'c1', 0: 'c1', 1: 'c2', 7: 'c2', 6: 'c2'}, 'variable': {5: 'ft1', 4: 'ft2', 3: 'ft3', 2: 'ft4', 0: 'ft5', 1: 'ft6', 7: 'ft7', 6: 'ft8'}, 'value': {5: 0.020915912763961077, 4: 0.020388363414781133, 3: 0.007204373035913109, 2: 0.0035298765062560817, 0: -0.002049702058734183, 1: -0.004283512505036808, 7: -0.01882610282871816, 6: -0.022324439779323434}}\n\ndf = pd.DataFrame(x)\n\nsns.barplot(data=df, x='value', y='variable', hue='prediction', orient=\"h\", color='red', ec='k', dodge=False)",
            "masked_code": "import pandas as pd\nimport seaborn as sns\n\n# new data; note there are different values for prediction\n{'prediction': {5: 'c1', 4: 'c3', 3: 'c3', 2: 'c1', 0: 'c1', 1: 'c2', 7: 'c2', 6: 'c2'}, 'variable': {5: 'ft1', 4: 'ft2', 3: 'ft3', 2: 'ft4', 0: 'ft5', 1: 'ft6', 7: 'ft7', 6: 'ft8'}, 'value': {5: 0.020915912763961077, 4: 0.020388363414781133, 3: 0.007204373035913109, 2: 0.0035298765062560817, 0: -0.002049702058734183, 1: -0.004283512505036808, 7: -0.01882610282871816, 6: -0.022324439779323434}}\n\ndf = pd.DataFrame(x)\n\n<line_mask>",
            "masked_line": "sns.barplot(data=df, x='value', y='variable', hue='prediction', orient=\"h\", color='red', ec='k', dodge=False)",
            "answer": "barplot",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_390"
        },
        {
            "dependency": "matplotlib",
            "version": ">=3.4.0",
            "time": "2021-07-11",
            "description": "This code generates a bar plot showing the relationship between two variables. The x-axis represents the index of the data group, the y-axis represents the values of the group. The plot displays the average of the second variable for each group. The plot also includes labels for the bars and a title describing the relationship between the two variables.",
            "code": "def barplot_groups(group_, my_labels, var_names):\n    fig, ax = plt.subplots(figsize=(15, 7))\n    sns.barplot(x=group_.index, y=group_.values, ax=ax)\n    ax.set(xlabel=f'{var_names[0]}',\n           ylabel=f'Average of {var_names[1]}',\n           title=f'Relationship between {var_names[0]} and {var_names[1]}')\n\n    ax.bar_label(ax.containers[0], labels=my_labels, label_type='center',\n                 rotation=90)\n    plt.show()",
            "masked_code": "def barplot_groups(group_, my_labels, var_names):\n    <line_mask>\n    sns.barplot(x=group_.index, y=group_.values, ax=ax)\n    ax.set(xlabel=f'{var_names[0]}',\n           ylabel=f'Average of {var_names[1]}',\n           title=f'Relationship between {var_names[0]} and {var_names[1]}')\n\n    ax.bar_label(ax.containers[0], labels=my_labels, label_type='center',\n                 rotation=90)\n    plt.show()",
            "masked_line": "fig, ax = plt.subplots(figsize=(15, 7))",
            "answer": "subplots",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_391"
        },
        {
            "dependency": "matplotlib",
            "version": "==3.0.3",
            "time": "2021-10-28",
            "description": "The code creates a polar plot with data points from the lists data1 and data2.",
            "code": "data1 = [-2, -5,  2, 2]\ndata2 = [-2, 2, -2, 2]\n\nfig = plt.figure()\nax = fig.add_subplot(111, projection=\"polar\")\nax.scatter(\n        data2,\n        data1,\n        s=30)\n\nplt.show()",
            "masked_code": "data1 = [-2, -5,  2, 2]\ndata2 = [-2, 2, -2, 2]\n\nfig = plt.figure()\n<line_mask>\nax.scatter(\n        data2,\n        data1,\n        s=30)\n\nplt.show()",
            "masked_line": "ax = fig.add_subplot(111, projection=\"polar\")",
            "answer": "add_subplot",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_392"
        },
        {
            "dependency": "requests",
            "version": ">=2.4.0",
            "time": "2021-05-07",
            "description": "The code tries to download content from a given link with a timeout of 10 seconds. If a connection error or read timeout occurs, an error message is printed. If any other exception occurs, an error message is also printed.",
            "code": "try : \n    timeout = 10\n    r = requests.get(\"download_link\", timeout=10)\n    data = r.content\nexcept requests.exceptions.ConnectionError as ex:\n    print('Issue file download...'+str(ex))\nexcept requests.exceptions.ReadTimeout as ex:\n    print('Issue file download...'+str(ex))\nexcept Exception as ex:\n    print('Issue file download...'+str(ex))",
            "masked_code": "try : \n    timeout = 10\n    <line_mask>\n    data = r.content\nexcept requests.exceptions.ConnectionError as ex:\n    print('Issue file download...'+str(ex))\nexcept requests.exceptions.ReadTimeout as ex:\n    print('Issue file download...'+str(ex))\nexcept Exception as ex:\n    print('Issue file download...'+str(ex))",
            "masked_line": "r = requests.get(\"download_link\", timeout=10)",
            "answer": "get",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_393"
        },
        {
            "dependency": "pandas",
            "version": "==0.24.2",
            "time": "2022-07-29",
            "description": "The code writes a pandas DataFrame to an Excel sheet named 'Sheet1' with a specific cell 'A2' formatted to display duration format in the format [hh]:mm:ss, and then saves the changes to the Excel file on disk.",
            "code": "writer = pd.ExcelWriter(file = './sheet.xlsx', engine='openpyxl')\n\n\n# Writes dataFrame to Writer Sheet, including column header\n\ndf.to_excel(writer, sheet_name='Sheet1', index=False)\n\n\n# Selects which Sheet in Writer to manipulate\n\nsheet = writer.sheets['Sheet1']\n\n\n# Formats specific cell with desired duration format\n\ncell = 'A2'\nsheet[cell].number_format = '[hh]:mm:ss'\n\n\n# Writes to file on disk\n\nwriter.save()\nwriter.close()",
            "masked_code": "writer = pd.ExcelWriter(file = './sheet.xlsx', engine='openpyxl')\n\n\n# Writes dataFrame to Writer Sheet, including column header\n\ndf.to_excel(writer, sheet_name='Sheet1', index=False)\n\n\n# Selects which Sheet in Writer to manipulate\n\nsheet = writer.sheets['Sheet1']\n\n\n# Formats specific cell with desired duration format\n\ncell = 'A2'\nsheet[cell].number_format = '[hh]:mm:ss'\n\n\n# Writes to file on disk\n\nwriter.save()\n<line_mask>",
            "masked_line": "writer.close()",
            "answer": "close",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_394"
        },
        {
            "dependency": "PyAutoGUI",
            "version": ">=0.9.41",
            "time": "2022-11-21",
            "description": "The code detects the center coordinates of an image on the screen with 80% confidence. If the image is not found, it prints \"Not Detected\" and clicks at a specific coordinate. If the image is found, it prints \"Detected\" and clicks at the center coordinates of the image.",
            "code": "pt = pyautogui.locateCenterOnScreen('yellow.png', confidence=0.8)\nif not pt:\n    print(\"Not Detected\")\n    pyautogui.click(1280,720)\nelse:\n    x, y = pt\n    print(\"Detected\")\n    pyautogui.click(x, y)",
            "masked_code": "<line_mask>\nif not pt:\n    print(\"Not Detected\")\n    pyautogui.click(1280,720)\nelse:\n    x, y = pt\n    print(\"Detected\")\n    pyautogui.click(x, y)",
            "masked_line": "pt = pyautogui.locateCenterOnScreen('yellow.png', confidence=0.8)",
            "answer": "locateCenterOnScreen",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_395"
        },
        {
            "dependency": "transformers",
            "version": "==4.16.2",
            "time": "2022-02-11",
            "description": "This code sets up a text classification pipeline using a pre-trained model and tokenizer to predict the category of a given input text with all the prediction scores returned.",
            "code": "from transformers import TextClassificationPipeline, AutoTokenizer, AutoModelForSequenceClassification\n\nMODEL_NAME = \"...\"\ntokenizer = AutoTokenizer.from_pretrained(MODEL_NAME)\nmodel = AutoModelForSequenceClassification.from_pretrained(MODEL_NAME)\n\npipe = TextClassificationPipeline(model=model, tokenizer=tokenizer)\nprediction = pipe(\"The text to predict\", return_all_scores=True)",
            "masked_code": "from transformers import TextClassificationPipeline, AutoTokenizer, AutoModelForSequenceClassification\n\nMODEL_NAME = \"...\"\ntokenizer = AutoTokenizer.from_pretrained(MODEL_NAME)\nmodel = AutoModelForSequenceClassification.from_pretrained(MODEL_NAME)\n\npipe = TextClassificationPipeline(model=model, tokenizer=tokenizer)\n<line_mask>",
            "masked_line": "prediction = pipe(\"The text to predict\", return_all_scores=True)",
            "answer": "pipe",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_396"
        },
        {
            "dependency": "pypdfium2",
            "version": "==4.9.0",
            "time": "2023-05-05",
            "description": "This code snippet loads a PDF file using pdfium, extracts the first page of the PDF, renders the page into a PIL image with a specified scale, and saves the PIL image as a JPEG file in a specified directory.",
            "code": "pdf = pdfium.PdfDocument(pdf_path)\npage = pdf.get_page(0)\npil_image = page.render(scale = 300/72).to_pil()\nimage_name =f\"Images/{image_name}.jpg\"\npil_image.save(image_name)",
            "masked_code": "pdf = pdfium.PdfDocument(pdf_path)\npage = pdf.get_page(0)\n<line_mask>\nimage_name =f\"Images/{image_name}.jpg\"\npil_image.save(image_name)",
            "masked_line": "pil_image = page.render(scale = 300/72).to_pil()",
            "answer": "to_pil",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_397"
        },
        {
            "dependency": "matplotlib",
            "version": ">=3.4",
            "time": "2023-09-29",
            "description": "The code performs the following tasks:\n- Inverts the order of rows in the DataFrame 'df' and assigns it to 'df2'.\n- Computes meshgrid using the range of row and column indices of the DataFrame.\n- Plots a scatter plot with markers colored in orange, outlined in black with dashed lines, sized based on values from 'df2', and transparency set based on normalized values.\n- Annotates each point on the scatter plot with its corresponding value from 'df2'.\n- Turns off axis lines, sets margins, and displays the plot.",
            "code": "# inverting df to have the same row order\ndf2 = df[::-1]\n\n# computing meshgrid\nx, y = np.meshgrid(range(df.shape[0]), range(df.shape[1]))\n\n# plotting\nplt.scatter(x, y, marker='o', color='tab:orange', ec='k', ls='--',\n            s=df2, alpha=df2.div(np.max(df2)))\n\nfor ix,iy,v in zip(x.ravel(), y.ravel(), df2.to_numpy().ravel()):\n    plt.annotate(str(v), (ix,iy), textcoords='offset points',\n                 xytext=(0,10), ha='center')\n        \nplt.axis(\"off\")\nplt.margins(y=0.2)\nplt.show()",
            "masked_code": "# inverting df to have the same row order\ndf2 = df[::-1]\n\n# computing meshgrid\nx, y = np.meshgrid(range(df.shape[0]), range(df.shape[1]))\n\n# plotting\nplt.scatter(x, y, marker='o', color='tab:orange', ec='k', ls='--',\n            s=df2, alpha=df2.div(np.max(df2)))\n\nfor ix,iy,v in zip(x.ravel(), y.ravel(), df2.to_numpy().ravel()):\n    plt.annotate(str(v), (ix,iy), textcoords='offset points',\n                 xytext=(0,10), ha='center')\n        \nplt.axis(\"off\")\n<line_mask>\nplt.show()",
            "masked_line": "plt.margins(y=0.2)",
            "answer": "margins",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_398"
        },
        {
            "dependency": "seaborn",
            "version": "==0.12.1",
            "time": "2023-01-19",
            "description": "The code creates a palette dictionary with unique values in the hue column, then plots a filtered dataframe using seaborn relplot with different facets. It iterates through each facet and plots error bars for each hue group with correct color.",
            "code": "# create a palette dictionary for the unique values in the hue column\npalette = dict(zip(filtered['Mineral content (g/g fibre)'].unique(), [\"#fdae61\", \"#abd9e9\"]))\n\n# plot the filtered dataframe\ng = sns.relplot(data=filtered, x=\"Impeller speed (rpm)\", y=\"Result\", col=\"Media size\", row='Material', hue=\"Mineral content (g/g fibre)\", size=\"Media size\", sizes=(50, 200), palette=palette)\n\n# iterate through each facet of the facetgrid\nfor (material, media), ax in g.axes_dict.items():\n    # select the data for the facet\n    data = filtered[filtered['Material'].eq(material) & filtered['Media size'].eq(media)]\n    # select the data for each hue group\n    for group, selected in data.groupby('Mineral content (g/g fibre)'):\n        # plot the errorbar with the correct color for each group \n        ax.errorbar(data=selected, x=\"Impeller speed (rpm)\", y=\"Result\", yerr=\"ster\", marker=\"none\", color=palette[group], ls='none')",
            "masked_code": "# create a palette dictionary for the unique values in the hue column\npalette = dict(zip(filtered['Mineral content (g/g fibre)'].unique(), [\"#fdae61\", \"#abd9e9\"]))\n\n# plot the filtered dataframe\n<line_mask>\n\n# iterate through each facet of the facetgrid\nfor (material, media), ax in g.axes_dict.items():\n    # select the data for the facet\n    data = filtered[filtered['Material'].eq(material) & filtered['Media size'].eq(media)]\n    # select the data for each hue group\n    for group, selected in data.groupby('Mineral content (g/g fibre)'):\n        # plot the errorbar with the correct color for each group \n        ax.errorbar(data=selected, x=\"Impeller speed (rpm)\", y=\"Result\", yerr=\"ster\", marker=\"none\", color=palette[group], ls='none')",
            "masked_line": "g = sns.relplot(data=filtered, x=\"Impeller speed (rpm)\", y=\"Result\", col=\"Media size\", row='Material', hue=\"Mineral content (g/g fibre)\", size=\"Media size\", sizes=(50, 200), palette=palette)",
            "answer": "relplot",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_399"
        },
        {
            "dependency": "numpy",
            "version": "==1.24.0",
            "time": "2023-01-28",
            "description": "This code calculates the gradient of a given temperature matrix T in the x and y directions.",
            "code": "def hc_grad(T):\n    dTdx = np.zeros_like(T)\n    dTdy = np.zeros_like(T)\n\n    dTdx[1:-1, 1:-1] = (T[1:-1, 2:] - T[1:-1, :-2]) / 2\n    dTdy[1:-1, 1:-1] = (T[2:, 1:-1] - T[:-2, 1:-1]) / 2",
            "masked_code": "def hc_grad(T):\n    <line_mask>\n    dTdy = np.zeros_like(T)\n\n    dTdx[1:-1, 1:-1] = (T[1:-1, 2:] - T[1:-1, :-2]) / 2\n    dTdy[1:-1, 1:-1] = (T[2:, 1:-1] - T[:-2, 1:-1]) / 2",
            "masked_line": "dTdx = np.zeros_like(T)",
            "answer": "zeros_like",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_400"
        },
        {
            "dependency": "pandas",
            "version": "==2.0.1",
            "time": "2023-05-12",
            "description": "The code compares two DataFrames, df1 and df2, with different index types (idx1 and idx2) and then asserts that they are equal, which passes without any errors.",
            "code": "print(pd.__version__)\n# 2.0.1\n\nidx1 = pd.Index([0, 3, 6, 9, 12, 15, 18, 1, 4, 7, 10, 13, 16, 19, 2, 5, 8, 11, 14, 17], dtype='int64')\nidx2 = pd.RangeIndex(start=0, stop=20, step=1)\n\ndf1 = pd.DataFrame(index=idx1).sort_index()\ndf2 = pd.DataFrame(index=idx2)\n\nprint(df1.index)\n# Index([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19], dtype='int64')\nprint(df2.index)\n# RangeIndex(start=0, stop=20, step=1)\n\npd.testing.assert_frame_equal(df1, df2) # no error",
            "masked_code": "print(pd.__version__)\n# 2.0.1\n\nidx1 = pd.Index([0, 3, 6, 9, 12, 15, 18, 1, 4, 7, 10, 13, 16, 19, 2, 5, 8, 11, 14, 17], dtype='int64')\nidx2 = pd.RangeIndex(start=0, stop=20, step=1)\n\n<line_mask>\ndf2 = pd.DataFrame(index=idx2)\n\nprint(df1.index)\n# Index([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19], dtype='int64')\nprint(df2.index)\n# RangeIndex(start=0, stop=20, step=1)\n\npd.testing.assert_frame_equal(df1, df2) # no error",
            "masked_line": "df1 = pd.DataFrame(index=idx1).sort_index()",
            "answer": "sort_index",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_401"
        },
        {
            "dependency": "PyAutoGUI",
            "version": "==0.9.41",
            "time": "2023-11-18",
            "description": "The code continuously searches for an image of an orange shape with a confidence level of 80%, and if found, prints \"I can see it\". If the image is not found, it prints \"I am unable to see it\" and then waits for 0.5 seconds before continuing the search.",
            "code": "while 1:\n    try:\n        pyautogui.locateOnScreen('orange shape.png', confidence=0.8)\n        print (\"I can see it\")\n    except pyautogui.ImageNotFoundException:\n        print(\"I am unable to see it\")\n    time.sleep(0.5)",
            "masked_code": "while 1:\n    try:\n        <line_mask>\n        print (\"I can see it\")\n    except pyautogui.ImageNotFoundException:\n        print(\"I am unable to see it\")\n    time.sleep(0.5)",
            "masked_line": "pyautogui.locateOnScreen('orange shape.png', confidence=0.8)",
            "answer": "locateOnScreen",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_402"
        },
        {
            "dependency": "tensorflow",
            "version": "==2.3",
            "time": "2020-08-25",
            "description": "The code preprocesses an image dataset by converting the pixel values of the images to floating point numbers between 0 and 1.",
            "code": "def process(image,label):\n    image = tf.cast(image/255. ,tf.float32)\n    return image,label\n\nds = tf.keras.preprocessing.image_dataset_from_directory(IMAGE_DIR)\nds = ds.map(process)",
            "masked_code": "def process(image,label):\n    <line_mask>\n    return image,label\n\nds = tf.keras.preprocessing.image_dataset_from_directory(IMAGE_DIR)\nds = ds.map(process)",
            "masked_line": "image = tf.cast(image/255. ,tf.float32)",
            "answer": "cast",
            "type": "general",
            "granularity": "block",
            "language": "python",
            "task": "code_completion",
            "source": "stackoverflow",
            "id": "stackoverflow_python_block_403"
        }
    ]
}